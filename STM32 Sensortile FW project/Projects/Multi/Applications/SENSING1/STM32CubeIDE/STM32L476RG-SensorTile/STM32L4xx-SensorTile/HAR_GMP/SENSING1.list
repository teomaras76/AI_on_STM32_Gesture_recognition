
SENSING1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08004000  08004000  00004000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001e878  08004190  08004190  00004190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00053778  08022a08  08022a08  00022a08  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08076180  08076180  00076180  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  08076188  08076188  00076188  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  0807618c  0807618c  0007618c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00001730  20000000  08076190  00080000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00011bf0  20001730  080778c0  00081730  2**3
                  ALLOC
  8 ._user_heap_stack 00001800  20013320  080778c0  00083320  2**0
                  ALLOC
  9 .ARM.attributes 00000034  00000000  00000000  00081730  2**0
                  CONTENTS, READONLY
 10 .debug_info   000b441f  00000000  00000000  00081764  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000e380  00000000  00000000  00135b83  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00063a56  00000000  00000000  00143f03  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00004880  00000000  00000000  001a7960  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 0000d380  00000000  00000000  001ac1e0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00030c3e  00000000  00000000  001b9560  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000212b4  00000000  00000000  001ea19e  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      00002b87  00000000  00000000  0020b452  2**0
                  CONTENTS, READONLY
 18 .iar.rtmodel  00000274  00000000  00000000  0020dfd9  2**0
                  CONTENTS, READONLY
 19 .iar_vfe_header 00000020  00000000  00000000  0020e250  2**2
                  CONTENTS, READONLY
 20 .debug_frame  00013bac  00000000  00000000  0020e270  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08004190 <__do_global_dtors_aux>:
 8004190:	b510      	push	{r4, lr}
 8004192:	4c05      	ldr	r4, [pc, #20]	; (80041a8 <__do_global_dtors_aux+0x18>)
 8004194:	7823      	ldrb	r3, [r4, #0]
 8004196:	b933      	cbnz	r3, 80041a6 <__do_global_dtors_aux+0x16>
 8004198:	4b04      	ldr	r3, [pc, #16]	; (80041ac <__do_global_dtors_aux+0x1c>)
 800419a:	b113      	cbz	r3, 80041a2 <__do_global_dtors_aux+0x12>
 800419c:	4804      	ldr	r0, [pc, #16]	; (80041b0 <__do_global_dtors_aux+0x20>)
 800419e:	f3af 8000 	nop.w
 80041a2:	2301      	movs	r3, #1
 80041a4:	7023      	strb	r3, [r4, #0]
 80041a6:	bd10      	pop	{r4, pc}
 80041a8:	20001730 	.word	0x20001730
 80041ac:	00000000 	.word	0x00000000
 80041b0:	080229f0 	.word	0x080229f0

080041b4 <frame_dummy>:
 80041b4:	b508      	push	{r3, lr}
 80041b6:	4b03      	ldr	r3, [pc, #12]	; (80041c4 <frame_dummy+0x10>)
 80041b8:	b11b      	cbz	r3, 80041c2 <frame_dummy+0xe>
 80041ba:	4903      	ldr	r1, [pc, #12]	; (80041c8 <frame_dummy+0x14>)
 80041bc:	4803      	ldr	r0, [pc, #12]	; (80041cc <frame_dummy+0x18>)
 80041be:	f3af 8000 	nop.w
 80041c2:	bd08      	pop	{r3, pc}
 80041c4:	00000000 	.word	0x00000000
 80041c8:	20001734 	.word	0x20001734
 80041cc:	080229f0 	.word	0x080229f0

080041d0 <ai_math_dot_array>:
 80041d0:	b530      	push	{r4, r5, lr}
 80041d2:	4604      	mov	r4, r0
 80041d4:	4608      	mov	r0, r1
 80041d6:	b081      	sub	sp, #4
 80041d8:	4611      	mov	r1, r2
 80041da:	461a      	mov	r2, r3
 80041dc:	2500      	movs	r5, #0
 80041de:	9500      	str	r5, [sp, #0]
 80041e0:	466b      	mov	r3, sp
 80041e2:	f01a fc01 	bl	801e9e8 <arm_dot_prod_f32>
 80041e6:	ed94 0a00 	vldr	s0, [r4]
 80041ea:	eddd 0a00 	vldr	s1, [sp]
 80041ee:	ee70 0a20 	vadd.f32	s1, s0, s1
 80041f2:	edc4 0a00 	vstr	s1, [r4]
 80041f6:	b001      	add	sp, #4
 80041f8:	bd30      	pop	{r4, r5, pc}
	...

080041fc <ai_math_sqrt>:
 80041fc:	eef0 0a40 	vmov.f32	s1, s0
 8004200:	eef5 0a40 	vcmp.f32	s1, #0.0
 8004204:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004208:	ed9f 0a28 	vldr	s0, [pc, #160]	; 80042ac <.text_12>
 800420c:	db01      	blt.n	8004212 <ai_math_sqrt+0x16>
 800420e:	eeb1 0ae0 	vsqrt.f32	s0, s1
 8004212:	4770      	bx	lr

08004214 <ai_math_exp>:
 8004214:	f01d baa6 	b.w	8021764 <expf>

08004218 <ai_math_pow>:
 8004218:	f01d bb94 	b.w	8021944 <powf>

0800421c <ai_math_tanh>:
 800421c:	f01d ba50 	b.w	80216c0 <tanhf>

08004220 <ai_math_relu>:
 8004220:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8004224:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004228:	bfd8      	it	le
 800422a:	ed9f 0a20 	vldrle	s0, [pc, #128]	; 80042ac <.text_12>
 800422e:	4770      	bx	lr

08004230 <ai_math_prelu>:
 8004230:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8004234:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004238:	bfd8      	it	le
 800423a:	ee20 0a20 	vmulle.f32	s0, s0, s1
 800423e:	4770      	bx	lr

08004240 <ai_math_sigmoid>:
 8004240:	b500      	push	{lr}
 8004242:	b081      	sub	sp, #4
 8004244:	eeb1 0a40 	vneg.f32	s0, s0
 8004248:	f01d fa8c 	bl	8021764 <expf>
 800424c:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8004250:	ee30 0a20 	vadd.f32	s0, s0, s1
 8004254:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8004258:	ee81 0a00 	vdiv.f32	s0, s2, s0
 800425c:	b001      	add	sp, #4
 800425e:	bd00      	pop	{pc}

08004260 <ai_math_hard_sigmoid>:
 8004260:	eef0 0a40 	vmov.f32	s1, s0
 8004264:	ed9f 1a12 	vldr	s2, [pc, #72]	; 80042b0 <.text_13>
 8004268:	eeb6 0a00 	vmov.f32	s0, #96	; 0x3f000000  0.5
 800426c:	ee00 0a81 	vmla.f32	s0, s1, s2
 8004270:	eddf 0a10 	vldr	s1, [pc, #64]	; 80042b4 <.text_14>
 8004274:	eeb4 0a60 	vcmp.f32	s0, s1
 8004278:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800427c:	da07      	bge.n	800428e <ai_math_hard_sigmoid+0x2e>
 800427e:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8004282:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004286:	d504      	bpl.n	8004292 <ai_math_hard_sigmoid+0x32>
 8004288:	ed9f 0a08 	vldr	s0, [pc, #32]	; 80042ac <.text_12>
 800428c:	4770      	bx	lr
 800428e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8004292:	4770      	bx	lr

08004294 <ai_math_sign>:
 8004294:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8004298:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800429c:	bfcc      	ite	gt
 800429e:	ed9f 0a06 	vldrgt	s0, [pc, #24]	; 80042b8 <.text_15>
 80042a2:	ed9f 0a06 	vldrle	s0, [pc, #24]	; 80042bc <.text_16>
 80042a6:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 80042aa:	4770      	bx	lr

080042ac <.text_12>:
 80042ac:	00000000 	.word	0x00000000

080042b0 <.text_13>:
 80042b0:	3e4ccccd 	.word	0x3e4ccccd

080042b4 <.text_14>:
 80042b4:	3f800001 	.word	0x3f800001

080042b8 <.text_15>:
 80042b8:	00000001 	.word	0x00000001

080042bc <.text_16>:
 80042bc:	ffffffff 	.word	0xffffffff

080042c0 <ai_array_get_byte_size>:
 80042c0:	b909      	cbnz	r1, 80042c6 <ai_array_get_byte_size+0x6>
 80042c2:	2000      	movs	r0, #0
 80042c4:	4770      	bx	lr
 80042c6:	f3c0 13c6 	ubfx	r3, r0, #7, #7
 80042ca:	f3c0 3282 	ubfx	r2, r0, #14, #3
 80042ce:	18d3      	adds	r3, r2, r3
 80042d0:	4359      	muls	r1, r3
 80042d2:	1dc9      	adds	r1, r1, #7
 80042d4:	08c9      	lsrs	r1, r1, #3
 80042d6:	0d42      	lsrs	r2, r0, #21
 80042d8:	00c9      	lsls	r1, r1, #3
 80042da:	f002 0203 	and.w	r2, r2, #3
 80042de:	0c43      	lsrs	r3, r0, #17
 80042e0:	40d1      	lsrs	r1, r2
 80042e2:	f003 030f 	and.w	r3, r3, #15
 80042e6:	2b04      	cmp	r3, #4
 80042e8:	d00b      	beq.n	8004302 <ai_array_get_byte_size+0x42>
 80042ea:	2b08      	cmp	r3, #8
 80042ec:	bf01      	itttt	eq
 80042ee:	f3c0 12c6 	ubfxeq	r2, r0, #7, #7
 80042f2:	f3c0 3082 	ubfxeq	r0, r0, #14, #3
 80042f6:	1882      	addeq	r2, r0, r2
 80042f8:	eb01 2102 	addeq.w	r1, r1, r2, lsl #8
 80042fc:	1dc9      	adds	r1, r1, #7
 80042fe:	08c8      	lsrs	r0, r1, #3
 8004300:	4770      	bx	lr
 8004302:	f3c0 12c6 	ubfx	r2, r0, #7, #7
 8004306:	f3c0 3082 	ubfx	r0, r0, #14, #3
 800430a:	1882      	adds	r2, r0, r2
 800430c:	eb01 1102 	add.w	r1, r1, r2, lsl #4
 8004310:	1dc9      	adds	r1, r1, #7
 8004312:	08c8      	lsrs	r0, r1, #3
 8004314:	4770      	bx	lr

08004316 <ai_mem_copy_buffer>:
 8004316:	b510      	push	{r4, lr}
 8004318:	4604      	mov	r4, r0
 800431a:	f01a fbae 	bl	801ea7a <__aeabi_memcpy>
 800431e:	4620      	mov	r0, r4
 8004320:	bd10      	pop	{r4, pc}

08004322 <ai_platform_runtime_get_revision>:
 8004322:	f8df 0414 	ldr.w	r0, [pc, #1044]	; 8004738 <.text_19>
 8004326:	6801      	ldr	r1, [r0, #0]
 8004328:	0849      	lsrs	r1, r1, #1
 800432a:	0049      	lsls	r1, r1, #1
 800432c:	6001      	str	r1, [r0, #0]
 800432e:	2001      	movs	r0, #1
 8004330:	f8df 1408 	ldr.w	r1, [pc, #1032]	; 800473c <.text_20>
 8004334:	6088      	str	r0, [r1, #8]
 8004336:	6888      	ldr	r0, [r1, #8]
 8004338:	2800      	cmp	r0, #0
 800433a:	d1fc      	bne.n	8004336 <ai_platform_runtime_get_revision+0x14>
 800433c:	f8df 2400 	ldr.w	r2, [pc, #1024]	; 8004740 <.text_21>
 8004340:	600a      	str	r2, [r1, #0]
 8004342:	6808      	ldr	r0, [r1, #0]
 8004344:	f8df 13fc 	ldr.w	r1, [pc, #1020]	; 8004744 <.text_22>
 8004348:	4288      	cmp	r0, r1
 800434a:	d000      	beq.n	800434e <ai_platform_runtime_get_revision+0x2c>
 800434c:	e7fe      	b.n	800434c <ai_platform_runtime_get_revision+0x2a>
 800434e:	a0a1      	add	r0, pc, #644	; (adr r0, 80045d4 <.text_17>)
 8004350:	4770      	bx	lr

08004352 <ai_platform_runtime_get_version>:
 8004352:	f8df 03e4 	ldr.w	r0, [pc, #996]	; 8004738 <.text_19>
 8004356:	6801      	ldr	r1, [r0, #0]
 8004358:	0849      	lsrs	r1, r1, #1
 800435a:	0049      	lsls	r1, r1, #1
 800435c:	6001      	str	r1, [r0, #0]
 800435e:	2001      	movs	r0, #1
 8004360:	f8df 13d8 	ldr.w	r1, [pc, #984]	; 800473c <.text_20>
 8004364:	6088      	str	r0, [r1, #8]
 8004366:	6888      	ldr	r0, [r1, #8]
 8004368:	2800      	cmp	r0, #0
 800436a:	d1fc      	bne.n	8004366 <ai_platform_runtime_get_version+0x14>
 800436c:	f8df 23d0 	ldr.w	r2, [pc, #976]	; 8004740 <.text_21>
 8004370:	600a      	str	r2, [r1, #0]
 8004372:	6808      	ldr	r0, [r1, #0]
 8004374:	f8df 13cc 	ldr.w	r1, [pc, #972]	; 8004744 <.text_22>
 8004378:	4288      	cmp	r0, r1
 800437a:	d000      	beq.n	800437e <ai_platform_runtime_get_version+0x2c>
 800437c:	e7fe      	b.n	800437c <ai_platform_runtime_get_version+0x2a>
 800437e:	f20f 32dc 	addw	r2, pc, #988	; 0x3dc
 8004382:	6810      	ldr	r0, [r2, #0]
 8004384:	4770      	bx	lr

08004386 <ai_platform_api_get_version>:
 8004386:	f8df 03b0 	ldr.w	r0, [pc, #944]	; 8004738 <.text_19>
 800438a:	6801      	ldr	r1, [r0, #0]
 800438c:	0849      	lsrs	r1, r1, #1
 800438e:	0049      	lsls	r1, r1, #1
 8004390:	6001      	str	r1, [r0, #0]
 8004392:	2001      	movs	r0, #1
 8004394:	f8df 13a4 	ldr.w	r1, [pc, #932]	; 800473c <.text_20>
 8004398:	6088      	str	r0, [r1, #8]
 800439a:	6888      	ldr	r0, [r1, #8]
 800439c:	2800      	cmp	r0, #0
 800439e:	d1fc      	bne.n	800439a <ai_platform_api_get_version+0x14>
 80043a0:	f8df 239c 	ldr.w	r2, [pc, #924]	; 8004740 <.text_21>
 80043a4:	600a      	str	r2, [r1, #0]
 80043a6:	6808      	ldr	r0, [r1, #0]
 80043a8:	f8df 1398 	ldr.w	r1, [pc, #920]	; 8004744 <.text_22>
 80043ac:	4288      	cmp	r0, r1
 80043ae:	d000      	beq.n	80043b2 <ai_platform_api_get_version+0x2c>
 80043b0:	e7fe      	b.n	80043b0 <ai_platform_api_get_version+0x2a>
 80043b2:	f20f 32ac 	addw	r2, pc, #940	; 0x3ac
 80043b6:	6810      	ldr	r0, [r2, #0]
 80043b8:	4770      	bx	lr

080043ba <ai_platform_interface_api_get_version>:
 80043ba:	f8df 037c 	ldr.w	r0, [pc, #892]	; 8004738 <.text_19>
 80043be:	6801      	ldr	r1, [r0, #0]
 80043c0:	0849      	lsrs	r1, r1, #1
 80043c2:	0049      	lsls	r1, r1, #1
 80043c4:	6001      	str	r1, [r0, #0]
 80043c6:	2001      	movs	r0, #1
 80043c8:	f8df 1370 	ldr.w	r1, [pc, #880]	; 800473c <.text_20>
 80043cc:	6088      	str	r0, [r1, #8]
 80043ce:	6888      	ldr	r0, [r1, #8]
 80043d0:	2800      	cmp	r0, #0
 80043d2:	d1fc      	bne.n	80043ce <ai_platform_interface_api_get_version+0x14>
 80043d4:	f8df 2368 	ldr.w	r2, [pc, #872]	; 8004740 <.text_21>
 80043d8:	600a      	str	r2, [r1, #0]
 80043da:	6808      	ldr	r0, [r1, #0]
 80043dc:	f8df 1364 	ldr.w	r1, [pc, #868]	; 8004744 <.text_22>
 80043e0:	4288      	cmp	r0, r1
 80043e2:	d000      	beq.n	80043e6 <ai_platform_interface_api_get_version+0x2c>
 80043e4:	e7fe      	b.n	80043e4 <ai_platform_interface_api_get_version+0x2a>
 80043e6:	f20f 327c 	addw	r2, pc, #892	; 0x37c
 80043ea:	6810      	ldr	r0, [r2, #0]
 80043ec:	4770      	bx	lr

080043ee <ai_platform_context_acquire>:
 80043ee:	b120      	cbz	r0, 80043fa <ai_platform_context_acquire+0xc>
 80043f0:	6801      	ldr	r1, [r0, #0]
 80043f2:	f8df 2354 	ldr.w	r2, [pc, #852]	; 8004748 <.text_23>
 80043f6:	4291      	cmp	r1, r2
 80043f8:	d000      	beq.n	80043fc <ai_platform_context_acquire+0xe>
 80043fa:	2000      	movs	r0, #0
 80043fc:	f8df 1338 	ldr.w	r1, [pc, #824]	; 8004738 <.text_19>
 8004400:	680a      	ldr	r2, [r1, #0]
 8004402:	0852      	lsrs	r2, r2, #1
 8004404:	0052      	lsls	r2, r2, #1
 8004406:	600a      	str	r2, [r1, #0]
 8004408:	2101      	movs	r1, #1
 800440a:	f8df 2330 	ldr.w	r2, [pc, #816]	; 800473c <.text_20>
 800440e:	6091      	str	r1, [r2, #8]
 8004410:	6891      	ldr	r1, [r2, #8]
 8004412:	2900      	cmp	r1, #0
 8004414:	d1fc      	bne.n	8004410 <ai_platform_context_acquire+0x22>
 8004416:	f8df 3328 	ldr.w	r3, [pc, #808]	; 8004740 <.text_21>
 800441a:	6013      	str	r3, [r2, #0]
 800441c:	6811      	ldr	r1, [r2, #0]
 800441e:	f8df 2324 	ldr.w	r2, [pc, #804]	; 8004744 <.text_22>
 8004422:	4291      	cmp	r1, r2
 8004424:	d000      	beq.n	8004428 <ai_platform_context_acquire+0x3a>
 8004426:	e7fe      	b.n	8004426 <ai_platform_context_acquire+0x38>
 8004428:	4770      	bx	lr

0800442a <ai_platform_context_release>:
 800442a:	f8df 131c 	ldr.w	r1, [pc, #796]	; 8004748 <.text_23>
 800442e:	6001      	str	r1, [r0, #0]
 8004430:	4770      	bx	lr

08004432 <ai_copy_buffer_fake_src>:
 8004432:	4608      	mov	r0, r1
 8004434:	4770      	bx	lr

08004436 <ai_copy_buffer_fake_dst>:
 8004436:	4770      	bx	lr

08004438 <ai_platform_network_get_error>:
 8004438:	b120      	cbz	r0, 8004444 <ai_platform_network_get_error+0xc>
 800443a:	6801      	ldr	r1, [r0, #0]
 800443c:	f8df 2308 	ldr.w	r2, [pc, #776]	; 8004748 <.text_23>
 8004440:	4291      	cmp	r1, r2
 8004442:	d000      	beq.n	8004446 <ai_platform_network_get_error+0xe>
 8004444:	2000      	movs	r0, #0
 8004446:	49bc      	ldr	r1, [pc, #752]	; (8004738 <.text_19>)
 8004448:	680a      	ldr	r2, [r1, #0]
 800444a:	0852      	lsrs	r2, r2, #1
 800444c:	0052      	lsls	r2, r2, #1
 800444e:	600a      	str	r2, [r1, #0]
 8004450:	2101      	movs	r1, #1
 8004452:	4aba      	ldr	r2, [pc, #744]	; (800473c <.text_20>)
 8004454:	6091      	str	r1, [r2, #8]
 8004456:	6891      	ldr	r1, [r2, #8]
 8004458:	2900      	cmp	r1, #0
 800445a:	d1fc      	bne.n	8004456 <ai_platform_network_get_error+0x1e>
 800445c:	4bb8      	ldr	r3, [pc, #736]	; (8004740 <.text_21>)
 800445e:	6013      	str	r3, [r2, #0]
 8004460:	6811      	ldr	r1, [r2, #0]
 8004462:	4ab8      	ldr	r2, [pc, #736]	; (8004744 <.text_22>)
 8004464:	4291      	cmp	r1, r2
 8004466:	d000      	beq.n	800446a <ai_platform_network_get_error+0x32>
 8004468:	e7fe      	b.n	8004468 <ai_platform_network_get_error+0x30>
 800446a:	2800      	cmp	r0, #0
 800446c:	bf1c      	itt	ne
 800446e:	300c      	addne	r0, #12
 8004470:	f000 b98a 	bne.w	8004788 <core_get_error>
 8004474:	f20f 3000 	addw	r0, pc, #768	; 0x300
 8004478:	6800      	ldr	r0, [r0, #0]
 800447a:	4770      	bx	lr

0800447c <ai_platform_network_set_error>:
 800447c:	2800      	cmp	r0, #0
 800447e:	bf1c      	itt	ne
 8004480:	300c      	addne	r0, #12
 8004482:	f000 b986 	bne.w	8004792 <core_set_error>
 8004486:	4770      	bx	lr

08004488 <ai_platform_network_create>:
 8004488:	b570      	push	{r4, r5, r6, lr}
 800448a:	9d04      	ldr	r5, [sp, #16]
 800448c:	4604      	mov	r4, r0
 800448e:	9805      	ldr	r0, [sp, #20]
 8004490:	b2db      	uxtb	r3, r3
 8004492:	042d      	lsls	r5, r5, #16
 8004494:	ea45 6503 	orr.w	r5, r5, r3, lsl #24
 8004498:	ea45 2500 	orr.w	r5, r5, r0, lsl #8
 800449c:	f20f 20dc 	addw	r0, pc, #732	; 0x2dc
 80044a0:	6806      	ldr	r6, [r0, #0]
 80044a2:	48a5      	ldr	r0, [pc, #660]	; (8004738 <.text_19>)
 80044a4:	6801      	ldr	r1, [r0, #0]
 80044a6:	0849      	lsrs	r1, r1, #1
 80044a8:	0049      	lsls	r1, r1, #1
 80044aa:	6001      	str	r1, [r0, #0]
 80044ac:	2001      	movs	r0, #1
 80044ae:	49a3      	ldr	r1, [pc, #652]	; (800473c <.text_20>)
 80044b0:	6088      	str	r0, [r1, #8]
 80044b2:	6888      	ldr	r0, [r1, #8]
 80044b4:	2800      	cmp	r0, #0
 80044b6:	d1fc      	bne.n	80044b2 <ai_platform_network_create+0x2a>
 80044b8:	4ba1      	ldr	r3, [pc, #644]	; (8004740 <.text_21>)
 80044ba:	600b      	str	r3, [r1, #0]
 80044bc:	6808      	ldr	r0, [r1, #0]
 80044be:	49a1      	ldr	r1, [pc, #644]	; (8004744 <.text_22>)
 80044c0:	4288      	cmp	r0, r1
 80044c2:	d000      	beq.n	80044c6 <ai_platform_network_create+0x3e>
 80044c4:	e7fe      	b.n	80044c4 <ai_platform_network_create+0x3c>
 80044c6:	b91c      	cbnz	r4, 80044d0 <ai_platform_network_create+0x48>
 80044c8:	f20f 20b4 	addw	r0, pc, #692	; 0x2b4
 80044cc:	6800      	ldr	r0, [r0, #0]
 80044ce:	bd70      	pop	{r4, r5, r6, pc}
 80044d0:	499d      	ldr	r1, [pc, #628]	; (8004748 <.text_23>)
 80044d2:	6011      	str	r1, [r2, #0]
 80044d4:	6022      	str	r2, [r4, #0]
 80044d6:	f000 f955 	bl	8004784 <core_init>
 80044da:	b910      	cbnz	r0, 80044e2 <ai_platform_network_create+0x5a>
 80044dc:	f20f 2088 	addw	r0, pc, #648	; 0x288
 80044e0:	e00b      	b.n	80044fa <ai_platform_network_create+0x72>
 80044e2:	499a      	ldr	r1, [pc, #616]	; (800474c <.text_24>)
 80044e4:	428d      	cmp	r5, r1
 80044e6:	bf28      	it	cs
 80044e8:	f20f 2080 	addwcs	r0, pc, #640	; 0x280
 80044ec:	d205      	bcs.n	80044fa <ai_platform_network_create+0x72>
 80044ee:	f20f 2080 	addw	r0, pc, #640	; 0x280
 80044f2:	f000 f963 	bl	80047bc <ai_check_custom_types>
 80044f6:	b918      	cbnz	r0, 8004500 <ai_platform_network_create+0x78>
 80044f8:	a09e      	add	r0, pc, #632	; (adr r0, 8004774 <.text_34>)
 80044fa:	6806      	ldr	r6, [r0, #0]
 80044fc:	2100      	movs	r1, #0
 80044fe:	6021      	str	r1, [r4, #0]
 8004500:	4630      	mov	r0, r6
 8004502:	bd70      	pop	{r4, r5, r6, pc}

08004504 <ai_platform_network_destroy>:
 8004504:	b128      	cbz	r0, 8004512 <ai_platform_network_destroy+0xe>
 8004506:	6801      	ldr	r1, [r0, #0]
 8004508:	4a8f      	ldr	r2, [pc, #572]	; (8004748 <.text_23>)
 800450a:	4291      	cmp	r1, r2
 800450c:	bf08      	it	eq
 800450e:	4602      	moveq	r2, r0
 8004510:	d000      	beq.n	8004514 <ai_platform_network_destroy+0x10>
 8004512:	2200      	movs	r2, #0
 8004514:	4988      	ldr	r1, [pc, #544]	; (8004738 <.text_19>)
 8004516:	680b      	ldr	r3, [r1, #0]
 8004518:	085b      	lsrs	r3, r3, #1
 800451a:	005b      	lsls	r3, r3, #1
 800451c:	600b      	str	r3, [r1, #0]
 800451e:	2101      	movs	r1, #1
 8004520:	4b86      	ldr	r3, [pc, #536]	; (800473c <.text_20>)
 8004522:	6099      	str	r1, [r3, #8]
 8004524:	6899      	ldr	r1, [r3, #8]
 8004526:	2900      	cmp	r1, #0
 8004528:	d1fc      	bne.n	8004524 <ai_platform_network_destroy+0x20>
 800452a:	f8df c214 	ldr.w	ip, [pc, #532]	; 8004740 <.text_21>
 800452e:	f8c3 c000 	str.w	ip, [r3]
 8004532:	6819      	ldr	r1, [r3, #0]
 8004534:	4b83      	ldr	r3, [pc, #524]	; (8004744 <.text_22>)
 8004536:	4299      	cmp	r1, r3
 8004538:	d000      	beq.n	800453c <ai_platform_network_destroy+0x38>
 800453a:	e7fe      	b.n	800453a <ai_platform_network_destroy+0x36>
 800453c:	b102      	cbz	r2, 8004540 <ai_platform_network_destroy+0x3c>
 800453e:	2000      	movs	r0, #0
 8004540:	4770      	bx	lr

08004542 <ai_platform_network_init>:
 8004542:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004546:	b081      	sub	sp, #4
 8004548:	460a      	mov	r2, r1
 800454a:	b118      	cbz	r0, 8004554 <ai_platform_network_init+0x12>
 800454c:	6801      	ldr	r1, [r0, #0]
 800454e:	4b7e      	ldr	r3, [pc, #504]	; (8004748 <.text_23>)
 8004550:	4299      	cmp	r1, r3
 8004552:	d000      	beq.n	8004556 <ai_platform_network_init+0x14>
 8004554:	2000      	movs	r0, #0
 8004556:	4978      	ldr	r1, [pc, #480]	; (8004738 <.text_19>)
 8004558:	680b      	ldr	r3, [r1, #0]
 800455a:	085b      	lsrs	r3, r3, #1
 800455c:	005b      	lsls	r3, r3, #1
 800455e:	600b      	str	r3, [r1, #0]
 8004560:	2101      	movs	r1, #1
 8004562:	4b76      	ldr	r3, [pc, #472]	; (800473c <.text_20>)
 8004564:	6099      	str	r1, [r3, #8]
 8004566:	6899      	ldr	r1, [r3, #8]
 8004568:	2900      	cmp	r1, #0
 800456a:	d1fc      	bne.n	8004566 <ai_platform_network_init+0x24>
 800456c:	4c74      	ldr	r4, [pc, #464]	; (8004740 <.text_21>)
 800456e:	601c      	str	r4, [r3, #0]
 8004570:	6819      	ldr	r1, [r3, #0]
 8004572:	4b74      	ldr	r3, [pc, #464]	; (8004744 <.text_22>)
 8004574:	4299      	cmp	r1, r3
 8004576:	d000      	beq.n	800457a <ai_platform_network_init+0x38>
 8004578:	e7fe      	b.n	8004578 <ai_platform_network_init+0x36>
 800457a:	b340      	cbz	r0, 80045ce <ai_platform_network_init+0x8c>
 800457c:	b90a      	cbnz	r2, 8004582 <ai_platform_network_init+0x40>
 800457e:	2211      	movs	r2, #17
 8004580:	e006      	b.n	8004590 <ai_platform_network_init+0x4e>
 8004582:	69d1      	ldr	r1, [r2, #28]
 8004584:	b909      	cbnz	r1, 800458a <ai_platform_network_init+0x48>
 8004586:	2213      	movs	r2, #19
 8004588:	e002      	b.n	8004590 <ai_platform_network_init+0x4e>
 800458a:	68d1      	ldr	r1, [r2, #12]
 800458c:	b941      	cbnz	r1, 80045a0 <ai_platform_network_init+0x5e>
 800458e:	2212      	movs	r2, #18
 8004590:	2110      	movs	r1, #16
 8004592:	300c      	adds	r0, #12
 8004594:	f000 f8fd 	bl	8004792 <core_set_error>
 8004598:	2000      	movs	r0, #0
 800459a:	b001      	add	sp, #4
 800459c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80045a0:	ca78      	ldmia	r2!, {r3, r4, r5, r6}
 80045a2:	f100 0114 	add.w	r1, r0, #20
 80045a6:	f100 0724 	add.w	r7, r0, #36	; 0x24
 80045aa:	e881 0078 	stmia.w	r1, {r3, r4, r5, r6}
 80045ae:	e892 5300 	ldmia.w	r2, {r8, r9, ip, lr}
 80045b2:	e887 5300 	stmia.w	r7, {r8, r9, ip, lr}
 80045b6:	2103      	movs	r1, #3
 80045b8:	6081      	str	r1, [r0, #8]
 80045ba:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 80045bc:	b13a      	cbz	r2, 80045ce <ai_platform_network_init+0x8c>
 80045be:	6891      	ldr	r1, [r2, #8]
 80045c0:	6050      	str	r0, [r2, #4]
 80045c2:	428a      	cmp	r2, r1
 80045c4:	bf18      	it	ne
 80045c6:	2900      	cmpne	r1, #0
 80045c8:	bf18      	it	ne
 80045ca:	460a      	movne	r2, r1
 80045cc:	d1f7      	bne.n	80045be <ai_platform_network_init+0x7c>
 80045ce:	b001      	add	sp, #4
 80045d0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

080045d4 <.text_17>:
 80045d4:	00000000 	.word	0x00000000

080045d8 <ai_platform_network_process>:
 80045d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80045dc:	b083      	sub	sp, #12
 80045de:	b128      	cbz	r0, 80045ec <ai_platform_network_process+0x14>
 80045e0:	6803      	ldr	r3, [r0, #0]
 80045e2:	4c59      	ldr	r4, [pc, #356]	; (8004748 <.text_23>)
 80045e4:	42a3      	cmp	r3, r4
 80045e6:	bf08      	it	eq
 80045e8:	4605      	moveq	r5, r0
 80045ea:	d000      	beq.n	80045ee <ai_platform_network_process+0x16>
 80045ec:	2500      	movs	r5, #0
 80045ee:	4852      	ldr	r0, [pc, #328]	; (8004738 <.text_19>)
 80045f0:	6803      	ldr	r3, [r0, #0]
 80045f2:	085b      	lsrs	r3, r3, #1
 80045f4:	005b      	lsls	r3, r3, #1
 80045f6:	6003      	str	r3, [r0, #0]
 80045f8:	2001      	movs	r0, #1
 80045fa:	4b50      	ldr	r3, [pc, #320]	; (800473c <.text_20>)
 80045fc:	6098      	str	r0, [r3, #8]
 80045fe:	6898      	ldr	r0, [r3, #8]
 8004600:	2800      	cmp	r0, #0
 8004602:	d1fc      	bne.n	80045fe <ai_platform_network_process+0x26>
 8004604:	4c4e      	ldr	r4, [pc, #312]	; (8004740 <.text_21>)
 8004606:	601c      	str	r4, [r3, #0]
 8004608:	6818      	ldr	r0, [r3, #0]
 800460a:	4b4e      	ldr	r3, [pc, #312]	; (8004744 <.text_22>)
 800460c:	4298      	cmp	r0, r3
 800460e:	d000      	beq.n	8004612 <ai_platform_network_process+0x3a>
 8004610:	e7fe      	b.n	8004610 <ai_platform_network_process+0x38>
 8004612:	2d00      	cmp	r5, #0
 8004614:	d048      	beq.n	80046a8 <ai_platform_network_process+0xd0>
 8004616:	68ab      	ldr	r3, [r5, #8]
 8004618:	f003 0003 	and.w	r0, r3, #3
 800461c:	2803      	cmp	r0, #3
 800461e:	d002      	beq.n	8004626 <ai_platform_network_process+0x4e>
 8004620:	2230      	movs	r2, #48	; 0x30
 8004622:	2111      	movs	r1, #17
 8004624:	e03c      	b.n	80046a0 <ai_platform_network_process+0xc8>
 8004626:	000f      	movs	r7, r1
 8004628:	bf1c      	itt	ne
 800462a:	68f8      	ldrne	r0, [r7, #12]
 800462c:	2800      	cmpne	r0, #0
 800462e:	d035      	beq.n	800469c <ai_platform_network_process+0xc4>
 8004630:	8878      	ldrh	r0, [r7, #2]
 8004632:	b908      	cbnz	r0, 8004638 <ai_platform_network_process+0x60>
 8004634:	2221      	movs	r2, #33	; 0x21
 8004636:	e032      	b.n	800469e <ai_platform_network_process+0xc6>
 8004638:	0014      	movs	r4, r2
 800463a:	d00b      	beq.n	8004654 <ai_platform_network_process+0x7c>
 800463c:	68e1      	ldr	r1, [r4, #12]
 800463e:	b351      	cbz	r1, 8004696 <ai_platform_network_process+0xbe>
 8004640:	8861      	ldrh	r1, [r4, #2]
 8004642:	b911      	cbnz	r1, 800464a <ai_platform_network_process+0x72>
 8004644:	2221      	movs	r2, #33	; 0x21
 8004646:	2113      	movs	r1, #19
 8004648:	e02a      	b.n	80046a0 <ai_platform_network_process+0xc8>
 800464a:	4288      	cmp	r0, r1
 800464c:	d002      	beq.n	8004654 <ai_platform_network_process+0x7c>
 800464e:	2221      	movs	r2, #33	; 0x21
 8004650:	2102      	movs	r1, #2
 8004652:	e025      	b.n	80046a0 <ai_platform_network_process+0xc8>
 8004654:	05d8      	lsls	r0, r3, #23
 8004656:	bf4c      	ite	mi
 8004658:	2002      	movmi	r0, #2
 800465a:	2000      	movpl	r0, #0
 800465c:	0a59      	lsrs	r1, r3, #9
 800465e:	f001 0101 	and.w	r1, r1, #1
 8004662:	ea41 0800 	orr.w	r8, r1, r0
 8004666:	6b68      	ldr	r0, [r5, #52]	; 0x34
 8004668:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 800466a:	6806      	ldr	r6, [r0, #0]
 800466c:	6808      	ldr	r0, [r1, #0]
 800466e:	9000      	str	r0, [sp, #0]
 8004670:	6871      	ldr	r1, [r6, #4]
 8004672:	6830      	ldr	r0, [r6, #0]
 8004674:	f7ff fe24 	bl	80042c0 <ai_array_get_byte_size>
 8004678:	9001      	str	r0, [sp, #4]
 800467a:	9800      	ldr	r0, [sp, #0]
 800467c:	6841      	ldr	r1, [r0, #4]
 800467e:	6800      	ldr	r0, [r0, #0]
 8004680:	f7ff fe1e 	bl	80042c0 <ai_array_get_byte_size>
 8004684:	68f9      	ldr	r1, [r7, #12]
 8004686:	2c00      	cmp	r4, #0
 8004688:	4602      	mov	r2, r0
 800468a:	bf14      	ite	ne
 800468c:	f8d4 b00c 	ldrne.w	fp, [r4, #12]
 8004690:	f04f 0b00 	moveq.w	fp, #0
 8004694:	e00c      	b.n	80046b0 <ai_platform_network_process+0xd8>
 8004696:	2217      	movs	r2, #23
 8004698:	2113      	movs	r1, #19
 800469a:	e001      	b.n	80046a0 <ai_platform_network_process+0xc8>
 800469c:	2217      	movs	r2, #23
 800469e:	2112      	movs	r1, #18
 80046a0:	f105 000c 	add.w	r0, r5, #12
 80046a4:	f000 f875 	bl	8004792 <core_set_error>
 80046a8:	2000      	movs	r0, #0
 80046aa:	b003      	add	sp, #12
 80046ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80046b0:	f018 0002 	ands.w	r0, r8, #2
 80046b4:	bf14      	ite	ne
 80046b6:	f8df 9098 	ldrne.w	r9, [pc, #152]	; 8004750 <.text_25>
 80046ba:	f8df 9098 	ldreq.w	r9, [pc, #152]	; 8004754 <.text_26>
 80046be:	ea5f 73c8 	movs.w	r3, r8, lsl #31
 80046c2:	bf4c      	ite	mi
 80046c4:	f8df a088 	ldrmi.w	sl, [pc, #136]	; 8004750 <.text_25>
 80046c8:	f8df a08c 	ldrpl.w	sl, [pc, #140]	; 8004758 <.text_27>
 80046cc:	887b      	ldrh	r3, [r7, #2]
 80046ce:	822b      	strh	r3, [r5, #16]
 80046d0:	2700      	movs	r7, #0
 80046d2:	826f      	strh	r7, [r5, #18]
 80046d4:	b908      	cbnz	r0, 80046da <ai_platform_network_process+0x102>
 80046d6:	60b1      	str	r1, [r6, #8]
 80046d8:	60f1      	str	r1, [r6, #12]
 80046da:	b144      	cbz	r4, 80046ee <ai_platform_network_process+0x116>
 80046dc:	ea5f 70c8 	movs.w	r0, r8, lsl #31
 80046e0:	d405      	bmi.n	80046ee <ai_platform_network_process+0x116>
 80046e2:	9b00      	ldr	r3, [sp, #0]
 80046e4:	f8c3 b008 	str.w	fp, [r3, #8]
 80046e8:	9800      	ldr	r0, [sp, #0]
 80046ea:	f8c0 b00c 	str.w	fp, [r0, #12]
 80046ee:	8a68      	ldrh	r0, [r5, #18]
 80046f0:	8a2b      	ldrh	r3, [r5, #16]
 80046f2:	4298      	cmp	r0, r3
 80046f4:	d21c      	bcs.n	8004730 <ai_platform_network_process+0x158>
 80046f6:	462c      	mov	r4, r5
 80046f8:	4635      	mov	r5, r6
 80046fa:	9e01      	ldr	r6, [sp, #4]
 80046fc:	4617      	mov	r7, r2
 80046fe:	4688      	mov	r8, r1
 8004700:	68a8      	ldr	r0, [r5, #8]
 8004702:	4632      	mov	r2, r6
 8004704:	4641      	mov	r1, r8
 8004706:	47c8      	blx	r9
 8004708:	60a8      	str	r0, [r5, #8]
 800470a:	44b0      	add	r8, r6
 800470c:	4620      	mov	r0, r4
 800470e:	f000 f8d7 	bl	80048c0 <ai_layers_forward_all>
 8004712:	9800      	ldr	r0, [sp, #0]
 8004714:	6881      	ldr	r1, [r0, #8]
 8004716:	463a      	mov	r2, r7
 8004718:	4658      	mov	r0, fp
 800471a:	47d0      	blx	sl
 800471c:	eb00 0b07 	add.w	fp, r0, r7
 8004720:	8a60      	ldrh	r0, [r4, #18]
 8004722:	8a21      	ldrh	r1, [r4, #16]
 8004724:	1c40      	adds	r0, r0, #1
 8004726:	8260      	strh	r0, [r4, #18]
 8004728:	b280      	uxth	r0, r0
 800472a:	4288      	cmp	r0, r1
 800472c:	d3e8      	bcc.n	8004700 <ai_platform_network_process+0x128>
 800472e:	4625      	mov	r5, r4
 8004730:	8a68      	ldrh	r0, [r5, #18]
 8004732:	b003      	add	sp, #12
 8004734:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004738 <.text_19>:
 8004738:	e0002000 	.word	0xe0002000

0800473c <.text_20>:
 800473c:	40023000 	.word	0x40023000

08004740 <.text_21>:
 8004740:	f407a5c2 	.word	0xf407a5c2

08004744 <.text_22>:
 8004744:	b5e8b5cd 	.word	0xb5e8b5cd

08004748 <.text_23>:
 8004748:	a1c00100 	.word	0xa1c00100

0800474c <.text_24>:
 800474c:	01010001 	.word	0x01010001

08004750 <.text_25>:
 8004750:	08004317 	.word	0x08004317

08004754 <.text_26>:
 8004754:	08004433 	.word	0x08004433

08004758 <.text_27>:
 8004758:	08004437 	.word	0x08004437

0800475c <.text_28>:
 800475c:	00000303 	.word	0x00000303

08004760 <.text_29>:
 8004760:	00000001 	.word	0x00000001

08004764 <.text_30>:
 8004764:	00000101 	.word	0x00000101

08004768 <.text_31>:
 8004768:	00001030 	.word	0x00001030

0800476c <.text_32>:
 800476c:	00001001 	.word	0x00001001

08004770 <_platform_network_sanity_check{8}::signatures>:
 8004770:	84048403                                ....

08004774 <.text_34>:
 8004774:	00001002 	.word	0x00001002

08004778 <.text_35>:
 8004778:	00001010 	.word	0x00001010

0800477c <.text_36>:
 800477c:	00000000 	.word	0x00000000

08004780 <.text_37>:
 8004780:	00001010 	.word	0x00001010

08004784 <core_init>:
 8004784:	2001      	movs	r0, #1
 8004786:	4770      	bx	lr

08004788 <core_get_error>:
 8004788:	4601      	mov	r1, r0
 800478a:	2200      	movs	r2, #0
 800478c:	6808      	ldr	r0, [r1, #0]
 800478e:	600a      	str	r2, [r1, #0]
 8004790:	4770      	bx	lr

08004792 <core_set_error>:
 8004792:	7803      	ldrb	r3, [r0, #0]
 8004794:	ea5f 6c03 	movs.w	ip, r3, lsl #24
 8004798:	d104      	bne.n	80047a4 <core_set_error+0x12>
 800479a:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
 800479e:	6001      	str	r1, [r0, #0]
 80047a0:	2001      	movs	r0, #1
 80047a2:	4770      	bx	lr
 80047a4:	2000      	movs	r0, #0
 80047a6:	4770      	bx	lr

080047a8 <ai_layers_forward_layer>:
 80047a8:	b510      	push	{r4, lr}
 80047aa:	4604      	mov	r4, r0
 80047ac:	68e1      	ldr	r1, [r4, #12]
 80047ae:	4788      	blx	r1
 80047b0:	68a0      	ldr	r0, [r4, #8]
 80047b2:	42a0      	cmp	r0, r4
 80047b4:	bf08      	it	eq
 80047b6:	2000      	moveq	r0, #0
 80047b8:	bd10      	pop	{r4, pc}
	...

080047bc <ai_check_custom_types>:
 80047bc:	b500      	push	{lr}
 80047be:	b081      	sub	sp, #4
 80047c0:	b160      	cbz	r0, 80047dc <ai_check_custom_types+0x20>
 80047c2:	7801      	ldrb	r1, [r0, #0]
 80047c4:	2903      	cmp	r1, #3
 80047c6:	d109      	bne.n	80047dc <ai_check_custom_types+0x20>
 80047c8:	f05f 0204 	movs.w	r2, #4
 80047cc:	a163      	add	r1, pc, #396	; (adr r1, 800495c <ai_check_custom_types::ref_signatures>)
 80047ce:	f01a f995 	bl	801eafc <memcmp>
 80047d2:	1e40      	subs	r0, r0, #1
 80047d4:	4180      	sbcs	r0, r0
 80047d6:	0fc0      	lsrs	r0, r0, #31
 80047d8:	b001      	add	sp, #4
 80047da:	bd00      	pop	{pc}
 80047dc:	2000      	movs	r0, #0
 80047de:	b001      	add	sp, #4
 80047e0:	bd00      	pop	{pc}
	...

080047e4 <ai_layer_type_name>:
 80047e4:	f242 7211 	movw	r2, #10001	; 0x2711
 80047e8:	1a81      	subs	r1, r0, r2
 80047ea:	2901      	cmp	r1, #1
 80047ec:	bf84      	itt	hi
 80047ee:	1ec9      	subhi	r1, r1, #3
 80047f0:	290d      	cmphi	r1, #13
 80047f2:	d901      	bls.n	80047f8 <ai_layer_type_name+0x14>
 80047f4:	390f      	subs	r1, #15
 80047f6:	d145      	bne.n	8004884 <ai_layer_type_name+0xa0>
 80047f8:	1a80      	subs	r0, r0, r2
 80047fa:	d021      	beq.n	8004840 <ai_layer_type_name+0x5c>
 80047fc:	1e40      	subs	r0, r0, #1
 80047fe:	d021      	beq.n	8004844 <ai_layer_type_name+0x60>
 8004800:	1e80      	subs	r0, r0, #2
 8004802:	d021      	beq.n	8004848 <ai_layer_type_name+0x64>
 8004804:	1e40      	subs	r0, r0, #1
 8004806:	d021      	beq.n	800484c <ai_layer_type_name+0x68>
 8004808:	1e40      	subs	r0, r0, #1
 800480a:	d021      	beq.n	8004850 <ai_layer_type_name+0x6c>
 800480c:	1e40      	subs	r0, r0, #1
 800480e:	d021      	beq.n	8004854 <ai_layer_type_name+0x70>
 8004810:	1e40      	subs	r0, r0, #1
 8004812:	d021      	beq.n	8004858 <ai_layer_type_name+0x74>
 8004814:	1e40      	subs	r0, r0, #1
 8004816:	d021      	beq.n	800485c <ai_layer_type_name+0x78>
 8004818:	1e40      	subs	r0, r0, #1
 800481a:	d021      	beq.n	8004860 <ai_layer_type_name+0x7c>
 800481c:	1e40      	subs	r0, r0, #1
 800481e:	d021      	beq.n	8004864 <ai_layer_type_name+0x80>
 8004820:	1e40      	subs	r0, r0, #1
 8004822:	d021      	beq.n	8004868 <ai_layer_type_name+0x84>
 8004824:	1e40      	subs	r0, r0, #1
 8004826:	d021      	beq.n	800486c <ai_layer_type_name+0x88>
 8004828:	1e40      	subs	r0, r0, #1
 800482a:	d021      	beq.n	8004870 <ai_layer_type_name+0x8c>
 800482c:	1e40      	subs	r0, r0, #1
 800482e:	d021      	beq.n	8004874 <ai_layer_type_name+0x90>
 8004830:	1e40      	subs	r0, r0, #1
 8004832:	d021      	beq.n	8004878 <ai_layer_type_name+0x94>
 8004834:	1e40      	subs	r0, r0, #1
 8004836:	d021      	beq.n	800487c <ai_layer_type_name+0x98>
 8004838:	1e80      	subs	r0, r0, #2
 800483a:	d021      	beq.n	8004880 <ai_layer_type_name+0x9c>
 800483c:	a012      	add	r0, pc, #72	; (adr r0, 8004888 <.text_5>)
 800483e:	4770      	bx	lr
 8004840:	a012      	add	r0, pc, #72	; (adr r0, 800488c <.text_6>)
 8004842:	4770      	bx	lr
 8004844:	a012      	add	r0, pc, #72	; (adr r0, 8004890 <.text_7>)
 8004846:	4770      	bx	lr
 8004848:	a027      	add	r0, pc, #156	; (adr r0, 80048e8 <.text_14>)
 800484a:	4770      	bx	lr
 800484c:	a028      	add	r0, pc, #160	; (adr r0, 80048f0 <.text_15>)
 800484e:	4770      	bx	lr
 8004850:	a010      	add	r0, pc, #64	; (adr r0, 8004894 <.text_8>)
 8004852:	4770      	bx	lr
 8004854:	a010      	add	r0, pc, #64	; (adr r0, 8004898 <.text_9>)
 8004856:	4770      	bx	lr
 8004858:	a027      	add	r0, pc, #156	; (adr r0, 80048f8 <.text_16>)
 800485a:	4770      	bx	lr
 800485c:	a00f      	add	r0, pc, #60	; (adr r0, 800489c <.text_10>)
 800485e:	4770      	bx	lr
 8004860:	a027      	add	r0, pc, #156	; (adr r0, 8004900 <.text_17>)
 8004862:	4770      	bx	lr
 8004864:	a028      	add	r0, pc, #160	; (adr r0, 8004908 <.text_18>)
 8004866:	4770      	bx	lr
 8004868:	a02c      	add	r0, pc, #176	; (adr r0, 800491c <.text_19>)
 800486a:	4770      	bx	lr
 800486c:	a02d      	add	r0, pc, #180	; (adr r0, 8004924 <.text_20>)
 800486e:	4770      	bx	lr
 8004870:	a00b      	add	r0, pc, #44	; (adr r0, 80048a0 <.text_11>)
 8004872:	4770      	bx	lr
 8004874:	a02d      	add	r0, pc, #180	; (adr r0, 800492c <.text_21>)
 8004876:	4770      	bx	lr
 8004878:	a02e      	add	r0, pc, #184	; (adr r0, 8004934 <.text_22>)
 800487a:	4770      	bx	lr
 800487c:	a030      	add	r0, pc, #192	; (adr r0, 8004940 <.text_23>)
 800487e:	4770      	bx	lr
 8004880:	a034      	add	r0, pc, #208	; (adr r0, 8004954 <.text_24>)
 8004882:	4770      	bx	lr
 8004884:	a000      	add	r0, pc, #0	; (adr r0, 8004888 <.text_5>)
 8004886:	4770      	bx	lr

08004888 <.text_5>:
 8004888:	00000000 	.word	0x00000000

0800488c <.text_6>:
 800488c:	00444441 	.word	0x00444441

08004890 <.text_7>:
 8004890:	00004e42 	.word	0x00004e42

08004894 <.text_8>:
 8004894:	00555247 	.word	0x00555247

08004898 <.text_9>:
 8004898:	004e524c 	.word	0x004e524c

0800489c <.text_10>:
 800489c:	00004c4e 	.word	0x00004c4e

080048a0 <.text_11>:
 80048a0:	00004d53 	.word	0x00004d53

080048a4 <ai_layer_type_is_valid>:
 80048a4:	f242 7111 	movw	r1, #10001	; 0x2711
 80048a8:	1a40      	subs	r0, r0, r1
 80048aa:	2801      	cmp	r0, #1
 80048ac:	bf84      	itt	hi
 80048ae:	1ec0      	subhi	r0, r0, #3
 80048b0:	280d      	cmphi	r0, #13
 80048b2:	d901      	bls.n	80048b8 <ai_layer_type_is_valid+0x14>
 80048b4:	380f      	subs	r0, #15
 80048b6:	d101      	bne.n	80048bc <ai_layer_type_is_valid+0x18>
 80048b8:	2001      	movs	r0, #1
 80048ba:	4770      	bx	lr
 80048bc:	2000      	movs	r0, #0
 80048be:	4770      	bx	lr

080048c0 <ai_layers_forward_all>:
 80048c0:	b530      	push	{r4, r5, lr}
 80048c2:	4604      	mov	r4, r0
 80048c4:	b081      	sub	sp, #4
 80048c6:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80048c8:	b158      	cbz	r0, 80048e2 <ai_layers_forward_all+0x22>
 80048ca:	6420      	str	r0, [r4, #64]	; 0x40
 80048cc:	6c25      	ldr	r5, [r4, #64]	; 0x40
 80048ce:	68e9      	ldr	r1, [r5, #12]
 80048d0:	4628      	mov	r0, r5
 80048d2:	4788      	blx	r1
 80048d4:	68a8      	ldr	r0, [r5, #8]
 80048d6:	42a8      	cmp	r0, r5
 80048d8:	bf08      	it	eq
 80048da:	2000      	moveq	r0, #0
 80048dc:	2800      	cmp	r0, #0
 80048de:	6420      	str	r0, [r4, #64]	; 0x40
 80048e0:	d1f4      	bne.n	80048cc <ai_layers_forward_all+0xc>
 80048e2:	b001      	add	sp, #4
 80048e4:	bd30      	pop	{r4, r5, pc}
	...

080048e8 <.text_14>:
 80048e8:	564e4f43 	.word	0x564e4f43
 80048ec:	00004432 	.word	0x00004432

080048f0 <.text_15>:
 80048f0:	534e4544 	.word	0x534e4544
 80048f4:	00000045 	.word	0x00000045

080048f8 <.text_16>:
 80048f8:	4d54534c 	.word	0x4d54534c
 80048fc:	00000000 	.word	0x00000000

08004900 <.text_17>:
 8004900:	4d524f4e 	.word	0x4d524f4e
 8004904:	00000000 	.word	0x00000000

08004908 <.text_18>:
 8004908:	4954504f 	.word	0x4954504f
 800490c:	455a494d 	.word	0x455a494d
 8004910:	4f435f44 	.word	0x4f435f44
 8004914:	4432564e 	.word	0x4432564e
 8004918:	00000000 	.word	0x00000000

0800491c <.text_19>:
 800491c:	4d524550 	.word	0x4d524550
 8004920:	00455455 	.word	0x00455455

08004924 <.text_20>:
 8004924:	4c4f4f50 	.word	0x4c4f4f50
 8004928:	00000000 	.word	0x00000000

0800492c <.text_21>:
 800492c:	494c5053 	.word	0x494c5053
 8004930:	00000054 	.word	0x00000054

08004934 <.text_22>:
 8004934:	454d4954 	.word	0x454d4954
 8004938:	4c45445f 	.word	0x4c45445f
 800493c:	00005941 	.word	0x00005941

08004940 <.text_23>:
 8004940:	454d4954 	.word	0x454d4954
 8004944:	5349445f 	.word	0x5349445f
 8004948:	42495254 	.word	0x42495254
 800494c:	44455455 	.word	0x44455455
 8004950:	00000000 	.word	0x00000000

08004954 <.text_24>:
 8004954:	434e4f43 	.word	0x434e4f43
 8004958:	00005441 	.word	0x00005441

0800495c <ai_check_custom_types::ref_signatures>:
 800495c:	84048403                                ....

08004960 <func_dummy>:
 8004960:	4770      	bx	lr
	...

08004964 <ai_simple_conv2d_kernel_f32>:
 8004964:	e92d 4ff4 	stmdb	sp!, {r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004968:	469a      	mov	sl, r3
 800496a:	b081      	sub	sp, #4
 800496c:	4683      	mov	fp, r0
 800496e:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 8004970:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8004972:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8004976:	f8dd e048 	ldr.w	lr, [sp, #72]	; 0x48
 800497a:	9e13      	ldr	r6, [sp, #76]	; 0x4c
 800497c:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 800497e:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 8004980:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
 8004984:	fb05 f90c 	mul.w	r9, r5, ip
 8004988:	f8cd 9000 	str.w	r9, [sp]
 800498c:	460a      	mov	r2, r1
 800498e:	eba8 0903 	sub.w	r9, r8, r3
 8004992:	eba7 0909 	sub.w	r9, r7, r9
 8004996:	9f00      	ldr	r7, [sp, #0]
 8004998:	fb09 f907 	mul.w	r9, r9, r7
 800499c:	eba6 000e 	sub.w	r0, r6, lr
 80049a0:	eba6 010e 	sub.w	r1, r6, lr
 80049a4:	eba6 060e 	sub.w	r6, r6, lr
 80049a8:	9f01      	ldr	r7, [sp, #4]
 80049aa:	1a20      	subs	r0, r4, r0
 80049ac:	1a69      	subs	r1, r5, r1
 80049ae:	45da      	cmp	sl, fp
 80049b0:	fb05 e503 	mla	r5, r5, r3, lr
 80049b4:	fb06 fe0c 	mul.w	lr, r6, ip
 80049b8:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 80049ba:	bf0c      	ite	eq
 80049bc:	ed9f 0a97 	vldreq	s0, [pc, #604]	; 8004c1c <.text_5>
 80049c0:	eeb7 0a00 	vmovne.f32	s0, #112	; 0x3f800000  1.0
 80049c4:	fb0c f505 	mul.w	r5, ip, r5
 80049c8:	2e01      	cmp	r6, #1
 80049ca:	fb0c f000 	mul.w	r0, ip, r0
 80049ce:	fb01 f10c 	mul.w	r1, r1, ip
 80049d2:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 80049d6:	db51      	blt.n	8004a7c <ai_simple_conv2d_kernel_f32+0x118>
 80049d8:	4617      	mov	r7, r2
 80049da:	4632      	mov	r2, r6
 80049dc:	435c      	muls	r4, r3
 80049de:	fb0c f604 	mul.w	r6, ip, r4
 80049e2:	eb07 0486 	add.w	r4, r7, r6, lsl #2
 80049e6:	9400      	str	r4, [sp, #0]
 80049e8:	edda 0a00 	vldr	s1, [sl]
 80049ec:	9c00      	ldr	r4, [sp, #0]
 80049ee:	4543      	cmp	r3, r8
 80049f0:	ee60 0a80 	vmul.f32	s1, s1, s0
 80049f4:	f280 8038 	bge.w	8004a68 <ai_simple_conv2d_kernel_f32+0x104>
 80049f8:	eba8 0703 	sub.w	r7, r8, r3
 80049fc:	f1be 0f01 	cmp.w	lr, #1
 8004a00:	db2c      	blt.n	8004a5c <ai_simple_conv2d_kernel_f32+0xf8>
 8004a02:	f01e 0c03 	ands.w	ip, lr, #3
 8004a06:	d00a      	beq.n	8004a1e <ai_simple_conv2d_kernel_f32+0xba>
 8004a08:	ed95 1a00 	vldr	s2, [r5]
 8004a0c:	edd4 1a00 	vldr	s3, [r4]
 8004a10:	1d24      	adds	r4, r4, #4
 8004a12:	1d2d      	adds	r5, r5, #4
 8004a14:	f1bc 0c01 	subs.w	ip, ip, #1
 8004a18:	ee41 0a21 	vmla.f32	s1, s2, s3
 8004a1c:	d1f4      	bne.n	8004a08 <ai_simple_conv2d_kernel_f32+0xa4>
 8004a1e:	ea5f 069e 	movs.w	r6, lr, lsr #2
 8004a22:	d01b      	beq.n	8004a5c <ai_simple_conv2d_kernel_f32+0xf8>
 8004a24:	ed95 2a00 	vldr	s4, [r5]
 8004a28:	ed94 1a00 	vldr	s2, [r4]
 8004a2c:	edd5 1a01 	vldr	s3, [r5, #4]
 8004a30:	edd4 2a01 	vldr	s5, [r4, #4]
 8004a34:	ee42 0a01 	vmla.f32	s1, s4, s2
 8004a38:	ee41 0aa2 	vmla.f32	s1, s3, s5
 8004a3c:	ed95 2a02 	vldr	s4, [r5, #8]
 8004a40:	ed94 1a02 	vldr	s2, [r4, #8]
 8004a44:	edd5 1a03 	vldr	s3, [r5, #12]
 8004a48:	edd4 2a03 	vldr	s5, [r4, #12]
 8004a4c:	3410      	adds	r4, #16
 8004a4e:	3510      	adds	r5, #16
 8004a50:	ee42 0a01 	vmla.f32	s1, s4, s2
 8004a54:	1e76      	subs	r6, r6, #1
 8004a56:	ee41 0aa2 	vmla.f32	s1, s3, s5
 8004a5a:	d1e3      	bne.n	8004a24 <ai_simple_conv2d_kernel_f32+0xc0>
 8004a5c:	1e7f      	subs	r7, r7, #1
 8004a5e:	eb04 0480 	add.w	r4, r4, r0, lsl #2
 8004a62:	eb05 0581 	add.w	r5, r5, r1, lsl #2
 8004a66:	d1c9      	bne.n	80049fc <ai_simple_conv2d_kernel_f32+0x98>
 8004a68:	edcb 0a00 	vstr	s1, [fp]
 8004a6c:	1e52      	subs	r2, r2, #1
 8004a6e:	eb05 0589 	add.w	r5, r5, r9, lsl #2
 8004a72:	f10b 0b04 	add.w	fp, fp, #4
 8004a76:	f10a 0a04 	add.w	sl, sl, #4
 8004a7a:	d1b5      	bne.n	80049e8 <ai_simple_conv2d_kernel_f32+0x84>
 8004a7c:	b002      	add	sp, #8
 8004a7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08004a84 <ai_group_conv2d_kernel_f32>:
 8004a84:	e92d 4ffb 	stmdb	sp!, {r0, r1, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004a88:	4693      	mov	fp, r2
 8004a8a:	b087      	sub	sp, #28
 8004a8c:	9f19      	ldr	r7, [sp, #100]	; 0x64
 8004a8e:	f8dd c068 	ldr.w	ip, [sp, #104]	; 0x68
 8004a92:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8004a94:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8004a96:	9814      	ldr	r0, [sp, #80]	; 0x50
 8004a98:	f8dd a060 	ldr.w	sl, [sp, #96]	; 0x60
 8004a9c:	9c15      	ldr	r4, [sp, #84]	; 0x54
 8004a9e:	9d16      	ldr	r5, [sp, #88]	; 0x58
 8004aa0:	9e17      	ldr	r6, [sp, #92]	; 0x5c
 8004aa2:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8004aa4:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
 8004aa8:	fbb0 fafa 	udiv	sl, r0, sl
 8004aac:	1a98      	subs	r0, r3, r2
 8004aae:	1a20      	subs	r0, r4, r0
 8004ab0:	fb01 f900 	mul.w	r9, r1, r0
 8004ab4:	f8cd a008 	str.w	sl, [sp, #8]
 8004ab8:	1ae8      	subs	r0, r5, r3
 8004aba:	fbb1 f8f8 	udiv	r8, r1, r8
 8004abe:	fb05 fe08 	mul.w	lr, r5, r8
 8004ac2:	f8cd e000 	str.w	lr, [sp]
 8004ac6:	fb05 2507 	mla	r5, r5, r7, r2
 8004aca:	ebac 0e07 	sub.w	lr, ip, r7
 8004ace:	eba6 0e0e 	sub.w	lr, r6, lr
 8004ad2:	9e00      	ldr	r6, [sp, #0]
 8004ad4:	fb08 f505 	mul.w	r5, r8, r5
 8004ad8:	fb0e fe06 	mul.w	lr, lr, r6
 8004adc:	eb0b 0585 	add.w	r5, fp, r5, lsl #2
 8004ae0:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
 8004ae4:	9e07      	ldr	r6, [sp, #28]
 8004ae6:	1810      	adds	r0, r2, r0
 8004ae8:	45b3      	cmp	fp, r6
 8004aea:	bf0c      	ite	eq
 8004aec:	ed9f 0a4b 	vldreq	s0, [pc, #300]	; 8004c1c <.text_5>
 8004af0:	eeb7 0a00 	vmovne.f32	s0, #112	; 0x3f800000  1.0
 8004af4:	2600      	movs	r6, #0
 8004af6:	9600      	str	r6, [sp, #0]
 8004af8:	46b3      	mov	fp, r6
 8004afa:	9e18      	ldr	r6, [sp, #96]	; 0x60
 8004afc:	2e00      	cmp	r6, #0
 8004afe:	eba1 0a08 	sub.w	sl, r1, r8
 8004b02:	fb00 f008 	mul.w	r0, r0, r8
 8004b06:	f000 8086 	beq.w	8004c16 <ai_group_conv2d_kernel_f32+0x192>
 8004b0a:	437c      	muls	r4, r7
 8004b0c:	4361      	muls	r1, r4
 8004b0e:	9106      	str	r1, [sp, #24]
 8004b10:	9906      	ldr	r1, [sp, #24]
 8004b12:	9c00      	ldr	r4, [sp, #0]
 8004b14:	fb04 1408 	mla	r4, r4, r8, r1
 8004b18:	9902      	ldr	r1, [sp, #8]
 8004b1a:	2901      	cmp	r1, #1
 8004b1c:	db74      	blt.n	8004c08 <ai_group_conv2d_kernel_f32+0x184>
 8004b1e:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8004b20:	eb06 068b 	add.w	r6, r6, fp, lsl #2
 8004b24:	9605      	str	r6, [sp, #20]
 8004b26:	9907      	ldr	r1, [sp, #28]
 8004b28:	eb01 068b 	add.w	r6, r1, fp, lsl #2
 8004b2c:	9604      	str	r6, [sp, #16]
 8004b2e:	9e08      	ldr	r6, [sp, #32]
 8004b30:	9902      	ldr	r1, [sp, #8]
 8004b32:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 8004b36:	9403      	str	r4, [sp, #12]
 8004b38:	9719      	str	r7, [sp, #100]	; 0x64
 8004b3a:	f8cd c068 	str.w	ip, [sp, #104]	; 0x68
 8004b3e:	f8cd e004 	str.w	lr, [sp, #4]
 8004b42:	9f05      	ldr	r7, [sp, #20]
 8004b44:	f8dd c010 	ldr.w	ip, [sp, #16]
 8004b48:	9c19      	ldr	r4, [sp, #100]	; 0x64
 8004b4a:	9e1a      	ldr	r6, [sp, #104]	; 0x68
 8004b4c:	edd7 0a00 	vldr	s1, [r7]
 8004b50:	f8dd e00c 	ldr.w	lr, [sp, #12]
 8004b54:	42b4      	cmp	r4, r6
 8004b56:	ee60 0a80 	vmul.f32	s1, s1, s0
 8004b5a:	da44      	bge.n	8004be6 <ai_group_conv2d_kernel_f32+0x162>
 8004b5c:	1b34      	subs	r4, r6, r4
 8004b5e:	921b      	str	r2, [sp, #108]	; 0x6c
 8004b60:	931c      	str	r3, [sp, #112]	; 0x70
 8004b62:	9e1c      	ldr	r6, [sp, #112]	; 0x70
 8004b64:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8004b66:	1af3      	subs	r3, r6, r3
 8004b68:	2b01      	cmp	r3, #1
 8004b6a:	db34      	blt.n	8004bd6 <ai_group_conv2d_kernel_f32+0x152>
 8004b6c:	f1b8 0f01 	cmp.w	r8, #1
 8004b70:	db2d      	blt.n	8004bce <ai_group_conv2d_kernel_f32+0x14a>
 8004b72:	f018 0603 	ands.w	r6, r8, #3
 8004b76:	d00a      	beq.n	8004b8e <ai_group_conv2d_kernel_f32+0x10a>
 8004b78:	ed95 1a00 	vldr	s2, [r5]
 8004b7c:	edde 1a00 	vldr	s3, [lr]
 8004b80:	1d2d      	adds	r5, r5, #4
 8004b82:	1e76      	subs	r6, r6, #1
 8004b84:	ee41 0a21 	vmla.f32	s1, s2, s3
 8004b88:	f10e 0e04 	add.w	lr, lr, #4
 8004b8c:	d1f4      	bne.n	8004b78 <ai_group_conv2d_kernel_f32+0xf4>
 8004b8e:	ea5f 0298 	movs.w	r2, r8, lsr #2
 8004b92:	d01c      	beq.n	8004bce <ai_group_conv2d_kernel_f32+0x14a>
 8004b94:	ed95 2a00 	vldr	s4, [r5]
 8004b98:	ed9e 1a00 	vldr	s2, [lr]
 8004b9c:	edd5 1a01 	vldr	s3, [r5, #4]
 8004ba0:	edde 2a01 	vldr	s5, [lr, #4]
 8004ba4:	ee42 0a01 	vmla.f32	s1, s4, s2
 8004ba8:	ee41 0aa2 	vmla.f32	s1, s3, s5
 8004bac:	ed95 2a02 	vldr	s4, [r5, #8]
 8004bb0:	ed9e 1a02 	vldr	s2, [lr, #8]
 8004bb4:	edd5 1a03 	vldr	s3, [r5, #12]
 8004bb8:	edde 2a03 	vldr	s5, [lr, #12]
 8004bbc:	3510      	adds	r5, #16
 8004bbe:	ee42 0a01 	vmla.f32	s1, s4, s2
 8004bc2:	1e52      	subs	r2, r2, #1
 8004bc4:	ee41 0aa2 	vmla.f32	s1, s3, s5
 8004bc8:	f10e 0e10 	add.w	lr, lr, #16
 8004bcc:	d1e2      	bne.n	8004b94 <ai_group_conv2d_kernel_f32+0x110>
 8004bce:	1e5b      	subs	r3, r3, #1
 8004bd0:	eb0e 0e8a 	add.w	lr, lr, sl, lsl #2
 8004bd4:	d1ca      	bne.n	8004b6c <ai_group_conv2d_kernel_f32+0xe8>
 8004bd6:	1e64      	subs	r4, r4, #1
 8004bd8:	eb0e 0e89 	add.w	lr, lr, r9, lsl #2
 8004bdc:	eb05 0580 	add.w	r5, r5, r0, lsl #2
 8004be0:	d1bf      	bne.n	8004b62 <ai_group_conv2d_kernel_f32+0xde>
 8004be2:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8004be4:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8004be6:	9c01      	ldr	r4, [sp, #4]
 8004be8:	edcc 0a00 	vstr	s1, [ip]
 8004bec:	1d3f      	adds	r7, r7, #4
 8004bee:	1e49      	subs	r1, r1, #1
 8004bf0:	eb05 0584 	add.w	r5, r5, r4, lsl #2
 8004bf4:	f10b 0b01 	add.w	fp, fp, #1
 8004bf8:	f10c 0c04 	add.w	ip, ip, #4
 8004bfc:	d1a4      	bne.n	8004b48 <ai_group_conv2d_kernel_f32+0xc4>
 8004bfe:	9f19      	ldr	r7, [sp, #100]	; 0x64
 8004c00:	f8dd c068 	ldr.w	ip, [sp, #104]	; 0x68
 8004c04:	f8dd e004 	ldr.w	lr, [sp, #4]
 8004c08:	9c00      	ldr	r4, [sp, #0]
 8004c0a:	1c64      	adds	r4, r4, #1
 8004c0c:	9400      	str	r4, [sp, #0]
 8004c0e:	9918      	ldr	r1, [sp, #96]	; 0x60
 8004c10:	428c      	cmp	r4, r1
 8004c12:	f4ff af7d 	bcc.w	8004b10 <ai_group_conv2d_kernel_f32+0x8c>
 8004c16:	b00a      	add	sp, #40	; 0x28
 8004c18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004c1c <.text_5>:
 8004c1c:	00000000 	.word	0x00000000

08004c20 <ai_depthwise_conv2d_kernel_f32>:
 8004c20:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004c24:	460c      	mov	r4, r1
 8004c26:	4610      	mov	r0, r2
 8004c28:	4619      	mov	r1, r3
 8004c2a:	b088      	sub	sp, #32
 8004c2c:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
 8004c30:	f8dd e05c 	ldr.w	lr, [sp, #92]	; 0x5c
 8004c34:	f8dd c060 	ldr.w	ip, [sp, #96]	; 0x60
 8004c38:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8004c3a:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8004c3c:	9e14      	ldr	r6, [sp, #80]	; 0x50
 8004c3e:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 8004c40:	9f15      	ldr	r7, [sp, #84]	; 0x54
 8004c42:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
 8004c46:	ebac 0c0e 	sub.w	ip, ip, lr
 8004c4a:	ebab 0b0c 	sub.w	fp, fp, ip
 8004c4e:	fb0b fb07 	mul.w	fp, fp, r7
 8004c52:	f8cd c00c 	str.w	ip, [sp, #12]
 8004c56:	f8cd b008 	str.w	fp, [sp, #8]
 8004c5a:	eba3 0a02 	sub.w	sl, r3, r2
 8004c5e:	eba6 0a0a 	sub.w	sl, r6, sl
 8004c62:	fbb5 f5f8 	udiv	r5, r5, r8
 8004c66:	fb08 fa0a 	mul.w	sl, r8, sl
 8004c6a:	eba7 0903 	sub.w	r9, r7, r3
 8004c6e:	fb07 270e 	mla	r7, r7, lr, r2
 8004c72:	eb00 0087 	add.w	r0, r0, r7, lsl #2
 8004c76:	9f08      	ldr	r7, [sp, #32]
 8004c78:	42b9      	cmp	r1, r7
 8004c7a:	9f12      	ldr	r7, [sp, #72]	; 0x48
 8004c7c:	bf0c      	ite	eq
 8004c7e:	ed9f 0a49 	vldreq	s0, [pc, #292]	; 8004da4 <.text_7>
 8004c82:	eeb7 0a00 	vmovne.f32	s0, #112	; 0x3f800000  1.0
 8004c86:	2f00      	cmp	r7, #0
 8004c88:	4491      	add	r9, r2
 8004c8a:	f04f 0800 	mov.w	r8, #0
 8004c8e:	f000 8086 	beq.w	8004d9e <ai_depthwise_conv2d_kernel_f32+0x17e>
 8004c92:	fb06 f60e 	mul.w	r6, r6, lr
 8004c96:	4377      	muls	r7, r6
 8004c98:	9e12      	ldr	r6, [sp, #72]	; 0x48
 8004c9a:	9407      	str	r4, [sp, #28]
 8004c9c:	9106      	str	r1, [sp, #24]
 8004c9e:	9504      	str	r5, [sp, #16]
 8004ca0:	9701      	str	r7, [sp, #4]
 8004ca2:	9600      	str	r6, [sp, #0]
 8004ca4:	9904      	ldr	r1, [sp, #16]
 8004ca6:	9c01      	ldr	r4, [sp, #4]
 8004ca8:	2901      	cmp	r1, #1
 8004caa:	db70      	blt.n	8004d8e <ai_depthwise_conv2d_kernel_f32+0x16e>
 8004cac:	9906      	ldr	r1, [sp, #24]
 8004cae:	9d08      	ldr	r5, [sp, #32]
 8004cb0:	9e07      	ldr	r6, [sp, #28]
 8004cb2:	eb01 0788 	add.w	r7, r1, r8, lsl #2
 8004cb6:	9904      	ldr	r1, [sp, #16]
 8004cb8:	eb05 0c88 	add.w	ip, r5, r8, lsl #2
 8004cbc:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 8004cc0:	9405      	str	r4, [sp, #20]
 8004cc2:	f8cd e05c 	str.w	lr, [sp, #92]	; 0x5c
 8004cc6:	9c18      	ldr	r4, [sp, #96]	; 0x60
 8004cc8:	9d02      	ldr	r5, [sp, #8]
 8004cca:	9e17      	ldr	r6, [sp, #92]	; 0x5c
 8004ccc:	edd7 0a00 	vldr	s1, [r7]
 8004cd0:	f8dd e014 	ldr.w	lr, [sp, #20]
 8004cd4:	42a6      	cmp	r6, r4
 8004cd6:	ee60 0a80 	vmul.f32	s1, s1, s0
 8004cda:	da49      	bge.n	8004d70 <ai_depthwise_conv2d_kernel_f32+0x150>
 8004cdc:	9e03      	ldr	r6, [sp, #12]
 8004cde:	9219      	str	r2, [sp, #100]	; 0x64
 8004ce0:	931a      	str	r3, [sp, #104]	; 0x68
 8004ce2:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8004ce4:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8004ce6:	1a9a      	subs	r2, r3, r2
 8004ce8:	2a01      	cmp	r2, #1
 8004cea:	db39      	blt.n	8004d60 <ai_depthwise_conv2d_kernel_f32+0x140>
 8004cec:	f012 0303 	ands.w	r3, r2, #3
 8004cf0:	f000 800f 	beq.w	8004d12 <ai_depthwise_conv2d_kernel_f32+0xf2>
 8004cf4:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
 8004cf8:	ed90 1a00 	vldr	s2, [r0]
 8004cfc:	edde 1a00 	vldr	s3, [lr]
 8004d00:	1d00      	adds	r0, r0, #4
 8004d02:	1e5b      	subs	r3, r3, #1
 8004d04:	ee41 0a21 	vmla.f32	s1, s2, s3
 8004d08:	eb0e 0e8b 	add.w	lr, lr, fp, lsl #2
 8004d0c:	d1f4      	bne.n	8004cf8 <ai_depthwise_conv2d_kernel_f32+0xd8>
 8004d0e:	f8cd b048 	str.w	fp, [sp, #72]	; 0x48
 8004d12:	0892      	lsrs	r2, r2, #2
 8004d14:	d024      	beq.n	8004d60 <ai_depthwise_conv2d_kernel_f32+0x140>
 8004d16:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8004d18:	ed90 1a00 	vldr	s2, [r0]
 8004d1c:	edde 1a00 	vldr	s3, [lr]
 8004d20:	eb0e 0e83 	add.w	lr, lr, r3, lsl #2
 8004d24:	ee41 0a21 	vmla.f32	s1, s2, s3
 8004d28:	edd0 1a01 	vldr	s3, [r0, #4]
 8004d2c:	ed9e 1a00 	vldr	s2, [lr]
 8004d30:	eb0e 0e83 	add.w	lr, lr, r3, lsl #2
 8004d34:	ee41 0a81 	vmla.f32	s1, s3, s2
 8004d38:	ed90 1a02 	vldr	s2, [r0, #8]
 8004d3c:	edde 1a00 	vldr	s3, [lr]
 8004d40:	eb0e 0e83 	add.w	lr, lr, r3, lsl #2
 8004d44:	ee41 0a21 	vmla.f32	s1, s2, s3
 8004d48:	edd0 1a03 	vldr	s3, [r0, #12]
 8004d4c:	ed9e 1a00 	vldr	s2, [lr]
 8004d50:	3010      	adds	r0, #16
 8004d52:	1e52      	subs	r2, r2, #1
 8004d54:	ee41 0a81 	vmla.f32	s1, s3, s2
 8004d58:	eb0e 0e83 	add.w	lr, lr, r3, lsl #2
 8004d5c:	d1dc      	bne.n	8004d18 <ai_depthwise_conv2d_kernel_f32+0xf8>
 8004d5e:	9312      	str	r3, [sp, #72]	; 0x48
 8004d60:	1e76      	subs	r6, r6, #1
 8004d62:	eb0e 0e8a 	add.w	lr, lr, sl, lsl #2
 8004d66:	eb00 0089 	add.w	r0, r0, r9, lsl #2
 8004d6a:	d1ba      	bne.n	8004ce2 <ai_depthwise_conv2d_kernel_f32+0xc2>
 8004d6c:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8004d6e:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8004d70:	edcc 0a00 	vstr	s1, [ip]
 8004d74:	1d3f      	adds	r7, r7, #4
 8004d76:	1e49      	subs	r1, r1, #1
 8004d78:	eb00 0085 	add.w	r0, r0, r5, lsl #2
 8004d7c:	f108 0801 	add.w	r8, r8, #1
 8004d80:	f10c 0c04 	add.w	ip, ip, #4
 8004d84:	d1a1      	bne.n	8004cca <ai_depthwise_conv2d_kernel_f32+0xaa>
 8004d86:	f8dd e05c 	ldr.w	lr, [sp, #92]	; 0x5c
 8004d8a:	9418      	str	r4, [sp, #96]	; 0x60
 8004d8c:	9502      	str	r5, [sp, #8]
 8004d8e:	9c01      	ldr	r4, [sp, #4]
 8004d90:	9900      	ldr	r1, [sp, #0]
 8004d92:	1c64      	adds	r4, r4, #1
 8004d94:	1e49      	subs	r1, r1, #1
 8004d96:	9401      	str	r4, [sp, #4]
 8004d98:	9100      	str	r1, [sp, #0]
 8004d9a:	f47f af83 	bne.w	8004ca4 <ai_depthwise_conv2d_kernel_f32+0x84>
 8004d9e:	b009      	add	sp, #36	; 0x24
 8004da0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004da4 <.text_7>:
 8004da4:	00000000 	.word	0x00000000

08004da8 <ai_conv2d_kernel_f32>:
 8004da8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004dac:	b08b      	sub	sp, #44	; 0x2c
 8004dae:	b903      	cbnz	r3, 8004db2 <ai_conv2d_kernel_f32+0xa>
 8004db0:	4603      	mov	r3, r0
 8004db2:	f8dd e064 	ldr.w	lr, [sp, #100]	; 0x64
 8004db6:	9c14      	ldr	r4, [sp, #80]	; 0x50
 8004db8:	9d15      	ldr	r5, [sp, #84]	; 0x54
 8004dba:	9e16      	ldr	r6, [sp, #88]	; 0x58
 8004dbc:	9f17      	ldr	r7, [sp, #92]	; 0x5c
 8004dbe:	f8dd c060 	ldr.w	ip, [sp, #96]	; 0x60
 8004dc2:	f8dd 8068 	ldr.w	r8, [sp, #104]	; 0x68
 8004dc6:	f8dd 906c 	ldr.w	r9, [sp, #108]	; 0x6c
 8004dca:	f8dd a070 	ldr.w	sl, [sp, #112]	; 0x70
 8004dce:	f8dd b074 	ldr.w	fp, [sp, #116]	; 0x74
 8004dd2:	f1be 0f01 	cmp.w	lr, #1
 8004dd6:	d112      	bne.n	8004dfe <ai_conv2d_kernel_f32+0x56>
 8004dd8:	f8cd c010 	str.w	ip, [sp, #16]
 8004ddc:	f8cd b020 	str.w	fp, [sp, #32]
 8004de0:	f8cd a01c 	str.w	sl, [sp, #28]
 8004de4:	f8cd 9018 	str.w	r9, [sp, #24]
 8004de8:	f8cd 8014 	str.w	r8, [sp, #20]
 8004dec:	9703      	str	r7, [sp, #12]
 8004dee:	9602      	str	r6, [sp, #8]
 8004df0:	9501      	str	r5, [sp, #4]
 8004df2:	9400      	str	r4, [sp, #0]
 8004df4:	f7ff fdb6 	bl	8004964 <ai_simple_conv2d_kernel_f32>
 8004df8:	b00b      	add	sp, #44	; 0x2c
 8004dfa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004dfe:	45a6      	cmp	lr, r4
 8004e00:	d112      	bne.n	8004e28 <ai_conv2d_kernel_f32+0x80>
 8004e02:	f8cd c010 	str.w	ip, [sp, #16]
 8004e06:	f8cd b020 	str.w	fp, [sp, #32]
 8004e0a:	f8cd a01c 	str.w	sl, [sp, #28]
 8004e0e:	f8cd 9018 	str.w	r9, [sp, #24]
 8004e12:	f8cd 8014 	str.w	r8, [sp, #20]
 8004e16:	9703      	str	r7, [sp, #12]
 8004e18:	9602      	str	r6, [sp, #8]
 8004e1a:	9501      	str	r5, [sp, #4]
 8004e1c:	9400      	str	r4, [sp, #0]
 8004e1e:	f7ff feff 	bl	8004c20 <ai_depthwise_conv2d_kernel_f32>
 8004e22:	b00b      	add	sp, #44	; 0x2c
 8004e24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004e28:	f8cd e014 	str.w	lr, [sp, #20]
 8004e2c:	f8cd c010 	str.w	ip, [sp, #16]
 8004e30:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
 8004e34:	f8cd a020 	str.w	sl, [sp, #32]
 8004e38:	f8cd 901c 	str.w	r9, [sp, #28]
 8004e3c:	f8cd 8018 	str.w	r8, [sp, #24]
 8004e40:	9703      	str	r7, [sp, #12]
 8004e42:	9602      	str	r6, [sp, #8]
 8004e44:	9501      	str	r5, [sp, #4]
 8004e46:	9400      	str	r4, [sp, #0]
 8004e48:	f7ff fe1c 	bl	8004a84 <ai_group_conv2d_kernel_f32>
 8004e4c:	b00b      	add	sp, #44	; 0x2c
 8004e4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08004e54 <ai_dict8_dot_array_f32>:
 8004e54:	b4f0      	push	{r4, r5, r6, r7}
 8004e56:	9c04      	ldr	r4, [sp, #16]
 8004e58:	eb03 0584 	add.w	r5, r3, r4, lsl #2
 8004e5c:	3d20      	subs	r5, #32
 8004e5e:	2c08      	cmp	r4, #8
 8004e60:	ed9f 0ab4 	vldr	s0, [pc, #720]	; 8005134 <.text_10>
 8004e64:	d230      	bcs.n	8004ec8 <ai_dict8_dot_array_f32+0x74>
 8004e66:	f105 0420 	add.w	r4, r5, #32
 8004e6a:	42a3      	cmp	r3, r4
 8004e6c:	d224      	bcs.n	8004eb8 <ai_dict8_dot_array_f32+0x64>
 8004e6e:	780d      	ldrb	r5, [r1, #0]
 8004e70:	ed93 1a00 	vldr	s2, [r3]
 8004e74:	eb02 0685 	add.w	r6, r2, r5, lsl #2
 8004e78:	1d1b      	adds	r3, r3, #4
 8004e7a:	edd6 0a00 	vldr	s1, [r6]
 8004e7e:	42a3      	cmp	r3, r4
 8004e80:	ee00 0a81 	vmla.f32	s0, s1, s2
 8004e84:	d218      	bcs.n	8004eb8 <ai_dict8_dot_array_f32+0x64>
 8004e86:	784d      	ldrb	r5, [r1, #1]
 8004e88:	ed93 1a00 	vldr	s2, [r3]
 8004e8c:	eb02 0685 	add.w	r6, r2, r5, lsl #2
 8004e90:	1d1b      	adds	r3, r3, #4
 8004e92:	edd6 0a00 	vldr	s1, [r6]
 8004e96:	42a3      	cmp	r3, r4
 8004e98:	ee00 0a81 	vmla.f32	s0, s1, s2
 8004e9c:	d20c      	bcs.n	8004eb8 <ai_dict8_dot_array_f32+0x64>
 8004e9e:	788d      	ldrb	r5, [r1, #2]
 8004ea0:	ed93 1a00 	vldr	s2, [r3]
 8004ea4:	eb02 0685 	add.w	r6, r2, r5, lsl #2
 8004ea8:	1d1b      	adds	r3, r3, #4
 8004eaa:	1cc9      	adds	r1, r1, #3
 8004eac:	edd6 0a00 	vldr	s1, [r6]
 8004eb0:	42a3      	cmp	r3, r4
 8004eb2:	ee00 0a81 	vmla.f32	s0, s1, s2
 8004eb6:	d3da      	bcc.n	8004e6e <ai_dict8_dot_array_f32+0x1a>
 8004eb8:	edd0 0a00 	vldr	s1, [r0]
 8004ebc:	ee30 0a80 	vadd.f32	s0, s1, s0
 8004ec0:	ed80 0a00 	vstr	s0, [r0]
 8004ec4:	bcf0      	pop	{r4, r5, r6, r7}
 8004ec6:	4770      	bx	lr
 8004ec8:	f001 0403 	and.w	r4, r1, #3
 8004ecc:	2c03      	cmp	r4, #3
 8004ece:	d8f3      	bhi.n	8004eb8 <ai_dict8_dot_array_f32+0x64>
 8004ed0:	e8df f004 	tbb	[pc, r4]
 8004ed4:	4f433703 	.word	0x4f433703
 8004ed8:	e7ee      	b.n	8004eb8 <ai_dict8_dot_array_f32+0x64>
 8004eda:	429d      	cmp	r5, r3
 8004edc:	f080 80da 	bcs.w	8005094 <ai_dict8_dot_array_f32+0x240>
 8004ee0:	f105 0420 	add.w	r4, r5, #32
 8004ee4:	42a3      	cmp	r3, r4
 8004ee6:	d2e7      	bcs.n	8004eb8 <ai_dict8_dot_array_f32+0x64>
 8004ee8:	780d      	ldrb	r5, [r1, #0]
 8004eea:	ed93 1a00 	vldr	s2, [r3]
 8004eee:	eb02 0685 	add.w	r6, r2, r5, lsl #2
 8004ef2:	1d1b      	adds	r3, r3, #4
 8004ef4:	edd6 0a00 	vldr	s1, [r6]
 8004ef8:	42a3      	cmp	r3, r4
 8004efa:	ee00 0a81 	vmla.f32	s0, s1, s2
 8004efe:	d2db      	bcs.n	8004eb8 <ai_dict8_dot_array_f32+0x64>
 8004f00:	784d      	ldrb	r5, [r1, #1]
 8004f02:	ed93 1a00 	vldr	s2, [r3]
 8004f06:	eb02 0685 	add.w	r6, r2, r5, lsl #2
 8004f0a:	1d1b      	adds	r3, r3, #4
 8004f0c:	edd6 0a00 	vldr	s1, [r6]
 8004f10:	42a3      	cmp	r3, r4
 8004f12:	ee00 0a81 	vmla.f32	s0, s1, s2
 8004f16:	d2cf      	bcs.n	8004eb8 <ai_dict8_dot_array_f32+0x64>
 8004f18:	788d      	ldrb	r5, [r1, #2]
 8004f1a:	ed93 1a00 	vldr	s2, [r3]
 8004f1e:	eb02 0685 	add.w	r6, r2, r5, lsl #2
 8004f22:	1d1b      	adds	r3, r3, #4
 8004f24:	1cc9      	adds	r1, r1, #3
 8004f26:	edd6 0a00 	vldr	s1, [r6]
 8004f2a:	42a3      	cmp	r3, r4
 8004f2c:	ee00 0a81 	vmla.f32	s0, s1, s2
 8004f30:	d3da      	bcc.n	8004ee8 <ai_dict8_dot_array_f32+0x94>
 8004f32:	edd0 0a00 	vldr	s1, [r0]
 8004f36:	ee30 0a80 	vadd.f32	s0, s1, s0
 8004f3a:	ed80 0a00 	vstr	s0, [r0]
 8004f3e:	bcf0      	pop	{r4, r5, r6, r7}
 8004f40:	4770      	bx	lr
 8004f42:	f811 4b01 	ldrb.w	r4, [r1], #1
 8004f46:	ed93 1a00 	vldr	s2, [r3]
 8004f4a:	eb02 0684 	add.w	r6, r2, r4, lsl #2
 8004f4e:	1d1b      	adds	r3, r3, #4
 8004f50:	edd6 0a00 	vldr	s1, [r6]
 8004f54:	ee00 0a81 	vmla.f32	s0, s1, s2
 8004f58:	1f2d      	subs	r5, r5, #4
 8004f5a:	f811 4b01 	ldrb.w	r4, [r1], #1
 8004f5e:	ed93 1a00 	vldr	s2, [r3]
 8004f62:	eb02 0684 	add.w	r6, r2, r4, lsl #2
 8004f66:	1d1b      	adds	r3, r3, #4
 8004f68:	edd6 0a00 	vldr	s1, [r6]
 8004f6c:	ee00 0a81 	vmla.f32	s0, s1, s2
 8004f70:	1f2d      	subs	r5, r5, #4
 8004f72:	f811 4b01 	ldrb.w	r4, [r1], #1
 8004f76:	ed93 1a00 	vldr	s2, [r3]
 8004f7a:	eb02 0684 	add.w	r6, r2, r4, lsl #2
 8004f7e:	1d1c      	adds	r4, r3, #4
 8004f80:	1f2d      	subs	r5, r5, #4
 8004f82:	edd6 0a00 	vldr	s1, [r6]
 8004f86:	42a5      	cmp	r5, r4
 8004f88:	ee00 0a81 	vmla.f32	s0, s1, s2
 8004f8c:	d34e      	bcc.n	800502c <ai_dict8_dot_array_f32+0x1d8>
 8004f8e:	78cf      	ldrb	r7, [r1, #3]
 8004f90:	ed94 4a00 	vldr	s8, [r4]
 8004f94:	ed94 3a01 	vldr	s6, [r4, #4]
 8004f98:	ed94 2a02 	vldr	s4, [r4, #8]
 8004f9c:	ed94 1a03 	vldr	s2, [r4, #12]
 8004fa0:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 8004fa4:	788f      	ldrb	r7, [r1, #2]
 8004fa6:	edd6 0a00 	vldr	s1, [r6]
 8004faa:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 8004fae:	784f      	ldrb	r7, [r1, #1]
 8004fb0:	edd6 1a00 	vldr	s3, [r6]
 8004fb4:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 8004fb8:	780f      	ldrb	r7, [r1, #0]
 8004fba:	edd6 2a00 	vldr	s5, [r6]
 8004fbe:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 8004fc2:	f104 0310 	add.w	r3, r4, #16
 8004fc6:	edd6 3a00 	vldr	s7, [r6]
 8004fca:	790c      	ldrb	r4, [r1, #4]
 8004fcc:	ee03 0a84 	vmla.f32	s0, s7, s8
 8004fd0:	ee02 0a83 	vmla.f32	s0, s5, s6
 8004fd4:	ee01 0a82 	vmla.f32	s0, s3, s4
 8004fd8:	eb02 0784 	add.w	r7, r2, r4, lsl #2
 8004fdc:	ee00 0a81 	vmla.f32	s0, s1, s2
 8004fe0:	794c      	ldrb	r4, [r1, #5]
 8004fe2:	edd7 0a00 	vldr	s1, [r7]
 8004fe6:	ed93 4a00 	vldr	s8, [r3]
 8004fea:	edd3 3a01 	vldr	s7, [r3, #4]
 8004fee:	ed93 3a02 	vldr	s6, [r3, #8]
 8004ff2:	edd3 2a03 	vldr	s5, [r3, #12]
 8004ff6:	eb02 0784 	add.w	r7, r2, r4, lsl #2
 8004ffa:	798c      	ldrb	r4, [r1, #6]
 8004ffc:	ed97 1a00 	vldr	s2, [r7]
 8005000:	eb02 0784 	add.w	r7, r2, r4, lsl #2
 8005004:	79cc      	ldrb	r4, [r1, #7]
 8005006:	edd7 1a00 	vldr	s3, [r7]
 800500a:	eb02 0784 	add.w	r7, r2, r4, lsl #2
 800500e:	ee00 0a84 	vmla.f32	s0, s1, s8
 8005012:	3108      	adds	r1, #8
 8005014:	f103 0410 	add.w	r4, r3, #16
 8005018:	ee01 0a23 	vmla.f32	s0, s2, s7
 800501c:	ed97 2a00 	vldr	s4, [r7]
 8005020:	ee01 0a83 	vmla.f32	s0, s3, s6
 8005024:	42a5      	cmp	r5, r4
 8005026:	ee02 0a22 	vmla.f32	s0, s4, s5
 800502a:	d2b0      	bcs.n	8004f8e <ai_dict8_dot_array_f32+0x13a>
 800502c:	f105 0320 	add.w	r3, r5, #32
 8005030:	429c      	cmp	r4, r3
 8005032:	f4bf af41 	bcs.w	8004eb8 <ai_dict8_dot_array_f32+0x64>
 8005036:	780d      	ldrb	r5, [r1, #0]
 8005038:	ed94 1a00 	vldr	s2, [r4]
 800503c:	eb02 0685 	add.w	r6, r2, r5, lsl #2
 8005040:	1d24      	adds	r4, r4, #4
 8005042:	edd6 0a00 	vldr	s1, [r6]
 8005046:	429c      	cmp	r4, r3
 8005048:	ee00 0a81 	vmla.f32	s0, s1, s2
 800504c:	f4bf af34 	bcs.w	8004eb8 <ai_dict8_dot_array_f32+0x64>
 8005050:	784d      	ldrb	r5, [r1, #1]
 8005052:	ed94 1a00 	vldr	s2, [r4]
 8005056:	eb02 0685 	add.w	r6, r2, r5, lsl #2
 800505a:	1d24      	adds	r4, r4, #4
 800505c:	edd6 0a00 	vldr	s1, [r6]
 8005060:	429c      	cmp	r4, r3
 8005062:	ee00 0a81 	vmla.f32	s0, s1, s2
 8005066:	f4bf af27 	bcs.w	8004eb8 <ai_dict8_dot_array_f32+0x64>
 800506a:	788d      	ldrb	r5, [r1, #2]
 800506c:	ed94 1a00 	vldr	s2, [r4]
 8005070:	eb02 0685 	add.w	r6, r2, r5, lsl #2
 8005074:	1d24      	adds	r4, r4, #4
 8005076:	1cc9      	adds	r1, r1, #3
 8005078:	edd6 0a00 	vldr	s1, [r6]
 800507c:	429c      	cmp	r4, r3
 800507e:	ee00 0a81 	vmla.f32	s0, s1, s2
 8005082:	d3d8      	bcc.n	8005036 <ai_dict8_dot_array_f32+0x1e2>
 8005084:	edd0 0a00 	vldr	s1, [r0]
 8005088:	ee30 0a80 	vadd.f32	s0, s1, s0
 800508c:	ed80 0a00 	vstr	s0, [r0]
 8005090:	bcf0      	pop	{r4, r5, r6, r7}
 8005092:	4770      	bx	lr
 8005094:	78cf      	ldrb	r7, [r1, #3]
 8005096:	ed93 4a00 	vldr	s8, [r3]
 800509a:	ed93 3a01 	vldr	s6, [r3, #4]
 800509e:	ed93 2a02 	vldr	s4, [r3, #8]
 80050a2:	ed93 1a03 	vldr	s2, [r3, #12]
 80050a6:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 80050aa:	788f      	ldrb	r7, [r1, #2]
 80050ac:	edd6 0a00 	vldr	s1, [r6]
 80050b0:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 80050b4:	784f      	ldrb	r7, [r1, #1]
 80050b6:	edd6 1a00 	vldr	s3, [r6]
 80050ba:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 80050be:	780f      	ldrb	r7, [r1, #0]
 80050c0:	edd6 2a00 	vldr	s5, [r6]
 80050c4:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 80050c8:	f103 0410 	add.w	r4, r3, #16
 80050cc:	edd6 3a00 	vldr	s7, [r6]
 80050d0:	790b      	ldrb	r3, [r1, #4]
 80050d2:	ee03 0a84 	vmla.f32	s0, s7, s8
 80050d6:	ee02 0a83 	vmla.f32	s0, s5, s6
 80050da:	ee01 0a82 	vmla.f32	s0, s3, s4
 80050de:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 80050e2:	ee00 0a81 	vmla.f32	s0, s1, s2
 80050e6:	794b      	ldrb	r3, [r1, #5]
 80050e8:	edd7 0a00 	vldr	s1, [r7]
 80050ec:	ed94 4a00 	vldr	s8, [r4]
 80050f0:	edd4 3a01 	vldr	s7, [r4, #4]
 80050f4:	ed94 3a02 	vldr	s6, [r4, #8]
 80050f8:	edd4 2a03 	vldr	s5, [r4, #12]
 80050fc:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 8005100:	798b      	ldrb	r3, [r1, #6]
 8005102:	ed97 1a00 	vldr	s2, [r7]
 8005106:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 800510a:	79cb      	ldrb	r3, [r1, #7]
 800510c:	edd7 1a00 	vldr	s3, [r7]
 8005110:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 8005114:	ee00 0a84 	vmla.f32	s0, s1, s8
 8005118:	3108      	adds	r1, #8
 800511a:	f104 0310 	add.w	r3, r4, #16
 800511e:	ee01 0a23 	vmla.f32	s0, s2, s7
 8005122:	ed97 2a00 	vldr	s4, [r7]
 8005126:	ee01 0a83 	vmla.f32	s0, s3, s6
 800512a:	429d      	cmp	r5, r3
 800512c:	ee02 0a22 	vmla.f32	s0, s4, s5
 8005130:	d2b0      	bcs.n	8005094 <ai_dict8_dot_array_f32+0x240>
 8005132:	e6d5      	b.n	8004ee0 <ai_dict8_dot_array_f32+0x8c>

08005134 <.text_10>:
 8005134:	00000000 	.word	0x00000000

08005138 <ai_dict4_dot_array_f32>:
 8005138:	b4f0      	push	{r4, r5, r6, r7}
 800513a:	9c04      	ldr	r4, [sp, #16]
 800513c:	0865      	lsrs	r5, r4, #1
 800513e:	006d      	lsls	r5, r5, #1
 8005140:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8005144:	42ab      	cmp	r3, r5
 8005146:	ed9f 0a7c 	vldr	s0, [pc, #496]	; 8005338 <.text_13>
 800514a:	d22f      	bcs.n	80051ac <ai_dict4_dot_array_f32+0x74>
 800514c:	f811 6b01 	ldrb.w	r6, [r1], #1
 8005150:	ed93 2a00 	vldr	s4, [r3]
 8005154:	ed93 1a01 	vldr	s2, [r3, #4]
 8005158:	f006 070f 	and.w	r7, r6, #15
 800515c:	0936      	lsrs	r6, r6, #4
 800515e:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 8005162:	eb02 0787 	add.w	r7, r2, r7, lsl #2
 8005166:	edd6 1a00 	vldr	s3, [r6]
 800516a:	edd7 0a00 	vldr	s1, [r7]
 800516e:	3308      	adds	r3, #8
 8005170:	ee01 0a82 	vmla.f32	s0, s3, s4
 8005174:	42ab      	cmp	r3, r5
 8005176:	ee00 0a81 	vmla.f32	s0, s1, s2
 800517a:	d217      	bcs.n	80051ac <ai_dict4_dot_array_f32+0x74>
 800517c:	f811 6b01 	ldrb.w	r6, [r1], #1
 8005180:	ed93 2a00 	vldr	s4, [r3]
 8005184:	ed93 1a01 	vldr	s2, [r3, #4]
 8005188:	f006 070f 	and.w	r7, r6, #15
 800518c:	0936      	lsrs	r6, r6, #4
 800518e:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 8005192:	eb02 0787 	add.w	r7, r2, r7, lsl #2
 8005196:	edd6 1a00 	vldr	s3, [r6]
 800519a:	edd7 0a00 	vldr	s1, [r7]
 800519e:	3308      	adds	r3, #8
 80051a0:	ee01 0a82 	vmla.f32	s0, s3, s4
 80051a4:	42ab      	cmp	r3, r5
 80051a6:	ee00 0a81 	vmla.f32	s0, s1, s2
 80051aa:	d3cf      	bcc.n	800514c <ai_dict4_dot_array_f32+0x14>
 80051ac:	07e4      	lsls	r4, r4, #31
 80051ae:	d509      	bpl.n	80051c4 <ai_dict4_dot_array_f32+0x8c>
 80051b0:	7809      	ldrb	r1, [r1, #0]
 80051b2:	ed93 1a00 	vldr	s2, [r3]
 80051b6:	0909      	lsrs	r1, r1, #4
 80051b8:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 80051bc:	edd2 0a00 	vldr	s1, [r2]
 80051c0:	ee00 0a81 	vmla.f32	s0, s1, s2
 80051c4:	edd0 1a00 	vldr	s3, [r0]
 80051c8:	ee31 0a80 	vadd.f32	s0, s3, s0
 80051cc:	ed80 0a00 	vstr	s0, [r0]
 80051d0:	bcf0      	pop	{r4, r5, r6, r7}
 80051d2:	4770      	bx	lr

080051d4 <forward_conv2d>:
 80051d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80051d8:	4605      	mov	r5, r0
 80051da:	b099      	sub	sp, #100	; 0x64
 80051dc:	6968      	ldr	r0, [r5, #20]
 80051de:	6800      	ldr	r0, [r0, #0]
 80051e0:	6801      	ldr	r1, [r0, #0]
 80051e2:	6842      	ldr	r2, [r0, #4]
 80051e4:	6880      	ldr	r0, [r0, #8]
 80051e6:	680f      	ldr	r7, [r1, #0]
 80051e8:	f8d2 a000 	ldr.w	sl, [r2]
 80051ec:	f8d0 e000 	ldr.w	lr, [r0]
 80051f0:	6840      	ldr	r0, [r0, #4]
 80051f2:	68ba      	ldr	r2, [r7, #8]
 80051f4:	920c      	str	r2, [sp, #48]	; 0x30
 80051f6:	2800      	cmp	r0, #0
 80051f8:	f8da 3008 	ldr.w	r3, [sl, #8]
 80051fc:	9301      	str	r3, [sp, #4]
 80051fe:	f8da 1010 	ldr.w	r1, [sl, #16]
 8005202:	f8da 900c 	ldr.w	r9, [sl, #12]
 8005206:	693c      	ldr	r4, [r7, #16]
 8005208:	f8d7 800c 	ldr.w	r8, [r7, #12]
 800520c:	8c2b      	ldrh	r3, [r5, #32]
 800520e:	930b      	str	r3, [sp, #44]	; 0x2c
 8005210:	8cae      	ldrh	r6, [r5, #36]	; 0x24
 8005212:	960e      	str	r6, [sp, #56]	; 0x38
 8005214:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8005216:	8d2e      	ldrh	r6, [r5, #40]	; 0x28
 8005218:	f8de 300c 	ldr.w	r3, [lr, #12]
 800521c:	930d      	str	r3, [sp, #52]	; 0x34
 800521e:	b292      	uxth	r2, r2
 8005220:	f8de 3008 	ldr.w	r3, [lr, #8]
 8005224:	9300      	str	r3, [sp, #0]
 8005226:	683f      	ldr	r7, [r7, #0]
 8005228:	f8d7 c008 	ldr.w	ip, [r7, #8]
 800522c:	f8de 7000 	ldr.w	r7, [lr]
 8005230:	f8d7 e008 	ldr.w	lr, [r7, #8]
 8005234:	69ab      	ldr	r3, [r5, #24]
 8005236:	bf1a      	itte	ne
 8005238:	6800      	ldrne	r0, [r0, #0]
 800523a:	6887      	ldrne	r7, [r0, #8]
 800523c:	2700      	moveq	r7, #0
 800523e:	f8da 0000 	ldr.w	r0, [sl]
 8005242:	f8d0 a008 	ldr.w	sl, [r0, #8]
 8005246:	69e8      	ldr	r0, [r5, #28]
 8005248:	2800      	cmp	r0, #0
 800524a:	bf14      	ite	ne
 800524c:	4605      	movne	r5, r0
 800524e:	f8df 5728 	ldreq.w	r5, [pc, #1832]	; 8005978 <.text_18>
 8005252:	4252      	negs	r2, r2
 8005254:	2900      	cmp	r1, #0
 8005256:	920a      	str	r2, [sp, #40]	; 0x28
 8005258:	d06a      	beq.n	8005330 <forward_conv2d+0x15c>
 800525a:	4276      	negs	r6, r6
 800525c:	9618      	str	r6, [sp, #96]	; 0x60
 800525e:	f8cd 9054 	str.w	r9, [sp, #84]	; 0x54
 8005262:	9414      	str	r4, [sp, #80]	; 0x50
 8005264:	910f      	str	r1, [sp, #60]	; 0x3c
 8005266:	f8dd b034 	ldr.w	fp, [sp, #52]	; 0x34
 800526a:	980a      	ldr	r0, [sp, #40]	; 0x28
 800526c:	9914      	ldr	r1, [sp, #80]	; 0x50
 800526e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8005270:	9c15      	ldr	r4, [sp, #84]	; 0x54
 8005272:	9e18      	ldr	r6, [sp, #96]	; 0x60
 8005274:	4240      	negs	r0, r0
 8005276:	bfd8      	it	le
 8005278:	2000      	movle	r0, #0
 800527a:	1a89      	subs	r1, r1, r2
 800527c:	4559      	cmp	r1, fp
 800527e:	bf28      	it	cs
 8005280:	4659      	movcs	r1, fp
 8005282:	2c00      	cmp	r4, #0
 8005284:	fb08 6202 	mla	r2, r8, r2, r6
 8005288:	d04a      	beq.n	8005320 <forward_conv2d+0x14c>
 800528a:	9402      	str	r4, [sp, #8]
 800528c:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
 8005290:	9c01      	ldr	r4, [sp, #4]
 8005292:	f8dd 9000 	ldr.w	r9, [sp]
 8005296:	9313      	str	r3, [sp, #76]	; 0x4c
 8005298:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
 800529c:	f8cd e044 	str.w	lr, [sp, #68]	; 0x44
 80052a0:	9710      	str	r7, [sp, #64]	; 0x40
 80052a2:	9017      	str	r0, [sp, #92]	; 0x5c
 80052a4:	9116      	str	r1, [sp, #88]	; 0x58
 80052a6:	4693      	mov	fp, r2
 80052a8:	9f02      	ldr	r7, [sp, #8]
 80052aa:	4270      	negs	r0, r6
 80052ac:	bfd8      	it	le
 80052ae:	2000      	movle	r0, #0
 80052b0:	eba8 0106 	sub.w	r1, r8, r6
 80052b4:	4549      	cmp	r1, r9
 80052b6:	bf28      	it	cs
 80052b8:	4649      	movcs	r1, r9
 80052ba:	9109      	str	r1, [sp, #36]	; 0x24
 80052bc:	9008      	str	r0, [sp, #32]
 80052be:	f8cd 900c 	str.w	r9, [sp, #12]
 80052c2:	f8cd 8008 	str.w	r8, [sp, #8]
 80052c6:	9401      	str	r4, [sp, #4]
 80052c8:	4458      	add	r0, fp
 80052ca:	9916      	ldr	r1, [sp, #88]	; 0x58
 80052cc:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80052ce:	f8dd c048 	ldr.w	ip, [sp, #72]	; 0x48
 80052d2:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80052d4:	9107      	str	r1, [sp, #28]
 80052d6:	9206      	str	r2, [sp, #24]
 80052d8:	9913      	ldr	r1, [sp, #76]	; 0x4c
 80052da:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80052dc:	9105      	str	r1, [sp, #20]
 80052de:	9204      	str	r2, [sp, #16]
 80052e0:	990c      	ldr	r1, [sp, #48]	; 0x30
 80052e2:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80052e4:	9100      	str	r1, [sp, #0]
 80052e6:	990c      	ldr	r1, [sp, #48]	; 0x30
 80052e8:	4348      	muls	r0, r1
 80052ea:	eb0c 0180 	add.w	r1, ip, r0, lsl #2
 80052ee:	4650      	mov	r0, sl
 80052f0:	f7ff fd5a 	bl	8004da8 <ai_conv2d_kernel_f32>
 80052f4:	4622      	mov	r2, r4
 80052f6:	4651      	mov	r1, sl
 80052f8:	4650      	mov	r0, sl
 80052fa:	47a8      	blx	r5
 80052fc:	980b      	ldr	r0, [sp, #44]	; 0x2c
 80052fe:	1986      	adds	r6, r0, r6
 8005300:	1e7f      	subs	r7, r7, #1
 8005302:	eb0a 0a84 	add.w	sl, sl, r4, lsl #2
 8005306:	4483      	add	fp, r0
 8005308:	d1cf      	bne.n	80052aa <forward_conv2d+0xd6>
 800530a:	9401      	str	r4, [sp, #4]
 800530c:	f8cd 9000 	str.w	r9, [sp]
 8005310:	f8dd b034 	ldr.w	fp, [sp, #52]	; 0x34
 8005314:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8005316:	f8dd c048 	ldr.w	ip, [sp, #72]	; 0x48
 800531a:	f8dd e044 	ldr.w	lr, [sp, #68]	; 0x44
 800531e:	9f10      	ldr	r7, [sp, #64]	; 0x40
 8005320:	990a      	ldr	r1, [sp, #40]	; 0x28
 8005322:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8005324:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8005326:	1851      	adds	r1, r2, r1
 8005328:	1e64      	subs	r4, r4, #1
 800532a:	910a      	str	r1, [sp, #40]	; 0x28
 800532c:	940f      	str	r4, [sp, #60]	; 0x3c
 800532e:	d19c      	bne.n	800526a <forward_conv2d+0x96>
 8005330:	b019      	add	sp, #100	; 0x64
 8005332:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08005338 <.text_13>:
 8005338:	00000000 	.word	0x00000000

0800533c <forward_conv2d_nl_pool>:
 800533c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005340:	b0b5      	sub	sp, #212	; 0xd4
 8005342:	6941      	ldr	r1, [r0, #20]
 8005344:	6809      	ldr	r1, [r1, #0]
 8005346:	684b      	ldr	r3, [r1, #4]
 8005348:	680a      	ldr	r2, [r1, #0]
 800534a:	f8d3 e000 	ldr.w	lr, [r3]
 800534e:	6889      	ldr	r1, [r1, #8]
 8005350:	f8d2 b000 	ldr.w	fp, [r2]
 8005354:	f8d1 a000 	ldr.w	sl, [r1]
 8005358:	684a      	ldr	r2, [r1, #4]
 800535a:	f10b 0314 	add.w	r3, fp, #20
 800535e:	e893 00f0 	ldmia.w	r3, {r4, r5, r6, r7}
 8005362:	a92d      	add	r1, sp, #180	; 0xb4
 8005364:	e881 00f0 	stmia.w	r1, {r4, r5, r6, r7}
 8005368:	f8db 1008 	ldr.w	r1, [fp, #8]
 800536c:	9104      	str	r1, [sp, #16]
 800536e:	f8de 3008 	ldr.w	r3, [lr, #8]
 8005372:	9303      	str	r3, [sp, #12]
 8005374:	f8de 1010 	ldr.w	r1, [lr, #16]
 8005378:	f8de 400c 	ldr.w	r4, [lr, #12]
 800537c:	941a      	str	r4, [sp, #104]	; 0x68
 800537e:	f8db 5010 	ldr.w	r5, [fp, #16]
 8005382:	950d      	str	r5, [sp, #52]	; 0x34
 8005384:	f8db 400c 	ldr.w	r4, [fp, #12]
 8005388:	9402      	str	r4, [sp, #8]
 800538a:	8c05      	ldrh	r5, [r0, #32]
 800538c:	9510      	str	r5, [sp, #64]	; 0x40
 800538e:	8d04      	ldrh	r4, [r0, #40]	; 0x28
 8005390:	8c85      	ldrh	r5, [r0, #36]	; 0x24
 8005392:	f8b0 c02c 	ldrh.w	ip, [r0, #44]	; 0x2c
 8005396:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8005398:	f8ad 3006 	strh.w	r3, [sp, #6]
 800539c:	6b47      	ldr	r7, [r0, #52]	; 0x34
 800539e:	f8ad 7004 	strh.w	r7, [sp, #4]
 80053a2:	6983      	ldr	r3, [r0, #24]
 80053a4:	930c      	str	r3, [sp, #48]	; 0x30
 80053a6:	f8da 7008 	ldr.w	r7, [sl, #8]
 80053aa:	9700      	str	r7, [sp, #0]
 80053ac:	f8da 300c 	ldr.w	r3, [sl, #12]
 80053b0:	6b86      	ldr	r6, [r0, #56]	; 0x38
 80053b2:	960f      	str	r6, [sp, #60]	; 0x3c
 80053b4:	6bc6      	ldr	r6, [r0, #60]	; 0x3c
 80053b6:	9619      	str	r6, [sp, #100]	; 0x64
 80053b8:	6c06      	ldr	r6, [r0, #64]	; 0x40
 80053ba:	9618      	str	r6, [sp, #96]	; 0x60
 80053bc:	6c46      	ldr	r6, [r0, #68]	; 0x44
 80053be:	961c      	str	r6, [sp, #112]	; 0x70
 80053c0:	f8de 6020 	ldr.w	r6, [lr, #32]
 80053c4:	f8d0 9048 	ldr.w	r9, [r0, #72]	; 0x48
 80053c8:	6cc7      	ldr	r7, [r0, #76]	; 0x4c
 80053ca:	434e      	muls	r6, r1
 80053cc:	9605      	str	r6, [sp, #20]
 80053ce:	2a00      	cmp	r2, #0
 80053d0:	f8de 601c 	ldr.w	r6, [lr, #28]
 80053d4:	9617      	str	r6, [sp, #92]	; 0x5c
 80053d6:	f8db 6000 	ldr.w	r6, [fp]
 80053da:	68b6      	ldr	r6, [r6, #8]
 80053dc:	9616      	str	r6, [sp, #88]	; 0x58
 80053de:	f8da 6000 	ldr.w	r6, [sl]
 80053e2:	68b6      	ldr	r6, [r6, #8]
 80053e4:	960b      	str	r6, [sp, #44]	; 0x2c
 80053e6:	bf1a      	itte	ne
 80053e8:	6812      	ldrne	r2, [r2, #0]
 80053ea:	6892      	ldrne	r2, [r2, #8]
 80053ec:	2200      	moveq	r2, #0
 80053ee:	920a      	str	r2, [sp, #40]	; 0x28
 80053f0:	69c2      	ldr	r2, [r0, #28]
 80053f2:	2a00      	cmp	r2, #0
 80053f4:	bf12      	itee	ne
 80053f6:	920e      	strne	r2, [sp, #56]	; 0x38
 80053f8:	f8df 257c 	ldreq.w	r2, [pc, #1404]	; 8005978 <.text_18>
 80053fc:	920e      	streq	r2, [sp, #56]	; 0x38
 80053fe:	6d06      	ldr	r6, [r0, #80]	; 0x50
 8005400:	9a02      	ldr	r2, [sp, #8]
 8005402:	9800      	ldr	r0, [sp, #0]
 8005404:	f8dd 8014 	ldr.w	r8, [sp, #20]
 8005408:	9615      	str	r6, [sp, #84]	; 0x54
 800540a:	1a12      	subs	r2, r2, r0
 800540c:	f8bd 6006 	ldrh.w	r6, [sp, #6]
 8005410:	f8de e000 	ldr.w	lr, [lr]
 8005414:	9810      	ldr	r0, [sp, #64]	; 0x40
 8005416:	18a2      	adds	r2, r4, r2
 8005418:	1992      	adds	r2, r2, r6
 800541a:	fbb2 f6f0 	udiv	r6, r2, r0
 800541e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8005420:	f8bd 0004 	ldrh.w	r0, [sp, #4]
 8005424:	1ad2      	subs	r2, r2, r3
 8005426:	4462      	add	r2, ip
 8005428:	1810      	adds	r0, r2, r0
 800542a:	fbb0 f2f5 	udiv	r2, r0, r5
 800542e:	f8de 0008 	ldr.w	r0, [lr, #8]
 8005432:	1c76      	adds	r6, r6, #1
 8005434:	1c52      	adds	r2, r2, #1
 8005436:	427f      	negs	r7, r7
 8005438:	4480      	add	r8, r0
 800543a:	2900      	cmp	r1, #0
 800543c:	f8cd 8050 	str.w	r8, [sp, #80]	; 0x50
 8005440:	f000 811c 	beq.w	800567c <forward_conv2d_nl_pool+0x340>
 8005444:	f1c9 0900 	rsb	r9, r9, #0
 8005448:	f8cd 90cc 	str.w	r9, [sp, #204]	; 0xcc
 800544c:	9229      	str	r2, [sp, #164]	; 0xa4
 800544e:	9713      	str	r7, [sp, #76]	; 0x4c
 8005450:	9124      	str	r1, [sp, #144]	; 0x90
 8005452:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8005454:	9f13      	ldr	r7, [sp, #76]	; 0x4c
 8005456:	f8dd e064 	ldr.w	lr, [sp, #100]	; 0x64
 800545a:	9929      	ldr	r1, [sp, #164]	; 0xa4
 800545c:	2a00      	cmp	r2, #0
 800545e:	bfd8      	it	le
 8005460:	2200      	movle	r2, #0
 8005462:	4477      	add	r7, lr
 8005464:	42b9      	cmp	r1, r7
 8005466:	bf32      	itee	cc
 8005468:	4688      	movcc	r8, r1
 800546a:	f8dd 804c 	ldrcs.w	r8, [sp, #76]	; 0x4c
 800546e:	44f0      	addcs	r8, lr
 8005470:	991a      	ldr	r1, [sp, #104]	; 0x68
 8005472:	9f33      	ldr	r7, [sp, #204]	; 0xcc
 8005474:	2900      	cmp	r1, #0
 8005476:	f000 80f8 	beq.w	800566a <forward_conv2d_nl_pool+0x32e>
 800547a:	eba2 0a08 	sub.w	sl, r2, r8
 800547e:	f8cd a0c8 	str.w	sl, [sp, #200]	; 0xc8
 8005482:	f8cd c0a8 	str.w	ip, [sp, #168]	; 0xa8
 8005486:	9625      	str	r6, [sp, #148]	; 0x94
 8005488:	9223      	str	r2, [sp, #140]	; 0x8c
 800548a:	f8cd 809c 	str.w	r8, [sp, #156]	; 0x9c
 800548e:	9712      	str	r7, [sp, #72]	; 0x48
 8005490:	9122      	str	r1, [sp, #136]	; 0x88
 8005492:	9912      	ldr	r1, [sp, #72]	; 0x48
 8005494:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8005496:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 8005498:	f8dd c08c 	ldr.w	ip, [sp, #140]	; 0x8c
 800549c:	2900      	cmp	r1, #0
 800549e:	bfcc      	ite	gt
 80054a0:	460e      	movgt	r6, r1
 80054a2:	2600      	movle	r6, #0
 80054a4:	9925      	ldr	r1, [sp, #148]	; 0x94
 80054a6:	18ba      	adds	r2, r7, r2
 80054a8:	4291      	cmp	r1, r2
 80054aa:	bf31      	iteee	cc
 80054ac:	460f      	movcc	r7, r1
 80054ae:	9f12      	ldrcs	r7, [sp, #72]	; 0x48
 80054b0:	990f      	ldrcs	r1, [sp, #60]	; 0x3c
 80054b2:	19cf      	addcs	r7, r1, r7
 80054b4:	9932      	ldr	r1, [sp, #200]	; 0xc8
 80054b6:	1bf2      	subs	r2, r6, r7
 80054b8:	4351      	muls	r1, r2
 80054ba:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 80054bc:	4594      	cmp	ip, r2
 80054be:	4681      	mov	r9, r0
 80054c0:	f04f 0800 	mov.w	r8, #0
 80054c4:	f280 80c3 	bge.w	800564e <forward_conv2d_nl_pool+0x312>
 80054c8:	f8dd a08c 	ldr.w	sl, [sp, #140]	; 0x8c
 80054cc:	f8dd e0a8 	ldr.w	lr, [sp, #168]	; 0xa8
 80054d0:	fb05 fc0c 	mul.w	ip, r5, ip
 80054d4:	eba2 0a0a 	sub.w	sl, r2, sl
 80054d8:	ebac 0e0e 	sub.w	lr, ip, lr
 80054dc:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80054de:	952c      	str	r5, [sp, #176]	; 0xb0
 80054e0:	942b      	str	r4, [sp, #172]	; 0xac
 80054e2:	9621      	str	r6, [sp, #132]	; 0x84
 80054e4:	f8cd 7098 	str.w	r7, [sp, #152]	; 0x98
 80054e8:	f8cd e044 	str.w	lr, [sp, #68]	; 0x44
 80054ec:	f8cd a07c 	str.w	sl, [sp, #124]	; 0x7c
 80054f0:	f8dd c044 	ldr.w	ip, [sp, #68]	; 0x44
 80054f4:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 80054f6:	9d11      	ldr	r5, [sp, #68]	; 0x44
 80054f8:	f1dc 0c00 	rsbs	ip, ip, #0
 80054fc:	bfd8      	it	le
 80054fe:	f04f 0c00 	movle.w	ip, #0
 8005502:	1b64      	subs	r4, r4, r5
 8005504:	429c      	cmp	r4, r3
 8005506:	bf3a      	itte	cc
 8005508:	9c0d      	ldrcc	r4, [sp, #52]	; 0x34
 800550a:	eba4 0e05 	subcc.w	lr, r4, r5
 800550e:	469e      	movcs	lr, r3
 8005510:	9c21      	ldr	r4, [sp, #132]	; 0x84
 8005512:	9d2b      	ldr	r5, [sp, #172]	; 0xac
 8005514:	4354      	muls	r4, r2
 8005516:	eba4 0a05 	sub.w	sl, r4, r5
 800551a:	9c21      	ldr	r4, [sp, #132]	; 0x84
 800551c:	9d26      	ldr	r5, [sp, #152]	; 0x98
 800551e:	42ac      	cmp	r4, r5
 8005520:	f280 8089 	bge.w	8005636 <forward_conv2d_nl_pool+0x2fa>
 8005524:	eba5 0b04 	sub.w	fp, r5, r4
 8005528:	9d11      	ldr	r5, [sp, #68]	; 0x44
 800552a:	9e30      	ldr	r6, [sp, #192]	; 0xc0
 800552c:	9c04      	ldr	r4, [sp, #16]
 800552e:	9f00      	ldr	r7, [sp, #0]
 8005530:	9210      	str	r2, [sp, #64]	; 0x40
 8005532:	4375      	muls	r5, r6
 8005534:	9531      	str	r5, [sp, #196]	; 0xc4
 8005536:	931b      	str	r3, [sp, #108]	; 0x6c
 8005538:	9d03      	ldr	r5, [sp, #12]
 800553a:	9e02      	ldr	r6, [sp, #8]
 800553c:	9028      	str	r0, [sp, #160]	; 0xa0
 800553e:	9120      	str	r1, [sp, #128]	; 0x80
 8005540:	f8cd c078 	str.w	ip, [sp, #120]	; 0x78
 8005544:	f8cd e074 	str.w	lr, [sp, #116]	; 0x74
 8005548:	9931      	ldr	r1, [sp, #196]	; 0xc4
 800554a:	f8dd e0bc 	ldr.w	lr, [sp, #188]	; 0xbc
 800554e:	f1da 0200 	rsbs	r2, sl, #0
 8005552:	bfd8      	it	le
 8005554:	2200      	movle	r2, #0
 8005556:	eb02 030a 	add.w	r3, r2, sl
 800555a:	fb0e 1103 	mla	r1, lr, r3, r1
 800555e:	eba6 000a 	sub.w	r0, r6, sl
 8005562:	42b8      	cmp	r0, r7
 8005564:	9816      	ldr	r0, [sp, #88]	; 0x58
 8005566:	4401      	add	r1, r0
 8005568:	980a      	ldr	r0, [sp, #40]	; 0x28
 800556a:	bf34      	ite	cc
 800556c:	eba6 0c0a 	subcc.w	ip, r6, sl
 8005570:	46bc      	movcs	ip, r7
 8005572:	2800      	cmp	r0, #0
 8005574:	bf14      	ite	ne
 8005576:	4603      	movne	r3, r0
 8005578:	464b      	moveq	r3, r9
 800557a:	980c      	ldr	r0, [sp, #48]	; 0x30
 800557c:	2801      	cmp	r0, #1
 800557e:	d111      	bne.n	80055a4 <forward_conv2d_nl_pool+0x268>
 8005580:	9207      	str	r2, [sp, #28]
 8005582:	f8cd c020 	str.w	ip, [sp, #32]
 8005586:	981d      	ldr	r0, [sp, #116]	; 0x74
 8005588:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 800558a:	9006      	str	r0, [sp, #24]
 800558c:	9205      	str	r2, [sp, #20]
 800558e:	981b      	ldr	r0, [sp, #108]	; 0x6c
 8005590:	9004      	str	r0, [sp, #16]
 8005592:	9703      	str	r7, [sp, #12]
 8005594:	9602      	str	r6, [sp, #8]
 8005596:	9501      	str	r5, [sp, #4]
 8005598:	9400      	str	r4, [sp, #0]
 800559a:	4648      	mov	r0, r9
 800559c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800559e:	f7ff f9e1 	bl	8004964 <ai_simple_conv2d_kernel_f32>
 80055a2:	e026      	b.n	80055f2 <forward_conv2d_nl_pool+0x2b6>
 80055a4:	42a0      	cmp	r0, r4
 80055a6:	d111      	bne.n	80055cc <forward_conv2d_nl_pool+0x290>
 80055a8:	9207      	str	r2, [sp, #28]
 80055aa:	f8cd c020 	str.w	ip, [sp, #32]
 80055ae:	9703      	str	r7, [sp, #12]
 80055b0:	9602      	str	r6, [sp, #8]
 80055b2:	9501      	str	r5, [sp, #4]
 80055b4:	9400      	str	r4, [sp, #0]
 80055b6:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 80055b8:	981e      	ldr	r0, [sp, #120]	; 0x78
 80055ba:	9206      	str	r2, [sp, #24]
 80055bc:	9005      	str	r0, [sp, #20]
 80055be:	4648      	mov	r0, r9
 80055c0:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 80055c2:	9204      	str	r2, [sp, #16]
 80055c4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80055c6:	f7ff fb2b 	bl	8004c20 <ai_depthwise_conv2d_kernel_f32>
 80055ca:	e012      	b.n	80055f2 <forward_conv2d_nl_pool+0x2b6>
 80055cc:	9208      	str	r2, [sp, #32]
 80055ce:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 80055d2:	9703      	str	r7, [sp, #12]
 80055d4:	9602      	str	r6, [sp, #8]
 80055d6:	9501      	str	r5, [sp, #4]
 80055d8:	9400      	str	r4, [sp, #0]
 80055da:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 80055dc:	981d      	ldr	r0, [sp, #116]	; 0x74
 80055de:	9206      	str	r2, [sp, #24]
 80055e0:	9007      	str	r0, [sp, #28]
 80055e2:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 80055e4:	980c      	ldr	r0, [sp, #48]	; 0x30
 80055e6:	9204      	str	r2, [sp, #16]
 80055e8:	9005      	str	r0, [sp, #20]
 80055ea:	4648      	mov	r0, r9
 80055ec:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80055ee:	f7ff fa49 	bl	8004a84 <ai_group_conv2d_kernel_f32>
 80055f2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80055f4:	462a      	mov	r2, r5
 80055f6:	4649      	mov	r1, r9
 80055f8:	4648      	mov	r0, r9
 80055fa:	4798      	blx	r3
 80055fc:	9820      	ldr	r0, [sp, #128]	; 0x80
 80055fe:	f8dd c054 	ldr.w	ip, [sp, #84]	; 0x54
 8005602:	f108 0801 	add.w	r8, r8, #1
 8005606:	4540      	cmp	r0, r8
 8005608:	bf18      	it	ne
 800560a:	2000      	movne	r0, #0
 800560c:	9000      	str	r0, [sp, #0]
 800560e:	462b      	mov	r3, r5
 8005610:	9828      	ldr	r0, [sp, #160]	; 0xa0
 8005612:	462a      	mov	r2, r5
 8005614:	4649      	mov	r1, r9
 8005616:	47e0      	blx	ip
 8005618:	9810      	ldr	r0, [sp, #64]	; 0x40
 800561a:	f8dd 9050 	ldr.w	r9, [sp, #80]	; 0x50
 800561e:	f1bb 0b01 	subs.w	fp, fp, #1
 8005622:	4482      	add	sl, r0
 8005624:	d190      	bne.n	8005548 <forward_conv2d_nl_pool+0x20c>
 8005626:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8005628:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800562a:	9828      	ldr	r0, [sp, #160]	; 0xa0
 800562c:	9920      	ldr	r1, [sp, #128]	; 0x80
 800562e:	9404      	str	r4, [sp, #16]
 8005630:	9503      	str	r5, [sp, #12]
 8005632:	9602      	str	r6, [sp, #8]
 8005634:	9700      	str	r7, [sp, #0]
 8005636:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8005638:	9d2c      	ldr	r5, [sp, #176]	; 0xb0
 800563a:	192c      	adds	r4, r5, r4
 800563c:	9411      	str	r4, [sp, #68]	; 0x44
 800563e:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
 8005640:	1e64      	subs	r4, r4, #1
 8005642:	941f      	str	r4, [sp, #124]	; 0x7c
 8005644:	f47f af54 	bne.w	80054f0 <forward_conv2d_nl_pool+0x1b4>
 8005648:	9d2c      	ldr	r5, [sp, #176]	; 0xb0
 800564a:	9c2b      	ldr	r4, [sp, #172]	; 0xac
 800564c:	9210      	str	r2, [sp, #64]	; 0x40
 800564e:	9912      	ldr	r1, [sp, #72]	; 0x48
 8005650:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8005652:	1851      	adds	r1, r2, r1
 8005654:	9112      	str	r1, [sp, #72]	; 0x48
 8005656:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8005658:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800565a:	1e52      	subs	r2, r2, #1
 800565c:	4408      	add	r0, r1
 800565e:	9222      	str	r2, [sp, #136]	; 0x88
 8005660:	f47f af17 	bne.w	8005492 <forward_conv2d_nl_pool+0x156>
 8005664:	f8dd c0a8 	ldr.w	ip, [sp, #168]	; 0xa8
 8005668:	9e25      	ldr	r6, [sp, #148]	; 0x94
 800566a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800566c:	9f1c      	ldr	r7, [sp, #112]	; 0x70
 800566e:	18ba      	adds	r2, r7, r2
 8005670:	9213      	str	r2, [sp, #76]	; 0x4c
 8005672:	9924      	ldr	r1, [sp, #144]	; 0x90
 8005674:	1e49      	subs	r1, r1, #1
 8005676:	9124      	str	r1, [sp, #144]	; 0x90
 8005678:	f47f aeeb 	bne.w	8005452 <forward_conv2d_nl_pool+0x116>
 800567c:	b035      	add	sp, #212	; 0xd4
 800567e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08005684 <forward_dense>:
 8005684:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005688:	b089      	sub	sp, #36	; 0x24
 800568a:	6940      	ldr	r0, [r0, #20]
 800568c:	6800      	ldr	r0, [r0, #0]
 800568e:	6801      	ldr	r1, [r0, #0]
 8005690:	6842      	ldr	r2, [r0, #4]
 8005692:	6880      	ldr	r0, [r0, #8]
 8005694:	f8d0 8000 	ldr.w	r8, [r0]
 8005698:	6844      	ldr	r4, [r0, #4]
 800569a:	680e      	ldr	r6, [r1, #0]
 800569c:	f8d2 e000 	ldr.w	lr, [r2]
 80056a0:	f8de 000c 	ldr.w	r0, [lr, #12]
 80056a4:	f8de 2010 	ldr.w	r2, [lr, #16]
 80056a8:	68b5      	ldr	r5, [r6, #8]
 80056aa:	f8de 1008 	ldr.w	r1, [lr, #8]
 80056ae:	4350      	muls	r0, r2
 80056b0:	f8d8 2000 	ldr.w	r2, [r8]
 80056b4:	6813      	ldr	r3, [r2, #0]
 80056b6:	ea4f 5a53 	mov.w	sl, r3, lsr #21
 80056ba:	f3c3 19c6 	ubfx	r9, r3, #7, #7
 80056be:	f00a 0a03 	and.w	sl, sl, #3
 80056c2:	0c5b      	lsrs	r3, r3, #17
 80056c4:	2700      	movs	r7, #0
 80056c6:	fa29 f90a 	lsr.w	r9, r9, sl
 80056ca:	f003 030f 	and.w	r3, r3, #15
 80056ce:	f8cd 9004 	str.w	r9, [sp, #4]
 80056d2:	2b04      	cmp	r3, #4
 80056d4:	6836      	ldr	r6, [r6, #0]
 80056d6:	bf14      	ite	ne
 80056d8:	2b08      	cmpne	r3, #8
 80056da:	68d7      	ldreq	r7, [r2, #12]
 80056dc:	f8de 2000 	ldr.w	r2, [lr]
 80056e0:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80056e4:	f8d2 9008 	ldr.w	r9, [r2, #8]
 80056e8:	68b2      	ldr	r2, [r6, #8]
 80056ea:	2800      	cmp	r0, #0
 80056ec:	eb09 0681 	add.w	r6, r9, r1, lsl #2
 80056f0:	d066      	beq.n	80057c0 <forward_dense+0x13c>
 80056f2:	f8cd 801c 	str.w	r8, [sp, #28]
 80056f6:	9405      	str	r4, [sp, #20]
 80056f8:	9106      	str	r1, [sp, #24]
 80056fa:	9704      	str	r7, [sp, #16]
 80056fc:	9600      	str	r6, [sp, #0]
 80056fe:	9003      	str	r0, [sp, #12]
 8005700:	9807      	ldr	r0, [sp, #28]
 8005702:	6801      	ldr	r1, [r0, #0]
 8005704:	6888      	ldr	r0, [r1, #8]
 8005706:	9905      	ldr	r1, [sp, #20]
 8005708:	b109      	cbz	r1, 800570e <forward_dense+0x8a>
 800570a:	680c      	ldr	r4, [r1, #0]
 800570c:	68a1      	ldr	r1, [r4, #8]
 800570e:	9c04      	ldr	r4, [sp, #16]
 8005710:	2c00      	cmp	r4, #0
 8005712:	9c00      	ldr	r4, [sp, #0]
 8005714:	d110      	bne.n	8005738 <forward_dense+0xb4>
 8005716:	45a1      	cmp	r9, r4
 8005718:	d247      	bcs.n	80057aa <forward_dense+0x126>
 800571a:	46a2      	mov	sl, r4
 800571c:	462e      	mov	r6, r5
 800571e:	464f      	mov	r7, r9
 8005720:	461c      	mov	r4, r3
 8005722:	4690      	mov	r8, r2
 8005724:	4681      	mov	r9, r0
 8005726:	460d      	mov	r5, r1
 8005728:	2d00      	cmp	r5, #0
 800572a:	bf19      	ittee	ne
 800572c:	f855 0b04 	ldrne.w	r0, [r5], #4
 8005730:	9002      	strne	r0, [sp, #8]
 8005732:	2100      	moveq	r1, #0
 8005734:	9102      	streq	r1, [sp, #8]
 8005736:	e028      	b.n	800578a <forward_dense+0x106>
 8005738:	45a1      	cmp	r9, r4
 800573a:	d236      	bcs.n	80057aa <forward_dense+0x126>
 800573c:	9c04      	ldr	r4, [sp, #16]
 800573e:	9f00      	ldr	r7, [sp, #0]
 8005740:	4698      	mov	r8, r3
 8005742:	4616      	mov	r6, r2
 8005744:	4682      	mov	sl, r0
 8005746:	468b      	mov	fp, r1
 8005748:	f1bb 0f00 	cmp.w	fp, #0
 800574c:	bf19      	ittee	ne
 800574e:	f85b 0b04 	ldrne.w	r0, [fp], #4
 8005752:	9002      	strne	r0, [sp, #8]
 8005754:	2000      	moveq	r0, #0
 8005756:	9002      	streq	r0, [sp, #8]
 8005758:	9901      	ldr	r1, [sp, #4]
 800575a:	9500      	str	r5, [sp, #0]
 800575c:	2904      	cmp	r1, #4
 800575e:	4633      	mov	r3, r6
 8005760:	4622      	mov	r2, r4
 8005762:	4651      	mov	r1, sl
 8005764:	a802      	add	r0, sp, #8
 8005766:	d103      	bne.n	8005770 <forward_dense+0xec>
 8005768:	f7ff fce6 	bl	8005138 <ai_dict4_dot_array_f32>
 800576c:	e002      	b.n	8005774 <forward_dense+0xf0>
 800576e:	bf00      	nop
 8005770:	f7ff fb70 	bl	8004e54 <ai_dict8_dot_array_f32>
 8005774:	9802      	ldr	r0, [sp, #8]
 8005776:	f849 0b04 	str.w	r0, [r9], #4
 800577a:	45b9      	cmp	r9, r7
 800577c:	44c2      	add	sl, r8
 800577e:	d3e3      	bcc.n	8005748 <forward_dense+0xc4>
 8005780:	9404      	str	r4, [sp, #16]
 8005782:	4643      	mov	r3, r8
 8005784:	4632      	mov	r2, r6
 8005786:	9700      	str	r7, [sp, #0]
 8005788:	e00f      	b.n	80057aa <forward_dense+0x126>
 800578a:	4633      	mov	r3, r6
 800578c:	4642      	mov	r2, r8
 800578e:	4649      	mov	r1, r9
 8005790:	a802      	add	r0, sp, #8
 8005792:	f7fe fd1d 	bl	80041d0 <ai_math_dot_array>
 8005796:	9802      	ldr	r0, [sp, #8]
 8005798:	f847 0b04 	str.w	r0, [r7], #4
 800579c:	4557      	cmp	r7, sl
 800579e:	44a1      	add	r9, r4
 80057a0:	d3c2      	bcc.n	8005728 <forward_dense+0xa4>
 80057a2:	4635      	mov	r5, r6
 80057a4:	4623      	mov	r3, r4
 80057a6:	46b9      	mov	r9, r7
 80057a8:	4642      	mov	r2, r8
 80057aa:	9800      	ldr	r0, [sp, #0]
 80057ac:	9906      	ldr	r1, [sp, #24]
 80057ae:	eb00 0481 	add.w	r4, r0, r1, lsl #2
 80057b2:	9803      	ldr	r0, [sp, #12]
 80057b4:	9400      	str	r4, [sp, #0]
 80057b6:	1e40      	subs	r0, r0, #1
 80057b8:	eb02 0285 	add.w	r2, r2, r5, lsl #2
 80057bc:	9003      	str	r0, [sp, #12]
 80057be:	d19f      	bne.n	8005700 <forward_dense+0x7c>
 80057c0:	b009      	add	sp, #36	; 0x24
 80057c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

080057c8 <arm_mat_gemm_f32>:
 80057c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80057cc:	b08a      	sub	sp, #40	; 0x28
 80057ce:	4615      	mov	r5, r2
 80057d0:	468b      	mov	fp, r1
 80057d2:	469a      	mov	sl, r3
 80057d4:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80057d6:	f8d0 c004 	ldr.w	ip, [r0, #4]
 80057da:	6869      	ldr	r1, [r5, #4]
 80057dc:	9100      	str	r1, [sp, #0]
 80057de:	685c      	ldr	r4, [r3, #4]
 80057e0:	9402      	str	r4, [sp, #8]
 80057e2:	f8b3 9000 	ldrh.w	r9, [r3]
 80057e6:	8804      	ldrh	r4, [r0, #0]
 80057e8:	885e      	ldrh	r6, [r3, #2]
 80057ea:	8840      	ldrh	r0, [r0, #2]
 80057ec:	f8bb 1000 	ldrh.w	r1, [fp]
 80057f0:	f8bb 2002 	ldrh.w	r2, [fp, #2]
 80057f4:	f8b5 e000 	ldrh.w	lr, [r5]
 80057f8:	886f      	ldrh	r7, [r5, #2]
 80057fa:	f8db 3004 	ldr.w	r3, [fp, #4]
 80057fe:	9305      	str	r3, [sp, #20]
 8005800:	9304      	str	r3, [sp, #16]
 8005802:	2500      	movs	r5, #0
 8005804:	fa4f f38a 	sxtb.w	r3, sl
 8005808:	2b00      	cmp	r3, #0
 800580a:	bf0c      	ite	eq
 800580c:	46a0      	moveq	r8, r4
 800580e:	4680      	movne	r8, r0
 8005810:	2f01      	cmp	r7, #1
 8005812:	bf0c      	ite	eq
 8005814:	2300      	moveq	r3, #0
 8005816:	2304      	movne	r3, #4
 8005818:	f1be 0f01 	cmp.w	lr, #1
 800581c:	d104      	bne.n	8005828 <arm_mat_gemm_f32+0x60>
 800581e:	2f01      	cmp	r7, #1
 8005820:	d007      	beq.n	8005832 <arm_mat_gemm_f32+0x6a>
 8005822:	f1c6 0e00 	rsb	lr, r6, #0
 8005826:	e005      	b.n	8005834 <arm_mat_gemm_f32+0x6c>
 8005828:	2f01      	cmp	r7, #1
 800582a:	bf08      	it	eq
 800582c:	f04f 0e01 	moveq.w	lr, #1
 8005830:	d000      	beq.n	8005834 <arm_mat_gemm_f32+0x6c>
 8005832:	46ae      	mov	lr, r5
 8005834:	fa0f f78e 	sxth.w	r7, lr
 8005838:	9701      	str	r7, [sp, #4]
 800583a:	fa4f f78a 	sxtb.w	r7, sl
 800583e:	2f00      	cmp	r7, #0
 8005840:	bf0c      	ite	eq
 8005842:	46a3      	moveq	fp, r4
 8005844:	4683      	movne	fp, r0
 8005846:	45cb      	cmp	fp, r9
 8005848:	d115      	bne.n	8005876 <arm_mat_gemm_f32+0xae>
 800584a:	f99d e04c 	ldrsb.w	lr, [sp, #76]	; 0x4c
 800584e:	f1be 0f00 	cmp.w	lr, #0
 8005852:	bf0c      	ite	eq
 8005854:	4691      	moveq	r9, r2
 8005856:	4689      	movne	r9, r1
 8005858:	45b1      	cmp	r9, r6
 800585a:	d10c      	bne.n	8005876 <arm_mat_gemm_f32+0xae>
 800585c:	fa4f f68a 	sxtb.w	r6, sl
 8005860:	2e00      	cmp	r6, #0
 8005862:	bf0c      	ite	eq
 8005864:	4683      	moveq	fp, r0
 8005866:	46a3      	movne	fp, r4
 8005868:	f1be 0f00 	cmp.w	lr, #0
 800586c:	bf0c      	ite	eq
 800586e:	460e      	moveq	r6, r1
 8005870:	4616      	movne	r6, r2
 8005872:	45b3      	cmp	fp, r6
 8005874:	d06c      	beq.n	8005950 <arm_mat_gemm_f32+0x188>
 8005876:	f06f 0002 	mvn.w	r0, #2
 800587a:	b00a      	add	sp, #40	; 0x28
 800587c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005880:	9d05      	ldr	r5, [sp, #20]
 8005882:	0097      	lsls	r7, r2, #2
 8005884:	9708      	str	r7, [sp, #32]
 8005886:	0086      	lsls	r6, r0, #2
 8005888:	9607      	str	r6, [sp, #28]
 800588a:	f8cd c018 	str.w	ip, [sp, #24]
 800588e:	f8ad 4002 	strh.w	r4, [sp, #2]
 8005892:	4644      	mov	r4, r8
 8005894:	f8dd c010 	ldr.w	ip, [sp, #16]
 8005898:	fa4f f68a 	sxtb.w	r6, sl
 800589c:	f8dd 8018 	ldr.w	r8, [sp, #24]
 80058a0:	2e00      	cmp	r6, #0
 80058a2:	ed9f 1a34 	vldr	s2, [pc, #208]	; 8005974 <.text_17>
 80058a6:	bf0c      	ite	eq
 80058a8:	4606      	moveq	r6, r0
 80058aa:	f8bd 6002 	ldrhne.w	r6, [sp, #2]
 80058ae:	b1b6      	cbz	r6, 80058de <arm_mat_gemm_f32+0x116>
 80058b0:	fa4f f78a 	sxtb.w	r7, sl
 80058b4:	2f00      	cmp	r7, #0
 80058b6:	bf0c      	ite	eq
 80058b8:	2704      	moveq	r7, #4
 80058ba:	9f07      	ldrne	r7, [sp, #28]
 80058bc:	f1be 0f00 	cmp.w	lr, #0
 80058c0:	edd8 1a00 	vldr	s3, [r8]
 80058c4:	ed95 2a00 	vldr	s4, [r5]
 80058c8:	44b8      	add	r8, r7
 80058ca:	bf0c      	ite	eq
 80058cc:	9f08      	ldreq	r7, [sp, #32]
 80058ce:	2704      	movne	r7, #4
 80058d0:	19ed      	adds	r5, r5, r7
 80058d2:	1e76      	subs	r6, r6, #1
 80058d4:	b2b7      	uxth	r7, r6
 80058d6:	2f00      	cmp	r7, #0
 80058d8:	ee01 1a82 	vmla.f32	s2, s3, s4
 80058dc:	d1e8      	bne.n	80058b0 <arm_mat_gemm_f32+0xe8>
 80058de:	ee20 1a01 	vmul.f32	s2, s0, s2
 80058e2:	eddb 1a00 	vldr	s3, [fp]
 80058e6:	1e64      	subs	r4, r4, #1
 80058e8:	ee00 1aa1 	vmla.f32	s2, s1, s3
 80058ec:	b2a4      	uxth	r4, r4
 80058ee:	f1be 0f00 	cmp.w	lr, #0
 80058f2:	ed89 1a00 	vstr	s2, [r9]
 80058f6:	bf0e      	itee	eq
 80058f8:	1b15      	subeq	r5, r2, r4
 80058fa:	1b0d      	subne	r5, r1, r4
 80058fc:	4355      	mulne	r5, r2
 80058fe:	2c00      	cmp	r4, #0
 8005900:	f109 0904 	add.w	r9, r9, #4
 8005904:	449b      	add	fp, r3
 8005906:	eb0c 0585 	add.w	r5, ip, r5, lsl #2
 800590a:	d1c5      	bne.n	8005898 <arm_mat_gemm_f32+0xd0>
 800590c:	f8dd 900c 	ldr.w	r9, [sp, #12]
 8005910:	9d06      	ldr	r5, [sp, #24]
 8005912:	f8bd 4002 	ldrh.w	r4, [sp, #2]
 8005916:	f8cd c010 	str.w	ip, [sp, #16]
 800591a:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800591c:	444e      	add	r6, r9
 800591e:	9603      	str	r6, [sp, #12]
 8005920:	fa4f f68a 	sxtb.w	r6, sl
 8005924:	2e00      	cmp	r6, #0
 8005926:	bf0c      	ite	eq
 8005928:	ea4f 0c80 	moveq.w	ip, r0, lsl #2
 800592c:	f04f 0c04 	movne.w	ip, #4
 8005930:	44ac      	add	ip, r5
 8005932:	9d01      	ldr	r5, [sp, #4]
 8005934:	eb0b 0b85 	add.w	fp, fp, r5, lsl #2
 8005938:	f8bd 5000 	ldrh.w	r5, [sp]
 800593c:	1e6e      	subs	r6, r5, #1
 800593e:	f8ad 6000 	strh.w	r6, [sp]
 8005942:	f8bd 5000 	ldrh.w	r5, [sp]
 8005946:	b955      	cbnz	r5, 800595e <arm_mat_gemm_f32+0x196>
 8005948:	2000      	movs	r0, #0
 800594a:	b00a      	add	sp, #40	; 0x28
 800594c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005950:	f8dd b000 	ldr.w	fp, [sp]
 8005954:	9503      	str	r5, [sp, #12]
 8005956:	f8ad 8000 	strh.w	r8, [sp]
 800595a:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 800595e:	ae03      	add	r6, sp, #12
 8005960:	9d02      	ldr	r5, [sp, #8]
 8005962:	8836      	ldrh	r6, [r6, #0]
 8005964:	f1be 0f00 	cmp.w	lr, #0
 8005968:	eb05 0986 	add.w	r9, r5, r6, lsl #2
 800596c:	bf0c      	ite	eq
 800596e:	4690      	moveq	r8, r2
 8005970:	4688      	movne	r8, r1
 8005972:	e785      	b.n	8005880 <arm_mat_gemm_f32+0xb8>

08005974 <.text_17>:
 8005974:	00000000 	.word	0x00000000

08005978 <.text_18>:
 8005978:	08004961 	.word	0x08004961

0800597c <forward_gemm>:
 800597c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800597e:	b08b      	sub	sp, #44	; 0x2c
 8005980:	6941      	ldr	r1, [r0, #20]
 8005982:	6809      	ldr	r1, [r1, #0]
 8005984:	680a      	ldr	r2, [r1, #0]
 8005986:	6849      	ldr	r1, [r1, #4]
 8005988:	6809      	ldr	r1, [r1, #0]
 800598a:	680d      	ldr	r5, [r1, #0]
 800598c:	6814      	ldr	r4, [r2, #0]
 800598e:	6853      	ldr	r3, [r2, #4]
 8005990:	6892      	ldr	r2, [r2, #8]
 8005992:	68ad      	ldr	r5, [r5, #8]
 8005994:	68ce      	ldr	r6, [r1, #12]
 8005996:	690f      	ldr	r7, [r1, #16]
 8005998:	9509      	str	r5, [sp, #36]	; 0x24
 800599a:	f8ad 7020 	strh.w	r7, [sp, #32]
 800599e:	f8ad 6022 	strh.w	r6, [sp, #34]	; 0x22
 80059a2:	6825      	ldr	r5, [r4, #0]
 80059a4:	68e6      	ldr	r6, [r4, #12]
 80059a6:	68ad      	ldr	r5, [r5, #8]
 80059a8:	6924      	ldr	r4, [r4, #16]
 80059aa:	f8ad 4018 	strh.w	r4, [sp, #24]
 80059ae:	f8ad 601a 	strh.w	r6, [sp, #26]
 80059b2:	9507      	str	r5, [sp, #28]
 80059b4:	681c      	ldr	r4, [r3, #0]
 80059b6:	68dd      	ldr	r5, [r3, #12]
 80059b8:	68a4      	ldr	r4, [r4, #8]
 80059ba:	691b      	ldr	r3, [r3, #16]
 80059bc:	f8ad 3010 	strh.w	r3, [sp, #16]
 80059c0:	f8ad 5012 	strh.w	r5, [sp, #18]
 80059c4:	9405      	str	r4, [sp, #20]
 80059c6:	6813      	ldr	r3, [r2, #0]
 80059c8:	68d4      	ldr	r4, [r2, #12]
 80059ca:	689b      	ldr	r3, [r3, #8]
 80059cc:	6912      	ldr	r2, [r2, #16]
 80059ce:	f8ad 2008 	strh.w	r2, [sp, #8]
 80059d2:	f8ad 400a 	strh.w	r4, [sp, #10]
 80059d6:	aa08      	add	r2, sp, #32
 80059d8:	9303      	str	r3, [sp, #12]
 80059da:	9201      	str	r2, [sp, #4]
 80059dc:	aa02      	add	r2, sp, #8
 80059de:	f990 1021 	ldrsb.w	r1, [r0, #33]	; 0x21
 80059e2:	9100      	str	r1, [sp, #0]
 80059e4:	a904      	add	r1, sp, #16
 80059e6:	f990 3020 	ldrsb.w	r3, [r0, #32]
 80059ea:	edd0 0a07 	vldr	s1, [r0, #28]
 80059ee:	ed90 0a06 	vldr	s0, [r0, #24]
 80059f2:	a806      	add	r0, sp, #24
 80059f4:	f7ff fee8 	bl	80057c8 <arm_mat_gemm_f32>
 80059f8:	b00b      	add	sp, #44	; 0x2c
 80059fa:	bdf0      	pop	{r4, r5, r6, r7, pc}

080059fc <nl_func_sm_channel_f32>:
 80059fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005a00:	460f      	mov	r7, r1
 8005a02:	4614      	mov	r4, r2
 8005a04:	ed2d 8b02 	vpush	{d8}
 8005a08:	2c02      	cmp	r4, #2
 8005a0a:	4606      	mov	r6, r0
 8005a0c:	ed97 8a00 	vldr	s16, [r7]
 8005a10:	eddf 8ac3 	vldr	s17, [pc, #780]	; 8005d20 <.text_11>
 8005a14:	d33d      	bcc.n	8005a92 <nl_func_sm_channel_f32+0x96>
 8005a16:	1e61      	subs	r1, r4, #1
 8005a18:	1d3a      	adds	r2, r7, #4
 8005a1a:	f011 0003 	ands.w	r0, r1, #3
 8005a1e:	d00c      	beq.n	8005a3a <nl_func_sm_channel_f32+0x3e>
 8005a20:	ed92 0a00 	vldr	s0, [r2]
 8005a24:	eeb4 0a48 	vcmp.f32	s0, s16
 8005a28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005a2c:	bf58      	it	pl
 8005a2e:	eeb0 8a40 	vmovpl.f32	s16, s0
 8005a32:	1e40      	subs	r0, r0, #1
 8005a34:	f102 0204 	add.w	r2, r2, #4
 8005a38:	d1f2      	bne.n	8005a20 <nl_func_sm_channel_f32+0x24>
 8005a3a:	0889      	lsrs	r1, r1, #2
 8005a3c:	f000 802b 	beq.w	8005a96 <nl_func_sm_channel_f32+0x9a>
 8005a40:	ed92 0a00 	vldr	s0, [r2]
 8005a44:	eeb4 0a48 	vcmp.f32	s0, s16
 8005a48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005a4c:	bf58      	it	pl
 8005a4e:	eeb0 8a40 	vmovpl.f32	s16, s0
 8005a52:	ed92 0a01 	vldr	s0, [r2, #4]
 8005a56:	eeb4 0a48 	vcmp.f32	s0, s16
 8005a5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005a5e:	bf58      	it	pl
 8005a60:	eeb0 8a40 	vmovpl.f32	s16, s0
 8005a64:	ed92 0a02 	vldr	s0, [r2, #8]
 8005a68:	eeb4 0a48 	vcmp.f32	s0, s16
 8005a6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005a70:	bf58      	it	pl
 8005a72:	eeb0 8a40 	vmovpl.f32	s16, s0
 8005a76:	ed92 0a03 	vldr	s0, [r2, #12]
 8005a7a:	eeb4 0a48 	vcmp.f32	s0, s16
 8005a7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005a82:	bf58      	it	pl
 8005a84:	eeb0 8a40 	vmovpl.f32	s16, s0
 8005a88:	1e49      	subs	r1, r1, #1
 8005a8a:	f102 0210 	add.w	r2, r2, #16
 8005a8e:	d1d7      	bne.n	8005a40 <nl_func_sm_channel_f32+0x44>
 8005a90:	e001      	b.n	8005a96 <nl_func_sm_channel_f32+0x9a>
 8005a92:	2c00      	cmp	r4, #0
 8005a94:	d040      	beq.n	8005b18 <nl_func_sm_channel_f32+0x11c>
 8005a96:	46b0      	mov	r8, r6
 8005a98:	ea4f 0504 	mov.w	r5, r4
 8005a9c:	ed97 0a00 	vldr	s0, [r7]
 8005aa0:	ee30 0a48 	vsub.f32	s0, s0, s16
 8005aa4:	f01b fe5e 	bl	8021764 <expf>
 8005aa8:	1d3f      	adds	r7, r7, #4
 8005aaa:	ed88 0a00 	vstr	s0, [r8]
 8005aae:	1e6d      	subs	r5, r5, #1
 8005ab0:	ee78 8a80 	vadd.f32	s17, s17, s0
 8005ab4:	f108 0804 	add.w	r8, r8, #4
 8005ab8:	d1f0      	bne.n	8005a9c <nl_func_sm_channel_f32+0xa0>
 8005aba:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8005abe:	f014 0003 	ands.w	r0, r4, #3
 8005ac2:	ee80 0a28 	vdiv.f32	s0, s0, s17
 8005ac6:	d009      	beq.n	8005adc <nl_func_sm_channel_f32+0xe0>
 8005ac8:	edd6 0a00 	vldr	s1, [r6]
 8005acc:	ee60 0a80 	vmul.f32	s1, s1, s0
 8005ad0:	edc6 0a00 	vstr	s1, [r6]
 8005ad4:	1e40      	subs	r0, r0, #1
 8005ad6:	f106 0604 	add.w	r6, r6, #4
 8005ada:	d1f5      	bne.n	8005ac8 <nl_func_sm_channel_f32+0xcc>
 8005adc:	08a4      	lsrs	r4, r4, #2
 8005ade:	d01b      	beq.n	8005b18 <nl_func_sm_channel_f32+0x11c>
 8005ae0:	edd6 0a00 	vldr	s1, [r6]
 8005ae4:	ee60 0a80 	vmul.f32	s1, s1, s0
 8005ae8:	edc6 0a00 	vstr	s1, [r6]
 8005aec:	1e64      	subs	r4, r4, #1
 8005aee:	ed96 1a01 	vldr	s2, [r6, #4]
 8005af2:	edd6 0a02 	vldr	s1, [r6, #8]
 8005af6:	ee21 1a00 	vmul.f32	s2, s2, s0
 8005afa:	ed86 1a01 	vstr	s2, [r6, #4]
 8005afe:	ee60 0a80 	vmul.f32	s1, s1, s0
 8005b02:	ed96 1a03 	vldr	s2, [r6, #12]
 8005b06:	edc6 0a02 	vstr	s1, [r6, #8]
 8005b0a:	ee21 1a00 	vmul.f32	s2, s2, s0
 8005b0e:	ed86 1a03 	vstr	s2, [r6, #12]
 8005b12:	f106 0610 	add.w	r6, r6, #16
 8005b16:	d1e3      	bne.n	8005ae0 <nl_func_sm_channel_f32+0xe4>
 8005b18:	ecbd 8b02 	vpop	{d8}
 8005b1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005b20 <nl_func_sm_array_f32>:
 8005b20:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8005b24:	b081      	sub	sp, #4
 8005b26:	460c      	mov	r4, r1
 8005b28:	eb04 0982 	add.w	r9, r4, r2, lsl #2
 8005b2c:	9e08      	ldr	r6, [sp, #32]
 8005b2e:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8005b30:	454c      	cmp	r4, r9
 8005b32:	4680      	mov	r8, r0
 8005b34:	461d      	mov	r5, r3
 8005b36:	d20a      	bcs.n	8005b4e <nl_func_sm_array_f32+0x2e>
 8005b38:	462a      	mov	r2, r5
 8005b3a:	4621      	mov	r1, r4
 8005b3c:	4640      	mov	r0, r8
 8005b3e:	f7ff ff5d 	bl	80059fc <nl_func_sm_channel_f32>
 8005b42:	eb04 0486 	add.w	r4, r4, r6, lsl #2
 8005b46:	454c      	cmp	r4, r9
 8005b48:	eb08 0887 	add.w	r8, r8, r7, lsl #2
 8005b4c:	d3f4      	bcc.n	8005b38 <nl_func_sm_array_f32+0x18>
 8005b4e:	b001      	add	sp, #4
 8005b50:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08005b54 <nl_func_tanh_array_f32>:
 8005b54:	b570      	push	{r4, r5, r6, lr}
 8005b56:	460d      	mov	r5, r1
 8005b58:	eb05 0682 	add.w	r6, r5, r2, lsl #2
 8005b5c:	42b5      	cmp	r5, r6
 8005b5e:	4604      	mov	r4, r0
 8005b60:	f080 800a 	bcs.w	8005b78 <nl_func_tanh_array_f32+0x24>
 8005b64:	ed95 0a00 	vldr	s0, [r5]
 8005b68:	f01b fdaa 	bl	80216c0 <tanhf>
 8005b6c:	ed84 0a00 	vstr	s0, [r4]
 8005b70:	1d24      	adds	r4, r4, #4
 8005b72:	1d2d      	adds	r5, r5, #4
 8005b74:	42b5      	cmp	r5, r6
 8005b76:	d3f5      	bcc.n	8005b64 <nl_func_tanh_array_f32+0x10>
 8005b78:	bd70      	pop	{r4, r5, r6, pc}
	...

08005b7c <nl_func_sigmoid_array_f32>:
 8005b7c:	b570      	push	{r4, r5, r6, lr}
 8005b7e:	460d      	mov	r5, r1
 8005b80:	eb05 0682 	add.w	r6, r5, r2, lsl #2
 8005b84:	42b5      	cmp	r5, r6
 8005b86:	4604      	mov	r4, r0
 8005b88:	f080 8014 	bcs.w	8005bb4 <nl_func_sigmoid_array_f32+0x38>
 8005b8c:	ed95 0a00 	vldr	s0, [r5]
 8005b90:	eeb1 0a40 	vneg.f32	s0, s0
 8005b94:	f01b fde6 	bl	8021764 <expf>
 8005b98:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8005b9c:	ee70 0a20 	vadd.f32	s1, s0, s1
 8005ba0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8005ba4:	ee80 0a20 	vdiv.f32	s0, s0, s1
 8005ba8:	ed84 0a00 	vstr	s0, [r4]
 8005bac:	1d24      	adds	r4, r4, #4
 8005bae:	1d2d      	adds	r5, r5, #4
 8005bb0:	42b5      	cmp	r5, r6
 8005bb2:	d3eb      	bcc.n	8005b8c <nl_func_sigmoid_array_f32+0x10>
 8005bb4:	bd70      	pop	{r4, r5, r6, pc}
	...

08005bb8 <nl_func_sign_array_f32>:
 8005bb8:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8005bbc:	4291      	cmp	r1, r2
 8005bbe:	d216      	bcs.n	8005bee <nl_func_sign_array_f32+0x36>
 8005bc0:	f04f 33ff 	mov.w	r3, #4294967295
 8005bc4:	ed91 0a00 	vldr	s0, [r1]
 8005bc8:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8005bcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005bd0:	bfcc      	ite	gt
 8005bd2:	ed9f 0ac6 	vldrgt	s0, [pc, #792]	; 8005eec <.text_16>
 8005bd6:	ee00 3a10 	vmovle	s0, r3
 8005bda:	1d09      	adds	r1, r1, #4
 8005bdc:	4684      	mov	ip, r0
 8005bde:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 8005be2:	4291      	cmp	r1, r2
 8005be4:	f10c 0004 	add.w	r0, ip, #4
 8005be8:	ed8c 0a00 	vstr	s0, [ip]
 8005bec:	d3ea      	bcc.n	8005bc4 <nl_func_sign_array_f32+0xc>
 8005bee:	4770      	bx	lr

08005bf0 <nl_func_clip_array_f32>:
 8005bf0:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8005bf4:	4291      	cmp	r1, r2
 8005bf6:	d216      	bcs.n	8005c26 <nl_func_clip_array_f32+0x36>
 8005bf8:	4603      	mov	r3, r0
 8005bfa:	ed91 1a00 	vldr	s2, [r1]
 8005bfe:	1d18      	adds	r0, r3, #4
 8005c00:	eeb4 0a41 	vcmp.f32	s0, s2
 8005c04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005c08:	bf58      	it	pl
 8005c0a:	eeb0 1a40 	vmovpl.f32	s2, s0
 8005c0e:	eeb4 1a60 	vcmp.f32	s2, s1
 8005c12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005c16:	bf58      	it	pl
 8005c18:	eeb0 1a60 	vmovpl.f32	s2, s1
 8005c1c:	1d09      	adds	r1, r1, #4
 8005c1e:	4291      	cmp	r1, r2
 8005c20:	ed83 1a00 	vstr	s2, [r3]
 8005c24:	d3e8      	bcc.n	8005bf8 <nl_func_clip_array_f32+0x8>
 8005c26:	4770      	bx	lr

08005c28 <nl_func_relu_array_f32>:
 8005c28:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8005c2c:	4291      	cmp	r1, r2
 8005c2e:	d20f      	bcs.n	8005c50 <nl_func_relu_array_f32+0x28>
 8005c30:	4603      	mov	r3, r0
 8005c32:	ed91 0a00 	vldr	s0, [r1]
 8005c36:	1d18      	adds	r0, r3, #4
 8005c38:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8005c3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005c40:	bfd8      	it	le
 8005c42:	ed9f 0a37 	vldrle	s0, [pc, #220]	; 8005d20 <.text_11>
 8005c46:	1d09      	adds	r1, r1, #4
 8005c48:	4291      	cmp	r1, r2
 8005c4a:	ed83 0a00 	vstr	s0, [r3]
 8005c4e:	d3ef      	bcc.n	8005c30 <nl_func_relu_array_f32+0x8>
 8005c50:	4770      	bx	lr
	...

08005c54 <nl_func_relu6_array_f32>:
 8005c54:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8005c58:	4291      	cmp	r1, r2
 8005c5a:	d21a      	bcs.n	8005c92 <nl_func_relu6_array_f32+0x3e>
 8005c5c:	eeb1 0a08 	vmov.f32	s0, #24	; 0x40c00000  6.0
 8005c60:	4603      	mov	r3, r0
 8005c62:	edd1 0a00 	vldr	s1, [r1]
 8005c66:	1d18      	adds	r0, r3, #4
 8005c68:	eef5 0a40 	vcmp.f32	s1, #0.0
 8005c6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005c70:	dd08      	ble.n	8005c84 <nl_func_relu6_array_f32+0x30>
 8005c72:	eef4 0a40 	vcmp.f32	s1, s0
 8005c76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005c7a:	bf58      	it	pl
 8005c7c:	eef0 0a40 	vmovpl.f32	s1, s0
 8005c80:	e002      	b.n	8005c88 <nl_func_relu6_array_f32+0x34>
 8005c82:	bf00      	nop
 8005c84:	eddf 0a26 	vldr	s1, [pc, #152]	; 8005d20 <.text_11>
 8005c88:	1d09      	adds	r1, r1, #4
 8005c8a:	4291      	cmp	r1, r2
 8005c8c:	edc3 0a00 	vstr	s1, [r3]
 8005c90:	d3e6      	bcc.n	8005c60 <nl_func_relu6_array_f32+0xc>
 8005c92:	4770      	bx	lr

08005c94 <nl_func_selu_array_f32>:
 8005c94:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005c96:	b081      	sub	sp, #4
 8005c98:	460d      	mov	r5, r1
 8005c9a:	eb05 0682 	add.w	r6, r5, r2, lsl #2
 8005c9e:	ed2d 8b04 	vpush	{d8-d9}
 8005ca2:	42b5      	cmp	r5, r6
 8005ca4:	4604      	mov	r4, r0
 8005ca6:	eef0 8a40 	vmov.f32	s17, s0
 8005caa:	eeb0 8a60 	vmov.f32	s16, s1
 8005cae:	d232      	bcs.n	8005d16 <nl_func_selu_array_f32+0x82>
 8005cb0:	4627      	mov	r7, r4
 8005cb2:	ed95 9a00 	vldr	s18, [r5]
 8005cb6:	1d3c      	adds	r4, r7, #4
 8005cb8:	eeb5 9a40 	vcmp.f32	s18, #0.0
 8005cbc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005cc0:	bf4c      	ite	mi
 8005cc2:	eddf 9a17 	vldrmi	s19, [pc, #92]	; 8005d20 <.text_11>
 8005cc6:	eef0 9a49 	vmovpl.f32	s19, s18
 8005cca:	eeb0 0a49 	vmov.f32	s0, s18
 8005cce:	f01b fd49 	bl	8021764 <expf>
 8005cd2:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
 8005cd6:	ee30 0a20 	vadd.f32	s0, s0, s1
 8005cda:	ee20 0a28 	vmul.f32	s0, s0, s17
 8005cde:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8005ce2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005ce6:	dd05      	ble.n	8005cf4 <nl_func_selu_array_f32+0x60>
 8005ce8:	ed9f 1a0d 	vldr	s2, [pc, #52]	; 8005d20 <.text_11>
 8005cec:	ee79 9a81 	vadd.f32	s19, s19, s2
 8005cf0:	e00a      	b.n	8005d08 <nl_func_selu_array_f32+0x74>
 8005cf2:	bf00      	nop
 8005cf4:	eeb0 0a49 	vmov.f32	s0, s18
 8005cf8:	f01b fd34 	bl	8021764 <expf>
 8005cfc:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
 8005d00:	ee30 0a20 	vadd.f32	s0, s0, s1
 8005d04:	ee40 9a28 	vmla.f32	s19, s0, s17
 8005d08:	1d2d      	adds	r5, r5, #4
 8005d0a:	ee28 0a29 	vmul.f32	s0, s16, s19
 8005d0e:	42b5      	cmp	r5, r6
 8005d10:	ed87 0a00 	vstr	s0, [r7]
 8005d14:	d3cc      	bcc.n	8005cb0 <nl_func_selu_array_f32+0x1c>
 8005d16:	ecbd 8b04 	vpop	{d8-d9}
 8005d1a:	b001      	add	sp, #4
 8005d1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08005d20 <.text_11>:
 8005d20:	00000000 	.word	0x00000000

08005d24 <nl_func_prelu_array_f32>:
 8005d24:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8005d28:	4299      	cmp	r1, r3
 8005d2a:	d220      	bcs.n	8005d6e <nl_func_prelu_array_f32+0x4a>
 8005d2c:	ed91 0a00 	vldr	s0, [r1]
 8005d30:	ed92 1a00 	vldr	s2, [r2]
 8005d34:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8005d38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005d3c:	bf4c      	ite	mi
 8005d3e:	eddf 0aa5 	vldrmi	s1, [pc, #660]	; 8005fd4 <.text_19>
 8005d42:	eef0 0a40 	vmovpl.f32	s1, s0
 8005d46:	eeb1 0a40 	vneg.f32	s0, s0
 8005d4a:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8005d4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005d52:	bf48      	it	mi
 8005d54:	ed9f 0a9f 	vldrmi	s0, [pc, #636]	; 8005fd4 <.text_19>
 8005d58:	1d09      	adds	r1, r1, #4
 8005d5a:	1d12      	adds	r2, r2, #4
 8005d5c:	4684      	mov	ip, r0
 8005d5e:	ee41 0a40 	vmls.f32	s1, s2, s0
 8005d62:	4299      	cmp	r1, r3
 8005d64:	f10c 0004 	add.w	r0, ip, #4
 8005d68:	edcc 0a00 	vstr	s1, [ip]
 8005d6c:	d3de      	bcc.n	8005d2c <nl_func_prelu_array_f32+0x8>
 8005d6e:	4770      	bx	lr

08005d70 <forward_relu>:
 8005d70:	6940      	ldr	r0, [r0, #20]
 8005d72:	6803      	ldr	r3, [r0, #0]
 8005d74:	6819      	ldr	r1, [r3, #0]
 8005d76:	f8d1 c000 	ldr.w	ip, [r1]
 8005d7a:	f8dc 2004 	ldr.w	r2, [ip, #4]
 8005d7e:	f8dc 0008 	ldr.w	r0, [ip, #8]
 8005d82:	f8dc 100c 	ldr.w	r1, [ip, #12]
 8005d86:	4342      	muls	r2, r0
 8005d88:	f8dc 0010 	ldr.w	r0, [ip, #16]
 8005d8c:	f8dc c000 	ldr.w	ip, [ip]
 8005d90:	434a      	muls	r2, r1
 8005d92:	6859      	ldr	r1, [r3, #4]
 8005d94:	680b      	ldr	r3, [r1, #0]
 8005d96:	4342      	muls	r2, r0
 8005d98:	f8dc 0008 	ldr.w	r0, [ip, #8]
 8005d9c:	f8d3 c000 	ldr.w	ip, [r3]
 8005da0:	f8dc 1008 	ldr.w	r1, [ip, #8]
 8005da4:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8005da8:	4290      	cmp	r0, r2
 8005daa:	d20f      	bcs.n	8005dcc <forward_relu+0x5c>
 8005dac:	460b      	mov	r3, r1
 8005dae:	ed90 0a00 	vldr	s0, [r0]
 8005db2:	1d19      	adds	r1, r3, #4
 8005db4:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8005db8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005dbc:	bfd8      	it	le
 8005dbe:	ed9f 0a85 	vldrle	s0, [pc, #532]	; 8005fd4 <.text_19>
 8005dc2:	1d00      	adds	r0, r0, #4
 8005dc4:	4290      	cmp	r0, r2
 8005dc6:	ed83 0a00 	vstr	s0, [r3]
 8005dca:	d3ef      	bcc.n	8005dac <forward_relu+0x3c>
 8005dcc:	4770      	bx	lr
	...

08005dd0 <forward_relu6>:
 8005dd0:	6940      	ldr	r0, [r0, #20]
 8005dd2:	6803      	ldr	r3, [r0, #0]
 8005dd4:	6819      	ldr	r1, [r3, #0]
 8005dd6:	f8d1 c000 	ldr.w	ip, [r1]
 8005dda:	f8dc 2004 	ldr.w	r2, [ip, #4]
 8005dde:	f8dc 0008 	ldr.w	r0, [ip, #8]
 8005de2:	f8dc 100c 	ldr.w	r1, [ip, #12]
 8005de6:	4342      	muls	r2, r0
 8005de8:	f8dc 0010 	ldr.w	r0, [ip, #16]
 8005dec:	f8dc c000 	ldr.w	ip, [ip]
 8005df0:	434a      	muls	r2, r1
 8005df2:	6859      	ldr	r1, [r3, #4]
 8005df4:	680b      	ldr	r3, [r1, #0]
 8005df6:	4342      	muls	r2, r0
 8005df8:	f8dc 0008 	ldr.w	r0, [ip, #8]
 8005dfc:	f8d3 c000 	ldr.w	ip, [r3]
 8005e00:	f8dc 1008 	ldr.w	r1, [ip, #8]
 8005e04:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8005e08:	4290      	cmp	r0, r2
 8005e0a:	d21a      	bcs.n	8005e42 <forward_relu6+0x72>
 8005e0c:	eeb1 0a08 	vmov.f32	s0, #24	; 0x40c00000  6.0
 8005e10:	460b      	mov	r3, r1
 8005e12:	edd0 0a00 	vldr	s1, [r0]
 8005e16:	1d19      	adds	r1, r3, #4
 8005e18:	eef5 0a40 	vcmp.f32	s1, #0.0
 8005e1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005e20:	dd08      	ble.n	8005e34 <forward_relu6+0x64>
 8005e22:	eef4 0a40 	vcmp.f32	s1, s0
 8005e26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005e2a:	bf58      	it	pl
 8005e2c:	eef0 0a40 	vmovpl.f32	s1, s0
 8005e30:	e002      	b.n	8005e38 <forward_relu6+0x68>
 8005e32:	bf00      	nop
 8005e34:	eddf 0a67 	vldr	s1, [pc, #412]	; 8005fd4 <.text_19>
 8005e38:	1d00      	adds	r0, r0, #4
 8005e3a:	4290      	cmp	r0, r2
 8005e3c:	edc3 0a00 	vstr	s1, [r3]
 8005e40:	d3e6      	bcc.n	8005e10 <forward_relu6+0x40>
 8005e42:	4770      	bx	lr

08005e44 <forward_selu>:
 8005e44:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005e46:	b081      	sub	sp, #4
 8005e48:	ed2d 8b04 	vpush	{d8-d9}
 8005e4c:	6941      	ldr	r1, [r0, #20]
 8005e4e:	ed90 8a07 	vldr	s16, [r0, #28]
 8005e52:	680d      	ldr	r5, [r1, #0]
 8005e54:	edd0 8a06 	vldr	s17, [r0, #24]
 8005e58:	682a      	ldr	r2, [r5, #0]
 8005e5a:	6814      	ldr	r4, [r2, #0]
 8005e5c:	6820      	ldr	r0, [r4, #0]
 8005e5e:	6863      	ldr	r3, [r4, #4]
 8005e60:	68a1      	ldr	r1, [r4, #8]
 8005e62:	68e2      	ldr	r2, [r4, #12]
 8005e64:	434b      	muls	r3, r1
 8005e66:	6921      	ldr	r1, [r4, #16]
 8005e68:	6884      	ldr	r4, [r0, #8]
 8005e6a:	6868      	ldr	r0, [r5, #4]
 8005e6c:	4353      	muls	r3, r2
 8005e6e:	434b      	muls	r3, r1
 8005e70:	6801      	ldr	r1, [r0, #0]
 8005e72:	680a      	ldr	r2, [r1, #0]
 8005e74:	6895      	ldr	r5, [r2, #8]
 8005e76:	eb04 0683 	add.w	r6, r4, r3, lsl #2
 8005e7a:	42b4      	cmp	r4, r6
 8005e7c:	d231      	bcs.n	8005ee2 <forward_selu+0x9e>
 8005e7e:	462f      	mov	r7, r5
 8005e80:	ed94 9a00 	vldr	s18, [r4]
 8005e84:	1d3d      	adds	r5, r7, #4
 8005e86:	eeb5 9a40 	vcmp.f32	s18, #0.0
 8005e8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005e8e:	bf4c      	ite	mi
 8005e90:	eddf 9a50 	vldrmi	s19, [pc, #320]	; 8005fd4 <.text_19>
 8005e94:	eef0 9a49 	vmovpl.f32	s19, s18
 8005e98:	eeb0 0a49 	vmov.f32	s0, s18
 8005e9c:	f01b fc62 	bl	8021764 <expf>
 8005ea0:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
 8005ea4:	ee30 0a20 	vadd.f32	s0, s0, s1
 8005ea8:	ee20 0a28 	vmul.f32	s0, s0, s17
 8005eac:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8005eb0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005eb4:	dd04      	ble.n	8005ec0 <forward_selu+0x7c>
 8005eb6:	ed9f 1a47 	vldr	s2, [pc, #284]	; 8005fd4 <.text_19>
 8005eba:	ee79 9a81 	vadd.f32	s19, s19, s2
 8005ebe:	e009      	b.n	8005ed4 <forward_selu+0x90>
 8005ec0:	eeb0 0a49 	vmov.f32	s0, s18
 8005ec4:	f01b fc4e 	bl	8021764 <expf>
 8005ec8:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
 8005ecc:	ee30 0a20 	vadd.f32	s0, s0, s1
 8005ed0:	ee40 9a28 	vmla.f32	s19, s0, s17
 8005ed4:	1d24      	adds	r4, r4, #4
 8005ed6:	ee28 0a29 	vmul.f32	s0, s16, s19
 8005eda:	42b4      	cmp	r4, r6
 8005edc:	ed87 0a00 	vstr	s0, [r7]
 8005ee0:	d3cd      	bcc.n	8005e7e <forward_selu+0x3a>
 8005ee2:	ecbd 8b04 	vpop	{d8-d9}
 8005ee6:	b001      	add	sp, #4
 8005ee8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08005eec <.text_16>:
 8005eec:	00000001 	.word	0x00000001

08005ef0 <forward_prelu>:
 8005ef0:	b430      	push	{r4, r5}
 8005ef2:	6941      	ldr	r1, [r0, #20]
 8005ef4:	680c      	ldr	r4, [r1, #0]
 8005ef6:	6822      	ldr	r2, [r4, #0]
 8005ef8:	6815      	ldr	r5, [r2, #0]
 8005efa:	686b      	ldr	r3, [r5, #4]
 8005efc:	68a9      	ldr	r1, [r5, #8]
 8005efe:	68ea      	ldr	r2, [r5, #12]
 8005f00:	6980      	ldr	r0, [r0, #24]
 8005f02:	434b      	muls	r3, r1
 8005f04:	6929      	ldr	r1, [r5, #16]
 8005f06:	682d      	ldr	r5, [r5, #0]
 8005f08:	4353      	muls	r3, r2
 8005f0a:	6862      	ldr	r2, [r4, #4]
 8005f0c:	6814      	ldr	r4, [r2, #0]
 8005f0e:	434b      	muls	r3, r1
 8005f10:	68a9      	ldr	r1, [r5, #8]
 8005f12:	6825      	ldr	r5, [r4, #0]
 8005f14:	6804      	ldr	r4, [r0, #0]
 8005f16:	68aa      	ldr	r2, [r5, #8]
 8005f18:	68a0      	ldr	r0, [r4, #8]
 8005f1a:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8005f1e:	4299      	cmp	r1, r3
 8005f20:	d21f      	bcs.n	8005f62 <forward_prelu+0x72>
 8005f22:	4614      	mov	r4, r2
 8005f24:	ed91 0a00 	vldr	s0, [r1]
 8005f28:	1d22      	adds	r2, r4, #4
 8005f2a:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8005f2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005f32:	bf4c      	ite	mi
 8005f34:	eddf 0a27 	vldrmi	s1, [pc, #156]	; 8005fd4 <.text_19>
 8005f38:	eef0 0a40 	vmovpl.f32	s1, s0
 8005f3c:	eeb1 0a40 	vneg.f32	s0, s0
 8005f40:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8005f44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005f48:	bf48      	it	mi
 8005f4a:	ed9f 0a22 	vldrmi	s0, [pc, #136]	; 8005fd4 <.text_19>
 8005f4e:	ed90 1a00 	vldr	s2, [r0]
 8005f52:	1d09      	adds	r1, r1, #4
 8005f54:	1d00      	adds	r0, r0, #4
 8005f56:	ee41 0a40 	vmls.f32	s1, s2, s0
 8005f5a:	4299      	cmp	r1, r3
 8005f5c:	edc4 0a00 	vstr	s1, [r4]
 8005f60:	d3df      	bcc.n	8005f22 <forward_prelu+0x32>
 8005f62:	bc30      	pop	{r4, r5}
 8005f64:	4770      	bx	lr
	...

08005f68 <forward_sign>:
 8005f68:	6940      	ldr	r0, [r0, #20]
 8005f6a:	6803      	ldr	r3, [r0, #0]
 8005f6c:	6819      	ldr	r1, [r3, #0]
 8005f6e:	f8d1 c000 	ldr.w	ip, [r1]
 8005f72:	f8dc 2004 	ldr.w	r2, [ip, #4]
 8005f76:	f8dc 0008 	ldr.w	r0, [ip, #8]
 8005f7a:	f8dc 100c 	ldr.w	r1, [ip, #12]
 8005f7e:	4342      	muls	r2, r0
 8005f80:	f8dc 0010 	ldr.w	r0, [ip, #16]
 8005f84:	f8dc c000 	ldr.w	ip, [ip]
 8005f88:	434a      	muls	r2, r1
 8005f8a:	6859      	ldr	r1, [r3, #4]
 8005f8c:	680b      	ldr	r3, [r1, #0]
 8005f8e:	4342      	muls	r2, r0
 8005f90:	f8dc 0008 	ldr.w	r0, [ip, #8]
 8005f94:	f8d3 c000 	ldr.w	ip, [r3]
 8005f98:	f8dc 1008 	ldr.w	r1, [ip, #8]
 8005f9c:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8005fa0:	4290      	cmp	r0, r2
 8005fa2:	d216      	bcs.n	8005fd2 <forward_sign+0x6a>
 8005fa4:	f04f 33ff 	mov.w	r3, #4294967295
 8005fa8:	ed90 0a00 	vldr	s0, [r0]
 8005fac:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8005fb0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005fb4:	bfcc      	ite	gt
 8005fb6:	ed9f 0a08 	vldrgt	s0, [pc, #32]	; 8005fd8 <.text_20>
 8005fba:	ee00 3a10 	vmovle	s0, r3
 8005fbe:	1d00      	adds	r0, r0, #4
 8005fc0:	468c      	mov	ip, r1
 8005fc2:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 8005fc6:	4290      	cmp	r0, r2
 8005fc8:	f10c 0104 	add.w	r1, ip, #4
 8005fcc:	ed8c 0a00 	vstr	s0, [ip]
 8005fd0:	d3ea      	bcc.n	8005fa8 <forward_sign+0x40>
 8005fd2:	4770      	bx	lr

08005fd4 <.text_19>:
 8005fd4:	00000000 	.word	0x00000000

08005fd8 <.text_20>:
 8005fd8:	00000001 	.word	0x00000001

08005fdc <forward_clip>:
 8005fdc:	b430      	push	{r4, r5}
 8005fde:	6941      	ldr	r1, [r0, #20]
 8005fe0:	ed90 0a07 	vldr	s0, [r0, #28]
 8005fe4:	680c      	ldr	r4, [r1, #0]
 8005fe6:	edd0 0a06 	vldr	s1, [r0, #24]
 8005fea:	6822      	ldr	r2, [r4, #0]
 8005fec:	6815      	ldr	r5, [r2, #0]
 8005fee:	686b      	ldr	r3, [r5, #4]
 8005ff0:	68a9      	ldr	r1, [r5, #8]
 8005ff2:	68ea      	ldr	r2, [r5, #12]
 8005ff4:	6828      	ldr	r0, [r5, #0]
 8005ff6:	6880      	ldr	r0, [r0, #8]
 8005ff8:	434b      	muls	r3, r1
 8005ffa:	6929      	ldr	r1, [r5, #16]
 8005ffc:	4353      	muls	r3, r2
 8005ffe:	434b      	muls	r3, r1
 8006000:	6861      	ldr	r1, [r4, #4]
 8006002:	680a      	ldr	r2, [r1, #0]
 8006004:	6814      	ldr	r4, [r2, #0]
 8006006:	68a1      	ldr	r1, [r4, #8]
 8006008:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 800600c:	4290      	cmp	r0, r2
 800600e:	d216      	bcs.n	800603e <forward_clip+0x62>
 8006010:	460b      	mov	r3, r1
 8006012:	ed90 1a00 	vldr	s2, [r0]
 8006016:	1d19      	adds	r1, r3, #4
 8006018:	eef4 0a41 	vcmp.f32	s1, s2
 800601c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006020:	bf58      	it	pl
 8006022:	eeb0 1a60 	vmovpl.f32	s2, s1
 8006026:	eeb4 1a40 	vcmp.f32	s2, s0
 800602a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800602e:	bf58      	it	pl
 8006030:	eeb0 1a40 	vmovpl.f32	s2, s0
 8006034:	1d00      	adds	r0, r0, #4
 8006036:	4290      	cmp	r0, r2
 8006038:	ed83 1a00 	vstr	s2, [r3]
 800603c:	d3e8      	bcc.n	8006010 <forward_clip+0x34>
 800603e:	bc30      	pop	{r4, r5}
 8006040:	4770      	bx	lr
	...

08006044 <forward_sigmoid>:
 8006044:	b570      	push	{r4, r5, r6, lr}
 8006046:	6940      	ldr	r0, [r0, #20]
 8006048:	6803      	ldr	r3, [r0, #0]
 800604a:	6819      	ldr	r1, [r3, #0]
 800604c:	680c      	ldr	r4, [r1, #0]
 800604e:	6862      	ldr	r2, [r4, #4]
 8006050:	68a0      	ldr	r0, [r4, #8]
 8006052:	68e1      	ldr	r1, [r4, #12]
 8006054:	4342      	muls	r2, r0
 8006056:	6920      	ldr	r0, [r4, #16]
 8006058:	6824      	ldr	r4, [r4, #0]
 800605a:	68a4      	ldr	r4, [r4, #8]
 800605c:	434a      	muls	r2, r1
 800605e:	4342      	muls	r2, r0
 8006060:	6858      	ldr	r0, [r3, #4]
 8006062:	6801      	ldr	r1, [r0, #0]
 8006064:	680b      	ldr	r3, [r1, #0]
 8006066:	689d      	ldr	r5, [r3, #8]
 8006068:	eb04 0682 	add.w	r6, r4, r2, lsl #2
 800606c:	42b4      	cmp	r4, r6
 800606e:	d213      	bcs.n	8006098 <forward_sigmoid+0x54>
 8006070:	ed94 0a00 	vldr	s0, [r4]
 8006074:	eeb1 0a40 	vneg.f32	s0, s0
 8006078:	f01b fb74 	bl	8021764 <expf>
 800607c:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8006080:	ee70 0a20 	vadd.f32	s1, s0, s1
 8006084:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8006088:	ee80 0a20 	vdiv.f32	s0, s0, s1
 800608c:	ed85 0a00 	vstr	s0, [r5]
 8006090:	1d2d      	adds	r5, r5, #4
 8006092:	1d24      	adds	r4, r4, #4
 8006094:	42b4      	cmp	r4, r6
 8006096:	d3eb      	bcc.n	8006070 <forward_sigmoid+0x2c>
 8006098:	bd70      	pop	{r4, r5, r6, pc}
	...

0800609c <forward_tanh>:
 800609c:	b570      	push	{r4, r5, r6, lr}
 800609e:	6940      	ldr	r0, [r0, #20]
 80060a0:	6803      	ldr	r3, [r0, #0]
 80060a2:	6819      	ldr	r1, [r3, #0]
 80060a4:	680c      	ldr	r4, [r1, #0]
 80060a6:	6862      	ldr	r2, [r4, #4]
 80060a8:	68a0      	ldr	r0, [r4, #8]
 80060aa:	68e1      	ldr	r1, [r4, #12]
 80060ac:	4342      	muls	r2, r0
 80060ae:	6920      	ldr	r0, [r4, #16]
 80060b0:	6824      	ldr	r4, [r4, #0]
 80060b2:	68a4      	ldr	r4, [r4, #8]
 80060b4:	434a      	muls	r2, r1
 80060b6:	4342      	muls	r2, r0
 80060b8:	6858      	ldr	r0, [r3, #4]
 80060ba:	6801      	ldr	r1, [r0, #0]
 80060bc:	680b      	ldr	r3, [r1, #0]
 80060be:	689d      	ldr	r5, [r3, #8]
 80060c0:	eb04 0682 	add.w	r6, r4, r2, lsl #2
 80060c4:	42b4      	cmp	r4, r6
 80060c6:	d209      	bcs.n	80060dc <forward_tanh+0x40>
 80060c8:	ed94 0a00 	vldr	s0, [r4]
 80060cc:	f01b faf8 	bl	80216c0 <tanhf>
 80060d0:	ed85 0a00 	vstr	s0, [r5]
 80060d4:	1d2d      	adds	r5, r5, #4
 80060d6:	1d24      	adds	r4, r4, #4
 80060d8:	42b4      	cmp	r4, r6
 80060da:	d3f5      	bcc.n	80060c8 <forward_tanh+0x2c>
 80060dc:	bd70      	pop	{r4, r5, r6, pc}

080060de <forward_sm>:
 80060de:	b530      	push	{r4, r5, lr}
 80060e0:	b083      	sub	sp, #12
 80060e2:	6940      	ldr	r0, [r0, #20]
 80060e4:	6804      	ldr	r4, [r0, #0]
 80060e6:	6821      	ldr	r1, [r4, #0]
 80060e8:	680d      	ldr	r5, [r1, #0]
 80060ea:	68aa      	ldr	r2, [r5, #8]
 80060ec:	9201      	str	r2, [sp, #4]
 80060ee:	9200      	str	r2, [sp, #0]
 80060f0:	4613      	mov	r3, r2
 80060f2:	6868      	ldr	r0, [r5, #4]
 80060f4:	68e9      	ldr	r1, [r5, #12]
 80060f6:	4342      	muls	r2, r0
 80060f8:	6928      	ldr	r0, [r5, #16]
 80060fa:	682d      	ldr	r5, [r5, #0]
 80060fc:	434a      	muls	r2, r1
 80060fe:	4342      	muls	r2, r0
 8006100:	6860      	ldr	r0, [r4, #4]
 8006102:	6804      	ldr	r4, [r0, #0]
 8006104:	68a9      	ldr	r1, [r5, #8]
 8006106:	6825      	ldr	r5, [r4, #0]
 8006108:	68a8      	ldr	r0, [r5, #8]
 800610a:	f7ff fd09 	bl	8005b20 <nl_func_sm_array_f32>
 800610e:	b003      	add	sp, #12
 8006110:	bd30      	pop	{r4, r5, pc}
	...

08006114 <func_lrn_channel_f32>:
 8006114:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006118:	461f      	mov	r7, r3
 800611a:	4604      	mov	r4, r0
 800611c:	b081      	sub	sp, #4
 800611e:	4616      	mov	r6, r2
 8006120:	ed2d 8b04 	vpush	{d8-d9}
 8006124:	460d      	mov	r5, r1
 8006126:	00b1      	lsls	r1, r6, #2
 8006128:	f018 fca4 	bl	801ea74 <__aeabi_memclr>
 800612c:	2e00      	cmp	r6, #0
 800612e:	eef0 8a40 	vmov.f32	s17, s0
 8006132:	eeb0 9a60 	vmov.f32	s18, s1
 8006136:	eeb0 8a41 	vmov.f32	s16, s2
 800613a:	eb05 0886 	add.w	r8, r5, r6, lsl #2
 800613e:	dd50      	ble.n	80061e2 <func_lrn_channel_f32+0xce>
 8006140:	f107 0e01 	add.w	lr, r7, #1
 8006144:	427f      	negs	r7, r7
 8006146:	46a9      	mov	r9, r5
 8006148:	4630      	mov	r0, r6
 800614a:	46b4      	mov	ip, r6
 800614c:	463b      	mov	r3, r7
 800614e:	4671      	mov	r1, lr
 8006150:	45e6      	cmp	lr, ip
 8006152:	bfc8      	it	gt
 8006154:	4661      	movgt	r1, ip
 8006156:	2b00      	cmp	r3, #0
 8006158:	bfcc      	ite	gt
 800615a:	461a      	movgt	r2, r3
 800615c:	2200      	movle	r2, #0
 800615e:	ed99 0a00 	vldr	s0, [r9]
 8006162:	428a      	cmp	r2, r1
 8006164:	ee20 0a00 	vmul.f32	s0, s0, s0
 8006168:	f280 8034 	bge.w	80061d4 <func_lrn_channel_f32+0xc0>
 800616c:	eb04 0782 	add.w	r7, r4, r2, lsl #2
 8006170:	eb04 0682 	add.w	r6, r4, r2, lsl #2
 8006174:	edd7 0a00 	vldr	s1, [r7]
 8006178:	1c52      	adds	r2, r2, #1
 800617a:	ee70 0a80 	vadd.f32	s1, s1, s0
 800617e:	428a      	cmp	r2, r1
 8006180:	edc6 0a00 	vstr	s1, [r6]
 8006184:	da26      	bge.n	80061d4 <func_lrn_channel_f32+0xc0>
 8006186:	eb04 0782 	add.w	r7, r4, r2, lsl #2
 800618a:	eb04 0682 	add.w	r6, r4, r2, lsl #2
 800618e:	edd7 0a00 	vldr	s1, [r7]
 8006192:	1c52      	adds	r2, r2, #1
 8006194:	ee70 0a80 	vadd.f32	s1, s1, s0
 8006198:	428a      	cmp	r2, r1
 800619a:	edc6 0a00 	vstr	s1, [r6]
 800619e:	da19      	bge.n	80061d4 <func_lrn_channel_f32+0xc0>
 80061a0:	eb04 0782 	add.w	r7, r4, r2, lsl #2
 80061a4:	eb04 0682 	add.w	r6, r4, r2, lsl #2
 80061a8:	edd7 0a00 	vldr	s1, [r7]
 80061ac:	1c52      	adds	r2, r2, #1
 80061ae:	ee70 0a80 	vadd.f32	s1, s1, s0
 80061b2:	428a      	cmp	r2, r1
 80061b4:	edc6 0a00 	vstr	s1, [r6]
 80061b8:	da0c      	bge.n	80061d4 <func_lrn_channel_f32+0xc0>
 80061ba:	eb04 0782 	add.w	r7, r4, r2, lsl #2
 80061be:	eb04 0682 	add.w	r6, r4, r2, lsl #2
 80061c2:	edd7 0a00 	vldr	s1, [r7]
 80061c6:	1c52      	adds	r2, r2, #1
 80061c8:	ee70 0a80 	vadd.f32	s1, s1, s0
 80061cc:	428a      	cmp	r2, r1
 80061ce:	edc6 0a00 	vstr	s1, [r6]
 80061d2:	dbcb      	blt.n	800616c <func_lrn_channel_f32+0x58>
 80061d4:	1c5b      	adds	r3, r3, #1
 80061d6:	1e40      	subs	r0, r0, #1
 80061d8:	f109 0904 	add.w	r9, r9, #4
 80061dc:	f10e 0e01 	add.w	lr, lr, #1
 80061e0:	d1b5      	bne.n	800614e <func_lrn_channel_f32+0x3a>
 80061e2:	4545      	cmp	r5, r8
 80061e4:	f080 8014 	bcs.w	8006210 <func_lrn_channel_f32+0xfc>
 80061e8:	ed94 1a00 	vldr	s2, [r4]
 80061ec:	eeb0 0a68 	vmov.f32	s0, s17
 80061f0:	eef1 0a48 	vneg.f32	s1, s16
 80061f4:	ee09 0a01 	vmla.f32	s0, s18, s2
 80061f8:	f01b fba4 	bl	8021944 <powf>
 80061fc:	edd5 0a00 	vldr	s1, [r5]
 8006200:	ee60 0a80 	vmul.f32	s1, s1, s0
 8006204:	edc4 0a00 	vstr	s1, [r4]
 8006208:	1d2d      	adds	r5, r5, #4
 800620a:	1d24      	adds	r4, r4, #4
 800620c:	4545      	cmp	r5, r8
 800620e:	d3eb      	bcc.n	80061e8 <func_lrn_channel_f32+0xd4>
 8006210:	ecbd 8b04 	vpop	{d8-d9}
 8006214:	b001      	add	sp, #4
 8006216:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	...

0800621c <func_norm_array_f32>:
 800621c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006220:	b081      	sub	sp, #4
 8006222:	4614      	mov	r4, r2
 8006224:	ed2d 8b04 	vpush	{d8-d9}
 8006228:	b084      	sub	sp, #16
 800622a:	eeb0 8a40 	vmov.f32	s16, s0
 800622e:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8006230:	2a00      	cmp	r2, #0
 8006232:	eef0 8a60 	vmov.f32	s17, s1
 8006236:	fb03 f804 	mul.w	r8, r3, r4
 800623a:	d064      	beq.n	8006306 <func_norm_array_f32+0xea>
 800623c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8006240:	ee80 9a08 	vdiv.f32	s18, s0, s16
 8006244:	9102      	str	r1, [sp, #8]
 8006246:	9001      	str	r0, [sp, #4]
 8006248:	9200      	str	r2, [sp, #0]
 800624a:	2600      	movs	r6, #0
 800624c:	2c00      	cmp	r4, #0
 800624e:	d04e      	beq.n	80062ee <func_norm_array_f32+0xd2>
 8006250:	9d02      	ldr	r5, [sp, #8]
 8006252:	9f01      	ldr	r7, [sp, #4]
 8006254:	46a9      	mov	r9, r5
 8006256:	eb09 0a88 	add.w	sl, r9, r8, lsl #2
 800625a:	46cb      	mov	fp, r9
 800625c:	45d3      	cmp	fp, sl
 800625e:	9703      	str	r7, [sp, #12]
 8006260:	eddf 9a62 	vldr	s19, [pc, #392]	; 80063ec <.text_5>
 8006264:	f080 800c 	bcs.w	8006280 <func_norm_array_f32+0x64>
 8006268:	eef0 0a48 	vmov.f32	s1, s16
 800626c:	ed99 0a00 	vldr	s0, [r9]
 8006270:	f01b fb68 	bl	8021944 <powf>
 8006274:	eb09 0984 	add.w	r9, r9, r4, lsl #2
 8006278:	45d1      	cmp	r9, sl
 800627a:	ee79 9a80 	vadd.f32	s19, s19, s0
 800627e:	d3f3      	bcc.n	8006268 <func_norm_array_f32+0x4c>
 8006280:	ed9f 0a5b 	vldr	s0, [pc, #364]	; 80063f0 <.text_6>
 8006284:	ee39 0a80 	vadd.f32	s0, s19, s0
 8006288:	eef0 0a49 	vmov.f32	s1, s18
 800628c:	ee88 0a80 	vdiv.f32	s0, s17, s0
 8006290:	f01b fb58 	bl	8021944 <powf>
 8006294:	45d3      	cmp	fp, sl
 8006296:	4628      	mov	r0, r5
 8006298:	d224      	bcs.n	80062e4 <func_norm_array_f32+0xc8>
 800629a:	9903      	ldr	r1, [sp, #12]
 800629c:	edd0 0a00 	vldr	s1, [r0]
 80062a0:	ee60 0a80 	vmul.f32	s1, s1, s0
 80062a4:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 80062a8:	edc1 0a00 	vstr	s1, [r1]
 80062ac:	4550      	cmp	r0, sl
 80062ae:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 80062b2:	d217      	bcs.n	80062e4 <func_norm_array_f32+0xc8>
 80062b4:	edd0 0a00 	vldr	s1, [r0]
 80062b8:	ee60 0a80 	vmul.f32	s1, s1, s0
 80062bc:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 80062c0:	edc1 0a00 	vstr	s1, [r1]
 80062c4:	4550      	cmp	r0, sl
 80062c6:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 80062ca:	d20b      	bcs.n	80062e4 <func_norm_array_f32+0xc8>
 80062cc:	edd0 0a00 	vldr	s1, [r0]
 80062d0:	ee60 0a80 	vmul.f32	s1, s1, s0
 80062d4:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 80062d8:	edc1 0a00 	vstr	s1, [r1]
 80062dc:	4550      	cmp	r0, sl
 80062de:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 80062e2:	d3db      	bcc.n	800629c <func_norm_array_f32+0x80>
 80062e4:	1c76      	adds	r6, r6, #1
 80062e6:	1d3f      	adds	r7, r7, #4
 80062e8:	1d2d      	adds	r5, r5, #4
 80062ea:	42a6      	cmp	r6, r4
 80062ec:	d3b2      	bcc.n	8006254 <func_norm_array_f32+0x38>
 80062ee:	9801      	ldr	r0, [sp, #4]
 80062f0:	eb00 0188 	add.w	r1, r0, r8, lsl #2
 80062f4:	9101      	str	r1, [sp, #4]
 80062f6:	9802      	ldr	r0, [sp, #8]
 80062f8:	eb00 0188 	add.w	r1, r0, r8, lsl #2
 80062fc:	9800      	ldr	r0, [sp, #0]
 80062fe:	9102      	str	r1, [sp, #8]
 8006300:	1e40      	subs	r0, r0, #1
 8006302:	9000      	str	r0, [sp, #0]
 8006304:	d1a1      	bne.n	800624a <func_norm_array_f32+0x2e>
 8006306:	b004      	add	sp, #16
 8006308:	ecbd 8b04 	vpop	{d8-d9}
 800630c:	b001      	add	sp, #4
 800630e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08006314 <func_norm_l2_fast_array_f32>:
 8006314:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006318:	b081      	sub	sp, #4
 800631a:	4616      	mov	r6, r2
 800631c:	ed2d 8b02 	vpush	{d8}
 8006320:	460d      	mov	r5, r1
 8006322:	00b7      	lsls	r7, r6, #2
 8006324:	4604      	mov	r4, r0
 8006326:	eeb0 8a40 	vmov.f32	s16, s0
 800632a:	eb05 0883 	add.w	r8, r5, r3, lsl #2
 800632e:	427f      	negs	r7, r7
 8006330:	4545      	cmp	r5, r8
 8006332:	d256      	bcs.n	80063e2 <func_norm_l2_fast_array_f32+0xce>
 8006334:	eb05 0986 	add.w	r9, r5, r6, lsl #2
 8006338:	454d      	cmp	r5, r9
 800633a:	ed9f 0a2c 	vldr	s0, [pc, #176]	; 80063ec <.text_5>
 800633e:	d21b      	bcs.n	8006378 <func_norm_l2_fast_array_f32+0x64>
 8006340:	edd5 0a00 	vldr	s1, [r5]
 8006344:	1d2d      	adds	r5, r5, #4
 8006346:	ee00 0aa0 	vmla.f32	s0, s1, s1
 800634a:	454d      	cmp	r5, r9
 800634c:	bf3f      	itttt	cc
 800634e:	edd5 0a00 	vldrcc	s1, [r5]
 8006352:	ee00 0aa0 	vmlacc.f32	s0, s1, s1
 8006356:	1d2d      	addcc	r5, r5, #4
 8006358:	454d      	cmpcc	r5, r9
 800635a:	d20d      	bcs.n	8006378 <func_norm_l2_fast_array_f32+0x64>
 800635c:	edd5 0a00 	vldr	s1, [r5]
 8006360:	1d2d      	adds	r5, r5, #4
 8006362:	ee00 0aa0 	vmla.f32	s0, s1, s1
 8006366:	454d      	cmp	r5, r9
 8006368:	bf3f      	itttt	cc
 800636a:	edd5 0a00 	vldrcc	s1, [r5]
 800636e:	ee00 0aa0 	vmlacc.f32	s0, s1, s1
 8006372:	1d2d      	addcc	r5, r5, #4
 8006374:	454d      	cmpcc	r5, r9
 8006376:	d3e3      	bcc.n	8006340 <func_norm_l2_fast_array_f32+0x2c>
 8006378:	eddf 0a1d 	vldr	s1, [pc, #116]	; 80063f0 <.text_6>
 800637c:	ee30 0a20 	vadd.f32	s0, s0, s1
 8006380:	ee88 0a00 	vdiv.f32	s0, s16, s0
 8006384:	f7fd ff3a 	bl	80041fc <ai_math_sqrt>
 8006388:	19ed      	adds	r5, r5, r7
 800638a:	454d      	cmp	r5, r9
 800638c:	f4bf afd0 	bcs.w	8006330 <func_norm_l2_fast_array_f32+0x1c>
 8006390:	ed95 1a00 	vldr	s2, [r5]
 8006394:	ee21 1a00 	vmul.f32	s2, s2, s0
 8006398:	ed84 1a00 	vstr	s2, [r4]
 800639c:	1d2d      	adds	r5, r5, #4
 800639e:	1d24      	adds	r4, r4, #4
 80063a0:	454d      	cmp	r5, r9
 80063a2:	d2c5      	bcs.n	8006330 <func_norm_l2_fast_array_f32+0x1c>
 80063a4:	edd5 0a00 	vldr	s1, [r5]
 80063a8:	ee60 0a80 	vmul.f32	s1, s1, s0
 80063ac:	edc4 0a00 	vstr	s1, [r4]
 80063b0:	1d2d      	adds	r5, r5, #4
 80063b2:	1d24      	adds	r4, r4, #4
 80063b4:	454d      	cmp	r5, r9
 80063b6:	d2bb      	bcs.n	8006330 <func_norm_l2_fast_array_f32+0x1c>
 80063b8:	edd5 0a00 	vldr	s1, [r5]
 80063bc:	ee60 0a80 	vmul.f32	s1, s1, s0
 80063c0:	edc4 0a00 	vstr	s1, [r4]
 80063c4:	1d2d      	adds	r5, r5, #4
 80063c6:	1d24      	adds	r4, r4, #4
 80063c8:	454d      	cmp	r5, r9
 80063ca:	d2b1      	bcs.n	8006330 <func_norm_l2_fast_array_f32+0x1c>
 80063cc:	edd5 0a00 	vldr	s1, [r5]
 80063d0:	ee60 0a80 	vmul.f32	s1, s1, s0
 80063d4:	edc4 0a00 	vstr	s1, [r4]
 80063d8:	1d2d      	adds	r5, r5, #4
 80063da:	1d24      	adds	r4, r4, #4
 80063dc:	454d      	cmp	r5, r9
 80063de:	d3d7      	bcc.n	8006390 <func_norm_l2_fast_array_f32+0x7c>
 80063e0:	e7a6      	b.n	8006330 <func_norm_l2_fast_array_f32+0x1c>
 80063e2:	ecbd 8b02 	vpop	{d8}
 80063e6:	b001      	add	sp, #4
 80063e8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

080063ec <.text_5>:
 80063ec:	00000000 	.word	0x00000000

080063f0 <.text_6>:
 80063f0:	34000000 	.word	0x34000000

080063f4 <func_lrn_array_f32>:
 80063f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80063f8:	460d      	mov	r5, r1
 80063fa:	eb05 0882 	add.w	r8, r5, r2, lsl #2
 80063fe:	ed2d 8b04 	vpush	{d8-d9}
 8006402:	4545      	cmp	r5, r8
 8006404:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8006406:	4604      	mov	r4, r0
 8006408:	461e      	mov	r6, r3
 800640a:	eeb0 8a40 	vmov.f32	s16, s0
 800640e:	eef0 8a60 	vmov.f32	s17, s1
 8006412:	eeb0 9a41 	vmov.f32	s18, s2
 8006416:	d211      	bcs.n	800643c <func_lrn_array_f32+0x48>
 8006418:	eeb0 1a49 	vmov.f32	s2, s18
 800641c:	eef0 0a68 	vmov.f32	s1, s17
 8006420:	eeb0 0a48 	vmov.f32	s0, s16
 8006424:	463b      	mov	r3, r7
 8006426:	4632      	mov	r2, r6
 8006428:	4629      	mov	r1, r5
 800642a:	4620      	mov	r0, r4
 800642c:	f7ff fe72 	bl	8006114 <func_lrn_channel_f32>
 8006430:	eb05 0586 	add.w	r5, r5, r6, lsl #2
 8006434:	4545      	cmp	r5, r8
 8006436:	eb04 0486 	add.w	r4, r4, r6, lsl #2
 800643a:	d3ed      	bcc.n	8006418 <func_lrn_array_f32+0x24>
 800643c:	ecbd 8b04 	vpop	{d8-d9}
 8006440:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08006444 <forward_bn>:
 8006444:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006448:	6940      	ldr	r0, [r0, #20]
 800644a:	6800      	ldr	r0, [r0, #0]
 800644c:	6801      	ldr	r1, [r0, #0]
 800644e:	6842      	ldr	r2, [r0, #4]
 8006450:	680d      	ldr	r5, [r1, #0]
 8006452:	6816      	ldr	r6, [r2, #0]
 8006454:	68ac      	ldr	r4, [r5, #8]
 8006456:	6869      	ldr	r1, [r5, #4]
 8006458:	6880      	ldr	r0, [r0, #8]
 800645a:	68eb      	ldr	r3, [r5, #12]
 800645c:	692a      	ldr	r2, [r5, #16]
 800645e:	6807      	ldr	r7, [r0, #0]
 8006460:	682d      	ldr	r5, [r5, #0]
 8006462:	6840      	ldr	r0, [r0, #4]
 8006464:	68ad      	ldr	r5, [r5, #8]
 8006466:	4361      	muls	r1, r4
 8006468:	4359      	muls	r1, r3
 800646a:	4351      	muls	r1, r2
 800646c:	6832      	ldr	r2, [r6, #0]
 800646e:	683b      	ldr	r3, [r7, #0]
 8006470:	6896      	ldr	r6, [r2, #8]
 8006472:	689f      	ldr	r7, [r3, #8]
 8006474:	2800      	cmp	r0, #0
 8006476:	d061      	beq.n	800653c <forward_bn+0xf8>
 8006478:	6800      	ldr	r0, [r0, #0]
 800647a:	f8d0 c008 	ldr.w	ip, [r0, #8]
 800647e:	2200      	movs	r2, #0
 8006480:	2900      	cmp	r1, #0
 8006482:	d059      	beq.n	8006538 <forward_bn+0xf4>
 8006484:	ea4f 0901 	mov.w	r9, r1
 8006488:	eb04 0e02 	add.w	lr, r4, r2
 800648c:	4572      	cmp	r2, lr
 800648e:	d250      	bcs.n	8006532 <forward_bn+0xee>
 8006490:	eb06 0082 	add.w	r0, r6, r2, lsl #2
 8006494:	eb05 0182 	add.w	r1, r5, r2, lsl #2
 8006498:	f014 0303 	ands.w	r3, r4, #3
 800649c:	463a      	mov	r2, r7
 800649e:	46e0      	mov	r8, ip
 80064a0:	f000 8012 	beq.w	80064c8 <forward_bn+0x84>
 80064a4:	ed91 0a00 	vldr	s0, [r1]
 80064a8:	edd2 0a00 	vldr	s1, [r2]
 80064ac:	ed98 1a00 	vldr	s2, [r8]
 80064b0:	ee00 1a20 	vmla.f32	s2, s0, s1
 80064b4:	ed80 1a00 	vstr	s2, [r0]
 80064b8:	1e5b      	subs	r3, r3, #1
 80064ba:	1d12      	adds	r2, r2, #4
 80064bc:	1d09      	adds	r1, r1, #4
 80064be:	1d00      	adds	r0, r0, #4
 80064c0:	2b00      	cmp	r3, #0
 80064c2:	f108 0804 	add.w	r8, r8, #4
 80064c6:	d1ed      	bne.n	80064a4 <forward_bn+0x60>
 80064c8:	08a3      	lsrs	r3, r4, #2
 80064ca:	d032      	beq.n	8006532 <forward_bn+0xee>
 80064cc:	4682      	mov	sl, r0
 80064ce:	4618      	mov	r0, r3
 80064d0:	ed91 2a00 	vldr	s4, [r1]
 80064d4:	ed92 1a00 	vldr	s2, [r2]
 80064d8:	ed98 0a00 	vldr	s0, [r8]
 80064dc:	ee02 0a01 	vmla.f32	s0, s4, s2
 80064e0:	ed8a 0a00 	vstr	s0, [sl]
 80064e4:	edd1 2a01 	vldr	s5, [r1, #4]
 80064e8:	edd2 1a01 	vldr	s3, [r2, #4]
 80064ec:	edd8 0a01 	vldr	s1, [r8, #4]
 80064f0:	ee42 0aa1 	vmla.f32	s1, s5, s3
 80064f4:	edca 0a01 	vstr	s1, [sl, #4]
 80064f8:	ed91 2a02 	vldr	s4, [r1, #8]
 80064fc:	ed92 1a02 	vldr	s2, [r2, #8]
 8006500:	ed98 0a02 	vldr	s0, [r8, #8]
 8006504:	ee02 0a01 	vmla.f32	s0, s4, s2
 8006508:	ed8a 0a02 	vstr	s0, [sl, #8]
 800650c:	edd1 1a03 	vldr	s3, [r1, #12]
 8006510:	edd2 0a03 	vldr	s1, [r2, #12]
 8006514:	edd8 2a03 	vldr	s5, [r8, #12]
 8006518:	ee41 2aa0 	vmla.f32	s5, s3, s1
 800651c:	1e40      	subs	r0, r0, #1
 800651e:	3210      	adds	r2, #16
 8006520:	3110      	adds	r1, #16
 8006522:	edca 2a03 	vstr	s5, [sl, #12]
 8006526:	2800      	cmp	r0, #0
 8006528:	f10a 0a10 	add.w	sl, sl, #16
 800652c:	f108 0810 	add.w	r8, r8, #16
 8006530:	d1ce      	bne.n	80064d0 <forward_bn+0x8c>
 8006532:	4672      	mov	r2, lr
 8006534:	454a      	cmp	r2, r9
 8006536:	d3a7      	bcc.n	8006488 <forward_bn+0x44>
 8006538:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800653c:	2900      	cmp	r1, #0
 800653e:	f04f 0c00 	mov.w	ip, #0
 8006542:	d0f9      	beq.n	8006538 <forward_bn+0xf4>
 8006544:	eb04 020c 	add.w	r2, r4, ip
 8006548:	4594      	cmp	ip, r2
 800654a:	4663      	mov	r3, ip
 800654c:	d24c      	bcs.n	80065e8 <forward_bn+0x1a4>
 800654e:	f014 0003 	ands.w	r0, r4, #3
 8006552:	eb06 0e83 	add.w	lr, r6, r3, lsl #2
 8006556:	eb05 0883 	add.w	r8, r5, r3, lsl #2
 800655a:	46b9      	mov	r9, r7
 800655c:	f000 8011 	beq.w	8006582 <forward_bn+0x13e>
 8006560:	ed98 0a00 	vldr	s0, [r8]
 8006564:	edd9 0a00 	vldr	s1, [r9]
 8006568:	ee60 0a20 	vmul.f32	s1, s0, s1
 800656c:	1c5b      	adds	r3, r3, #1
 800656e:	edce 0a00 	vstr	s1, [lr]
 8006572:	1e40      	subs	r0, r0, #1
 8006574:	f109 0904 	add.w	r9, r9, #4
 8006578:	f108 0804 	add.w	r8, r8, #4
 800657c:	f10e 0e04 	add.w	lr, lr, #4
 8006580:	d1ee      	bne.n	8006560 <forward_bn+0x11c>
 8006582:	08a0      	lsrs	r0, r4, #2
 8006584:	f000 8030 	beq.w	80065e8 <forward_bn+0x1a4>
 8006588:	eb05 0e83 	add.w	lr, r5, r3, lsl #2
 800658c:	eba3 0c0c 	sub.w	ip, r3, ip
 8006590:	eb07 0c8c 	add.w	ip, r7, ip, lsl #2
 8006594:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8006598:	ed9e 1a00 	vldr	s2, [lr]
 800659c:	ed9c 0a00 	vldr	s0, [ip]
 80065a0:	ee21 0a00 	vmul.f32	s0, s2, s0
 80065a4:	ed83 0a00 	vstr	s0, [r3]
 80065a8:	edde 1a01 	vldr	s3, [lr, #4]
 80065ac:	eddc 0a01 	vldr	s1, [ip, #4]
 80065b0:	ee21 0aa0 	vmul.f32	s0, s3, s1
 80065b4:	ed83 0a01 	vstr	s0, [r3, #4]
 80065b8:	ed9e 1a02 	vldr	s2, [lr, #8]
 80065bc:	ed9c 0a02 	vldr	s0, [ip, #8]
 80065c0:	ee21 0a00 	vmul.f32	s0, s2, s0
 80065c4:	ed83 0a02 	vstr	s0, [r3, #8]
 80065c8:	edde 0a03 	vldr	s1, [lr, #12]
 80065cc:	eddc 1a03 	vldr	s3, [ip, #12]
 80065d0:	ee20 0aa1 	vmul.f32	s0, s1, s3
 80065d4:	ed83 0a03 	vstr	s0, [r3, #12]
 80065d8:	1e40      	subs	r0, r0, #1
 80065da:	3310      	adds	r3, #16
 80065dc:	2800      	cmp	r0, #0
 80065de:	f10c 0c10 	add.w	ip, ip, #16
 80065e2:	f10e 0e10 	add.w	lr, lr, #16
 80065e6:	d1d7      	bne.n	8006598 <forward_bn+0x154>
 80065e8:	4694      	mov	ip, r2
 80065ea:	458c      	cmp	ip, r1
 80065ec:	d3aa      	bcc.n	8006544 <forward_bn+0x100>
 80065ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080065f2 <forward_lrn>:
 80065f2:	b530      	push	{r4, r5, lr}
 80065f4:	b081      	sub	sp, #4
 80065f6:	6941      	ldr	r1, [r0, #20]
 80065f8:	680c      	ldr	r4, [r1, #0]
 80065fa:	6822      	ldr	r2, [r4, #0]
 80065fc:	6815      	ldr	r5, [r2, #0]
 80065fe:	6981      	ldr	r1, [r0, #24]
 8006600:	68aa      	ldr	r2, [r5, #8]
 8006602:	0849      	lsrs	r1, r1, #1
 8006604:	9100      	str	r1, [sp, #0]
 8006606:	ed90 1a09 	vldr	s2, [r0, #36]	; 0x24
 800660a:	edd0 0a08 	vldr	s1, [r0, #32]
 800660e:	ed90 0a07 	vldr	s0, [r0, #28]
 8006612:	6868      	ldr	r0, [r5, #4]
 8006614:	68e9      	ldr	r1, [r5, #12]
 8006616:	4613      	mov	r3, r2
 8006618:	4342      	muls	r2, r0
 800661a:	6928      	ldr	r0, [r5, #16]
 800661c:	682d      	ldr	r5, [r5, #0]
 800661e:	434a      	muls	r2, r1
 8006620:	4342      	muls	r2, r0
 8006622:	6860      	ldr	r0, [r4, #4]
 8006624:	6804      	ldr	r4, [r0, #0]
 8006626:	68a9      	ldr	r1, [r5, #8]
 8006628:	6825      	ldr	r5, [r4, #0]
 800662a:	68a8      	ldr	r0, [r5, #8]
 800662c:	f7ff fee2 	bl	80063f4 <func_lrn_array_f32>
 8006630:	b001      	add	sp, #4
 8006632:	bd30      	pop	{r4, r5, pc}

08006634 <forward_norm>:
 8006634:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006636:	b081      	sub	sp, #4
 8006638:	6941      	ldr	r1, [r0, #20]
 800663a:	6809      	ldr	r1, [r1, #0]
 800663c:	680a      	ldr	r2, [r1, #0]
 800663e:	6849      	ldr	r1, [r1, #4]
 8006640:	6816      	ldr	r6, [r2, #0]
 8006642:	680f      	ldr	r7, [r1, #0]
 8006644:	7e01      	ldrb	r1, [r0, #24]
 8006646:	6875      	ldr	r5, [r6, #4]
 8006648:	1d32      	adds	r2, r6, #4
 800664a:	f106 0314 	add.w	r3, r6, #20
 800664e:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8006652:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 8006656:	6973      	ldr	r3, [r6, #20]
 8006658:	fb91 f4f3 	sdiv	r4, r1, r3
 800665c:	68b3      	ldr	r3, [r6, #8]
 800665e:	68f1      	ldr	r1, [r6, #12]
 8006660:	435d      	muls	r5, r3
 8006662:	6933      	ldr	r3, [r6, #16]
 8006664:	eeb0 1a00 	vmov.f32	s2, #0	; 0x40000000  2.0
 8006668:	434d      	muls	r5, r1
 800666a:	f890 1020 	ldrb.w	r1, [r0, #32]
 800666e:	435d      	muls	r5, r3
 8006670:	2900      	cmp	r1, #0
 8006672:	bf1a      	itte	ne
 8006674:	ee00 2a10 	vmovne	s0, r2
 8006678:	eef8 0a40 	vcvtne.f32.u32	s1, s0
 800667c:	eef7 0a00 	vmoveq.f32	s1, #112	; 0x3f800000  1.0
 8006680:	ed90 0a07 	vldr	s0, [r0, #28]
 8006684:	eeb4 0a41 	vcmp.f32	s0, s2
 8006688:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800668c:	fb04 f302 	mul.w	r3, r4, r2
 8006690:	bf08      	it	eq
 8006692:	2c01      	cmpeq	r4, #1
 8006694:	fbb5 f3f3 	udiv	r3, r5, r3
 8006698:	d10a      	bne.n	80066b0 <forward_norm+0x7c>
 800669a:	6830      	ldr	r0, [r6, #0]
 800669c:	683c      	ldr	r4, [r7, #0]
 800669e:	6881      	ldr	r1, [r0, #8]
 80066a0:	68a0      	ldr	r0, [r4, #8]
 80066a2:	462b      	mov	r3, r5
 80066a4:	b001      	add	sp, #4
 80066a6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 80066aa:	eeb0 0a60 	vmov.f32	s0, s1
 80066ae:	e631      	b.n	8006314 <func_norm_l2_fast_array_f32>
 80066b0:	9300      	str	r3, [sp, #0]
 80066b2:	6831      	ldr	r1, [r6, #0]
 80066b4:	6838      	ldr	r0, [r7, #0]
 80066b6:	6889      	ldr	r1, [r1, #8]
 80066b8:	6880      	ldr	r0, [r0, #8]
 80066ba:	4613      	mov	r3, r2
 80066bc:	4622      	mov	r2, r4
 80066be:	f7ff fdad 	bl	800621c <func_norm_array_f32>
 80066c2:	b001      	add	sp, #4
 80066c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080066c8 <gru_cell_before>:
 80066c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80066cc:	b081      	sub	sp, #4
 80066ce:	4602      	mov	r2, r0
 80066d0:	ed2d 8b02 	vpush	{d8}
 80066d4:	b08a      	sub	sp, #40	; 0x28
 80066d6:	8bc8      	ldrh	r0, [r1, #30]
 80066d8:	f8b1 b01c 	ldrh.w	fp, [r1, #28]
 80066dc:	680b      	ldr	r3, [r1, #0]
 80066de:	9306      	str	r3, [sp, #24]
 80066e0:	fb0b f300 	mul.w	r3, fp, r0
 80066e4:	9c06      	ldr	r4, [sp, #24]
 80066e6:	eb04 0883 	add.w	r8, r4, r3, lsl #2
 80066ea:	eb08 0583 	add.w	r5, r8, r3, lsl #2
 80066ee:	9508      	str	r5, [sp, #32]
 80066f0:	fb00 f300 	mul.w	r3, r0, r0
 80066f4:	684c      	ldr	r4, [r1, #4]
 80066f6:	9405      	str	r4, [sp, #20]
 80066f8:	eb04 0983 	add.w	r9, r4, r3, lsl #2
 80066fc:	eb09 0483 	add.w	r4, r9, r3, lsl #2
 8006700:	9407      	str	r4, [sp, #28]
 8006702:	2800      	cmp	r0, #0
 8006704:	688d      	ldr	r5, [r1, #8]
 8006706:	9501      	str	r5, [sp, #4]
 8006708:	f000 808c 	beq.w	8006824 <gru_cell_before+0x15c>
 800670c:	eb05 0780 	add.w	r7, r5, r0, lsl #2
 8006710:	2600      	movs	r6, #0
 8006712:	4604      	mov	r4, r0
 8006714:	9202      	str	r2, [sp, #8]
 8006716:	460d      	mov	r5, r1
 8006718:	ea4f 0a00 	mov.w	sl, r0
 800671c:	f857 3b04 	ldr.w	r3, [r7], #4
 8006720:	9a02      	ldr	r2, [sp, #8]
 8006722:	9300      	str	r3, [sp, #0]
 8006724:	4641      	mov	r1, r8
 8006726:	465b      	mov	r3, fp
 8006728:	4668      	mov	r0, sp
 800672a:	f7fd fd51 	bl	80041d0 <ai_math_dot_array>
 800672e:	696a      	ldr	r2, [r5, #20]
 8006730:	4653      	mov	r3, sl
 8006732:	4649      	mov	r1, r9
 8006734:	4668      	mov	r0, sp
 8006736:	f7fd fd4b 	bl	80041d0 <ai_math_dot_array>
 800673a:	6928      	ldr	r0, [r5, #16]
 800673c:	ed9d 0a00 	vldr	s0, [sp]
 8006740:	4780      	blx	r0
 8006742:	6969      	ldr	r1, [r5, #20]
 8006744:	6a28      	ldr	r0, [r5, #32]
 8006746:	1989      	adds	r1, r1, r6
 8006748:	1980      	adds	r0, r0, r6
 800674a:	edd1 0a00 	vldr	s1, [r1]
 800674e:	1d36      	adds	r6, r6, #4
 8006750:	ee20 0a80 	vmul.f32	s0, s1, s0
 8006754:	1e64      	subs	r4, r4, #1
 8006756:	ed80 0a00 	vstr	s0, [r0]
 800675a:	eb08 088b 	add.w	r8, r8, fp, lsl #2
 800675e:	eb09 098a 	add.w	r9, r9, sl, lsl #2
 8006762:	d1db      	bne.n	800671c <gru_cell_before+0x54>
 8006764:	9e01      	ldr	r6, [sp, #4]
 8006766:	9501      	str	r5, [sp, #4]
 8006768:	f8cd a010 	str.w	sl, [sp, #16]
 800676c:	f8cd b00c 	str.w	fp, [sp, #12]
 8006770:	eb06 07ca 	add.w	r7, r6, sl, lsl #3
 8006774:	9902      	ldr	r1, [sp, #8]
 8006776:	9d06      	ldr	r5, [sp, #24]
 8006778:	f8dd b014 	ldr.w	fp, [sp, #20]
 800677c:	f8dd 801c 	ldr.w	r8, [sp, #28]
 8006780:	9102      	str	r1, [sp, #8]
 8006782:	4654      	mov	r4, sl
 8006784:	f8dd a020 	ldr.w	sl, [sp, #32]
 8006788:	f04f 0900 	mov.w	r9, #0
 800678c:	f856 0b04 	ldr.w	r0, [r6], #4
 8006790:	9b03      	ldr	r3, [sp, #12]
 8006792:	9a02      	ldr	r2, [sp, #8]
 8006794:	9000      	str	r0, [sp, #0]
 8006796:	4629      	mov	r1, r5
 8006798:	4668      	mov	r0, sp
 800679a:	f7fd fd19 	bl	80041d0 <ai_math_dot_array>
 800679e:	9801      	ldr	r0, [sp, #4]
 80067a0:	6942      	ldr	r2, [r0, #20]
 80067a2:	9b04      	ldr	r3, [sp, #16]
 80067a4:	4659      	mov	r1, fp
 80067a6:	4668      	mov	r0, sp
 80067a8:	f7fd fd12 	bl	80041d0 <ai_math_dot_array>
 80067ac:	9801      	ldr	r0, [sp, #4]
 80067ae:	ed9d 0a00 	vldr	s0, [sp]
 80067b2:	6901      	ldr	r1, [r0, #16]
 80067b4:	4788      	blx	r1
 80067b6:	f857 0b04 	ldr.w	r0, [r7], #4
 80067ba:	9b03      	ldr	r3, [sp, #12]
 80067bc:	9a02      	ldr	r2, [sp, #8]
 80067be:	9000      	str	r0, [sp, #0]
 80067c0:	eeb0 8a40 	vmov.f32	s16, s0
 80067c4:	4651      	mov	r1, sl
 80067c6:	4668      	mov	r0, sp
 80067c8:	f7fd fd02 	bl	80041d0 <ai_math_dot_array>
 80067cc:	9801      	ldr	r0, [sp, #4]
 80067ce:	6a02      	ldr	r2, [r0, #32]
 80067d0:	9b04      	ldr	r3, [sp, #16]
 80067d2:	4641      	mov	r1, r8
 80067d4:	4668      	mov	r0, sp
 80067d6:	f7fd fcfb 	bl	80041d0 <ai_math_dot_array>
 80067da:	9801      	ldr	r0, [sp, #4]
 80067dc:	ed9d 0a00 	vldr	s0, [sp]
 80067e0:	68c1      	ldr	r1, [r0, #12]
 80067e2:	4788      	blx	r1
 80067e4:	9801      	ldr	r0, [sp, #4]
 80067e6:	6941      	ldr	r1, [r0, #20]
 80067e8:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 80067ec:	ee70 0ac8 	vsub.f32	s1, s1, s16
 80067f0:	4449      	add	r1, r9
 80067f2:	ee20 0a80 	vmul.f32	s0, s1, s0
 80067f6:	edd1 0a00 	vldr	s1, [r1]
 80067fa:	6981      	ldr	r1, [r0, #24]
 80067fc:	4449      	add	r1, r9
 80067fe:	ee08 0a20 	vmla.f32	s0, s16, s1
 8006802:	ed81 0a00 	vstr	s0, [r1]
 8006806:	1e64      	subs	r4, r4, #1
 8006808:	9803      	ldr	r0, [sp, #12]
 800680a:	eb05 0580 	add.w	r5, r5, r0, lsl #2
 800680e:	eb0a 0a80 	add.w	sl, sl, r0, lsl #2
 8006812:	9804      	ldr	r0, [sp, #16]
 8006814:	eb0b 0b80 	add.w	fp, fp, r0, lsl #2
 8006818:	eb08 0880 	add.w	r8, r8, r0, lsl #2
 800681c:	f109 0904 	add.w	r9, r9, #4
 8006820:	d1b4      	bne.n	800678c <gru_cell_before+0xc4>
 8006822:	9901      	ldr	r1, [sp, #4]
 8006824:	6988      	ldr	r0, [r1, #24]
 8006826:	694a      	ldr	r2, [r1, #20]
 8006828:	618a      	str	r2, [r1, #24]
 800682a:	6148      	str	r0, [r1, #20]
 800682c:	b00a      	add	sp, #40	; 0x28
 800682e:	ecbd 8b02 	vpop	{d8}
 8006832:	b001      	add	sp, #4
 8006834:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08006838 <gru_cell_after>:
 8006838:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800683c:	b081      	sub	sp, #4
 800683e:	460c      	mov	r4, r1
 8006840:	ed2d 8b02 	vpush	{d8}
 8006844:	b08a      	sub	sp, #40	; 0x28
 8006846:	4602      	mov	r2, r0
 8006848:	8be0      	ldrh	r0, [r4, #30]
 800684a:	8ba1      	ldrh	r1, [r4, #28]
 800684c:	6823      	ldr	r3, [r4, #0]
 800684e:	f8d4 8004 	ldr.w	r8, [r4, #4]
 8006852:	68a7      	ldr	r7, [r4, #8]
 8006854:	fb01 f500 	mul.w	r5, r1, r0
 8006858:	eb03 0c85 	add.w	ip, r3, r5, lsl #2
 800685c:	eb0c 0e85 	add.w	lr, ip, r5, lsl #2
 8006860:	fb00 f500 	mul.w	r5, r0, r0
 8006864:	eb08 0985 	add.w	r9, r8, r5, lsl #2
 8006868:	2800      	cmp	r0, #0
 800686a:	eb09 0a85 	add.w	sl, r9, r5, lsl #2
 800686e:	f000 8084 	beq.w	800697a <gru_cell_after+0x142>
 8006872:	9700      	str	r7, [sp, #0]
 8006874:	eb07 0680 	add.w	r6, r7, r0, lsl #2
 8006878:	eb07 05c0 	add.w	r5, r7, r0, lsl #3
 800687c:	9003      	str	r0, [sp, #12]
 800687e:	9207      	str	r2, [sp, #28]
 8006880:	9002      	str	r0, [sp, #8]
 8006882:	9101      	str	r1, [sp, #4]
 8006884:	9306      	str	r3, [sp, #24]
 8006886:	f8cd c014 	str.w	ip, [sp, #20]
 800688a:	f8cd e010 	str.w	lr, [sp, #16]
 800688e:	f04f 0b00 	mov.w	fp, #0
 8006892:	9f00      	ldr	r7, [sp, #0]
 8006894:	2100      	movs	r1, #0
 8006896:	9108      	str	r1, [sp, #32]
 8006898:	4668      	mov	r0, sp
 800689a:	f857 2b04 	ldr.w	r2, [r7], #4
 800689e:	9b01      	ldr	r3, [sp, #4]
 80068a0:	9906      	ldr	r1, [sp, #24]
 80068a2:	9200      	str	r2, [sp, #0]
 80068a4:	9a07      	ldr	r2, [sp, #28]
 80068a6:	f7fd fc93 	bl	80041d0 <ai_math_dot_array>
 80068aa:	9b02      	ldr	r3, [sp, #8]
 80068ac:	6962      	ldr	r2, [r4, #20]
 80068ae:	4641      	mov	r1, r8
 80068b0:	4668      	mov	r0, sp
 80068b2:	f7fd fc8d 	bl	80041d0 <ai_math_dot_array>
 80068b6:	6920      	ldr	r0, [r4, #16]
 80068b8:	ed9d 0a00 	vldr	s0, [sp]
 80068bc:	4780      	blx	r0
 80068be:	f856 1b04 	ldr.w	r1, [r6], #4
 80068c2:	9b01      	ldr	r3, [sp, #4]
 80068c4:	9a07      	ldr	r2, [sp, #28]
 80068c6:	9100      	str	r1, [sp, #0]
 80068c8:	eeb0 8a40 	vmov.f32	s16, s0
 80068cc:	9905      	ldr	r1, [sp, #20]
 80068ce:	4668      	mov	r0, sp
 80068d0:	f7fd fc7e 	bl	80041d0 <ai_math_dot_array>
 80068d4:	9b02      	ldr	r3, [sp, #8]
 80068d6:	6962      	ldr	r2, [r4, #20]
 80068d8:	4649      	mov	r1, r9
 80068da:	4668      	mov	r0, sp
 80068dc:	f7fd fc78 	bl	80041d0 <ai_math_dot_array>
 80068e0:	6920      	ldr	r0, [r4, #16]
 80068e2:	ed9d 0a00 	vldr	s0, [sp]
 80068e6:	4780      	blx	r0
 80068e8:	f855 1b04 	ldr.w	r1, [r5], #4
 80068ec:	9b01      	ldr	r3, [sp, #4]
 80068ee:	9a07      	ldr	r2, [sp, #28]
 80068f0:	9100      	str	r1, [sp, #0]
 80068f2:	eef0 8a40 	vmov.f32	s17, s0
 80068f6:	9904      	ldr	r1, [sp, #16]
 80068f8:	4668      	mov	r0, sp
 80068fa:	f7fd fc69 	bl	80041d0 <ai_math_dot_array>
 80068fe:	9b02      	ldr	r3, [sp, #8]
 8006900:	6962      	ldr	r2, [r4, #20]
 8006902:	4651      	mov	r1, sl
 8006904:	a808      	add	r0, sp, #32
 8006906:	f7fd fc63 	bl	80041d0 <ai_math_dot_array>
 800690a:	ed9d 0a08 	vldr	s0, [sp, #32]
 800690e:	eddd 0a00 	vldr	s1, [sp]
 8006912:	ee40 0a28 	vmla.f32	s1, s0, s17
 8006916:	edcd 0a00 	vstr	s1, [sp]
 800691a:	68e0      	ldr	r0, [r4, #12]
 800691c:	ed9d 0a00 	vldr	s0, [sp]
 8006920:	4780      	blx	r0
 8006922:	6960      	ldr	r0, [r4, #20]
 8006924:	69a1      	ldr	r1, [r4, #24]
 8006926:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 800692a:	4458      	add	r0, fp
 800692c:	ee70 0ac8 	vsub.f32	s1, s1, s16
 8006930:	ee20 0a80 	vmul.f32	s0, s1, s0
 8006934:	ed90 1a00 	vldr	s2, [r0]
 8006938:	4459      	add	r1, fp
 800693a:	ee08 0a01 	vmla.f32	s0, s16, s2
 800693e:	ed81 0a00 	vstr	s0, [r1]
 8006942:	9806      	ldr	r0, [sp, #24]
 8006944:	9901      	ldr	r1, [sp, #4]
 8006946:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 800694a:	9206      	str	r2, [sp, #24]
 800694c:	9805      	ldr	r0, [sp, #20]
 800694e:	9901      	ldr	r1, [sp, #4]
 8006950:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 8006954:	9205      	str	r2, [sp, #20]
 8006956:	9804      	ldr	r0, [sp, #16]
 8006958:	9901      	ldr	r1, [sp, #4]
 800695a:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 800695e:	9802      	ldr	r0, [sp, #8]
 8006960:	eb08 0880 	add.w	r8, r8, r0, lsl #2
 8006964:	eb09 0980 	add.w	r9, r9, r0, lsl #2
 8006968:	eb0a 0a80 	add.w	sl, sl, r0, lsl #2
 800696c:	9803      	ldr	r0, [sp, #12]
 800696e:	9204      	str	r2, [sp, #16]
 8006970:	1e40      	subs	r0, r0, #1
 8006972:	f10b 0b04 	add.w	fp, fp, #4
 8006976:	9003      	str	r0, [sp, #12]
 8006978:	d18c      	bne.n	8006894 <gru_cell_after+0x5c>
 800697a:	69a0      	ldr	r0, [r4, #24]
 800697c:	6961      	ldr	r1, [r4, #20]
 800697e:	61a1      	str	r1, [r4, #24]
 8006980:	6160      	str	r0, [r4, #20]
 8006982:	b00a      	add	sp, #40	; 0x28
 8006984:	ecbd 8b02 	vpop	{d8}
 8006988:	b001      	add	sp, #4
 800698a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800698e <lstm_cell>:
 800698e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006992:	b081      	sub	sp, #4
 8006994:	460c      	mov	r4, r1
 8006996:	ed2d 8b02 	vpush	{d8}
 800699a:	b092      	sub	sp, #72	; 0x48
 800699c:	4602      	mov	r2, r0
 800699e:	8be0      	ldrh	r0, [r4, #30]
 80069a0:	8ba1      	ldrh	r1, [r4, #28]
 80069a2:	6823      	ldr	r3, [r4, #0]
 80069a4:	f8d4 c004 	ldr.w	ip, [r4, #4]
 80069a8:	fb01 f600 	mul.w	r6, r1, r0
 80069ac:	eb03 0586 	add.w	r5, r3, r6, lsl #2
 80069b0:	fb00 f700 	mul.w	r7, r0, r0
 80069b4:	eb05 0a86 	add.w	sl, r5, r6, lsl #2
 80069b8:	eb0c 0e87 	add.w	lr, ip, r7, lsl #2
 80069bc:	eb0a 0b86 	add.w	fp, sl, r6, lsl #2
 80069c0:	eb0e 0887 	add.w	r8, lr, r7, lsl #2
 80069c4:	eb08 0687 	add.w	r6, r8, r7, lsl #2
 80069c8:	9605      	str	r6, [sp, #20]
 80069ca:	2800      	cmp	r0, #0
 80069cc:	f8d4 9020 	ldr.w	r9, [r4, #32]
 80069d0:	68a6      	ldr	r6, [r4, #8]
 80069d2:	f000 8105 	beq.w	8006be0 <lstm_cell+0x252>
 80069d6:	2700      	movs	r7, #0
 80069d8:	9711      	str	r7, [sp, #68]	; 0x44
 80069da:	f8cd 9010 	str.w	r9, [sp, #16]
 80069de:	9610      	str	r6, [sp, #64]	; 0x40
 80069e0:	eb09 07c0 	add.w	r7, r9, r0, lsl #3
 80069e4:	970f      	str	r7, [sp, #60]	; 0x3c
 80069e6:	eb09 0980 	add.w	r9, r9, r0, lsl #2
 80069ea:	eb06 0780 	add.w	r7, r6, r0, lsl #2
 80069ee:	970e      	str	r7, [sp, #56]	; 0x38
 80069f0:	eb06 06c0 	add.w	r6, r6, r0, lsl #3
 80069f4:	9600      	str	r6, [sp, #0]
 80069f6:	950c      	str	r5, [sp, #48]	; 0x30
 80069f8:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
 80069fc:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
 8006a00:	f8cd 801c 	str.w	r8, [sp, #28]
 8006a04:	9003      	str	r0, [sp, #12]
 8006a06:	9206      	str	r2, [sp, #24]
 8006a08:	9002      	str	r0, [sp, #8]
 8006a0a:	9101      	str	r1, [sp, #4]
 8006a0c:	930d      	str	r3, [sp, #52]	; 0x34
 8006a0e:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 8006a12:	f8cd e020 	str.w	lr, [sp, #32]
 8006a16:	9d11      	ldr	r5, [sp, #68]	; 0x44
 8006a18:	f8dd a040 	ldr.w	sl, [sp, #64]	; 0x40
 8006a1c:	f8dd b03c 	ldr.w	fp, [sp, #60]	; 0x3c
 8006a20:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
 8006a24:	9f00      	ldr	r7, [sp, #0]
 8006a26:	eb06 0680 	add.w	r6, r6, r0, lsl #2
 8006a2a:	2000      	movs	r0, #0
 8006a2c:	9000      	str	r0, [sp, #0]
 8006a2e:	9b01      	ldr	r3, [sp, #4]
 8006a30:	9a06      	ldr	r2, [sp, #24]
 8006a32:	990d      	ldr	r1, [sp, #52]	; 0x34
 8006a34:	4668      	mov	r0, sp
 8006a36:	f7fd fbcb 	bl	80041d0 <ai_math_dot_array>
 8006a3a:	9b02      	ldr	r3, [sp, #8]
 8006a3c:	6962      	ldr	r2, [r4, #20]
 8006a3e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8006a40:	4668      	mov	r0, sp
 8006a42:	f7fd fbc5 	bl	80041d0 <ai_math_dot_array>
 8006a46:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8006a48:	9804      	ldr	r0, [sp, #16]
 8006a4a:	ed9a 1a00 	vldr	s2, [sl]
 8006a4e:	ed90 0a00 	vldr	s0, [r0]
 8006a52:	eddd 1a00 	vldr	s3, [sp]
 8006a56:	4429      	add	r1, r5
 8006a58:	edd1 0a00 	vldr	s1, [r1]
 8006a5c:	ee00 1a20 	vmla.f32	s2, s0, s1
 8006a60:	ee71 1a21 	vadd.f32	s3, s2, s3
 8006a64:	edcd 1a00 	vstr	s3, [sp]
 8006a68:	6920      	ldr	r0, [r4, #16]
 8006a6a:	ed9d 0a00 	vldr	s0, [sp]
 8006a6e:	4780      	blx	r0
 8006a70:	2100      	movs	r1, #0
 8006a72:	9100      	str	r1, [sp, #0]
 8006a74:	9b01      	ldr	r3, [sp, #4]
 8006a76:	9a06      	ldr	r2, [sp, #24]
 8006a78:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006a7a:	eeb0 8a40 	vmov.f32	s16, s0
 8006a7e:	4668      	mov	r0, sp
 8006a80:	f7fd fba6 	bl	80041d0 <ai_math_dot_array>
 8006a84:	9b02      	ldr	r3, [sp, #8]
 8006a86:	6962      	ldr	r2, [r4, #20]
 8006a88:	9908      	ldr	r1, [sp, #32]
 8006a8a:	4668      	mov	r0, sp
 8006a8c:	f7fd fba0 	bl	80041d0 <ai_math_dot_array>
 8006a90:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8006a92:	ed9b 0a00 	vldr	s0, [fp]
 8006a96:	ed98 1a00 	vldr	s2, [r8]
 8006a9a:	4428      	add	r0, r5
 8006a9c:	edd0 0a00 	vldr	s1, [r0]
 8006aa0:	ee00 1a20 	vmla.f32	s2, s0, s1
 8006aa4:	ed9d 0a00 	vldr	s0, [sp]
 8006aa8:	ee31 0a00 	vadd.f32	s0, s2, s0
 8006aac:	ed8d 0a00 	vstr	s0, [sp]
 8006ab0:	6920      	ldr	r0, [r4, #16]
 8006ab2:	4780      	blx	r0
 8006ab4:	2100      	movs	r1, #0
 8006ab6:	9100      	str	r1, [sp, #0]
 8006ab8:	9b01      	ldr	r3, [sp, #4]
 8006aba:	9a06      	ldr	r2, [sp, #24]
 8006abc:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8006abe:	eef0 8a40 	vmov.f32	s17, s0
 8006ac2:	4668      	mov	r0, sp
 8006ac4:	f7fd fb84 	bl	80041d0 <ai_math_dot_array>
 8006ac8:	9b02      	ldr	r3, [sp, #8]
 8006aca:	6962      	ldr	r2, [r4, #20]
 8006acc:	9907      	ldr	r1, [sp, #28]
 8006ace:	4668      	mov	r0, sp
 8006ad0:	f7fd fb7e 	bl	80041d0 <ai_math_dot_array>
 8006ad4:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8006ad6:	ed9b 0a00 	vldr	s0, [fp]
 8006ada:	ed97 1a00 	vldr	s2, [r7]
 8006ade:	4428      	add	r0, r5
 8006ae0:	edd0 0a00 	vldr	s1, [r0]
 8006ae4:	ee00 1a20 	vmla.f32	s2, s0, s1
 8006ae8:	ed9d 0a00 	vldr	s0, [sp]
 8006aec:	ee31 0a00 	vadd.f32	s0, s2, s0
 8006af0:	ed8d 0a00 	vstr	s0, [sp]
 8006af4:	68e0      	ldr	r0, [r4, #12]
 8006af6:	4780      	blx	r0
 8006af8:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8006afa:	1941      	adds	r1, r0, r5
 8006afc:	4428      	add	r0, r5
 8006afe:	edd1 0a00 	vldr	s1, [r1]
 8006b02:	ee60 0aa8 	vmul.f32	s1, s1, s17
 8006b06:	ee48 0a00 	vmla.f32	s1, s16, s0
 8006b0a:	edc0 0a00 	vstr	s1, [r0]
 8006b0e:	2200      	movs	r2, #0
 8006b10:	9200      	str	r2, [sp, #0]
 8006b12:	9b01      	ldr	r3, [sp, #4]
 8006b14:	9a06      	ldr	r2, [sp, #24]
 8006b16:	990a      	ldr	r1, [sp, #40]	; 0x28
 8006b18:	4668      	mov	r0, sp
 8006b1a:	f7fd fb59 	bl	80041d0 <ai_math_dot_array>
 8006b1e:	9b02      	ldr	r3, [sp, #8]
 8006b20:	6962      	ldr	r2, [r4, #20]
 8006b22:	9905      	ldr	r1, [sp, #20]
 8006b24:	4668      	mov	r0, sp
 8006b26:	f7fd fb53 	bl	80041d0 <ai_math_dot_array>
 8006b2a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8006b2c:	ed99 0a00 	vldr	s0, [r9]
 8006b30:	ed96 1a00 	vldr	s2, [r6]
 8006b34:	4428      	add	r0, r5
 8006b36:	edd0 0a00 	vldr	s1, [r0]
 8006b3a:	ee00 1a20 	vmla.f32	s2, s0, s1
 8006b3e:	ed9d 0a00 	vldr	s0, [sp]
 8006b42:	ee31 0a00 	vadd.f32	s0, s2, s0
 8006b46:	ed8d 0a00 	vstr	s0, [sp]
 8006b4a:	6920      	ldr	r0, [r4, #16]
 8006b4c:	4780      	blx	r0
 8006b4e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8006b50:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8006b52:	4429      	add	r1, r5
 8006b54:	eeb0 8a40 	vmov.f32	s16, s0
 8006b58:	ed91 0a00 	vldr	s0, [r1]
 8006b5c:	4780      	blx	r0
 8006b5e:	69a1      	ldr	r1, [r4, #24]
 8006b60:	4429      	add	r1, r5
 8006b62:	ee28 0a00 	vmul.f32	s0, s16, s0
 8006b66:	ed81 0a00 	vstr	s0, [r1]
 8006b6a:	980d      	ldr	r0, [sp, #52]	; 0x34
 8006b6c:	9901      	ldr	r1, [sp, #4]
 8006b6e:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 8006b72:	920d      	str	r2, [sp, #52]	; 0x34
 8006b74:	980c      	ldr	r0, [sp, #48]	; 0x30
 8006b76:	9901      	ldr	r1, [sp, #4]
 8006b78:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 8006b7c:	920c      	str	r2, [sp, #48]	; 0x30
 8006b7e:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8006b80:	9901      	ldr	r1, [sp, #4]
 8006b82:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 8006b86:	920b      	str	r2, [sp, #44]	; 0x2c
 8006b88:	980a      	ldr	r0, [sp, #40]	; 0x28
 8006b8a:	9901      	ldr	r1, [sp, #4]
 8006b8c:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 8006b90:	920a      	str	r2, [sp, #40]	; 0x28
 8006b92:	9809      	ldr	r0, [sp, #36]	; 0x24
 8006b94:	9902      	ldr	r1, [sp, #8]
 8006b96:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 8006b9a:	9209      	str	r2, [sp, #36]	; 0x24
 8006b9c:	9808      	ldr	r0, [sp, #32]
 8006b9e:	9902      	ldr	r1, [sp, #8]
 8006ba0:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 8006ba4:	9208      	str	r2, [sp, #32]
 8006ba6:	9807      	ldr	r0, [sp, #28]
 8006ba8:	9902      	ldr	r1, [sp, #8]
 8006baa:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 8006bae:	9207      	str	r2, [sp, #28]
 8006bb0:	9805      	ldr	r0, [sp, #20]
 8006bb2:	9902      	ldr	r1, [sp, #8]
 8006bb4:	1d36      	adds	r6, r6, #4
 8006bb6:	1d3f      	adds	r7, r7, #4
 8006bb8:	1d2d      	adds	r5, r5, #4
 8006bba:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 8006bbe:	9804      	ldr	r0, [sp, #16]
 8006bc0:	9205      	str	r2, [sp, #20]
 8006bc2:	1d01      	adds	r1, r0, #4
 8006bc4:	9803      	ldr	r0, [sp, #12]
 8006bc6:	9104      	str	r1, [sp, #16]
 8006bc8:	1e40      	subs	r0, r0, #1
 8006bca:	f109 0904 	add.w	r9, r9, #4
 8006bce:	f108 0804 	add.w	r8, r8, #4
 8006bd2:	f10b 0b04 	add.w	fp, fp, #4
 8006bd6:	f10a 0a04 	add.w	sl, sl, #4
 8006bda:	9003      	str	r0, [sp, #12]
 8006bdc:	f47f af25 	bne.w	8006a2a <lstm_cell+0x9c>
 8006be0:	69a0      	ldr	r0, [r4, #24]
 8006be2:	6961      	ldr	r1, [r4, #20]
 8006be4:	61a1      	str	r1, [r4, #24]
 8006be6:	6160      	str	r0, [r4, #20]
 8006be8:	b012      	add	sp, #72	; 0x48
 8006bea:	ecbd 8b02 	vpop	{d8}
 8006bee:	b001      	add	sp, #4
 8006bf0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08006bf4 <_forward_gru_before>:
 8006bf4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006bf8:	4607      	mov	r7, r0
 8006bfa:	b08d      	sub	sp, #52	; 0x34
 8006bfc:	6978      	ldr	r0, [r7, #20]
 8006bfe:	6800      	ldr	r0, [r0, #0]
 8006c00:	6801      	ldr	r1, [r0, #0]
 8006c02:	6842      	ldr	r2, [r0, #4]
 8006c04:	6880      	ldr	r0, [r0, #8]
 8006c06:	680d      	ldr	r5, [r1, #0]
 8006c08:	6813      	ldr	r3, [r2, #0]
 8006c0a:	6806      	ldr	r6, [r0, #0]
 8006c0c:	6841      	ldr	r1, [r0, #4]
 8006c0e:	6882      	ldr	r2, [r0, #8]
 8006c10:	6928      	ldr	r0, [r5, #16]
 8006c12:	9001      	str	r0, [sp, #4]
 8006c14:	69b8      	ldr	r0, [r7, #24]
 8006c16:	691c      	ldr	r4, [r3, #16]
 8006c18:	9000      	str	r0, [sp, #0]
 8006c1a:	2c02      	cmp	r4, #2
 8006c1c:	68a8      	ldr	r0, [r5, #8]
 8006c1e:	9003      	str	r0, [sp, #12]
 8006c20:	41a4      	sbcs	r4, r4
 8006c22:	6818      	ldr	r0, [r3, #0]
 8006c24:	f8d0 9008 	ldr.w	r9, [r0, #8]
 8006c28:	6808      	ldr	r0, [r1, #0]
 8006c2a:	6811      	ldr	r1, [r2, #0]
 8006c2c:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8006c30:	6833      	ldr	r3, [r6, #0]
 8006c32:	688e      	ldr	r6, [r1, #8]
 8006c34:	9800      	ldr	r0, [sp, #0]
 8006c36:	f8d3 b008 	ldr.w	fp, [r3, #8]
 8006c3a:	eb00 0140 	add.w	r1, r0, r0, lsl #1
 8006c3e:	0089      	lsls	r1, r1, #2
 8006c40:	9102      	str	r1, [sp, #8]
 8006c42:	4608      	mov	r0, r1
 8006c44:	f017 ff4a 	bl	801eadc <malloc>
 8006c48:	9902      	ldr	r1, [sp, #8]
 8006c4a:	4682      	mov	sl, r0
 8006c4c:	f017 ff12 	bl	801ea74 <__aeabi_memclr>
 8006c50:	f8cd b010 	str.w	fp, [sp, #16]
 8006c54:	f8cd 8014 	str.w	r8, [sp, #20]
 8006c58:	9606      	str	r6, [sp, #24]
 8006c5a:	43e4      	mvns	r4, r4
 8006c5c:	69f8      	ldr	r0, [r7, #28]
 8006c5e:	9007      	str	r0, [sp, #28]
 8006c60:	0fe4      	lsrs	r4, r4, #31
 8006c62:	6a39      	ldr	r1, [r7, #32]
 8006c64:	9800      	ldr	r0, [sp, #0]
 8006c66:	9108      	str	r1, [sp, #32]
 8006c68:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
 8006c6c:	eb0a 0180 	add.w	r1, sl, r0, lsl #2
 8006c70:	9803      	ldr	r0, [sp, #12]
 8006c72:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
 8006c76:	910a      	str	r1, [sp, #40]	; 0x28
 8006c78:	9800      	ldr	r0, [sp, #0]
 8006c7a:	f8ad 002e 	strh.w	r0, [sp, #46]	; 0x2e
 8006c7e:	9800      	ldr	r0, [sp, #0]
 8006c80:	eb0a 01c0 	add.w	r1, sl, r0, lsl #3
 8006c84:	910c      	str	r1, [sp, #48]	; 0x30
 8006c86:	b104      	cbz	r4, 8006c8a <_forward_gru_before+0x96>
 8006c88:	9c00      	ldr	r4, [sp, #0]
 8006c8a:	f897 0025 	ldrb.w	r0, [r7, #37]	; 0x25
 8006c8e:	b918      	cbnz	r0, 8006c98 <_forward_gru_before+0xa4>
 8006c90:	2600      	movs	r6, #0
 8006c92:	f04f 0b01 	mov.w	fp, #1
 8006c96:	e003      	b.n	8006ca0 <_forward_gru_before+0xac>
 8006c98:	9e01      	ldr	r6, [sp, #4]
 8006c9a:	1e76      	subs	r6, r6, #1
 8006c9c:	f04f 3bff 	mov.w	fp, #4294967295
 8006ca0:	f897 0026 	ldrb.w	r0, [r7, #38]	; 0x26
 8006ca4:	b128      	cbz	r0, 8006cb2 <_forward_gru_before+0xbe>
 8006ca6:	9801      	ldr	r0, [sp, #4]
 8006ca8:	1e40      	subs	r0, r0, #1
 8006caa:	4360      	muls	r0, r4
 8006cac:	eb09 0980 	add.w	r9, r9, r0, lsl #2
 8006cb0:	4264      	negs	r4, r4
 8006cb2:	9502      	str	r5, [sp, #8]
 8006cb4:	9f01      	ldr	r7, [sp, #4]
 8006cb6:	9d00      	ldr	r5, [sp, #0]
 8006cb8:	f8dd 800c 	ldr.w	r8, [sp, #12]
 8006cbc:	9802      	ldr	r0, [sp, #8]
 8006cbe:	6801      	ldr	r1, [r0, #0]
 8006cc0:	688a      	ldr	r2, [r1, #8]
 8006cc2:	fb06 f308 	mul.w	r3, r6, r8
 8006cc6:	eb02 0083 	add.w	r0, r2, r3, lsl #2
 8006cca:	a904      	add	r1, sp, #16
 8006ccc:	f7ff fcfc 	bl	80066c8 <gru_cell_before>
 8006cd0:	445e      	add	r6, fp
 8006cd2:	b124      	cbz	r4, 8006cde <_forward_gru_before+0xea>
 8006cd4:	9909      	ldr	r1, [sp, #36]	; 0x24
 8006cd6:	00aa      	lsls	r2, r5, #2
 8006cd8:	4648      	mov	r0, r9
 8006cda:	f017 fece 	bl	801ea7a <__aeabi_memcpy>
 8006cde:	42be      	cmp	r6, r7
 8006ce0:	eb09 0984 	add.w	r9, r9, r4, lsl #2
 8006ce4:	d201      	bcs.n	8006cea <_forward_gru_before+0xf6>
 8006ce6:	2e00      	cmp	r6, #0
 8006ce8:	d5e8      	bpl.n	8006cbc <_forward_gru_before+0xc8>
 8006cea:	4648      	mov	r0, r9
 8006cec:	b91c      	cbnz	r4, 8006cf6 <_forward_gru_before+0x102>
 8006cee:	9909      	ldr	r1, [sp, #36]	; 0x24
 8006cf0:	00aa      	lsls	r2, r5, #2
 8006cf2:	f017 fec2 	bl	801ea7a <__aeabi_memcpy>
 8006cf6:	4650      	mov	r0, sl
 8006cf8:	f017 fef8 	bl	801eaec <free>
 8006cfc:	b00d      	add	sp, #52	; 0x34
 8006cfe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08006d02 <_forward_gru_after>:
 8006d02:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006d06:	4607      	mov	r7, r0
 8006d08:	b08d      	sub	sp, #52	; 0x34
 8006d0a:	6978      	ldr	r0, [r7, #20]
 8006d0c:	6800      	ldr	r0, [r0, #0]
 8006d0e:	6801      	ldr	r1, [r0, #0]
 8006d10:	6842      	ldr	r2, [r0, #4]
 8006d12:	6880      	ldr	r0, [r0, #8]
 8006d14:	680d      	ldr	r5, [r1, #0]
 8006d16:	6813      	ldr	r3, [r2, #0]
 8006d18:	6806      	ldr	r6, [r0, #0]
 8006d1a:	6841      	ldr	r1, [r0, #4]
 8006d1c:	6882      	ldr	r2, [r0, #8]
 8006d1e:	6928      	ldr	r0, [r5, #16]
 8006d20:	9001      	str	r0, [sp, #4]
 8006d22:	69b8      	ldr	r0, [r7, #24]
 8006d24:	691c      	ldr	r4, [r3, #16]
 8006d26:	9000      	str	r0, [sp, #0]
 8006d28:	2c02      	cmp	r4, #2
 8006d2a:	68a8      	ldr	r0, [r5, #8]
 8006d2c:	9003      	str	r0, [sp, #12]
 8006d2e:	41a4      	sbcs	r4, r4
 8006d30:	6818      	ldr	r0, [r3, #0]
 8006d32:	f8d0 9008 	ldr.w	r9, [r0, #8]
 8006d36:	6808      	ldr	r0, [r1, #0]
 8006d38:	6833      	ldr	r3, [r6, #0]
 8006d3a:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8006d3e:	6811      	ldr	r1, [r2, #0]
 8006d40:	9800      	ldr	r0, [sp, #0]
 8006d42:	f8d3 b008 	ldr.w	fp, [r3, #8]
 8006d46:	688e      	ldr	r6, [r1, #8]
 8006d48:	00c0      	lsls	r0, r0, #3
 8006d4a:	9002      	str	r0, [sp, #8]
 8006d4c:	43e4      	mvns	r4, r4
 8006d4e:	f017 fec5 	bl	801eadc <malloc>
 8006d52:	9902      	ldr	r1, [sp, #8]
 8006d54:	4682      	mov	sl, r0
 8006d56:	f017 fe8d 	bl	801ea74 <__aeabi_memclr>
 8006d5a:	a804      	add	r0, sp, #16
 8006d5c:	2100      	movs	r1, #0
 8006d5e:	2200      	movs	r2, #0
 8006d60:	2300      	movs	r3, #0
 8006d62:	c00e      	stmia	r0!, {r1, r2, r3}
 8006d64:	c00e      	stmia	r0!, {r1, r2, r3}
 8006d66:	c00e      	stmia	r0!, {r1, r2, r3}
 8006d68:	f8cd b010 	str.w	fp, [sp, #16]
 8006d6c:	f8cd 8014 	str.w	r8, [sp, #20]
 8006d70:	9606      	str	r6, [sp, #24]
 8006d72:	0fe4      	lsrs	r4, r4, #31
 8006d74:	69f8      	ldr	r0, [r7, #28]
 8006d76:	9007      	str	r0, [sp, #28]
 8006d78:	6a39      	ldr	r1, [r7, #32]
 8006d7a:	9800      	ldr	r0, [sp, #0]
 8006d7c:	9108      	str	r1, [sp, #32]
 8006d7e:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
 8006d82:	eb0a 0180 	add.w	r1, sl, r0, lsl #2
 8006d86:	9803      	ldr	r0, [sp, #12]
 8006d88:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
 8006d8c:	910a      	str	r1, [sp, #40]	; 0x28
 8006d8e:	9800      	ldr	r0, [sp, #0]
 8006d90:	f8ad 002e 	strh.w	r0, [sp, #46]	; 0x2e
 8006d94:	b104      	cbz	r4, 8006d98 <_forward_gru_after+0x96>
 8006d96:	9c00      	ldr	r4, [sp, #0]
 8006d98:	f897 0025 	ldrb.w	r0, [r7, #37]	; 0x25
 8006d9c:	b918      	cbnz	r0, 8006da6 <_forward_gru_after+0xa4>
 8006d9e:	2600      	movs	r6, #0
 8006da0:	f04f 0b01 	mov.w	fp, #1
 8006da4:	e003      	b.n	8006dae <_forward_gru_after+0xac>
 8006da6:	9e01      	ldr	r6, [sp, #4]
 8006da8:	1e76      	subs	r6, r6, #1
 8006daa:	f04f 3bff 	mov.w	fp, #4294967295
 8006dae:	f897 0026 	ldrb.w	r0, [r7, #38]	; 0x26
 8006db2:	b128      	cbz	r0, 8006dc0 <_forward_gru_after+0xbe>
 8006db4:	9801      	ldr	r0, [sp, #4]
 8006db6:	1e40      	subs	r0, r0, #1
 8006db8:	4360      	muls	r0, r4
 8006dba:	eb09 0980 	add.w	r9, r9, r0, lsl #2
 8006dbe:	4264      	negs	r4, r4
 8006dc0:	9502      	str	r5, [sp, #8]
 8006dc2:	9f01      	ldr	r7, [sp, #4]
 8006dc4:	9d00      	ldr	r5, [sp, #0]
 8006dc6:	f8dd 800c 	ldr.w	r8, [sp, #12]
 8006dca:	9802      	ldr	r0, [sp, #8]
 8006dcc:	6801      	ldr	r1, [r0, #0]
 8006dce:	688a      	ldr	r2, [r1, #8]
 8006dd0:	fb06 f308 	mul.w	r3, r6, r8
 8006dd4:	eb02 0083 	add.w	r0, r2, r3, lsl #2
 8006dd8:	a904      	add	r1, sp, #16
 8006dda:	f7ff fd2d 	bl	8006838 <gru_cell_after>
 8006dde:	445e      	add	r6, fp
 8006de0:	b124      	cbz	r4, 8006dec <_forward_gru_after+0xea>
 8006de2:	9909      	ldr	r1, [sp, #36]	; 0x24
 8006de4:	00aa      	lsls	r2, r5, #2
 8006de6:	4648      	mov	r0, r9
 8006de8:	f017 fe47 	bl	801ea7a <__aeabi_memcpy>
 8006dec:	42be      	cmp	r6, r7
 8006dee:	eb09 0984 	add.w	r9, r9, r4, lsl #2
 8006df2:	d201      	bcs.n	8006df8 <_forward_gru_after+0xf6>
 8006df4:	2e00      	cmp	r6, #0
 8006df6:	d5e8      	bpl.n	8006dca <_forward_gru_after+0xc8>
 8006df8:	4648      	mov	r0, r9
 8006dfa:	b91c      	cbnz	r4, 8006e04 <_forward_gru_after+0x102>
 8006dfc:	9909      	ldr	r1, [sp, #36]	; 0x24
 8006dfe:	00aa      	lsls	r2, r5, #2
 8006e00:	f017 fe3b 	bl	801ea7a <__aeabi_memcpy>
 8006e04:	4650      	mov	r0, sl
 8006e06:	f017 fe71 	bl	801eaec <free>
 8006e0a:	b00d      	add	sp, #52	; 0x34
 8006e0c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08006e10 <forward_lstm>:
 8006e10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006e14:	4605      	mov	r5, r0
 8006e16:	b091      	sub	sp, #68	; 0x44
 8006e18:	6968      	ldr	r0, [r5, #20]
 8006e1a:	6800      	ldr	r0, [r0, #0]
 8006e1c:	6801      	ldr	r1, [r0, #0]
 8006e1e:	6842      	ldr	r2, [r0, #4]
 8006e20:	6880      	ldr	r0, [r0, #8]
 8006e22:	f8d1 a000 	ldr.w	sl, [r1]
 8006e26:	6817      	ldr	r7, [r2, #0]
 8006e28:	6806      	ldr	r6, [r0, #0]
 8006e2a:	6843      	ldr	r3, [r0, #4]
 8006e2c:	6882      	ldr	r2, [r0, #8]
 8006e2e:	68c1      	ldr	r1, [r0, #12]
 8006e30:	f8da 0010 	ldr.w	r0, [sl, #16]
 8006e34:	9002      	str	r0, [sp, #8]
 8006e36:	69a8      	ldr	r0, [r5, #24]
 8006e38:	693c      	ldr	r4, [r7, #16]
 8006e3a:	9000      	str	r0, [sp, #0]
 8006e3c:	2c02      	cmp	r4, #2
 8006e3e:	f8da 0008 	ldr.w	r0, [sl, #8]
 8006e42:	9004      	str	r0, [sp, #16]
 8006e44:	41a4      	sbcs	r4, r4
 8006e46:	6838      	ldr	r0, [r7, #0]
 8006e48:	f8d0 9008 	ldr.w	r9, [r0, #8]
 8006e4c:	6818      	ldr	r0, [r3, #0]
 8006e4e:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8006e52:	6808      	ldr	r0, [r1, #0]
 8006e54:	f8d0 b008 	ldr.w	fp, [r0, #8]
 8006e58:	6837      	ldr	r7, [r6, #0]
 8006e5a:	6812      	ldr	r2, [r2, #0]
 8006e5c:	9800      	ldr	r0, [sp, #0]
 8006e5e:	68bf      	ldr	r7, [r7, #8]
 8006e60:	6896      	ldr	r6, [r2, #8]
 8006e62:	eb00 0140 	add.w	r1, r0, r0, lsl #1
 8006e66:	0089      	lsls	r1, r1, #2
 8006e68:	9103      	str	r1, [sp, #12]
 8006e6a:	4608      	mov	r0, r1
 8006e6c:	f017 fe36 	bl	801eadc <malloc>
 8006e70:	9001      	str	r0, [sp, #4]
 8006e72:	43e4      	mvns	r4, r4
 8006e74:	9903      	ldr	r1, [sp, #12]
 8006e76:	f017 fdfd 	bl	801ea74 <__aeabi_memclr>
 8006e7a:	9705      	str	r7, [sp, #20]
 8006e7c:	f8cd 8018 	str.w	r8, [sp, #24]
 8006e80:	f8cd b01c 	str.w	fp, [sp, #28]
 8006e84:	0fe4      	lsrs	r4, r4, #31
 8006e86:	69e8      	ldr	r0, [r5, #28]
 8006e88:	9900      	ldr	r1, [sp, #0]
 8006e8a:	9008      	str	r0, [sp, #32]
 8006e8c:	6a28      	ldr	r0, [r5, #32]
 8006e8e:	9009      	str	r0, [sp, #36]	; 0x24
 8006e90:	9801      	ldr	r0, [sp, #4]
 8006e92:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 8006e96:	900a      	str	r0, [sp, #40]	; 0x28
 8006e98:	9900      	ldr	r1, [sp, #0]
 8006e9a:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 8006e9e:	900b      	str	r0, [sp, #44]	; 0x2c
 8006ea0:	9900      	ldr	r1, [sp, #0]
 8006ea2:	9804      	ldr	r0, [sp, #16]
 8006ea4:	f8ad 0030 	strh.w	r0, [sp, #48]	; 0x30
 8006ea8:	f8ad 1032 	strh.w	r1, [sp, #50]	; 0x32
 8006eac:	960d      	str	r6, [sp, #52]	; 0x34
 8006eae:	9801      	ldr	r0, [sp, #4]
 8006eb0:	900e      	str	r0, [sp, #56]	; 0x38
 8006eb2:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8006eb4:	900f      	str	r0, [sp, #60]	; 0x3c
 8006eb6:	b104      	cbz	r4, 8006eba <forward_lstm+0xaa>
 8006eb8:	9c00      	ldr	r4, [sp, #0]
 8006eba:	f895 0028 	ldrb.w	r0, [r5, #40]	; 0x28
 8006ebe:	b918      	cbnz	r0, 8006ec8 <forward_lstm+0xb8>
 8006ec0:	2600      	movs	r6, #0
 8006ec2:	f04f 0b01 	mov.w	fp, #1
 8006ec6:	e003      	b.n	8006ed0 <forward_lstm+0xc0>
 8006ec8:	9e02      	ldr	r6, [sp, #8]
 8006eca:	1e76      	subs	r6, r6, #1
 8006ecc:	f04f 3bff 	mov.w	fp, #4294967295
 8006ed0:	f895 0029 	ldrb.w	r0, [r5, #41]	; 0x29
 8006ed4:	b128      	cbz	r0, 8006ee2 <forward_lstm+0xd2>
 8006ed6:	9802      	ldr	r0, [sp, #8]
 8006ed8:	1e40      	subs	r0, r0, #1
 8006eda:	4360      	muls	r0, r4
 8006edc:	eb09 0980 	add.w	r9, r9, r0, lsl #2
 8006ee0:	4264      	negs	r4, r4
 8006ee2:	9f02      	ldr	r7, [sp, #8]
 8006ee4:	f8dd 5000 	ldr.w	r5, [sp]
 8006ee8:	f8dd 8010 	ldr.w	r8, [sp, #16]
 8006eec:	f8da 0000 	ldr.w	r0, [sl]
 8006ef0:	6881      	ldr	r1, [r0, #8]
 8006ef2:	fb06 f208 	mul.w	r2, r6, r8
 8006ef6:	eb01 0082 	add.w	r0, r1, r2, lsl #2
 8006efa:	a905      	add	r1, sp, #20
 8006efc:	f7ff fd47 	bl	800698e <lstm_cell>
 8006f00:	445e      	add	r6, fp
 8006f02:	b124      	cbz	r4, 8006f0e <forward_lstm+0xfe>
 8006f04:	990a      	ldr	r1, [sp, #40]	; 0x28
 8006f06:	00aa      	lsls	r2, r5, #2
 8006f08:	4648      	mov	r0, r9
 8006f0a:	f017 fdb6 	bl	801ea7a <__aeabi_memcpy>
 8006f0e:	42be      	cmp	r6, r7
 8006f10:	eb09 0984 	add.w	r9, r9, r4, lsl #2
 8006f14:	d201      	bcs.n	8006f1a <forward_lstm+0x10a>
 8006f16:	2e00      	cmp	r6, #0
 8006f18:	d5e8      	bpl.n	8006eec <forward_lstm+0xdc>
 8006f1a:	4648      	mov	r0, r9
 8006f1c:	b91c      	cbnz	r4, 8006f26 <forward_lstm+0x116>
 8006f1e:	990a      	ldr	r1, [sp, #40]	; 0x28
 8006f20:	00aa      	lsls	r2, r5, #2
 8006f22:	f017 fdaa 	bl	801ea7a <__aeabi_memcpy>
 8006f26:	9801      	ldr	r0, [sp, #4]
 8006f28:	f017 fde0 	bl	801eaec <free>
 8006f2c:	b011      	add	sp, #68	; 0x44
 8006f2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08006f32 <forward_gru>:
 8006f32:	f890 1024 	ldrb.w	r1, [r0, #36]	; 0x24
 8006f36:	2900      	cmp	r1, #0
 8006f38:	bf18      	it	ne
 8006f3a:	f7ff bee2 	bne.w	8006d02 <_forward_gru_after>
 8006f3e:	e659      	b.n	8006bf4 <_forward_gru_before>

08006f40 <__aeabi_memset>:
 8006f40:	b470      	push	{r4, r5, r6}
 8006f42:	0784      	lsls	r4, r0, #30
 8006f44:	d046      	beq.n	8006fd4 <__aeabi_memset+0x94>
 8006f46:	1e4c      	subs	r4, r1, #1
 8006f48:	2900      	cmp	r1, #0
 8006f4a:	d041      	beq.n	8006fd0 <__aeabi_memset+0x90>
 8006f4c:	b2d5      	uxtb	r5, r2
 8006f4e:	4603      	mov	r3, r0
 8006f50:	e002      	b.n	8006f58 <__aeabi_memset+0x18>
 8006f52:	1e61      	subs	r1, r4, #1
 8006f54:	b3e4      	cbz	r4, 8006fd0 <__aeabi_memset+0x90>
 8006f56:	460c      	mov	r4, r1
 8006f58:	f803 5b01 	strb.w	r5, [r3], #1
 8006f5c:	0799      	lsls	r1, r3, #30
 8006f5e:	d1f8      	bne.n	8006f52 <__aeabi_memset+0x12>
 8006f60:	2c03      	cmp	r4, #3
 8006f62:	d92e      	bls.n	8006fc2 <__aeabi_memset+0x82>
 8006f64:	b2d5      	uxtb	r5, r2
 8006f66:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8006f6a:	2c0f      	cmp	r4, #15
 8006f6c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8006f70:	d919      	bls.n	8006fa6 <__aeabi_memset+0x66>
 8006f72:	4626      	mov	r6, r4
 8006f74:	f103 0110 	add.w	r1, r3, #16
 8006f78:	3e10      	subs	r6, #16
 8006f7a:	2e0f      	cmp	r6, #15
 8006f7c:	f841 5c10 	str.w	r5, [r1, #-16]
 8006f80:	f841 5c0c 	str.w	r5, [r1, #-12]
 8006f84:	f841 5c08 	str.w	r5, [r1, #-8]
 8006f88:	f841 5c04 	str.w	r5, [r1, #-4]
 8006f8c:	f101 0110 	add.w	r1, r1, #16
 8006f90:	d8f2      	bhi.n	8006f78 <__aeabi_memset+0x38>
 8006f92:	f1a4 0110 	sub.w	r1, r4, #16
 8006f96:	f021 010f 	bic.w	r1, r1, #15
 8006f9a:	f004 040f 	and.w	r4, r4, #15
 8006f9e:	3110      	adds	r1, #16
 8006fa0:	2c03      	cmp	r4, #3
 8006fa2:	440b      	add	r3, r1
 8006fa4:	d90d      	bls.n	8006fc2 <__aeabi_memset+0x82>
 8006fa6:	461e      	mov	r6, r3
 8006fa8:	4621      	mov	r1, r4
 8006faa:	3904      	subs	r1, #4
 8006fac:	2903      	cmp	r1, #3
 8006fae:	f846 5b04 	str.w	r5, [r6], #4
 8006fb2:	d8fa      	bhi.n	8006faa <__aeabi_memset+0x6a>
 8006fb4:	1f21      	subs	r1, r4, #4
 8006fb6:	f021 0103 	bic.w	r1, r1, #3
 8006fba:	3104      	adds	r1, #4
 8006fbc:	440b      	add	r3, r1
 8006fbe:	f004 0403 	and.w	r4, r4, #3
 8006fc2:	b12c      	cbz	r4, 8006fd0 <__aeabi_memset+0x90>
 8006fc4:	b2d2      	uxtb	r2, r2
 8006fc6:	441c      	add	r4, r3
 8006fc8:	f803 2b01 	strb.w	r2, [r3], #1
 8006fcc:	42a3      	cmp	r3, r4
 8006fce:	d1fb      	bne.n	8006fc8 <__aeabi_memset+0x88>
 8006fd0:	bc70      	pop	{r4, r5, r6}
 8006fd2:	4770      	bx	lr
 8006fd4:	460c      	mov	r4, r1
 8006fd6:	4603      	mov	r3, r0
 8006fd8:	e7c2      	b.n	8006f60 <__aeabi_memset+0x20>

08006fda <strlen>:
 8006fda:	4603      	mov	r3, r0
 8006fdc:	f813 2b01 	ldrb.w	r2, [r3], #1
 8006fe0:	2a00      	cmp	r2, #0
 8006fe2:	d1fb      	bne.n	8006fdc <strlen+0x2>
 8006fe4:	1a18      	subs	r0, r3, r0
 8006fe6:	3801      	subs	r0, #1
 8006fe8:	4770      	bx	lr
 8006fea:	0000      	movs	r0, r0
 8006fec:	0000      	movs	r0, r0
	...

08006ff0 <memchr>:
 8006ff0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8006ff4:	2a10      	cmp	r2, #16
 8006ff6:	db2b      	blt.n	8007050 <memchr+0x60>
 8006ff8:	f010 0f07 	tst.w	r0, #7
 8006ffc:	d008      	beq.n	8007010 <memchr+0x20>
 8006ffe:	f810 3b01 	ldrb.w	r3, [r0], #1
 8007002:	3a01      	subs	r2, #1
 8007004:	428b      	cmp	r3, r1
 8007006:	d02d      	beq.n	8007064 <memchr+0x74>
 8007008:	f010 0f07 	tst.w	r0, #7
 800700c:	b342      	cbz	r2, 8007060 <memchr+0x70>
 800700e:	d1f6      	bne.n	8006ffe <memchr+0xe>
 8007010:	b4f0      	push	{r4, r5, r6, r7}
 8007012:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8007016:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800701a:	f022 0407 	bic.w	r4, r2, #7
 800701e:	f07f 0700 	mvns.w	r7, #0
 8007022:	2300      	movs	r3, #0
 8007024:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8007028:	3c08      	subs	r4, #8
 800702a:	ea85 0501 	eor.w	r5, r5, r1
 800702e:	ea86 0601 	eor.w	r6, r6, r1
 8007032:	fa85 f547 	uadd8	r5, r5, r7
 8007036:	faa3 f587 	sel	r5, r3, r7
 800703a:	fa86 f647 	uadd8	r6, r6, r7
 800703e:	faa5 f687 	sel	r6, r5, r7
 8007042:	b98e      	cbnz	r6, 8007068 <memchr+0x78>
 8007044:	d1ee      	bne.n	8007024 <memchr+0x34>
 8007046:	bcf0      	pop	{r4, r5, r6, r7}
 8007048:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800704c:	f002 0207 	and.w	r2, r2, #7
 8007050:	b132      	cbz	r2, 8007060 <memchr+0x70>
 8007052:	f810 3b01 	ldrb.w	r3, [r0], #1
 8007056:	3a01      	subs	r2, #1
 8007058:	ea83 0301 	eor.w	r3, r3, r1
 800705c:	b113      	cbz	r3, 8007064 <memchr+0x74>
 800705e:	d1f8      	bne.n	8007052 <memchr+0x62>
 8007060:	2000      	movs	r0, #0
 8007062:	4770      	bx	lr
 8007064:	3801      	subs	r0, #1
 8007066:	4770      	bx	lr
 8007068:	2d00      	cmp	r5, #0
 800706a:	bf06      	itte	eq
 800706c:	4635      	moveq	r5, r6
 800706e:	3803      	subeq	r0, #3
 8007070:	3807      	subne	r0, #7
 8007072:	f015 0f01 	tst.w	r5, #1
 8007076:	d107      	bne.n	8007088 <memchr+0x98>
 8007078:	3001      	adds	r0, #1
 800707a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800707e:	bf02      	ittt	eq
 8007080:	3001      	addeq	r0, #1
 8007082:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8007086:	3001      	addeq	r0, #1
 8007088:	bcf0      	pop	{r4, r5, r6, r7}
 800708a:	3801      	subs	r0, #1
 800708c:	4770      	bx	lr
 800708e:	bf00      	nop

08007090 <__aeabi_drsub>:
 8007090:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8007094:	e002      	b.n	800709c <__adddf3>
 8007096:	bf00      	nop

08007098 <__aeabi_dsub>:
 8007098:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800709c <__adddf3>:
 800709c:	b530      	push	{r4, r5, lr}
 800709e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80070a2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80070a6:	ea94 0f05 	teq	r4, r5
 80070aa:	bf08      	it	eq
 80070ac:	ea90 0f02 	teqeq	r0, r2
 80070b0:	bf1f      	itttt	ne
 80070b2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80070b6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80070ba:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80070be:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80070c2:	f000 80e2 	beq.w	800728a <__adddf3+0x1ee>
 80070c6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80070ca:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80070ce:	bfb8      	it	lt
 80070d0:	426d      	neglt	r5, r5
 80070d2:	dd0c      	ble.n	80070ee <__adddf3+0x52>
 80070d4:	442c      	add	r4, r5
 80070d6:	ea80 0202 	eor.w	r2, r0, r2
 80070da:	ea81 0303 	eor.w	r3, r1, r3
 80070de:	ea82 0000 	eor.w	r0, r2, r0
 80070e2:	ea83 0101 	eor.w	r1, r3, r1
 80070e6:	ea80 0202 	eor.w	r2, r0, r2
 80070ea:	ea81 0303 	eor.w	r3, r1, r3
 80070ee:	2d36      	cmp	r5, #54	; 0x36
 80070f0:	bf88      	it	hi
 80070f2:	bd30      	pophi	{r4, r5, pc}
 80070f4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80070f8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80070fc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8007100:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8007104:	d002      	beq.n	800710c <__adddf3+0x70>
 8007106:	4240      	negs	r0, r0
 8007108:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800710c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8007110:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8007114:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8007118:	d002      	beq.n	8007120 <__adddf3+0x84>
 800711a:	4252      	negs	r2, r2
 800711c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8007120:	ea94 0f05 	teq	r4, r5
 8007124:	f000 80a7 	beq.w	8007276 <__adddf3+0x1da>
 8007128:	f1a4 0401 	sub.w	r4, r4, #1
 800712c:	f1d5 0e20 	rsbs	lr, r5, #32
 8007130:	db0d      	blt.n	800714e <__adddf3+0xb2>
 8007132:	fa02 fc0e 	lsl.w	ip, r2, lr
 8007136:	fa22 f205 	lsr.w	r2, r2, r5
 800713a:	1880      	adds	r0, r0, r2
 800713c:	f141 0100 	adc.w	r1, r1, #0
 8007140:	fa03 f20e 	lsl.w	r2, r3, lr
 8007144:	1880      	adds	r0, r0, r2
 8007146:	fa43 f305 	asr.w	r3, r3, r5
 800714a:	4159      	adcs	r1, r3
 800714c:	e00e      	b.n	800716c <__adddf3+0xd0>
 800714e:	f1a5 0520 	sub.w	r5, r5, #32
 8007152:	f10e 0e20 	add.w	lr, lr, #32
 8007156:	2a01      	cmp	r2, #1
 8007158:	fa03 fc0e 	lsl.w	ip, r3, lr
 800715c:	bf28      	it	cs
 800715e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8007162:	fa43 f305 	asr.w	r3, r3, r5
 8007166:	18c0      	adds	r0, r0, r3
 8007168:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800716c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8007170:	d507      	bpl.n	8007182 <__adddf3+0xe6>
 8007172:	f04f 0e00 	mov.w	lr, #0
 8007176:	f1dc 0c00 	rsbs	ip, ip, #0
 800717a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800717e:	eb6e 0101 	sbc.w	r1, lr, r1
 8007182:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8007186:	d31b      	bcc.n	80071c0 <__adddf3+0x124>
 8007188:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800718c:	d30c      	bcc.n	80071a8 <__adddf3+0x10c>
 800718e:	0849      	lsrs	r1, r1, #1
 8007190:	ea5f 0030 	movs.w	r0, r0, rrx
 8007194:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8007198:	f104 0401 	add.w	r4, r4, #1
 800719c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80071a0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80071a4:	f080 809a 	bcs.w	80072dc <__adddf3+0x240>
 80071a8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80071ac:	bf08      	it	eq
 80071ae:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80071b2:	f150 0000 	adcs.w	r0, r0, #0
 80071b6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80071ba:	ea41 0105 	orr.w	r1, r1, r5
 80071be:	bd30      	pop	{r4, r5, pc}
 80071c0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80071c4:	4140      	adcs	r0, r0
 80071c6:	eb41 0101 	adc.w	r1, r1, r1
 80071ca:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80071ce:	f1a4 0401 	sub.w	r4, r4, #1
 80071d2:	d1e9      	bne.n	80071a8 <__adddf3+0x10c>
 80071d4:	f091 0f00 	teq	r1, #0
 80071d8:	bf04      	itt	eq
 80071da:	4601      	moveq	r1, r0
 80071dc:	2000      	moveq	r0, #0
 80071de:	fab1 f381 	clz	r3, r1
 80071e2:	bf08      	it	eq
 80071e4:	3320      	addeq	r3, #32
 80071e6:	f1a3 030b 	sub.w	r3, r3, #11
 80071ea:	f1b3 0220 	subs.w	r2, r3, #32
 80071ee:	da0c      	bge.n	800720a <__adddf3+0x16e>
 80071f0:	320c      	adds	r2, #12
 80071f2:	dd08      	ble.n	8007206 <__adddf3+0x16a>
 80071f4:	f102 0c14 	add.w	ip, r2, #20
 80071f8:	f1c2 020c 	rsb	r2, r2, #12
 80071fc:	fa01 f00c 	lsl.w	r0, r1, ip
 8007200:	fa21 f102 	lsr.w	r1, r1, r2
 8007204:	e00c      	b.n	8007220 <__adddf3+0x184>
 8007206:	f102 0214 	add.w	r2, r2, #20
 800720a:	bfd8      	it	le
 800720c:	f1c2 0c20 	rsble	ip, r2, #32
 8007210:	fa01 f102 	lsl.w	r1, r1, r2
 8007214:	fa20 fc0c 	lsr.w	ip, r0, ip
 8007218:	bfdc      	itt	le
 800721a:	ea41 010c 	orrle.w	r1, r1, ip
 800721e:	4090      	lslle	r0, r2
 8007220:	1ae4      	subs	r4, r4, r3
 8007222:	bfa2      	ittt	ge
 8007224:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8007228:	4329      	orrge	r1, r5
 800722a:	bd30      	popge	{r4, r5, pc}
 800722c:	ea6f 0404 	mvn.w	r4, r4
 8007230:	3c1f      	subs	r4, #31
 8007232:	da1c      	bge.n	800726e <__adddf3+0x1d2>
 8007234:	340c      	adds	r4, #12
 8007236:	dc0e      	bgt.n	8007256 <__adddf3+0x1ba>
 8007238:	f104 0414 	add.w	r4, r4, #20
 800723c:	f1c4 0220 	rsb	r2, r4, #32
 8007240:	fa20 f004 	lsr.w	r0, r0, r4
 8007244:	fa01 f302 	lsl.w	r3, r1, r2
 8007248:	ea40 0003 	orr.w	r0, r0, r3
 800724c:	fa21 f304 	lsr.w	r3, r1, r4
 8007250:	ea45 0103 	orr.w	r1, r5, r3
 8007254:	bd30      	pop	{r4, r5, pc}
 8007256:	f1c4 040c 	rsb	r4, r4, #12
 800725a:	f1c4 0220 	rsb	r2, r4, #32
 800725e:	fa20 f002 	lsr.w	r0, r0, r2
 8007262:	fa01 f304 	lsl.w	r3, r1, r4
 8007266:	ea40 0003 	orr.w	r0, r0, r3
 800726a:	4629      	mov	r1, r5
 800726c:	bd30      	pop	{r4, r5, pc}
 800726e:	fa21 f004 	lsr.w	r0, r1, r4
 8007272:	4629      	mov	r1, r5
 8007274:	bd30      	pop	{r4, r5, pc}
 8007276:	f094 0f00 	teq	r4, #0
 800727a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800727e:	bf06      	itte	eq
 8007280:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8007284:	3401      	addeq	r4, #1
 8007286:	3d01      	subne	r5, #1
 8007288:	e74e      	b.n	8007128 <__adddf3+0x8c>
 800728a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800728e:	bf18      	it	ne
 8007290:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8007294:	d029      	beq.n	80072ea <__adddf3+0x24e>
 8007296:	ea94 0f05 	teq	r4, r5
 800729a:	bf08      	it	eq
 800729c:	ea90 0f02 	teqeq	r0, r2
 80072a0:	d005      	beq.n	80072ae <__adddf3+0x212>
 80072a2:	ea54 0c00 	orrs.w	ip, r4, r0
 80072a6:	bf04      	itt	eq
 80072a8:	4619      	moveq	r1, r3
 80072aa:	4610      	moveq	r0, r2
 80072ac:	bd30      	pop	{r4, r5, pc}
 80072ae:	ea91 0f03 	teq	r1, r3
 80072b2:	bf1e      	ittt	ne
 80072b4:	2100      	movne	r1, #0
 80072b6:	2000      	movne	r0, #0
 80072b8:	bd30      	popne	{r4, r5, pc}
 80072ba:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80072be:	d105      	bne.n	80072cc <__adddf3+0x230>
 80072c0:	0040      	lsls	r0, r0, #1
 80072c2:	4149      	adcs	r1, r1
 80072c4:	bf28      	it	cs
 80072c6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80072ca:	bd30      	pop	{r4, r5, pc}
 80072cc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80072d0:	bf3c      	itt	cc
 80072d2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80072d6:	bd30      	popcc	{r4, r5, pc}
 80072d8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80072dc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80072e0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80072e4:	f04f 0000 	mov.w	r0, #0
 80072e8:	bd30      	pop	{r4, r5, pc}
 80072ea:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80072ee:	bf1a      	itte	ne
 80072f0:	4619      	movne	r1, r3
 80072f2:	4610      	movne	r0, r2
 80072f4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80072f8:	bf1c      	itt	ne
 80072fa:	460b      	movne	r3, r1
 80072fc:	4602      	movne	r2, r0
 80072fe:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8007302:	bf06      	itte	eq
 8007304:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8007308:	ea91 0f03 	teqeq	r1, r3
 800730c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8007310:	bd30      	pop	{r4, r5, pc}
 8007312:	bf00      	nop

08007314 <__aeabi_ui2d>:
 8007314:	f090 0f00 	teq	r0, #0
 8007318:	bf04      	itt	eq
 800731a:	2100      	moveq	r1, #0
 800731c:	4770      	bxeq	lr
 800731e:	b530      	push	{r4, r5, lr}
 8007320:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8007324:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8007328:	f04f 0500 	mov.w	r5, #0
 800732c:	f04f 0100 	mov.w	r1, #0
 8007330:	e750      	b.n	80071d4 <__adddf3+0x138>
 8007332:	bf00      	nop

08007334 <__aeabi_i2d>:
 8007334:	f090 0f00 	teq	r0, #0
 8007338:	bf04      	itt	eq
 800733a:	2100      	moveq	r1, #0
 800733c:	4770      	bxeq	lr
 800733e:	b530      	push	{r4, r5, lr}
 8007340:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8007344:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8007348:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800734c:	bf48      	it	mi
 800734e:	4240      	negmi	r0, r0
 8007350:	f04f 0100 	mov.w	r1, #0
 8007354:	e73e      	b.n	80071d4 <__adddf3+0x138>
 8007356:	bf00      	nop

08007358 <__aeabi_f2d>:
 8007358:	0042      	lsls	r2, r0, #1
 800735a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800735e:	ea4f 0131 	mov.w	r1, r1, rrx
 8007362:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8007366:	bf1f      	itttt	ne
 8007368:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800736c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8007370:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8007374:	4770      	bxne	lr
 8007376:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 800737a:	bf08      	it	eq
 800737c:	4770      	bxeq	lr
 800737e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8007382:	bf04      	itt	eq
 8007384:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8007388:	4770      	bxeq	lr
 800738a:	b530      	push	{r4, r5, lr}
 800738c:	f44f 7460 	mov.w	r4, #896	; 0x380
 8007390:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8007394:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8007398:	e71c      	b.n	80071d4 <__adddf3+0x138>
 800739a:	bf00      	nop

0800739c <__aeabi_ul2d>:
 800739c:	ea50 0201 	orrs.w	r2, r0, r1
 80073a0:	bf08      	it	eq
 80073a2:	4770      	bxeq	lr
 80073a4:	b530      	push	{r4, r5, lr}
 80073a6:	f04f 0500 	mov.w	r5, #0
 80073aa:	e00a      	b.n	80073c2 <__aeabi_l2d+0x16>

080073ac <__aeabi_l2d>:
 80073ac:	ea50 0201 	orrs.w	r2, r0, r1
 80073b0:	bf08      	it	eq
 80073b2:	4770      	bxeq	lr
 80073b4:	b530      	push	{r4, r5, lr}
 80073b6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80073ba:	d502      	bpl.n	80073c2 <__aeabi_l2d+0x16>
 80073bc:	4240      	negs	r0, r0
 80073be:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80073c2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80073c6:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80073ca:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80073ce:	f43f aed8 	beq.w	8007182 <__adddf3+0xe6>
 80073d2:	f04f 0203 	mov.w	r2, #3
 80073d6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80073da:	bf18      	it	ne
 80073dc:	3203      	addne	r2, #3
 80073de:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80073e2:	bf18      	it	ne
 80073e4:	3203      	addne	r2, #3
 80073e6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80073ea:	f1c2 0320 	rsb	r3, r2, #32
 80073ee:	fa00 fc03 	lsl.w	ip, r0, r3
 80073f2:	fa20 f002 	lsr.w	r0, r0, r2
 80073f6:	fa01 fe03 	lsl.w	lr, r1, r3
 80073fa:	ea40 000e 	orr.w	r0, r0, lr
 80073fe:	fa21 f102 	lsr.w	r1, r1, r2
 8007402:	4414      	add	r4, r2
 8007404:	e6bd      	b.n	8007182 <__adddf3+0xe6>
 8007406:	bf00      	nop

08007408 <__aeabi_dmul>:
 8007408:	b570      	push	{r4, r5, r6, lr}
 800740a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800740e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8007412:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8007416:	bf1d      	ittte	ne
 8007418:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800741c:	ea94 0f0c 	teqne	r4, ip
 8007420:	ea95 0f0c 	teqne	r5, ip
 8007424:	f000 f8de 	bleq	80075e4 <__aeabi_dmul+0x1dc>
 8007428:	442c      	add	r4, r5
 800742a:	ea81 0603 	eor.w	r6, r1, r3
 800742e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8007432:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8007436:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800743a:	bf18      	it	ne
 800743c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8007440:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8007444:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8007448:	d038      	beq.n	80074bc <__aeabi_dmul+0xb4>
 800744a:	fba0 ce02 	umull	ip, lr, r0, r2
 800744e:	f04f 0500 	mov.w	r5, #0
 8007452:	fbe1 e502 	umlal	lr, r5, r1, r2
 8007456:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800745a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800745e:	f04f 0600 	mov.w	r6, #0
 8007462:	fbe1 5603 	umlal	r5, r6, r1, r3
 8007466:	f09c 0f00 	teq	ip, #0
 800746a:	bf18      	it	ne
 800746c:	f04e 0e01 	orrne.w	lr, lr, #1
 8007470:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8007474:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8007478:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800747c:	d204      	bcs.n	8007488 <__aeabi_dmul+0x80>
 800747e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8007482:	416d      	adcs	r5, r5
 8007484:	eb46 0606 	adc.w	r6, r6, r6
 8007488:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800748c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8007490:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8007494:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8007498:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800749c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80074a0:	bf88      	it	hi
 80074a2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80074a6:	d81e      	bhi.n	80074e6 <__aeabi_dmul+0xde>
 80074a8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80074ac:	bf08      	it	eq
 80074ae:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80074b2:	f150 0000 	adcs.w	r0, r0, #0
 80074b6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80074ba:	bd70      	pop	{r4, r5, r6, pc}
 80074bc:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80074c0:	ea46 0101 	orr.w	r1, r6, r1
 80074c4:	ea40 0002 	orr.w	r0, r0, r2
 80074c8:	ea81 0103 	eor.w	r1, r1, r3
 80074cc:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80074d0:	bfc2      	ittt	gt
 80074d2:	ebd4 050c 	rsbsgt	r5, r4, ip
 80074d6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80074da:	bd70      	popgt	{r4, r5, r6, pc}
 80074dc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80074e0:	f04f 0e00 	mov.w	lr, #0
 80074e4:	3c01      	subs	r4, #1
 80074e6:	f300 80ab 	bgt.w	8007640 <__aeabi_dmul+0x238>
 80074ea:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80074ee:	bfde      	ittt	le
 80074f0:	2000      	movle	r0, #0
 80074f2:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80074f6:	bd70      	pople	{r4, r5, r6, pc}
 80074f8:	f1c4 0400 	rsb	r4, r4, #0
 80074fc:	3c20      	subs	r4, #32
 80074fe:	da35      	bge.n	800756c <__aeabi_dmul+0x164>
 8007500:	340c      	adds	r4, #12
 8007502:	dc1b      	bgt.n	800753c <__aeabi_dmul+0x134>
 8007504:	f104 0414 	add.w	r4, r4, #20
 8007508:	f1c4 0520 	rsb	r5, r4, #32
 800750c:	fa00 f305 	lsl.w	r3, r0, r5
 8007510:	fa20 f004 	lsr.w	r0, r0, r4
 8007514:	fa01 f205 	lsl.w	r2, r1, r5
 8007518:	ea40 0002 	orr.w	r0, r0, r2
 800751c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8007520:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8007524:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8007528:	fa21 f604 	lsr.w	r6, r1, r4
 800752c:	eb42 0106 	adc.w	r1, r2, r6
 8007530:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8007534:	bf08      	it	eq
 8007536:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800753a:	bd70      	pop	{r4, r5, r6, pc}
 800753c:	f1c4 040c 	rsb	r4, r4, #12
 8007540:	f1c4 0520 	rsb	r5, r4, #32
 8007544:	fa00 f304 	lsl.w	r3, r0, r4
 8007548:	fa20 f005 	lsr.w	r0, r0, r5
 800754c:	fa01 f204 	lsl.w	r2, r1, r4
 8007550:	ea40 0002 	orr.w	r0, r0, r2
 8007554:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8007558:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800755c:	f141 0100 	adc.w	r1, r1, #0
 8007560:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8007564:	bf08      	it	eq
 8007566:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800756a:	bd70      	pop	{r4, r5, r6, pc}
 800756c:	f1c4 0520 	rsb	r5, r4, #32
 8007570:	fa00 f205 	lsl.w	r2, r0, r5
 8007574:	ea4e 0e02 	orr.w	lr, lr, r2
 8007578:	fa20 f304 	lsr.w	r3, r0, r4
 800757c:	fa01 f205 	lsl.w	r2, r1, r5
 8007580:	ea43 0302 	orr.w	r3, r3, r2
 8007584:	fa21 f004 	lsr.w	r0, r1, r4
 8007588:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800758c:	fa21 f204 	lsr.w	r2, r1, r4
 8007590:	ea20 0002 	bic.w	r0, r0, r2
 8007594:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8007598:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800759c:	bf08      	it	eq
 800759e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80075a2:	bd70      	pop	{r4, r5, r6, pc}
 80075a4:	f094 0f00 	teq	r4, #0
 80075a8:	d10f      	bne.n	80075ca <__aeabi_dmul+0x1c2>
 80075aa:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80075ae:	0040      	lsls	r0, r0, #1
 80075b0:	eb41 0101 	adc.w	r1, r1, r1
 80075b4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80075b8:	bf08      	it	eq
 80075ba:	3c01      	subeq	r4, #1
 80075bc:	d0f7      	beq.n	80075ae <__aeabi_dmul+0x1a6>
 80075be:	ea41 0106 	orr.w	r1, r1, r6
 80075c2:	f095 0f00 	teq	r5, #0
 80075c6:	bf18      	it	ne
 80075c8:	4770      	bxne	lr
 80075ca:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80075ce:	0052      	lsls	r2, r2, #1
 80075d0:	eb43 0303 	adc.w	r3, r3, r3
 80075d4:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80075d8:	bf08      	it	eq
 80075da:	3d01      	subeq	r5, #1
 80075dc:	d0f7      	beq.n	80075ce <__aeabi_dmul+0x1c6>
 80075de:	ea43 0306 	orr.w	r3, r3, r6
 80075e2:	4770      	bx	lr
 80075e4:	ea94 0f0c 	teq	r4, ip
 80075e8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80075ec:	bf18      	it	ne
 80075ee:	ea95 0f0c 	teqne	r5, ip
 80075f2:	d00c      	beq.n	800760e <__aeabi_dmul+0x206>
 80075f4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80075f8:	bf18      	it	ne
 80075fa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80075fe:	d1d1      	bne.n	80075a4 <__aeabi_dmul+0x19c>
 8007600:	ea81 0103 	eor.w	r1, r1, r3
 8007604:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8007608:	f04f 0000 	mov.w	r0, #0
 800760c:	bd70      	pop	{r4, r5, r6, pc}
 800760e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8007612:	bf06      	itte	eq
 8007614:	4610      	moveq	r0, r2
 8007616:	4619      	moveq	r1, r3
 8007618:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800761c:	d019      	beq.n	8007652 <__aeabi_dmul+0x24a>
 800761e:	ea94 0f0c 	teq	r4, ip
 8007622:	d102      	bne.n	800762a <__aeabi_dmul+0x222>
 8007624:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8007628:	d113      	bne.n	8007652 <__aeabi_dmul+0x24a>
 800762a:	ea95 0f0c 	teq	r5, ip
 800762e:	d105      	bne.n	800763c <__aeabi_dmul+0x234>
 8007630:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8007634:	bf1c      	itt	ne
 8007636:	4610      	movne	r0, r2
 8007638:	4619      	movne	r1, r3
 800763a:	d10a      	bne.n	8007652 <__aeabi_dmul+0x24a>
 800763c:	ea81 0103 	eor.w	r1, r1, r3
 8007640:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8007644:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8007648:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800764c:	f04f 0000 	mov.w	r0, #0
 8007650:	bd70      	pop	{r4, r5, r6, pc}
 8007652:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8007656:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800765a:	bd70      	pop	{r4, r5, r6, pc}

0800765c <__aeabi_ddiv>:
 800765c:	b570      	push	{r4, r5, r6, lr}
 800765e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8007662:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8007666:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800766a:	bf1d      	ittte	ne
 800766c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8007670:	ea94 0f0c 	teqne	r4, ip
 8007674:	ea95 0f0c 	teqne	r5, ip
 8007678:	f000 f8a7 	bleq	80077ca <__aeabi_ddiv+0x16e>
 800767c:	eba4 0405 	sub.w	r4, r4, r5
 8007680:	ea81 0e03 	eor.w	lr, r1, r3
 8007684:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8007688:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800768c:	f000 8088 	beq.w	80077a0 <__aeabi_ddiv+0x144>
 8007690:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8007694:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8007698:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800769c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80076a0:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80076a4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80076a8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80076ac:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80076b0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80076b4:	429d      	cmp	r5, r3
 80076b6:	bf08      	it	eq
 80076b8:	4296      	cmpeq	r6, r2
 80076ba:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80076be:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80076c2:	d202      	bcs.n	80076ca <__aeabi_ddiv+0x6e>
 80076c4:	085b      	lsrs	r3, r3, #1
 80076c6:	ea4f 0232 	mov.w	r2, r2, rrx
 80076ca:	1ab6      	subs	r6, r6, r2
 80076cc:	eb65 0503 	sbc.w	r5, r5, r3
 80076d0:	085b      	lsrs	r3, r3, #1
 80076d2:	ea4f 0232 	mov.w	r2, r2, rrx
 80076d6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80076da:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80076de:	ebb6 0e02 	subs.w	lr, r6, r2
 80076e2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80076e6:	bf22      	ittt	cs
 80076e8:	1ab6      	subcs	r6, r6, r2
 80076ea:	4675      	movcs	r5, lr
 80076ec:	ea40 000c 	orrcs.w	r0, r0, ip
 80076f0:	085b      	lsrs	r3, r3, #1
 80076f2:	ea4f 0232 	mov.w	r2, r2, rrx
 80076f6:	ebb6 0e02 	subs.w	lr, r6, r2
 80076fa:	eb75 0e03 	sbcs.w	lr, r5, r3
 80076fe:	bf22      	ittt	cs
 8007700:	1ab6      	subcs	r6, r6, r2
 8007702:	4675      	movcs	r5, lr
 8007704:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8007708:	085b      	lsrs	r3, r3, #1
 800770a:	ea4f 0232 	mov.w	r2, r2, rrx
 800770e:	ebb6 0e02 	subs.w	lr, r6, r2
 8007712:	eb75 0e03 	sbcs.w	lr, r5, r3
 8007716:	bf22      	ittt	cs
 8007718:	1ab6      	subcs	r6, r6, r2
 800771a:	4675      	movcs	r5, lr
 800771c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8007720:	085b      	lsrs	r3, r3, #1
 8007722:	ea4f 0232 	mov.w	r2, r2, rrx
 8007726:	ebb6 0e02 	subs.w	lr, r6, r2
 800772a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800772e:	bf22      	ittt	cs
 8007730:	1ab6      	subcs	r6, r6, r2
 8007732:	4675      	movcs	r5, lr
 8007734:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8007738:	ea55 0e06 	orrs.w	lr, r5, r6
 800773c:	d018      	beq.n	8007770 <__aeabi_ddiv+0x114>
 800773e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8007742:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8007746:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800774a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800774e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8007752:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8007756:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800775a:	d1c0      	bne.n	80076de <__aeabi_ddiv+0x82>
 800775c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8007760:	d10b      	bne.n	800777a <__aeabi_ddiv+0x11e>
 8007762:	ea41 0100 	orr.w	r1, r1, r0
 8007766:	f04f 0000 	mov.w	r0, #0
 800776a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800776e:	e7b6      	b.n	80076de <__aeabi_ddiv+0x82>
 8007770:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8007774:	bf04      	itt	eq
 8007776:	4301      	orreq	r1, r0
 8007778:	2000      	moveq	r0, #0
 800777a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800777e:	bf88      	it	hi
 8007780:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8007784:	f63f aeaf 	bhi.w	80074e6 <__aeabi_dmul+0xde>
 8007788:	ebb5 0c03 	subs.w	ip, r5, r3
 800778c:	bf04      	itt	eq
 800778e:	ebb6 0c02 	subseq.w	ip, r6, r2
 8007792:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8007796:	f150 0000 	adcs.w	r0, r0, #0
 800779a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800779e:	bd70      	pop	{r4, r5, r6, pc}
 80077a0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80077a4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80077a8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80077ac:	bfc2      	ittt	gt
 80077ae:	ebd4 050c 	rsbsgt	r5, r4, ip
 80077b2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80077b6:	bd70      	popgt	{r4, r5, r6, pc}
 80077b8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80077bc:	f04f 0e00 	mov.w	lr, #0
 80077c0:	3c01      	subs	r4, #1
 80077c2:	e690      	b.n	80074e6 <__aeabi_dmul+0xde>
 80077c4:	ea45 0e06 	orr.w	lr, r5, r6
 80077c8:	e68d      	b.n	80074e6 <__aeabi_dmul+0xde>
 80077ca:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80077ce:	ea94 0f0c 	teq	r4, ip
 80077d2:	bf08      	it	eq
 80077d4:	ea95 0f0c 	teqeq	r5, ip
 80077d8:	f43f af3b 	beq.w	8007652 <__aeabi_dmul+0x24a>
 80077dc:	ea94 0f0c 	teq	r4, ip
 80077e0:	d10a      	bne.n	80077f8 <__aeabi_ddiv+0x19c>
 80077e2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80077e6:	f47f af34 	bne.w	8007652 <__aeabi_dmul+0x24a>
 80077ea:	ea95 0f0c 	teq	r5, ip
 80077ee:	f47f af25 	bne.w	800763c <__aeabi_dmul+0x234>
 80077f2:	4610      	mov	r0, r2
 80077f4:	4619      	mov	r1, r3
 80077f6:	e72c      	b.n	8007652 <__aeabi_dmul+0x24a>
 80077f8:	ea95 0f0c 	teq	r5, ip
 80077fc:	d106      	bne.n	800780c <__aeabi_ddiv+0x1b0>
 80077fe:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8007802:	f43f aefd 	beq.w	8007600 <__aeabi_dmul+0x1f8>
 8007806:	4610      	mov	r0, r2
 8007808:	4619      	mov	r1, r3
 800780a:	e722      	b.n	8007652 <__aeabi_dmul+0x24a>
 800780c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8007810:	bf18      	it	ne
 8007812:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8007816:	f47f aec5 	bne.w	80075a4 <__aeabi_dmul+0x19c>
 800781a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800781e:	f47f af0d 	bne.w	800763c <__aeabi_dmul+0x234>
 8007822:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8007826:	f47f aeeb 	bne.w	8007600 <__aeabi_dmul+0x1f8>
 800782a:	e712      	b.n	8007652 <__aeabi_dmul+0x24a>

0800782c <__gedf2>:
 800782c:	f04f 3cff 	mov.w	ip, #4294967295
 8007830:	e006      	b.n	8007840 <__cmpdf2+0x4>
 8007832:	bf00      	nop

08007834 <__ledf2>:
 8007834:	f04f 0c01 	mov.w	ip, #1
 8007838:	e002      	b.n	8007840 <__cmpdf2+0x4>
 800783a:	bf00      	nop

0800783c <__cmpdf2>:
 800783c:	f04f 0c01 	mov.w	ip, #1
 8007840:	f84d cd04 	str.w	ip, [sp, #-4]!
 8007844:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8007848:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800784c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8007850:	bf18      	it	ne
 8007852:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8007856:	d01b      	beq.n	8007890 <__cmpdf2+0x54>
 8007858:	b001      	add	sp, #4
 800785a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 800785e:	bf0c      	ite	eq
 8007860:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8007864:	ea91 0f03 	teqne	r1, r3
 8007868:	bf02      	ittt	eq
 800786a:	ea90 0f02 	teqeq	r0, r2
 800786e:	2000      	moveq	r0, #0
 8007870:	4770      	bxeq	lr
 8007872:	f110 0f00 	cmn.w	r0, #0
 8007876:	ea91 0f03 	teq	r1, r3
 800787a:	bf58      	it	pl
 800787c:	4299      	cmppl	r1, r3
 800787e:	bf08      	it	eq
 8007880:	4290      	cmpeq	r0, r2
 8007882:	bf2c      	ite	cs
 8007884:	17d8      	asrcs	r0, r3, #31
 8007886:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800788a:	f040 0001 	orr.w	r0, r0, #1
 800788e:	4770      	bx	lr
 8007890:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8007894:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8007898:	d102      	bne.n	80078a0 <__cmpdf2+0x64>
 800789a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800789e:	d107      	bne.n	80078b0 <__cmpdf2+0x74>
 80078a0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80078a4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80078a8:	d1d6      	bne.n	8007858 <__cmpdf2+0x1c>
 80078aa:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80078ae:	d0d3      	beq.n	8007858 <__cmpdf2+0x1c>
 80078b0:	f85d 0b04 	ldr.w	r0, [sp], #4
 80078b4:	4770      	bx	lr
 80078b6:	bf00      	nop

080078b8 <__aeabi_cdrcmple>:
 80078b8:	4684      	mov	ip, r0
 80078ba:	4610      	mov	r0, r2
 80078bc:	4662      	mov	r2, ip
 80078be:	468c      	mov	ip, r1
 80078c0:	4619      	mov	r1, r3
 80078c2:	4663      	mov	r3, ip
 80078c4:	e000      	b.n	80078c8 <__aeabi_cdcmpeq>
 80078c6:	bf00      	nop

080078c8 <__aeabi_cdcmpeq>:
 80078c8:	b501      	push	{r0, lr}
 80078ca:	f7ff ffb7 	bl	800783c <__cmpdf2>
 80078ce:	2800      	cmp	r0, #0
 80078d0:	bf48      	it	mi
 80078d2:	f110 0f00 	cmnmi.w	r0, #0
 80078d6:	bd01      	pop	{r0, pc}

080078d8 <__aeabi_dcmpeq>:
 80078d8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80078dc:	f7ff fff4 	bl	80078c8 <__aeabi_cdcmpeq>
 80078e0:	bf0c      	ite	eq
 80078e2:	2001      	moveq	r0, #1
 80078e4:	2000      	movne	r0, #0
 80078e6:	f85d fb08 	ldr.w	pc, [sp], #8
 80078ea:	bf00      	nop

080078ec <__aeabi_dcmplt>:
 80078ec:	f84d ed08 	str.w	lr, [sp, #-8]!
 80078f0:	f7ff ffea 	bl	80078c8 <__aeabi_cdcmpeq>
 80078f4:	bf34      	ite	cc
 80078f6:	2001      	movcc	r0, #1
 80078f8:	2000      	movcs	r0, #0
 80078fa:	f85d fb08 	ldr.w	pc, [sp], #8
 80078fe:	bf00      	nop

08007900 <__aeabi_dcmple>:
 8007900:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007904:	f7ff ffe0 	bl	80078c8 <__aeabi_cdcmpeq>
 8007908:	bf94      	ite	ls
 800790a:	2001      	movls	r0, #1
 800790c:	2000      	movhi	r0, #0
 800790e:	f85d fb08 	ldr.w	pc, [sp], #8
 8007912:	bf00      	nop

08007914 <__aeabi_dcmpge>:
 8007914:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007918:	f7ff ffce 	bl	80078b8 <__aeabi_cdrcmple>
 800791c:	bf94      	ite	ls
 800791e:	2001      	movls	r0, #1
 8007920:	2000      	movhi	r0, #0
 8007922:	f85d fb08 	ldr.w	pc, [sp], #8
 8007926:	bf00      	nop

08007928 <__aeabi_dcmpgt>:
 8007928:	f84d ed08 	str.w	lr, [sp, #-8]!
 800792c:	f7ff ffc4 	bl	80078b8 <__aeabi_cdrcmple>
 8007930:	bf34      	ite	cc
 8007932:	2001      	movcc	r0, #1
 8007934:	2000      	movcs	r0, #0
 8007936:	f85d fb08 	ldr.w	pc, [sp], #8
 800793a:	bf00      	nop

0800793c <__aeabi_dcmpun>:
 800793c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8007940:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8007944:	d102      	bne.n	800794c <__aeabi_dcmpun+0x10>
 8007946:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800794a:	d10a      	bne.n	8007962 <__aeabi_dcmpun+0x26>
 800794c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8007950:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8007954:	d102      	bne.n	800795c <__aeabi_dcmpun+0x20>
 8007956:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800795a:	d102      	bne.n	8007962 <__aeabi_dcmpun+0x26>
 800795c:	f04f 0000 	mov.w	r0, #0
 8007960:	4770      	bx	lr
 8007962:	f04f 0001 	mov.w	r0, #1
 8007966:	4770      	bx	lr

08007968 <__aeabi_d2iz>:
 8007968:	ea4f 0241 	mov.w	r2, r1, lsl #1
 800796c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8007970:	d215      	bcs.n	800799e <__aeabi_d2iz+0x36>
 8007972:	d511      	bpl.n	8007998 <__aeabi_d2iz+0x30>
 8007974:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8007978:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800797c:	d912      	bls.n	80079a4 <__aeabi_d2iz+0x3c>
 800797e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8007982:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8007986:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800798a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800798e:	fa23 f002 	lsr.w	r0, r3, r2
 8007992:	bf18      	it	ne
 8007994:	4240      	negne	r0, r0
 8007996:	4770      	bx	lr
 8007998:	f04f 0000 	mov.w	r0, #0
 800799c:	4770      	bx	lr
 800799e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80079a2:	d105      	bne.n	80079b0 <__aeabi_d2iz+0x48>
 80079a4:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 80079a8:	bf08      	it	eq
 80079aa:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80079ae:	4770      	bx	lr
 80079b0:	f04f 0000 	mov.w	r0, #0
 80079b4:	4770      	bx	lr
 80079b6:	bf00      	nop

080079b8 <__aeabi_d2f>:
 80079b8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80079bc:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80079c0:	bf24      	itt	cs
 80079c2:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80079c6:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80079ca:	d90d      	bls.n	80079e8 <__aeabi_d2f+0x30>
 80079cc:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80079d0:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80079d4:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80079d8:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 80079dc:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 80079e0:	bf08      	it	eq
 80079e2:	f020 0001 	biceq.w	r0, r0, #1
 80079e6:	4770      	bx	lr
 80079e8:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 80079ec:	d121      	bne.n	8007a32 <__aeabi_d2f+0x7a>
 80079ee:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 80079f2:	bfbc      	itt	lt
 80079f4:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 80079f8:	4770      	bxlt	lr
 80079fa:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80079fe:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8007a02:	f1c2 0218 	rsb	r2, r2, #24
 8007a06:	f1c2 0c20 	rsb	ip, r2, #32
 8007a0a:	fa10 f30c 	lsls.w	r3, r0, ip
 8007a0e:	fa20 f002 	lsr.w	r0, r0, r2
 8007a12:	bf18      	it	ne
 8007a14:	f040 0001 	orrne.w	r0, r0, #1
 8007a18:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8007a1c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8007a20:	fa03 fc0c 	lsl.w	ip, r3, ip
 8007a24:	ea40 000c 	orr.w	r0, r0, ip
 8007a28:	fa23 f302 	lsr.w	r3, r3, r2
 8007a2c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8007a30:	e7cc      	b.n	80079cc <__aeabi_d2f+0x14>
 8007a32:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8007a36:	d107      	bne.n	8007a48 <__aeabi_d2f+0x90>
 8007a38:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8007a3c:	bf1e      	ittt	ne
 8007a3e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8007a42:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8007a46:	4770      	bxne	lr
 8007a48:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8007a4c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8007a50:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8007a54:	4770      	bx	lr
 8007a56:	bf00      	nop

08007a58 <__aeabi_ldivmod>:
 8007a58:	b97b      	cbnz	r3, 8007a7a <__aeabi_ldivmod+0x22>
 8007a5a:	b972      	cbnz	r2, 8007a7a <__aeabi_ldivmod+0x22>
 8007a5c:	2900      	cmp	r1, #0
 8007a5e:	bfbe      	ittt	lt
 8007a60:	2000      	movlt	r0, #0
 8007a62:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 8007a66:	e006      	blt.n	8007a76 <__aeabi_ldivmod+0x1e>
 8007a68:	bf08      	it	eq
 8007a6a:	2800      	cmpeq	r0, #0
 8007a6c:	bf1c      	itt	ne
 8007a6e:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
 8007a72:	f04f 30ff 	movne.w	r0, #4294967295
 8007a76:	f000 b9a5 	b.w	8007dc4 <__aeabi_idiv0>
 8007a7a:	f1ad 0c08 	sub.w	ip, sp, #8
 8007a7e:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8007a82:	2900      	cmp	r1, #0
 8007a84:	db09      	blt.n	8007a9a <__aeabi_ldivmod+0x42>
 8007a86:	2b00      	cmp	r3, #0
 8007a88:	db1a      	blt.n	8007ac0 <__aeabi_ldivmod+0x68>
 8007a8a:	f000 f835 	bl	8007af8 <__udivmoddi4>
 8007a8e:	f8dd e004 	ldr.w	lr, [sp, #4]
 8007a92:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8007a96:	b004      	add	sp, #16
 8007a98:	4770      	bx	lr
 8007a9a:	4240      	negs	r0, r0
 8007a9c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8007aa0:	2b00      	cmp	r3, #0
 8007aa2:	db1b      	blt.n	8007adc <__aeabi_ldivmod+0x84>
 8007aa4:	f000 f828 	bl	8007af8 <__udivmoddi4>
 8007aa8:	f8dd e004 	ldr.w	lr, [sp, #4]
 8007aac:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8007ab0:	b004      	add	sp, #16
 8007ab2:	4240      	negs	r0, r0
 8007ab4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8007ab8:	4252      	negs	r2, r2
 8007aba:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8007abe:	4770      	bx	lr
 8007ac0:	4252      	negs	r2, r2
 8007ac2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8007ac6:	f000 f817 	bl	8007af8 <__udivmoddi4>
 8007aca:	f8dd e004 	ldr.w	lr, [sp, #4]
 8007ace:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8007ad2:	b004      	add	sp, #16
 8007ad4:	4240      	negs	r0, r0
 8007ad6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8007ada:	4770      	bx	lr
 8007adc:	4252      	negs	r2, r2
 8007ade:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8007ae2:	f000 f809 	bl	8007af8 <__udivmoddi4>
 8007ae6:	f8dd e004 	ldr.w	lr, [sp, #4]
 8007aea:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8007aee:	b004      	add	sp, #16
 8007af0:	4252      	negs	r2, r2
 8007af2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8007af6:	4770      	bx	lr

08007af8 <__udivmoddi4>:
 8007af8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007afc:	9e08      	ldr	r6, [sp, #32]
 8007afe:	4604      	mov	r4, r0
 8007b00:	4688      	mov	r8, r1
 8007b02:	2b00      	cmp	r3, #0
 8007b04:	d14b      	bne.n	8007b9e <__udivmoddi4+0xa6>
 8007b06:	428a      	cmp	r2, r1
 8007b08:	4615      	mov	r5, r2
 8007b0a:	d967      	bls.n	8007bdc <__udivmoddi4+0xe4>
 8007b0c:	fab2 f282 	clz	r2, r2
 8007b10:	b14a      	cbz	r2, 8007b26 <__udivmoddi4+0x2e>
 8007b12:	f1c2 0720 	rsb	r7, r2, #32
 8007b16:	fa01 f302 	lsl.w	r3, r1, r2
 8007b1a:	fa20 f707 	lsr.w	r7, r0, r7
 8007b1e:	4095      	lsls	r5, r2
 8007b20:	ea47 0803 	orr.w	r8, r7, r3
 8007b24:	4094      	lsls	r4, r2
 8007b26:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8007b2a:	0c23      	lsrs	r3, r4, #16
 8007b2c:	fbb8 f7fe 	udiv	r7, r8, lr
 8007b30:	fa1f fc85 	uxth.w	ip, r5
 8007b34:	fb0e 8817 	mls	r8, lr, r7, r8
 8007b38:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8007b3c:	fb07 f10c 	mul.w	r1, r7, ip
 8007b40:	4299      	cmp	r1, r3
 8007b42:	d909      	bls.n	8007b58 <__udivmoddi4+0x60>
 8007b44:	18eb      	adds	r3, r5, r3
 8007b46:	f107 30ff 	add.w	r0, r7, #4294967295
 8007b4a:	f080 811b 	bcs.w	8007d84 <__udivmoddi4+0x28c>
 8007b4e:	4299      	cmp	r1, r3
 8007b50:	f240 8118 	bls.w	8007d84 <__udivmoddi4+0x28c>
 8007b54:	3f02      	subs	r7, #2
 8007b56:	442b      	add	r3, r5
 8007b58:	1a5b      	subs	r3, r3, r1
 8007b5a:	b2a4      	uxth	r4, r4
 8007b5c:	fbb3 f0fe 	udiv	r0, r3, lr
 8007b60:	fb0e 3310 	mls	r3, lr, r0, r3
 8007b64:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8007b68:	fb00 fc0c 	mul.w	ip, r0, ip
 8007b6c:	45a4      	cmp	ip, r4
 8007b6e:	d909      	bls.n	8007b84 <__udivmoddi4+0x8c>
 8007b70:	192c      	adds	r4, r5, r4
 8007b72:	f100 33ff 	add.w	r3, r0, #4294967295
 8007b76:	f080 8107 	bcs.w	8007d88 <__udivmoddi4+0x290>
 8007b7a:	45a4      	cmp	ip, r4
 8007b7c:	f240 8104 	bls.w	8007d88 <__udivmoddi4+0x290>
 8007b80:	3802      	subs	r0, #2
 8007b82:	442c      	add	r4, r5
 8007b84:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8007b88:	eba4 040c 	sub.w	r4, r4, ip
 8007b8c:	2700      	movs	r7, #0
 8007b8e:	b11e      	cbz	r6, 8007b98 <__udivmoddi4+0xa0>
 8007b90:	40d4      	lsrs	r4, r2
 8007b92:	2300      	movs	r3, #0
 8007b94:	e9c6 4300 	strd	r4, r3, [r6]
 8007b98:	4639      	mov	r1, r7
 8007b9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007b9e:	428b      	cmp	r3, r1
 8007ba0:	d909      	bls.n	8007bb6 <__udivmoddi4+0xbe>
 8007ba2:	2e00      	cmp	r6, #0
 8007ba4:	f000 80eb 	beq.w	8007d7e <__udivmoddi4+0x286>
 8007ba8:	2700      	movs	r7, #0
 8007baa:	e9c6 0100 	strd	r0, r1, [r6]
 8007bae:	4638      	mov	r0, r7
 8007bb0:	4639      	mov	r1, r7
 8007bb2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007bb6:	fab3 f783 	clz	r7, r3
 8007bba:	2f00      	cmp	r7, #0
 8007bbc:	d147      	bne.n	8007c4e <__udivmoddi4+0x156>
 8007bbe:	428b      	cmp	r3, r1
 8007bc0:	d302      	bcc.n	8007bc8 <__udivmoddi4+0xd0>
 8007bc2:	4282      	cmp	r2, r0
 8007bc4:	f200 80fa 	bhi.w	8007dbc <__udivmoddi4+0x2c4>
 8007bc8:	1a84      	subs	r4, r0, r2
 8007bca:	eb61 0303 	sbc.w	r3, r1, r3
 8007bce:	2001      	movs	r0, #1
 8007bd0:	4698      	mov	r8, r3
 8007bd2:	2e00      	cmp	r6, #0
 8007bd4:	d0e0      	beq.n	8007b98 <__udivmoddi4+0xa0>
 8007bd6:	e9c6 4800 	strd	r4, r8, [r6]
 8007bda:	e7dd      	b.n	8007b98 <__udivmoddi4+0xa0>
 8007bdc:	b902      	cbnz	r2, 8007be0 <__udivmoddi4+0xe8>
 8007bde:	deff      	udf	#255	; 0xff
 8007be0:	fab2 f282 	clz	r2, r2
 8007be4:	2a00      	cmp	r2, #0
 8007be6:	f040 808f 	bne.w	8007d08 <__udivmoddi4+0x210>
 8007bea:	1b49      	subs	r1, r1, r5
 8007bec:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8007bf0:	fa1f f885 	uxth.w	r8, r5
 8007bf4:	2701      	movs	r7, #1
 8007bf6:	fbb1 fcfe 	udiv	ip, r1, lr
 8007bfa:	0c23      	lsrs	r3, r4, #16
 8007bfc:	fb0e 111c 	mls	r1, lr, ip, r1
 8007c00:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8007c04:	fb08 f10c 	mul.w	r1, r8, ip
 8007c08:	4299      	cmp	r1, r3
 8007c0a:	d907      	bls.n	8007c1c <__udivmoddi4+0x124>
 8007c0c:	18eb      	adds	r3, r5, r3
 8007c0e:	f10c 30ff 	add.w	r0, ip, #4294967295
 8007c12:	d202      	bcs.n	8007c1a <__udivmoddi4+0x122>
 8007c14:	4299      	cmp	r1, r3
 8007c16:	f200 80cd 	bhi.w	8007db4 <__udivmoddi4+0x2bc>
 8007c1a:	4684      	mov	ip, r0
 8007c1c:	1a59      	subs	r1, r3, r1
 8007c1e:	b2a3      	uxth	r3, r4
 8007c20:	fbb1 f0fe 	udiv	r0, r1, lr
 8007c24:	fb0e 1410 	mls	r4, lr, r0, r1
 8007c28:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 8007c2c:	fb08 f800 	mul.w	r8, r8, r0
 8007c30:	45a0      	cmp	r8, r4
 8007c32:	d907      	bls.n	8007c44 <__udivmoddi4+0x14c>
 8007c34:	192c      	adds	r4, r5, r4
 8007c36:	f100 33ff 	add.w	r3, r0, #4294967295
 8007c3a:	d202      	bcs.n	8007c42 <__udivmoddi4+0x14a>
 8007c3c:	45a0      	cmp	r8, r4
 8007c3e:	f200 80b6 	bhi.w	8007dae <__udivmoddi4+0x2b6>
 8007c42:	4618      	mov	r0, r3
 8007c44:	eba4 0408 	sub.w	r4, r4, r8
 8007c48:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8007c4c:	e79f      	b.n	8007b8e <__udivmoddi4+0x96>
 8007c4e:	f1c7 0c20 	rsb	ip, r7, #32
 8007c52:	40bb      	lsls	r3, r7
 8007c54:	fa22 fe0c 	lsr.w	lr, r2, ip
 8007c58:	ea4e 0e03 	orr.w	lr, lr, r3
 8007c5c:	fa01 f407 	lsl.w	r4, r1, r7
 8007c60:	fa20 f50c 	lsr.w	r5, r0, ip
 8007c64:	fa21 f30c 	lsr.w	r3, r1, ip
 8007c68:	ea4f 481e 	mov.w	r8, lr, lsr #16
 8007c6c:	4325      	orrs	r5, r4
 8007c6e:	fbb3 f9f8 	udiv	r9, r3, r8
 8007c72:	0c2c      	lsrs	r4, r5, #16
 8007c74:	fb08 3319 	mls	r3, r8, r9, r3
 8007c78:	fa1f fa8e 	uxth.w	sl, lr
 8007c7c:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 8007c80:	fb09 f40a 	mul.w	r4, r9, sl
 8007c84:	429c      	cmp	r4, r3
 8007c86:	fa02 f207 	lsl.w	r2, r2, r7
 8007c8a:	fa00 f107 	lsl.w	r1, r0, r7
 8007c8e:	d90b      	bls.n	8007ca8 <__udivmoddi4+0x1b0>
 8007c90:	eb1e 0303 	adds.w	r3, lr, r3
 8007c94:	f109 30ff 	add.w	r0, r9, #4294967295
 8007c98:	f080 8087 	bcs.w	8007daa <__udivmoddi4+0x2b2>
 8007c9c:	429c      	cmp	r4, r3
 8007c9e:	f240 8084 	bls.w	8007daa <__udivmoddi4+0x2b2>
 8007ca2:	f1a9 0902 	sub.w	r9, r9, #2
 8007ca6:	4473      	add	r3, lr
 8007ca8:	1b1b      	subs	r3, r3, r4
 8007caa:	b2ad      	uxth	r5, r5
 8007cac:	fbb3 f0f8 	udiv	r0, r3, r8
 8007cb0:	fb08 3310 	mls	r3, r8, r0, r3
 8007cb4:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 8007cb8:	fb00 fa0a 	mul.w	sl, r0, sl
 8007cbc:	45a2      	cmp	sl, r4
 8007cbe:	d908      	bls.n	8007cd2 <__udivmoddi4+0x1da>
 8007cc0:	eb1e 0404 	adds.w	r4, lr, r4
 8007cc4:	f100 33ff 	add.w	r3, r0, #4294967295
 8007cc8:	d26b      	bcs.n	8007da2 <__udivmoddi4+0x2aa>
 8007cca:	45a2      	cmp	sl, r4
 8007ccc:	d969      	bls.n	8007da2 <__udivmoddi4+0x2aa>
 8007cce:	3802      	subs	r0, #2
 8007cd0:	4474      	add	r4, lr
 8007cd2:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8007cd6:	fba0 8902 	umull	r8, r9, r0, r2
 8007cda:	eba4 040a 	sub.w	r4, r4, sl
 8007cde:	454c      	cmp	r4, r9
 8007ce0:	46c2      	mov	sl, r8
 8007ce2:	464b      	mov	r3, r9
 8007ce4:	d354      	bcc.n	8007d90 <__udivmoddi4+0x298>
 8007ce6:	d051      	beq.n	8007d8c <__udivmoddi4+0x294>
 8007ce8:	2e00      	cmp	r6, #0
 8007cea:	d069      	beq.n	8007dc0 <__udivmoddi4+0x2c8>
 8007cec:	ebb1 050a 	subs.w	r5, r1, sl
 8007cf0:	eb64 0403 	sbc.w	r4, r4, r3
 8007cf4:	fa04 fc0c 	lsl.w	ip, r4, ip
 8007cf8:	40fd      	lsrs	r5, r7
 8007cfa:	40fc      	lsrs	r4, r7
 8007cfc:	ea4c 0505 	orr.w	r5, ip, r5
 8007d00:	e9c6 5400 	strd	r5, r4, [r6]
 8007d04:	2700      	movs	r7, #0
 8007d06:	e747      	b.n	8007b98 <__udivmoddi4+0xa0>
 8007d08:	f1c2 0320 	rsb	r3, r2, #32
 8007d0c:	fa20 f703 	lsr.w	r7, r0, r3
 8007d10:	4095      	lsls	r5, r2
 8007d12:	fa01 f002 	lsl.w	r0, r1, r2
 8007d16:	fa21 f303 	lsr.w	r3, r1, r3
 8007d1a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8007d1e:	4338      	orrs	r0, r7
 8007d20:	0c01      	lsrs	r1, r0, #16
 8007d22:	fbb3 f7fe 	udiv	r7, r3, lr
 8007d26:	fa1f f885 	uxth.w	r8, r5
 8007d2a:	fb0e 3317 	mls	r3, lr, r7, r3
 8007d2e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8007d32:	fb07 f308 	mul.w	r3, r7, r8
 8007d36:	428b      	cmp	r3, r1
 8007d38:	fa04 f402 	lsl.w	r4, r4, r2
 8007d3c:	d907      	bls.n	8007d4e <__udivmoddi4+0x256>
 8007d3e:	1869      	adds	r1, r5, r1
 8007d40:	f107 3cff 	add.w	ip, r7, #4294967295
 8007d44:	d22f      	bcs.n	8007da6 <__udivmoddi4+0x2ae>
 8007d46:	428b      	cmp	r3, r1
 8007d48:	d92d      	bls.n	8007da6 <__udivmoddi4+0x2ae>
 8007d4a:	3f02      	subs	r7, #2
 8007d4c:	4429      	add	r1, r5
 8007d4e:	1acb      	subs	r3, r1, r3
 8007d50:	b281      	uxth	r1, r0
 8007d52:	fbb3 f0fe 	udiv	r0, r3, lr
 8007d56:	fb0e 3310 	mls	r3, lr, r0, r3
 8007d5a:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8007d5e:	fb00 f308 	mul.w	r3, r0, r8
 8007d62:	428b      	cmp	r3, r1
 8007d64:	d907      	bls.n	8007d76 <__udivmoddi4+0x27e>
 8007d66:	1869      	adds	r1, r5, r1
 8007d68:	f100 3cff 	add.w	ip, r0, #4294967295
 8007d6c:	d217      	bcs.n	8007d9e <__udivmoddi4+0x2a6>
 8007d6e:	428b      	cmp	r3, r1
 8007d70:	d915      	bls.n	8007d9e <__udivmoddi4+0x2a6>
 8007d72:	3802      	subs	r0, #2
 8007d74:	4429      	add	r1, r5
 8007d76:	1ac9      	subs	r1, r1, r3
 8007d78:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 8007d7c:	e73b      	b.n	8007bf6 <__udivmoddi4+0xfe>
 8007d7e:	4637      	mov	r7, r6
 8007d80:	4630      	mov	r0, r6
 8007d82:	e709      	b.n	8007b98 <__udivmoddi4+0xa0>
 8007d84:	4607      	mov	r7, r0
 8007d86:	e6e7      	b.n	8007b58 <__udivmoddi4+0x60>
 8007d88:	4618      	mov	r0, r3
 8007d8a:	e6fb      	b.n	8007b84 <__udivmoddi4+0x8c>
 8007d8c:	4541      	cmp	r1, r8
 8007d8e:	d2ab      	bcs.n	8007ce8 <__udivmoddi4+0x1f0>
 8007d90:	ebb8 0a02 	subs.w	sl, r8, r2
 8007d94:	eb69 020e 	sbc.w	r2, r9, lr
 8007d98:	3801      	subs	r0, #1
 8007d9a:	4613      	mov	r3, r2
 8007d9c:	e7a4      	b.n	8007ce8 <__udivmoddi4+0x1f0>
 8007d9e:	4660      	mov	r0, ip
 8007da0:	e7e9      	b.n	8007d76 <__udivmoddi4+0x27e>
 8007da2:	4618      	mov	r0, r3
 8007da4:	e795      	b.n	8007cd2 <__udivmoddi4+0x1da>
 8007da6:	4667      	mov	r7, ip
 8007da8:	e7d1      	b.n	8007d4e <__udivmoddi4+0x256>
 8007daa:	4681      	mov	r9, r0
 8007dac:	e77c      	b.n	8007ca8 <__udivmoddi4+0x1b0>
 8007dae:	3802      	subs	r0, #2
 8007db0:	442c      	add	r4, r5
 8007db2:	e747      	b.n	8007c44 <__udivmoddi4+0x14c>
 8007db4:	f1ac 0c02 	sub.w	ip, ip, #2
 8007db8:	442b      	add	r3, r5
 8007dba:	e72f      	b.n	8007c1c <__udivmoddi4+0x124>
 8007dbc:	4638      	mov	r0, r7
 8007dbe:	e708      	b.n	8007bd2 <__udivmoddi4+0xda>
 8007dc0:	4637      	mov	r7, r6
 8007dc2:	e6e9      	b.n	8007b98 <__udivmoddi4+0xa0>

08007dc4 <__aeabi_idiv0>:
 8007dc4:	4770      	bx	lr
 8007dc6:	bf00      	nop

08007dc8 <HTS221_ReadReg>:
* Input       : Register Address
* Output      : Data Read
* Return      : None
*******************************************************************************/
HTS221_Error_et HTS221_ReadReg( void *handle, uint8_t RegAddr, uint16_t NumByteToRead, uint8_t *Data )
{
 8007dc8:	b510      	push	{r4, lr}
 8007dca:	461c      	mov	r4, r3

  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8007dcc:	4613      	mov	r3, r2
 8007dce:	4622      	mov	r2, r4
 8007dd0:	f006 fc36 	bl	800e640 <Sensor_IO_Read>
    return HTS221_ERROR;
  else
    return HTS221_OK;
}
 8007dd4:	3000      	adds	r0, #0
 8007dd6:	bf18      	it	ne
 8007dd8:	2001      	movne	r0, #1
 8007dda:	bd10      	pop	{r4, pc}

08007ddc <HTS221_WriteReg>:
* Input       : Register Address, Data to be written
* Output      : None
* Return      : None
*******************************************************************************/
HTS221_Error_et HTS221_WriteReg( void *handle, uint8_t RegAddr, uint16_t NumByteToWrite, uint8_t *Data )
{
 8007ddc:	b510      	push	{r4, lr}
 8007dde:	461c      	mov	r4, r3

  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8007de0:	4613      	mov	r3, r2
 8007de2:	4622      	mov	r2, r4
 8007de4:	f006 fb3e 	bl	800e464 <Sensor_IO_Write>
    return HTS221_ERROR;
  else
    return HTS221_OK;
}
 8007de8:	3000      	adds	r0, #0
 8007dea:	bf18      	it	ne
 8007dec:	2001      	movne	r0, #1
 8007dee:	bd10      	pop	{r4, pc}

08007df0 <HTS221_Get_DeviceID>:
* @param  *handle Device handle.
* @param  deviceid pointer to the returned device type ID.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_DeviceID(void *handle, uint8_t* deviceid)
{
 8007df0:	b508      	push	{r3, lr}
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8007df2:	460a      	mov	r2, r1
 8007df4:	2301      	movs	r3, #1
 8007df6:	210f      	movs	r1, #15
 8007df8:	f006 fc22 	bl	800e640 <Sensor_IO_Read>
  if(HTS221_ReadReg(handle, HTS221_WHO_AM_I_REG, 1, deviceid))
    return HTS221_ERROR;

  return HTS221_OK;
}
 8007dfc:	3000      	adds	r0, #0
 8007dfe:	bf18      	it	ne
 8007e00:	2001      	movne	r0, #1
 8007e02:	bd08      	pop	{r3, pc}

08007e04 <HTS221_Get_Humidity>:
* @param  *handle Device handle.
* @param  Pointer to the returned humidity value that must be divided by 10 to get the value in [%].
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_Humidity(void *handle, uint16_t* value)
{
 8007e04:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007e08:	b082      	sub	sp, #8
 8007e0a:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8007e0c:	aa01      	add	r2, sp, #4
 8007e0e:	2302      	movs	r3, #2
 8007e10:	2130      	movs	r1, #48	; 0x30
{
 8007e12:	4604      	mov	r4, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8007e14:	f006 fc14 	bl	800e640 <Sensor_IO_Read>
 8007e18:	b118      	cbz	r0, 8007e22 <HTS221_Get_Humidity+0x1e>
  int16_t H0_rh, H1_rh;
  uint8_t buffer[2];
  float   tmp_f;

  if(HTS221_ReadReg(handle, HTS221_H0_RH_X2, 2, buffer))
    return HTS221_ERROR;
 8007e1a:	2001      	movs	r0, #1
  *value = ( tmp_f > 1000.0f ) ? 1000
           : ( tmp_f <    0.0f ) ?    0
           : ( uint16_t )tmp_f;

  return HTS221_OK;
}
 8007e1c:	b002      	add	sp, #8
 8007e1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8007e22:	2302      	movs	r3, #2
 8007e24:	aa01      	add	r2, sp, #4
 8007e26:	2136      	movs	r1, #54	; 0x36
 8007e28:	4620      	mov	r0, r4
  H0_rh = buffer[0] >> 1;
 8007e2a:	f89d 6004 	ldrb.w	r6, [sp, #4]
  H1_rh = buffer[1] >> 1;
 8007e2e:	f89d 7005 	ldrb.w	r7, [sp, #5]
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8007e32:	f006 fc05 	bl	800e640 <Sensor_IO_Read>
 8007e36:	2800      	cmp	r0, #0
 8007e38:	d1ef      	bne.n	8007e1a <HTS221_Get_Humidity+0x16>
 8007e3a:	2302      	movs	r3, #2
 8007e3c:	aa01      	add	r2, sp, #4
 8007e3e:	213a      	movs	r1, #58	; 0x3a
 8007e40:	4620      	mov	r0, r4
  H0_T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8007e42:	f89d a005 	ldrb.w	sl, [sp, #5]
 8007e46:	f89d 9004 	ldrb.w	r9, [sp, #4]
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8007e4a:	f006 fbf9 	bl	800e640 <Sensor_IO_Read>
 8007e4e:	2800      	cmp	r0, #0
 8007e50:	d1e3      	bne.n	8007e1a <HTS221_Get_Humidity+0x16>
 8007e52:	4620      	mov	r0, r4
 8007e54:	aa01      	add	r2, sp, #4
 8007e56:	2302      	movs	r3, #2
 8007e58:	2128      	movs	r1, #40	; 0x28
  H1_T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8007e5a:	f89d 8005 	ldrb.w	r8, [sp, #5]
 8007e5e:	f89d 4004 	ldrb.w	r4, [sp, #4]
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8007e62:	f006 fbed 	bl	800e640 <Sensor_IO_Read>
 8007e66:	2800      	cmp	r0, #0
 8007e68:	d1d7      	bne.n	8007e1a <HTS221_Get_Humidity+0x16>
  H_T_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8007e6a:	f89d 2005 	ldrb.w	r2, [sp, #5]
 8007e6e:	f89d 3004 	ldrb.w	r3, [sp, #4]
  *value = ( tmp_f > 1000.0f ) ? 1000
 8007e72:	eddf 5a21 	vldr	s11, [pc, #132]	; 8007ef8 <HTS221_Get_Humidity+0xf4>
  H0_T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8007e76:	ea49 290a 	orr.w	r9, r9, sl, lsl #8
  H_T_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8007e7a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  tmp_f = (float)(H_T_out - H0_T0_out) * (float)(H1_rh - H0_rh) / (float)(H1_T0_out - H0_T0_out)  +  H0_rh;
 8007e7e:	fa0f f989 	sxth.w	r9, r9
  H0_rh = buffer[0] >> 1;
 8007e82:	0876      	lsrs	r6, r6, #1
  tmp_f = (float)(H_T_out - H0_T0_out) * (float)(H1_rh - H0_rh) / (float)(H1_T0_out - H0_T0_out)  +  H0_rh;
 8007e84:	b21b      	sxth	r3, r3
 8007e86:	eba3 0309 	sub.w	r3, r3, r9
 8007e8a:	ebc6 0757 	rsb	r7, r6, r7, lsr #1
 8007e8e:	ee07 3a10 	vmov	s14, r3
 8007e92:	ee07 7a90 	vmov	s15, r7
  H1_T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8007e96:	ea44 2408 	orr.w	r4, r4, r8, lsl #8
  tmp_f = (float)(H_T_out - H0_T0_out) * (float)(H1_rh - H0_rh) / (float)(H1_T0_out - H0_T0_out)  +  H0_rh;
 8007e9a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8007e9e:	b224      	sxth	r4, r4
 8007ea0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8007ea4:	eba4 0909 	sub.w	r9, r4, r9
 8007ea8:	ee27 7a27 	vmul.f32	s14, s14, s15
 8007eac:	ee07 9a90 	vmov	s15, r9
 8007eb0:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 8007eb4:	ee07 6a90 	vmov	s15, r6
 8007eb8:	ee87 6a26 	vdiv.f32	s12, s14, s13
 8007ebc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  tmp_f *= 10.0f;
 8007ec0:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
  tmp_f = (float)(H_T_out - H0_T0_out) * (float)(H1_rh - H0_rh) / (float)(H1_T0_out - H0_T0_out)  +  H0_rh;
 8007ec4:	ee76 7a27 	vadd.f32	s15, s12, s15
  tmp_f *= 10.0f;
 8007ec8:	ee67 7a87 	vmul.f32	s15, s15, s14
  *value = ( tmp_f > 1000.0f ) ? 1000
 8007ecc:	eef4 7ae5 	vcmpe.f32	s15, s11
 8007ed0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007ed4:	dc0c      	bgt.n	8007ef0 <HTS221_Get_Humidity+0xec>
 8007ed6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8007eda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007ede:	d404      	bmi.n	8007eea <HTS221_Get_Humidity+0xe6>
 8007ee0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8007ee4:	ee17 3a90 	vmov	r3, s15
 8007ee8:	b298      	uxth	r0, r3
 8007eea:	8028      	strh	r0, [r5, #0]
  return HTS221_OK;
 8007eec:	2000      	movs	r0, #0
 8007eee:	e795      	b.n	8007e1c <HTS221_Get_Humidity+0x18>
  *value = ( tmp_f > 1000.0f ) ? 1000
 8007ef0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007ef4:	e7f9      	b.n	8007eea <HTS221_Get_Humidity+0xe6>
 8007ef6:	bf00      	nop
 8007ef8:	447a0000 	.word	0x447a0000

08007efc <HTS221_Get_Temperature>:
* @param  *handle Device handle.
* @param  Pointer to the returned temperature value that must be divided by 10 to get the value in ['C].
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_Temperature(void *handle, int16_t *value)
{
 8007efc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007f00:	b083      	sub	sp, #12
 8007f02:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8007f04:	aa01      	add	r2, sp, #4
 8007f06:	2302      	movs	r3, #2
 8007f08:	2132      	movs	r1, #50	; 0x32
{
 8007f0a:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8007f0c:	f006 fb98 	bl	800e640 <Sensor_IO_Read>
 8007f10:	b118      	cbz	r0, 8007f1a <HTS221_Get_Temperature+0x1e>
  int16_t T0_degC, T1_degC;
  uint8_t buffer[4], tmp;
  float   tmp_f;

  if(HTS221_ReadReg(handle, HTS221_T0_DEGC_X8, 2, buffer))
    return HTS221_ERROR;
 8007f12:	2001      	movs	r0, #1
  tmp_f *= 10.0f;

  *value = ( int16_t )tmp_f;

  return HTS221_OK;
}
 8007f14:	b003      	add	sp, #12
 8007f16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8007f1a:	2301      	movs	r3, #1
 8007f1c:	f10d 0203 	add.w	r2, sp, #3
 8007f20:	2135      	movs	r1, #53	; 0x35
 8007f22:	4630      	mov	r0, r6
 8007f24:	f006 fb8c 	bl	800e640 <Sensor_IO_Read>
 8007f28:	2800      	cmp	r0, #0
 8007f2a:	d1f2      	bne.n	8007f12 <HTS221_Get_Temperature+0x16>
 8007f2c:	2304      	movs	r3, #4
 8007f2e:	eb0d 0203 	add.w	r2, sp, r3
 8007f32:	213c      	movs	r1, #60	; 0x3c
 8007f34:	4630      	mov	r0, r6
  T0_degC_x8_u16 = (((uint16_t)(tmp & 0x03)) << 8) | ((uint16_t)buffer[0]);
 8007f36:	f89d 5003 	ldrb.w	r5, [sp, #3]
 8007f3a:	f89d 9004 	ldrb.w	r9, [sp, #4]
  T1_degC_x8_u16 = (((uint16_t)(tmp & 0x0C)) << 6) | ((uint16_t)buffer[1]);
 8007f3e:	f89d 8005 	ldrb.w	r8, [sp, #5]
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8007f42:	f006 fb7d 	bl	800e640 <Sensor_IO_Read>
 8007f46:	2800      	cmp	r0, #0
 8007f48:	d1e3      	bne.n	8007f12 <HTS221_Get_Temperature+0x16>
 8007f4a:	4630      	mov	r0, r6
 8007f4c:	aa01      	add	r2, sp, #4
 8007f4e:	2302      	movs	r3, #2
 8007f50:	212a      	movs	r1, #42	; 0x2a
  T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8007f52:	f89d b005 	ldrb.w	fp, [sp, #5]
 8007f56:	f89d 7004 	ldrb.w	r7, [sp, #4]
  T1_out = (((uint16_t)buffer[3]) << 8) | (uint16_t)buffer[2];
 8007f5a:	f89d a007 	ldrb.w	sl, [sp, #7]
 8007f5e:	f89d 6006 	ldrb.w	r6, [sp, #6]
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8007f62:	f006 fb6d 	bl	800e640 <Sensor_IO_Read>
 8007f66:	2800      	cmp	r0, #0
 8007f68:	d1d3      	bne.n	8007f12 <HTS221_Get_Temperature+0x16>
  T_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8007f6a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8007f6e:	f89d 2005 	ldrb.w	r2, [sp, #5]
 8007f72:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
  T0_degC_x8_u16 = (((uint16_t)(tmp & 0x03)) << 8) | ((uint16_t)buffer[0]);
 8007f76:	022b      	lsls	r3, r5, #8
 8007f78:	f403 7340 	and.w	r3, r3, #768	; 0x300
  T1_degC_x8_u16 = (((uint16_t)(tmp & 0x0C)) << 6) | ((uint16_t)buffer[1]);
 8007f7c:	01ad      	lsls	r5, r5, #6
  T0_degC = T0_degC_x8_u16 >> 3;
 8007f7e:	ea43 0909 	orr.w	r9, r3, r9
  T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8007f82:	ea47 270b 	orr.w	r7, r7, fp, lsl #8
  T1_degC_x8_u16 = (((uint16_t)(tmp & 0x0C)) << 6) | ((uint16_t)buffer[1]);
 8007f86:	f405 7540 	and.w	r5, r5, #768	; 0x300
  tmp_f = (float)(T_out - T0_out) * (float)(T1_degC - T0_degC) / (float)(T1_out - T0_out)  +  T0_degC;
 8007f8a:	b23f      	sxth	r7, r7
  T0_degC = T0_degC_x8_u16 >> 3;
 8007f8c:	ea4f 09d9 	mov.w	r9, r9, lsr #3
  tmp_f = (float)(T_out - T0_out) * (float)(T1_degC - T0_degC) / (float)(T1_out - T0_out)  +  T0_degC;
 8007f90:	b213      	sxth	r3, r2
  T1_degC = T1_degC_x8_u16 >> 3;
 8007f92:	ea45 0808 	orr.w	r8, r5, r8
  tmp_f = (float)(T_out - T0_out) * (float)(T1_degC - T0_degC) / (float)(T1_out - T0_out)  +  T0_degC;
 8007f96:	1bdb      	subs	r3, r3, r7
 8007f98:	ebc9 08d8 	rsb	r8, r9, r8, lsr #3
 8007f9c:	ee07 3a10 	vmov	s14, r3
 8007fa0:	ee07 8a90 	vmov	s15, r8
  T1_out = (((uint16_t)buffer[3]) << 8) | (uint16_t)buffer[2];
 8007fa4:	ea46 260a 	orr.w	r6, r6, sl, lsl #8
  tmp_f = (float)(T_out - T0_out) * (float)(T1_degC - T0_degC) / (float)(T1_out - T0_out)  +  T0_degC;
 8007fa8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8007fac:	b236      	sxth	r6, r6
 8007fae:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8007fb2:	1bf6      	subs	r6, r6, r7
 8007fb4:	ee67 7a27 	vmul.f32	s15, s14, s15
 8007fb8:	ee07 6a10 	vmov	s14, r6
 8007fbc:	eef8 6ac7 	vcvt.f32.s32	s13, s14
 8007fc0:	ee07 9a10 	vmov	s14, r9
 8007fc4:	ee87 6aa6 	vdiv.f32	s12, s15, s13
 8007fc8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  tmp_f *= 10.0f;
 8007fcc:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
  tmp_f = (float)(T_out - T0_out) * (float)(T1_degC - T0_degC) / (float)(T1_out - T0_out)  +  T0_degC;
 8007fd0:	ee36 7a07 	vadd.f32	s14, s12, s14
  tmp_f *= 10.0f;
 8007fd4:	ee27 7a27 	vmul.f32	s14, s14, s15
  *value = ( int16_t )tmp_f;
 8007fd8:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 8007fdc:	ee17 3a10 	vmov	r3, s14
 8007fe0:	8023      	strh	r3, [r4, #0]
  return HTS221_OK;
 8007fe2:	e797      	b.n	8007f14 <HTS221_Get_Temperature+0x18>

08007fe4 <HTS221_Get_DataStatus>:
* @param  temperature pointer to the returned temperature data status [HTS221_SET/HTS221_RESET].
*         This parameter is a pointer to @ref HTS221_BitStatus_et.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_DataStatus(void *handle, HTS221_BitStatus_et* humidity, HTS221_BitStatus_et* temperature)
{
 8007fe4:	b530      	push	{r4, r5, lr}
 8007fe6:	b083      	sub	sp, #12
 8007fe8:	460d      	mov	r5, r1
 8007fea:	4614      	mov	r4, r2
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8007fec:	2301      	movs	r3, #1
 8007fee:	f10d 0207 	add.w	r2, sp, #7
 8007ff2:	2127      	movs	r1, #39	; 0x27
 8007ff4:	f006 fb24 	bl	800e640 <Sensor_IO_Read>
 8007ff8:	b948      	cbnz	r0, 800800e <HTS221_Get_DataStatus+0x2a>
  uint8_t tmp;

  if(HTS221_ReadReg(handle, HTS221_STATUS_REG, 1, &tmp))
    return HTS221_ERROR;

  *humidity = (HTS221_BitStatus_et)((tmp & HTS221_HDA_MASK) >> HTS221_H_DA_BIT);
 8007ffa:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8007ffe:	f3c3 0240 	ubfx	r2, r3, #1, #1
  *temperature = (HTS221_BitStatus_et)(tmp & HTS221_TDA_MASK);
 8008002:	f003 0301 	and.w	r3, r3, #1
  *humidity = (HTS221_BitStatus_et)((tmp & HTS221_HDA_MASK) >> HTS221_H_DA_BIT);
 8008006:	702a      	strb	r2, [r5, #0]
  *temperature = (HTS221_BitStatus_et)(tmp & HTS221_TDA_MASK);
 8008008:	7023      	strb	r3, [r4, #0]

  return HTS221_OK;
}
 800800a:	b003      	add	sp, #12
 800800c:	bd30      	pop	{r4, r5, pc}
    return HTS221_ERROR;
 800800e:	2001      	movs	r0, #1
}
 8008010:	b003      	add	sp, #12
 8008012:	bd30      	pop	{r4, r5, pc}

08008014 <HTS221_Activate>:
* @param  *handle Device handle.
* @param  void.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Activate(void *handle)
{
 8008014:	b530      	push	{r4, r5, lr}
 8008016:	b083      	sub	sp, #12
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008018:	f10d 0207 	add.w	r2, sp, #7
 800801c:	2301      	movs	r3, #1
 800801e:	2120      	movs	r1, #32
{
 8008020:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008022:	f006 fb0d 	bl	800e640 <Sensor_IO_Read>
 8008026:	b110      	cbz	r0, 800802e <HTS221_Activate+0x1a>
  uint8_t tmp;

  if(HTS221_ReadReg(handle, HTS221_CTRL_REG1, 1, &tmp))
    return HTS221_ERROR;
 8008028:	2001      	movs	r0, #1

  if(HTS221_WriteReg(handle, HTS221_CTRL_REG1, 1, &tmp))
    return HTS221_ERROR;

  return HTS221_OK;
}
 800802a:	b003      	add	sp, #12
 800802c:	bd30      	pop	{r4, r5, pc}
  tmp |= HTS221_PD_MASK;
 800802e:	f89d 4007 	ldrb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008032:	f10d 0207 	add.w	r2, sp, #7
 8008036:	4628      	mov	r0, r5
  tmp |= HTS221_PD_MASK;
 8008038:	f064 047f 	orn	r4, r4, #127	; 0x7f
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800803c:	2301      	movs	r3, #1
 800803e:	2120      	movs	r1, #32
  tmp |= HTS221_PD_MASK;
 8008040:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008044:	f006 fa0e 	bl	800e464 <Sensor_IO_Write>
    return HTS221_ERROR;
 8008048:	3000      	adds	r0, #0
 800804a:	bf18      	it	ne
 800804c:	2001      	movne	r0, #1
}
 800804e:	b003      	add	sp, #12
 8008050:	bd30      	pop	{r4, r5, pc}
 8008052:	bf00      	nop

08008054 <HTS221_DeActivate>:
* @brief  Put the sensor in power down mode.
* @param  *handle Device handle.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_DeActivate(void *handle)
{
 8008054:	b530      	push	{r4, r5, lr}
 8008056:	b083      	sub	sp, #12
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008058:	f10d 0207 	add.w	r2, sp, #7
 800805c:	2301      	movs	r3, #1
 800805e:	2120      	movs	r1, #32
{
 8008060:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008062:	f006 faed 	bl	800e640 <Sensor_IO_Read>
 8008066:	b110      	cbz	r0, 800806e <HTS221_DeActivate+0x1a>
  uint8_t tmp;

  if(HTS221_ReadReg(handle, HTS221_CTRL_REG1, 1, &tmp))
    return HTS221_ERROR;
 8008068:	2001      	movs	r0, #1

  if(HTS221_WriteReg(handle, HTS221_CTRL_REG1, 1, &tmp))
    return HTS221_ERROR;

  return HTS221_OK;
}
 800806a:	b003      	add	sp, #12
 800806c:	bd30      	pop	{r4, r5, pc}
  tmp &= ~HTS221_PD_MASK;
 800806e:	f89d 4007 	ldrb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008072:	f10d 0207 	add.w	r2, sp, #7
 8008076:	4628      	mov	r0, r5
  tmp &= ~HTS221_PD_MASK;
 8008078:	f004 047f 	and.w	r4, r4, #127	; 0x7f
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800807c:	2301      	movs	r3, #1
 800807e:	2120      	movs	r1, #32
  tmp &= ~HTS221_PD_MASK;
 8008080:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008084:	f006 f9ee 	bl	800e464 <Sensor_IO_Write>
    return HTS221_ERROR;
 8008088:	3000      	adds	r0, #0
 800808a:	bf18      	it	ne
 800808c:	2001      	movne	r0, #1
}
 800808e:	b003      	add	sp, #12
 8008090:	bd30      	pop	{r4, r5, pc}
 8008092:	bf00      	nop

08008094 <HTS221_Get_Odr>:
* @param  *handle Device handle.
* @param  Pointer to the returned value with output data rate mode.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_Odr(void *handle, HTS221_Odr_et* odr)
{
 8008094:	b510      	push	{r4, lr}
 8008096:	b082      	sub	sp, #8
 8008098:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800809a:	2301      	movs	r3, #1
 800809c:	f10d 0207 	add.w	r2, sp, #7
 80080a0:	2120      	movs	r1, #32
 80080a2:	f006 facd 	bl	800e640 <Sensor_IO_Read>
 80080a6:	b930      	cbnz	r0, 80080b6 <HTS221_Get_Odr+0x22>
  uint8_t tmp;

  if(HTS221_ReadReg(handle, HTS221_CTRL_REG1, 1, &tmp))
    return HTS221_ERROR;

  tmp &= HTS221_ODR_MASK;
 80080a8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80080ac:	f003 0303 	and.w	r3, r3, #3
  *odr = (HTS221_Odr_et)tmp;
 80080b0:	7023      	strb	r3, [r4, #0]

  return HTS221_OK;
}
 80080b2:	b002      	add	sp, #8
 80080b4:	bd10      	pop	{r4, pc}
    return HTS221_ERROR;
 80080b6:	2001      	movs	r0, #1
}
 80080b8:	b002      	add	sp, #8
 80080ba:	bd10      	pop	{r4, pc}

080080bc <HTS221_StartOneShotMeasurement>:
*         Once the measurement is done, ONE_SHOT bit is self-cleared.
* @param  *handle Device handle.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_StartOneShotMeasurement(void *handle)
{
 80080bc:	b530      	push	{r4, r5, lr}
 80080be:	b083      	sub	sp, #12
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80080c0:	f10d 0207 	add.w	r2, sp, #7
 80080c4:	2301      	movs	r3, #1
 80080c6:	2121      	movs	r1, #33	; 0x21
{
 80080c8:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80080ca:	f006 fab9 	bl	800e640 <Sensor_IO_Read>
 80080ce:	b110      	cbz	r0, 80080d6 <HTS221_StartOneShotMeasurement+0x1a>
  uint8_t tmp;

  if(HTS221_ReadReg(handle, HTS221_CTRL_REG2, 1, &tmp))
    return HTS221_ERROR;
 80080d0:	2001      	movs	r0, #1
  if(HTS221_WriteReg(handle, HTS221_CTRL_REG2, 1, &tmp))
    return HTS221_ERROR;

  return HTS221_OK;

}
 80080d2:	b003      	add	sp, #12
 80080d4:	bd30      	pop	{r4, r5, pc}
  tmp |= HTS221_ONE_SHOT_MASK;
 80080d6:	f89d 4007 	ldrb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80080da:	f10d 0207 	add.w	r2, sp, #7
 80080de:	4628      	mov	r0, r5
  tmp |= HTS221_ONE_SHOT_MASK;
 80080e0:	f044 0401 	orr.w	r4, r4, #1
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80080e4:	2301      	movs	r3, #1
 80080e6:	2121      	movs	r1, #33	; 0x21
  tmp |= HTS221_ONE_SHOT_MASK;
 80080e8:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80080ec:	f006 f9ba 	bl	800e464 <Sensor_IO_Write>
    return HTS221_ERROR;
 80080f0:	3000      	adds	r0, #0
 80080f2:	bf18      	it	ne
 80080f4:	2001      	movne	r0, #1
}
 80080f6:	b003      	add	sp, #12
 80080f8:	bd30      	pop	{r4, r5, pc}
 80080fa:	bf00      	nop

080080fc <HTS221_assert_failed>:
* @retval : None
*/
void HTS221_assert_failed(uint8_t* file, uint32_t line)
{
  /* User can add his own implementation to report the file name and line number */
  printf("Wrong parameters value: file %s on line %d\r\n", file, (int)line);
 80080fc:	460a      	mov	r2, r1
{
 80080fe:	b508      	push	{r3, lr}
  printf("Wrong parameters value: file %s on line %d\r\n", file, (int)line);
 8008100:	4601      	mov	r1, r0
 8008102:	4802      	ldr	r0, [pc, #8]	; (800810c <HTS221_assert_failed+0x10>)
 8008104:	f017 fa20 	bl	801f548 <iprintf>
 8008108:	e7fe      	b.n	8008108 <HTS221_assert_failed+0xc>
 800810a:	bf00      	nop
 800810c:	080753b0 	.word	0x080753b0

08008110 <HTS221_Set_BduMode>:
{
 8008110:	b530      	push	{r4, r5, lr}
  HTS221_assert_param(IS_HTS221_State(status));
 8008112:	2901      	cmp	r1, #1
{
 8008114:	b083      	sub	sp, #12
  HTS221_assert_param(IS_HTS221_State(status));
 8008116:	d81f      	bhi.n	8008158 <HTS221_Set_BduMode+0x48>
 8008118:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800811a:	f10d 0207 	add.w	r2, sp, #7
 800811e:	2301      	movs	r3, #1
 8008120:	2120      	movs	r1, #32
 8008122:	4605      	mov	r5, r0
 8008124:	f006 fa8c 	bl	800e640 <Sensor_IO_Read>
 8008128:	b110      	cbz	r0, 8008130 <HTS221_Set_BduMode+0x20>
    return HTS221_ERROR;
 800812a:	2001      	movs	r0, #1
}
 800812c:	b003      	add	sp, #12
 800812e:	bd30      	pop	{r4, r5, pc}
  tmp &= ~HTS221_BDU_MASK;
 8008130:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8008134:	f023 0304 	bic.w	r3, r3, #4
  tmp |= ((uint8_t)status) << HTS221_BDU_BIT;
 8008138:	ea43 0484 	orr.w	r4, r3, r4, lsl #2
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800813c:	f10d 0207 	add.w	r2, sp, #7
 8008140:	4628      	mov	r0, r5
 8008142:	2301      	movs	r3, #1
 8008144:	2120      	movs	r1, #32
  tmp |= ((uint8_t)status) << HTS221_BDU_BIT;
 8008146:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800814a:	f006 f98b 	bl	800e464 <Sensor_IO_Write>
    return HTS221_ERROR;
 800814e:	3000      	adds	r0, #0
 8008150:	bf18      	it	ne
 8008152:	2001      	movne	r0, #1
}
 8008154:	b003      	add	sp, #12
 8008156:	bd30      	pop	{r4, r5, pc}
  HTS221_assert_param(IS_HTS221_State(status));
 8008158:	f240 216b 	movw	r1, #619	; 0x26b
 800815c:	4801      	ldr	r0, [pc, #4]	; (8008164 <HTS221_Set_BduMode+0x54>)
 800815e:	f7ff ffcd 	bl	80080fc <HTS221_assert_failed>
 8008162:	bf00      	nop
 8008164:	080753e0 	.word	0x080753e0

08008168 <HTS221_Set_Odr>:
{
 8008168:	b530      	push	{r4, r5, lr}
  HTS221_assert_param(IS_HTS221_ODR(odr));
 800816a:	2903      	cmp	r1, #3
{
 800816c:	b083      	sub	sp, #12
  HTS221_assert_param(IS_HTS221_ODR(odr));
 800816e:	d81e      	bhi.n	80081ae <HTS221_Set_Odr+0x46>
 8008170:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008172:	f10d 0207 	add.w	r2, sp, #7
 8008176:	2301      	movs	r3, #1
 8008178:	2120      	movs	r1, #32
 800817a:	4605      	mov	r5, r0
 800817c:	f006 fa60 	bl	800e640 <Sensor_IO_Read>
 8008180:	b110      	cbz	r0, 8008188 <HTS221_Set_Odr+0x20>
    return HTS221_ERROR;
 8008182:	2001      	movs	r0, #1
}
 8008184:	b003      	add	sp, #12
 8008186:	bd30      	pop	{r4, r5, pc}
  tmp &= ~HTS221_ODR_MASK;
 8008188:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800818c:	f023 0303 	bic.w	r3, r3, #3
  tmp |= (uint8_t)odr;
 8008190:	431c      	orrs	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008192:	f10d 0207 	add.w	r2, sp, #7
 8008196:	4628      	mov	r0, r5
 8008198:	2301      	movs	r3, #1
 800819a:	2120      	movs	r1, #32
  tmp |= (uint8_t)odr;
 800819c:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80081a0:	f006 f960 	bl	800e464 <Sensor_IO_Write>
    return HTS221_ERROR;
 80081a4:	3000      	adds	r0, #0
 80081a6:	bf18      	it	ne
 80081a8:	2001      	movne	r0, #1
}
 80081aa:	b003      	add	sp, #12
 80081ac:	bd30      	pop	{r4, r5, pc}
  HTS221_assert_param(IS_HTS221_ODR(odr));
 80081ae:	f240 21c2 	movw	r1, #706	; 0x2c2
 80081b2:	4801      	ldr	r0, [pc, #4]	; (80081b8 <HTS221_Set_Odr+0x50>)
 80081b4:	f7ff ffa2 	bl	80080fc <HTS221_assert_failed>
 80081b8:	080753e0 	.word	0x080753e0

080081bc <HTS221_H_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 80081bc:	b510      	push	{r4, lr}
 80081be:	b082      	sub	sp, #8
 80081c0:	460c      	mov	r4, r1

  HTS221_BitStatus_et hum_status_raw;
  HTS221_BitStatus_et temp_status_raw;

  if ( HTS221_Get_DataStatus( (void *)handle, &hum_status_raw, &temp_status_raw ) == HTS221_ERROR )
 80081c2:	f10d 0207 	add.w	r2, sp, #7
 80081c6:	f10d 0106 	add.w	r1, sp, #6
 80081ca:	f7ff ff0b 	bl	8007fe4 <HTS221_Get_DataStatus>
 80081ce:	2801      	cmp	r0, #1
 80081d0:	d006      	beq.n	80081e0 <HTS221_H_Get_DRDY_Status+0x24>
  {
    return COMPONENT_ERROR;
  }

  switch( hum_status_raw )
 80081d2:	f89d 0006 	ldrb.w	r0, [sp, #6]
 80081d6:	b128      	cbz	r0, 80081e4 <HTS221_H_Get_DRDY_Status+0x28>
 80081d8:	2801      	cmp	r0, #1
 80081da:	d106      	bne.n	80081ea <HTS221_H_Get_DRDY_Status+0x2e>
  {
    case HTS221_SET:
      *status = 1;
 80081dc:	7020      	strb	r0, [r4, #0]
      break;
    default:
      return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
 80081de:	2000      	movs	r0, #0
}
 80081e0:	b002      	add	sp, #8
 80081e2:	bd10      	pop	{r4, pc}
      *status = 0;
 80081e4:	7020      	strb	r0, [r4, #0]
}
 80081e6:	b002      	add	sp, #8
 80081e8:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 80081ea:	2001      	movs	r0, #1
}
 80081ec:	b002      	add	sp, #8
 80081ee:	bd10      	pop	{r4, pc}

080081f0 <HTS221_T_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 80081f0:	b510      	push	{r4, lr}
 80081f2:	b082      	sub	sp, #8
 80081f4:	460c      	mov	r4, r1

  HTS221_BitStatus_et hum_status_raw;
  HTS221_BitStatus_et temp_status_raw;

  if ( HTS221_Get_DataStatus( (void *)handle, &hum_status_raw, &temp_status_raw ) == HTS221_ERROR )
 80081f6:	f10d 0207 	add.w	r2, sp, #7
 80081fa:	f10d 0106 	add.w	r1, sp, #6
 80081fe:	f7ff fef1 	bl	8007fe4 <HTS221_Get_DataStatus>
 8008202:	2801      	cmp	r0, #1
 8008204:	d006      	beq.n	8008214 <HTS221_T_Get_DRDY_Status+0x24>
  {
    return COMPONENT_ERROR;
  }

  switch( temp_status_raw )
 8008206:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800820a:	b128      	cbz	r0, 8008218 <HTS221_T_Get_DRDY_Status+0x28>
 800820c:	2801      	cmp	r0, #1
 800820e:	d106      	bne.n	800821e <HTS221_T_Get_DRDY_Status+0x2e>
  {
    case HTS221_SET:
      *status = 1;
 8008210:	7020      	strb	r0, [r4, #0]
      break;
    default:
      return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
 8008212:	2000      	movs	r0, #0
}
 8008214:	b002      	add	sp, #8
 8008216:	bd10      	pop	{r4, pc}
      *status = 0;
 8008218:	7020      	strb	r0, [r4, #0]
}
 800821a:	b002      	add	sp, #8
 800821c:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 800821e:	2001      	movs	r0, #1
}
 8008220:	b002      	add	sp, #8
 8008222:	bd10      	pop	{r4, pc}

08008224 <HTS221_H_Write_Reg>:
{
 8008224:	b500      	push	{lr}
 8008226:	b083      	sub	sp, #12
 8008228:	ab02      	add	r3, sp, #8
 800822a:	f803 2d01 	strb.w	r2, [r3, #-1]!
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_Write_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t data )
{

  if ( HTS221_WriteReg( (void *)handle, reg, 1, &data ) == HTS221_ERROR )
 800822e:	2201      	movs	r2, #1
 8008230:	f7ff fdd4 	bl	8007ddc <HTS221_WriteReg>
}
 8008234:	f1a0 0001 	sub.w	r0, r0, #1
 8008238:	fab0 f080 	clz	r0, r0
 800823c:	0940      	lsrs	r0, r0, #5
 800823e:	b003      	add	sp, #12
 8008240:	f85d fb04 	ldr.w	pc, [sp], #4

08008244 <HTS221_T_Write_Reg>:
 8008244:	f7ff bfee 	b.w	8008224 <HTS221_H_Write_Reg>

08008248 <HTS221_H_Read_Reg>:
{
 8008248:	b508      	push	{r3, lr}
  if ( HTS221_ReadReg( (void *)handle, reg, 1, data ) == HTS221_ERROR )
 800824a:	4613      	mov	r3, r2
 800824c:	2201      	movs	r2, #1
 800824e:	f7ff fdbb 	bl	8007dc8 <HTS221_ReadReg>
}
 8008252:	f1a0 0001 	sub.w	r0, r0, #1
 8008256:	fab0 f080 	clz	r0, r0
 800825a:	0940      	lsrs	r0, r0, #5
 800825c:	bd08      	pop	{r3, pc}
 800825e:	bf00      	nop

08008260 <HTS221_T_Read_Reg>:
 8008260:	f7ff bff2 	b.w	8008248 <HTS221_H_Read_Reg>

08008264 <HTS221_H_Set_ODR_Value>:
            : ( odr <= 7.0f ) ? HTS221_ODR_7HZ
 8008264:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8008268:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800826c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 8008270:	b508      	push	{r3, lr}
            : ( odr <= 7.0f ) ? HTS221_ODR_7HZ
 8008272:	d910      	bls.n	8008296 <HTS221_H_Set_ODR_Value+0x32>
 8008274:	eef1 7a0c 	vmov.f32	s15, #28	; 0x40e00000  7.0
 8008278:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800827c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008280:	bf94      	ite	ls
 8008282:	2102      	movls	r1, #2
 8008284:	2103      	movhi	r1, #3
  if ( HTS221_Set_Odr( (void *)handle, new_odr ) == HTS221_ERROR )
 8008286:	f7ff ff6f 	bl	8008168 <HTS221_Set_Odr>
}
 800828a:	f1a0 0001 	sub.w	r0, r0, #1
 800828e:	fab0 f080 	clz	r0, r0
 8008292:	0940      	lsrs	r0, r0, #5
 8008294:	bd08      	pop	{r3, pc}
            : ( odr <= 7.0f ) ? HTS221_ODR_7HZ
 8008296:	2101      	movs	r1, #1
 8008298:	e7f5      	b.n	8008286 <HTS221_H_Set_ODR_Value+0x22>
 800829a:	bf00      	nop

0800829c <HTS221_T_Set_ODR_Value>:
 800829c:	f7ff bfe2 	b.w	8008264 <HTS221_H_Set_ODR_Value>

080082a0 <HTS221_Set_ODR>:
  switch( odr )
 80082a0:	b159      	cbz	r1, 80082ba <HTS221_Set_ODR+0x1a>
 80082a2:	2904      	cmp	r1, #4
 80082a4:	d80b      	bhi.n	80082be <HTS221_Set_ODR+0x1e>
      new_odr = HTS221_ODR_12_5HZ;
 80082a6:	2103      	movs	r1, #3
{
 80082a8:	b508      	push	{r3, lr}
  if ( HTS221_Set_Odr( (void *)handle, new_odr ) == HTS221_ERROR )
 80082aa:	f7ff ff5d 	bl	8008168 <HTS221_Set_Odr>
      return COMPONENT_ERROR;
 80082ae:	f1a0 0001 	sub.w	r0, r0, #1
 80082b2:	fab0 f080 	clz	r0, r0
 80082b6:	0940      	lsrs	r0, r0, #5
}
 80082b8:	bd08      	pop	{r3, pc}
      new_odr = HTS221_ODR_1HZ;
 80082ba:	2101      	movs	r1, #1
 80082bc:	e7f4      	b.n	80082a8 <HTS221_Set_ODR+0x8>
      return COMPONENT_ERROR;
 80082be:	2001      	movs	r0, #1
}
 80082c0:	4770      	bx	lr
 80082c2:	bf00      	nop

080082c4 <HTS221_H_Set_ODR>:
  return HTS221_Set_ODR( handle, odr );
 80082c4:	f7ff bfec 	b.w	80082a0 <HTS221_Set_ODR>

080082c8 <HTS221_Get_ODR>:
{
 80082c8:	b510      	push	{r4, lr}
 80082ca:	b082      	sub	sp, #8
 80082cc:	460c      	mov	r4, r1
  if ( HTS221_Get_Odr( (void *)handle, &odr_low_level ) == HTS221_ERROR )
 80082ce:	f10d 0107 	add.w	r1, sp, #7
 80082d2:	f7ff fedf 	bl	8008094 <HTS221_Get_Odr>
 80082d6:	2801      	cmp	r0, #1
 80082d8:	d00b      	beq.n	80082f2 <HTS221_Get_ODR+0x2a>
  switch( odr_low_level )
 80082da:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80082de:	2b03      	cmp	r3, #3
 80082e0:	d818      	bhi.n	8008314 <HTS221_Get_ODR+0x4c>
 80082e2:	e8df f003 	tbb	[pc, r3]
 80082e6:	020d      	.short	0x020d
 80082e8:	0812      	.short	0x0812
      *odr =  1.0f;
 80082ea:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 80082ee:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80082f0:	2000      	movs	r0, #0
}
 80082f2:	b002      	add	sp, #8
 80082f4:	bd10      	pop	{r4, pc}
      *odr = 12.5f;
 80082f6:	4b0a      	ldr	r3, [pc, #40]	; (8008320 <HTS221_Get_ODR+0x58>)
 80082f8:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80082fa:	2000      	movs	r0, #0
}
 80082fc:	b002      	add	sp, #8
 80082fe:	bd10      	pop	{r4, pc}
      *odr =  0.0f;
 8008300:	2300      	movs	r3, #0
  return COMPONENT_OK;
 8008302:	2000      	movs	r0, #0
      *odr =  0.0f;
 8008304:	6023      	str	r3, [r4, #0]
}
 8008306:	b002      	add	sp, #8
 8008308:	bd10      	pop	{r4, pc}
      *odr =  7.0f;
 800830a:	4b06      	ldr	r3, [pc, #24]	; (8008324 <HTS221_Get_ODR+0x5c>)
 800830c:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800830e:	2000      	movs	r0, #0
}
 8008310:	b002      	add	sp, #8
 8008312:	bd10      	pop	{r4, pc}
      *odr = -1.0f;
 8008314:	4b04      	ldr	r3, [pc, #16]	; (8008328 <HTS221_Get_ODR+0x60>)
 8008316:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 8008318:	2001      	movs	r0, #1
}
 800831a:	b002      	add	sp, #8
 800831c:	bd10      	pop	{r4, pc}
 800831e:	bf00      	nop
 8008320:	41480000 	.word	0x41480000
 8008324:	40e00000 	.word	0x40e00000
 8008328:	bf800000 	.word	0xbf800000

0800832c <HTS221_H_Get_ODR>:
  return HTS221_Get_ODR( handle, odr );
 800832c:	f7ff bfcc 	b.w	80082c8 <HTS221_Get_ODR>

08008330 <HTS221_H_Get_Hum>:
{
 8008330:	b530      	push	{r4, r5, lr}
 8008332:	b083      	sub	sp, #12
  uint16_t uint16data = 0;
 8008334:	ab02      	add	r3, sp, #8
 8008336:	2400      	movs	r4, #0
 8008338:	f823 4d02 	strh.w	r4, [r3, #-2]!
{
 800833c:	460d      	mov	r5, r1
  if ( HTS221_Get_Humidity( (void *)handle, &uint16data ) == HTS221_ERROR )
 800833e:	4619      	mov	r1, r3
 8008340:	f7ff fd60 	bl	8007e04 <HTS221_Get_Humidity>
 8008344:	2801      	cmp	r0, #1
 8008346:	d00c      	beq.n	8008362 <HTS221_H_Get_Hum+0x32>
  *humidity = ( float )uint16data / 10.0f;
 8008348:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800834c:	ee07 3a90 	vmov	s15, r3
 8008350:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8008354:	eef2 6a04 	vmov.f32	s13, #36	; 0x41200000  10.0
 8008358:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  return COMPONENT_OK;
 800835c:	4620      	mov	r0, r4
  *humidity = ( float )uint16data / 10.0f;
 800835e:	ed85 7a00 	vstr	s14, [r5]
}
 8008362:	b003      	add	sp, #12
 8008364:	bd30      	pop	{r4, r5, pc}
 8008366:	bf00      	nop

08008368 <HTS221_Check_WhoAmI>:
{
 8008368:	b510      	push	{r4, lr}
 800836a:	b082      	sub	sp, #8
  uint8_t who_am_i = 0x00;
 800836c:	a902      	add	r1, sp, #8
 800836e:	2300      	movs	r3, #0
 8008370:	f801 3d01 	strb.w	r3, [r1, #-1]!
{
 8008374:	4604      	mov	r4, r0
  if ( HTS221_Get_DeviceID( (void *)handle, who_am_i ) == HTS221_ERROR )
 8008376:	f7ff fd3b 	bl	8007df0 <HTS221_Get_DeviceID>
 800837a:	2801      	cmp	r0, #1
 800837c:	d005      	beq.n	800838a <HTS221_Check_WhoAmI+0x22>
  if ( who_am_i != handle->who_am_i )
 800837e:	7820      	ldrb	r0, [r4, #0]
 8008380:	f89d 3007 	ldrb.w	r3, [sp, #7]
    return COMPONENT_ERROR;
 8008384:	1ac0      	subs	r0, r0, r3
 8008386:	bf18      	it	ne
 8008388:	2001      	movne	r0, #1
}
 800838a:	b002      	add	sp, #8
 800838c:	bd10      	pop	{r4, pc}
 800838e:	bf00      	nop

08008390 <HTS221_H_Check_WhoAmI>:
  return HTS221_Check_WhoAmI( handle );
 8008390:	f7ff bfea 	b.w	8008368 <HTS221_Check_WhoAmI>

08008394 <HTS221_H_Get_WhoAmI>:
{
 8008394:	b508      	push	{r3, lr}
  if ( HTS221_Get_DeviceID( (void *)handle, who_am_i ) == HTS221_ERROR )
 8008396:	f7ff fd2b 	bl	8007df0 <HTS221_Get_DeviceID>
}
 800839a:	f1a0 0001 	sub.w	r0, r0, #1
 800839e:	fab0 f080 	clz	r0, r0
 80083a2:	0940      	lsrs	r0, r0, #5
 80083a4:	bd08      	pop	{r3, pc}
 80083a6:	bf00      	nop

080083a8 <HTS221_T_Get_WhoAmI>:
 80083a8:	f7ff bff4 	b.w	8008394 <HTS221_H_Get_WhoAmI>

080083ac <HTS221_T_Get_Temp>:
{
 80083ac:	b530      	push	{r4, r5, lr}
 80083ae:	b083      	sub	sp, #12
  int16_t int16data = 0;
 80083b0:	ab02      	add	r3, sp, #8
 80083b2:	2400      	movs	r4, #0
 80083b4:	f823 4d02 	strh.w	r4, [r3, #-2]!
{
 80083b8:	460d      	mov	r5, r1
  if ( HTS221_Get_Temperature( (void *)handle, &int16data ) == HTS221_ERROR )
 80083ba:	4619      	mov	r1, r3
 80083bc:	f7ff fd9e 	bl	8007efc <HTS221_Get_Temperature>
 80083c0:	2801      	cmp	r0, #1
 80083c2:	d00c      	beq.n	80083de <HTS221_T_Get_Temp+0x32>
  *temperature = ( float )int16data / 10.0f;
 80083c4:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 80083c8:	ee07 3a90 	vmov	s15, r3
 80083cc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80083d0:	eef2 6a04 	vmov.f32	s13, #36	; 0x41200000  10.0
 80083d4:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  return COMPONENT_OK;
 80083d8:	4620      	mov	r0, r4
  *temperature = ( float )int16data / 10.0f;
 80083da:	ed85 7a00 	vstr	s14, [r5]
}
 80083de:	b003      	add	sp, #12
 80083e0:	bd30      	pop	{r4, r5, pc}
 80083e2:	bf00      	nop

080083e4 <HTS221_H_Sensor_Disable>:
  if ( handle->isEnabled == 0 )
 80083e4:	7983      	ldrb	r3, [r0, #6]
 80083e6:	b15b      	cbz	r3, 8008400 <HTS221_H_Sensor_Disable+0x1c>
  if((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled == 0))
 80083e8:	6883      	ldr	r3, [r0, #8]
{
 80083ea:	b510      	push	{r4, lr}
  if((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled == 0))
 80083ec:	681b      	ldr	r3, [r3, #0]
 80083ee:	681a      	ldr	r2, [r3, #0]
 80083f0:	78d3      	ldrb	r3, [r2, #3]
 80083f2:	4604      	mov	r4, r0
 80083f4:	b133      	cbz	r3, 8008404 <HTS221_H_Sensor_Disable+0x20>
  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled = 0;
 80083f6:	2300      	movs	r3, #0
 80083f8:	7093      	strb	r3, [r2, #2]
  handle->isEnabled = 0;
 80083fa:	4618      	mov	r0, r3
 80083fc:	71a3      	strb	r3, [r4, #6]
}
 80083fe:	bd10      	pop	{r4, pc}
    return COMPONENT_OK;
 8008400:	4618      	mov	r0, r3
}
 8008402:	4770      	bx	lr
  if ( HTS221_DeActivate( (void *)handle ) == HTS221_ERROR )
 8008404:	f7ff fe26 	bl	8008054 <HTS221_DeActivate>
 8008408:	2801      	cmp	r0, #1
 800840a:	d0f8      	beq.n	80083fe <HTS221_H_Sensor_Disable+0x1a>
 800840c:	68a3      	ldr	r3, [r4, #8]
 800840e:	681b      	ldr	r3, [r3, #0]
 8008410:	681a      	ldr	r2, [r3, #0]
  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled = 0;
 8008412:	2300      	movs	r3, #0
 8008414:	7093      	strb	r3, [r2, #2]
  handle->isEnabled = 0;
 8008416:	4618      	mov	r0, r3
 8008418:	71a3      	strb	r3, [r4, #6]
 800841a:	e7f0      	b.n	80083fe <HTS221_H_Sensor_Disable+0x1a>

0800841c <HTS221_H_DeInit>:
  if ((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized == 0))
 800841c:	6883      	ldr	r3, [r0, #8]
{
 800841e:	b510      	push	{r4, lr}
  if ((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized == 0))
 8008420:	681b      	ldr	r3, [r3, #0]
 8008422:	681a      	ldr	r2, [r3, #0]
 8008424:	7853      	ldrb	r3, [r2, #1]
{
 8008426:	4604      	mov	r4, r0
  if ((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized == 0))
 8008428:	b123      	cbz	r3, 8008434 <HTS221_H_DeInit+0x18>
  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized = 0;
 800842a:	2300      	movs	r3, #0
 800842c:	7013      	strb	r3, [r2, #0]
  return COMPONENT_OK;
 800842e:	4618      	mov	r0, r3
  handle->isInitialized = 0;
 8008430:	7163      	strb	r3, [r4, #5]
}
 8008432:	bd10      	pop	{r4, pc}
    if(HTS221_H_Sensor_Disable(handle) == COMPONENT_ERROR)
 8008434:	f7ff ffd6 	bl	80083e4 <HTS221_H_Sensor_Disable>
 8008438:	2801      	cmp	r0, #1
 800843a:	d0fa      	beq.n	8008432 <HTS221_H_DeInit+0x16>
 800843c:	68a3      	ldr	r3, [r4, #8]
 800843e:	681b      	ldr	r3, [r3, #0]
 8008440:	681a      	ldr	r2, [r3, #0]
 8008442:	e7f2      	b.n	800842a <HTS221_H_DeInit+0xe>

08008444 <HTS221_T_Sensor_Disable>:
  if ( handle->isEnabled == 0 )
 8008444:	7983      	ldrb	r3, [r0, #6]
 8008446:	b15b      	cbz	r3, 8008460 <HTS221_T_Sensor_Disable+0x1c>
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled == 0))
 8008448:	6883      	ldr	r3, [r0, #8]
{
 800844a:	b510      	push	{r4, lr}
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled == 0))
 800844c:	681b      	ldr	r3, [r3, #0]
 800844e:	681a      	ldr	r2, [r3, #0]
 8008450:	7893      	ldrb	r3, [r2, #2]
 8008452:	4604      	mov	r4, r0
 8008454:	b133      	cbz	r3, 8008464 <HTS221_T_Sensor_Disable+0x20>
  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled = 0;
 8008456:	2300      	movs	r3, #0
 8008458:	70d3      	strb	r3, [r2, #3]
  handle->isEnabled = 0;
 800845a:	4618      	mov	r0, r3
 800845c:	71a3      	strb	r3, [r4, #6]
}
 800845e:	bd10      	pop	{r4, pc}
    return COMPONENT_OK;
 8008460:	4618      	mov	r0, r3
}
 8008462:	4770      	bx	lr
  if ( HTS221_DeActivate( (void *)handle ) == HTS221_ERROR )
 8008464:	f7ff fdf6 	bl	8008054 <HTS221_DeActivate>
 8008468:	2801      	cmp	r0, #1
 800846a:	d0f8      	beq.n	800845e <HTS221_T_Sensor_Disable+0x1a>
 800846c:	68a3      	ldr	r3, [r4, #8]
 800846e:	681b      	ldr	r3, [r3, #0]
 8008470:	681a      	ldr	r2, [r3, #0]
  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled = 0;
 8008472:	2300      	movs	r3, #0
 8008474:	70d3      	strb	r3, [r2, #3]
  handle->isEnabled = 0;
 8008476:	4618      	mov	r0, r3
 8008478:	71a3      	strb	r3, [r4, #6]
 800847a:	e7f0      	b.n	800845e <HTS221_T_Sensor_Disable+0x1a>

0800847c <HTS221_T_DeInit>:
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized == 0))
 800847c:	6883      	ldr	r3, [r0, #8]
{
 800847e:	b510      	push	{r4, lr}
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized == 0))
 8008480:	681b      	ldr	r3, [r3, #0]
 8008482:	681a      	ldr	r2, [r3, #0]
 8008484:	7813      	ldrb	r3, [r2, #0]
{
 8008486:	4604      	mov	r4, r0
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized == 0))
 8008488:	b123      	cbz	r3, 8008494 <HTS221_T_DeInit+0x18>
  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized = 0;
 800848a:	2300      	movs	r3, #0
 800848c:	7053      	strb	r3, [r2, #1]
  return COMPONENT_OK;
 800848e:	4618      	mov	r0, r3
  handle->isInitialized = 0;
 8008490:	7163      	strb	r3, [r4, #5]
}
 8008492:	bd10      	pop	{r4, pc}
    if(HTS221_T_Sensor_Disable(handle) == COMPONENT_ERROR)
 8008494:	f7ff ffd6 	bl	8008444 <HTS221_T_Sensor_Disable>
 8008498:	2801      	cmp	r0, #1
 800849a:	d0fa      	beq.n	8008492 <HTS221_T_DeInit+0x16>
 800849c:	68a3      	ldr	r3, [r4, #8]
 800849e:	681b      	ldr	r3, [r3, #0]
 80084a0:	681a      	ldr	r2, [r3, #0]
 80084a2:	e7f2      	b.n	800848a <HTS221_T_DeInit+0xe>

080084a4 <HTS221_H_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 80084a4:	7982      	ldrb	r2, [r0, #6]
 80084a6:	2a01      	cmp	r2, #1
 80084a8:	d017      	beq.n	80084da <HTS221_H_Sensor_Enable+0x36>
  if((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled == 0))
 80084aa:	6883      	ldr	r3, [r0, #8]
{
 80084ac:	b510      	push	{r4, lr}
  if((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled == 0))
 80084ae:	681b      	ldr	r3, [r3, #0]
 80084b0:	681b      	ldr	r3, [r3, #0]
 80084b2:	78da      	ldrb	r2, [r3, #3]
 80084b4:	4604      	mov	r4, r0
 80084b6:	b122      	cbz	r2, 80084c2 <HTS221_H_Sensor_Enable+0x1e>
  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled = 1;
 80084b8:	2201      	movs	r2, #1
 80084ba:	709a      	strb	r2, [r3, #2]
  handle->isEnabled = 1;
 80084bc:	2000      	movs	r0, #0
 80084be:	71a2      	strb	r2, [r4, #6]
}
 80084c0:	bd10      	pop	{r4, pc}
  if ( HTS221_Activate( (void *)handle ) == HTS221_ERROR )
 80084c2:	f7ff fda7 	bl	8008014 <HTS221_Activate>
 80084c6:	2801      	cmp	r0, #1
 80084c8:	d0fa      	beq.n	80084c0 <HTS221_H_Sensor_Enable+0x1c>
 80084ca:	68a3      	ldr	r3, [r4, #8]
 80084cc:	681b      	ldr	r3, [r3, #0]
 80084ce:	681b      	ldr	r3, [r3, #0]
  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled = 1;
 80084d0:	2201      	movs	r2, #1
 80084d2:	709a      	strb	r2, [r3, #2]
  handle->isEnabled = 1;
 80084d4:	2000      	movs	r0, #0
 80084d6:	71a2      	strb	r2, [r4, #6]
 80084d8:	e7f2      	b.n	80084c0 <HTS221_H_Sensor_Enable+0x1c>
    return COMPONENT_OK;
 80084da:	2000      	movs	r0, #0
}
 80084dc:	4770      	bx	lr
 80084de:	bf00      	nop

080084e0 <HTS221_T_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 80084e0:	7982      	ldrb	r2, [r0, #6]
 80084e2:	2a01      	cmp	r2, #1
 80084e4:	d017      	beq.n	8008516 <HTS221_T_Sensor_Enable+0x36>
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled == 0))
 80084e6:	6883      	ldr	r3, [r0, #8]
{
 80084e8:	b510      	push	{r4, lr}
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled == 0))
 80084ea:	681b      	ldr	r3, [r3, #0]
 80084ec:	681b      	ldr	r3, [r3, #0]
 80084ee:	789a      	ldrb	r2, [r3, #2]
 80084f0:	4604      	mov	r4, r0
 80084f2:	b122      	cbz	r2, 80084fe <HTS221_T_Sensor_Enable+0x1e>
  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled = 1;
 80084f4:	2201      	movs	r2, #1
 80084f6:	70da      	strb	r2, [r3, #3]
  handle->isEnabled = 1;
 80084f8:	2000      	movs	r0, #0
 80084fa:	71a2      	strb	r2, [r4, #6]
}
 80084fc:	bd10      	pop	{r4, pc}
  if ( HTS221_Activate( (void *)handle ) == HTS221_ERROR )
 80084fe:	f7ff fd89 	bl	8008014 <HTS221_Activate>
 8008502:	2801      	cmp	r0, #1
 8008504:	d0fa      	beq.n	80084fc <HTS221_T_Sensor_Enable+0x1c>
 8008506:	68a3      	ldr	r3, [r4, #8]
 8008508:	681b      	ldr	r3, [r3, #0]
 800850a:	681b      	ldr	r3, [r3, #0]
  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled = 1;
 800850c:	2201      	movs	r2, #1
 800850e:	70da      	strb	r2, [r3, #3]
  handle->isEnabled = 1;
 8008510:	2000      	movs	r0, #0
 8008512:	71a2      	strb	r2, [r4, #6]
 8008514:	e7f2      	b.n	80084fc <HTS221_T_Sensor_Enable+0x1c>
    return COMPONENT_OK;
 8008516:	2000      	movs	r0, #0
}
 8008518:	4770      	bx	lr
 800851a:	bf00      	nop

0800851c <HTS221_Init>:
{
 800851c:	b510      	push	{r4, lr}
 800851e:	4604      	mov	r4, r0
  if ( HTS221_Check_WhoAmI( handle ) == COMPONENT_ERROR )
 8008520:	f7ff ff22 	bl	8008368 <HTS221_Check_WhoAmI>
 8008524:	2801      	cmp	r0, #1
 8008526:	d014      	beq.n	8008552 <HTS221_Init+0x36>
  if ( HTS221_DeActivate( (void *)handle ) == HTS221_ERROR )
 8008528:	4620      	mov	r0, r4
 800852a:	f7ff fd93 	bl	8008054 <HTS221_DeActivate>
 800852e:	2801      	cmp	r0, #1
 8008530:	d00f      	beq.n	8008552 <HTS221_Init+0x36>
  if ( HTS221_Set_BduMode( (void *)handle, HTS221_ENABLE ) == HTS221_ERROR )
 8008532:	2101      	movs	r1, #1
 8008534:	4620      	mov	r0, r4
 8008536:	f7ff fdeb 	bl	8008110 <HTS221_Set_BduMode>
 800853a:	2801      	cmp	r0, #1
 800853c:	d009      	beq.n	8008552 <HTS221_Init+0x36>
  if ( HTS221_Set_Odr( (void *)handle, new_odr ) == HTS221_ERROR )
 800853e:	4620      	mov	r0, r4
 8008540:	2101      	movs	r1, #1
 8008542:	f7ff fe11 	bl	8008168 <HTS221_Set_Odr>
    return COMPONENT_ERROR;
 8008546:	f1a0 0001 	sub.w	r0, r0, #1
 800854a:	fab0 f080 	clz	r0, r0
 800854e:	0940      	lsrs	r0, r0, #5
}
 8008550:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 8008552:	2001      	movs	r0, #1
}
 8008554:	bd10      	pop	{r4, pc}
 8008556:	bf00      	nop

08008558 <HTS221_H_Init>:
  if ((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized == 0))
 8008558:	6883      	ldr	r3, [r0, #8]
{
 800855a:	b510      	push	{r4, lr}
  if ((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized == 0))
 800855c:	681b      	ldr	r3, [r3, #0]
 800855e:	681b      	ldr	r3, [r3, #0]
 8008560:	785a      	ldrb	r2, [r3, #1]
{
 8008562:	4604      	mov	r4, r0
  if ((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized == 0))
 8008564:	b122      	cbz	r2, 8008570 <HTS221_H_Init+0x18>
  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized = 1;
 8008566:	2201      	movs	r2, #1
 8008568:	701a      	strb	r2, [r3, #0]
  return COMPONENT_OK;
 800856a:	2000      	movs	r0, #0
  handle->isInitialized = 1;
 800856c:	7162      	strb	r2, [r4, #5]
}
 800856e:	bd10      	pop	{r4, pc}
    if(HTS221_Init(handle) == COMPONENT_ERROR)
 8008570:	f7ff ffd4 	bl	800851c <HTS221_Init>
 8008574:	2801      	cmp	r0, #1
 8008576:	d0fa      	beq.n	800856e <HTS221_H_Init+0x16>
 8008578:	68a3      	ldr	r3, [r4, #8]
 800857a:	681b      	ldr	r3, [r3, #0]
 800857c:	681b      	ldr	r3, [r3, #0]
 800857e:	e7f2      	b.n	8008566 <HTS221_H_Init+0xe>

08008580 <HTS221_T_Init>:
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized == 0))
 8008580:	6883      	ldr	r3, [r0, #8]
{
 8008582:	b510      	push	{r4, lr}
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized == 0))
 8008584:	681b      	ldr	r3, [r3, #0]
 8008586:	681b      	ldr	r3, [r3, #0]
 8008588:	781a      	ldrb	r2, [r3, #0]
{
 800858a:	4604      	mov	r4, r0
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized == 0))
 800858c:	b122      	cbz	r2, 8008598 <HTS221_T_Init+0x18>
  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized = 1;
 800858e:	2201      	movs	r2, #1
 8008590:	705a      	strb	r2, [r3, #1]
  return COMPONENT_OK;
 8008592:	2000      	movs	r0, #0
  handle->isInitialized = 1;
 8008594:	7162      	strb	r2, [r4, #5]
}
 8008596:	bd10      	pop	{r4, pc}
    if(HTS221_Init(handle) == COMPONENT_ERROR)
 8008598:	f7ff ffc0 	bl	800851c <HTS221_Init>
 800859c:	2801      	cmp	r0, #1
 800859e:	d0fa      	beq.n	8008596 <HTS221_T_Init+0x16>
 80085a0:	68a3      	ldr	r3, [r4, #8]
 80085a2:	681b      	ldr	r3, [r3, #0]
 80085a4:	681b      	ldr	r3, [r3, #0]
 80085a6:	e7f2      	b.n	800858e <HTS221_T_Init+0xe>

080085a8 <HTS221_T_Set_ODR>:
 80085a8:	f7ff be7a 	b.w	80082a0 <HTS221_Set_ODR>

080085ac <HTS221_T_Check_WhoAmI>:
 80085ac:	f7ff bedc 	b.w	8008368 <HTS221_Check_WhoAmI>

080085b0 <HTS221_T_Get_ODR>:
 80085b0:	f7ff be8a 	b.w	80082c8 <HTS221_Get_ODR>

080085b4 <LPS22HB_ReadReg>:
* Input       : Register Address
* Output      : Data Read
* Return      : None
*******************************************************************************/
LPS22HB_Error_et LPS22HB_ReadReg( void *handle, uint8_t RegAddr, uint16_t NumByteToRead, uint8_t *Data )
{
 80085b4:	b510      	push	{r4, lr}
 80085b6:	461c      	mov	r4, r3
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80085b8:	4613      	mov	r3, r2
 80085ba:	4622      	mov	r2, r4
 80085bc:	f006 f840 	bl	800e640 <Sensor_IO_Read>
    return LPS22HB_ERROR;
  else
    return LPS22HB_OK;
}
 80085c0:	3000      	adds	r0, #0
 80085c2:	bf18      	it	ne
 80085c4:	2001      	movne	r0, #1
 80085c6:	bd10      	pop	{r4, pc}

080085c8 <LPS22HB_WriteReg>:
* Input       : Register Address, Data to be written
* Output      : None
* Return      : None
*******************************************************************************/
LPS22HB_Error_et LPS22HB_WriteReg( void *handle, uint8_t RegAddr, uint16_t NumByteToWrite, uint8_t *Data )
{
 80085c8:	b510      	push	{r4, lr}
 80085ca:	461c      	mov	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80085cc:	4613      	mov	r3, r2
 80085ce:	4622      	mov	r2, r4
 80085d0:	f005 ff48 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
  else
    return LPS22HB_OK;
}
 80085d4:	3000      	adds	r0, #0
 80085d6:	bf18      	it	ne
 80085d8:	2001      	movne	r0, #1
 80085da:	bd10      	pop	{r4, pc}

080085dc <LPS22HB_Get_DeviceID>:
* @param  *handle Device handle.
* @param  Buffer to empty by Device identification Value.
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_DeviceID(void *handle, uint8_t* deviceid)
{
 80085dc:	b508      	push	{r3, lr}
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80085de:	460a      	mov	r2, r1
 80085e0:	2301      	movs	r3, #1
 80085e2:	210f      	movs	r1, #15
 80085e4:	f006 f82c 	bl	800e640 <Sensor_IO_Read>
  if(LPS22HB_ReadReg(handle, LPS22HB_WHO_AM_I_REG, 1, deviceid))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 80085e8:	3000      	adds	r0, #0
 80085ea:	bf18      	it	ne
 80085ec:	2001      	movne	r0, #1
 80085ee:	bd08      	pop	{r3, pc}

080085f0 <LPS22HB_Set_PowerMode>:
* @param  *handle Device handle.
* @param  LPS22HB_LowNoise or LPS22HB_LowPower mode
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_PowerMode(void *handle, LPS22HB_PowerMode_et mode)
{
 80085f0:	b530      	push	{r4, r5, lr}
 80085f2:	b083      	sub	sp, #12
 80085f4:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80085f6:	f10d 0207 	add.w	r2, sp, #7
 80085fa:	2301      	movs	r3, #1
 80085fc:	211a      	movs	r1, #26
{
 80085fe:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008600:	f006 f81e 	bl	800e640 <Sensor_IO_Read>
 8008604:	b110      	cbz	r0, 800860c <LPS22HB_Set_PowerMode+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_PowerMode(mode));

  if(LPS22HB_ReadReg(handle, LPS22HB_RES_CONF_REG, 1, &tmp))
    return LPS22HB_ERROR;
 8008606:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_RES_CONF_REG, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 8008608:	b003      	add	sp, #12
 800860a:	bd30      	pop	{r4, r5, pc}
  tmp &= ~LPS22HB_LCEN_MASK;
 800860c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8008610:	f023 0301 	bic.w	r3, r3, #1
  tmp |= (uint8_t)mode;
 8008614:	431c      	orrs	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008616:	f10d 0207 	add.w	r2, sp, #7
 800861a:	4628      	mov	r0, r5
 800861c:	2301      	movs	r3, #1
 800861e:	211a      	movs	r1, #26
  tmp |= (uint8_t)mode;
 8008620:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008624:	f005 ff1e 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 8008628:	3000      	adds	r0, #0
 800862a:	bf18      	it	ne
 800862c:	2001      	movne	r0, #1
}
 800862e:	b003      	add	sp, #12
 8008630:	bd30      	pop	{r4, r5, pc}
 8008632:	bf00      	nop

08008634 <LPS22HB_Set_Odr>:
* @param  *handle Device handle.
* @param  Output Data Rate
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_Odr(void *handle, LPS22HB_Odr_et odr)
{
 8008634:	b530      	push	{r4, r5, lr}
 8008636:	b083      	sub	sp, #12
 8008638:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800863a:	f10d 0207 	add.w	r2, sp, #7
 800863e:	2301      	movs	r3, #1
 8008640:	2110      	movs	r1, #16
{
 8008642:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008644:	f005 fffc 	bl	800e640 <Sensor_IO_Read>
 8008648:	b110      	cbz	r0, 8008650 <LPS22HB_Set_Odr+0x1c>


  LPS22HB_assert_param(IS_LPS22HB_ODR(odr));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_ERROR;
 800864a:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 800864c:	b003      	add	sp, #12
 800864e:	bd30      	pop	{r4, r5, pc}
  tmp &= ~LPS22HB_ODR_MASK;
 8008650:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8008654:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmp |= (uint8_t)odr;
 8008658:	431c      	orrs	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800865a:	f10d 0207 	add.w	r2, sp, #7
 800865e:	4628      	mov	r0, r5
 8008660:	2301      	movs	r3, #1
 8008662:	2110      	movs	r1, #16
  tmp |= (uint8_t)odr;
 8008664:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008668:	f005 fefc 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 800866c:	3000      	adds	r0, #0
 800866e:	bf18      	it	ne
 8008670:	2001      	movne	r0, #1
}
 8008672:	b003      	add	sp, #12
 8008674:	bd30      	pop	{r4, r5, pc}
 8008676:	bf00      	nop

08008678 <LPS22HB_Get_Odr>:
* @param  *handle Device handle.
* @param  Buffer to empty with Output Data Rate
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_Odr(void *handle, LPS22HB_Odr_et* odr)
{
 8008678:	b510      	push	{r4, lr}
 800867a:	b082      	sub	sp, #8
 800867c:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800867e:	2301      	movs	r3, #1
 8008680:	f10d 0207 	add.w	r2, sp, #7
 8008684:	2110      	movs	r1, #16
 8008686:	f005 ffdb 	bl	800e640 <Sensor_IO_Read>
 800868a:	b930      	cbnz	r0, 800869a <LPS22HB_Get_Odr+0x22>
  uint8_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_ERROR;

  *odr = (LPS22HB_Odr_et)(tmp & LPS22HB_ODR_MASK);
 800868c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8008690:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8008694:	7023      	strb	r3, [r4, #0]

  return LPS22HB_OK;
}
 8008696:	b002      	add	sp, #8
 8008698:	bd10      	pop	{r4, pc}
    return LPS22HB_ERROR;
 800869a:	2001      	movs	r0, #1
}
 800869c:	b002      	add	sp, #8
 800869e:	bd10      	pop	{r4, pc}

080086a0 <LPS22HB_Set_LowPassFilter>:
* @param  *handle Device handle.
* @param  state: enable or disable
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_LowPassFilter(void *handle, LPS22HB_State_et state)
{
 80086a0:	b570      	push	{r4, r5, r6, lr}
 80086a2:	b082      	sub	sp, #8
 80086a4:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80086a6:	f10d 0207 	add.w	r2, sp, #7
 80086aa:	2301      	movs	r3, #1
 80086ac:	2110      	movs	r1, #16
{
 80086ae:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80086b0:	f005 ffc6 	bl	800e640 <Sensor_IO_Read>
 80086b4:	b110      	cbz	r0, 80086bc <LPS22HB_Set_LowPassFilter+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(state));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_ERROR;
 80086b6:	2001      	movs	r0, #1
  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_ERROR;


  return LPS22HB_OK;
}
 80086b8:	b002      	add	sp, #8
 80086ba:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_LPFP_MASK;
 80086bc:	f89d 4007 	ldrb.w	r4, [sp, #7]
 80086c0:	f024 0408 	bic.w	r4, r4, #8
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80086c4:	f10d 0207 	add.w	r2, sp, #7
 80086c8:	4630      	mov	r0, r6
  tmp |= ((uint8_t)state) << LPS22HB_LPFP_BIT;
 80086ca:	ea44 04c5 	orr.w	r4, r4, r5, lsl #3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80086ce:	2301      	movs	r3, #1
 80086d0:	2110      	movs	r1, #16
  tmp |= ((uint8_t)state) << LPS22HB_LPFP_BIT;
 80086d2:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80086d6:	f005 fec5 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 80086da:	3000      	adds	r0, #0
 80086dc:	bf18      	it	ne
 80086de:	2001      	movne	r0, #1
}
 80086e0:	b002      	add	sp, #8
 80086e2:	bd70      	pop	{r4, r5, r6, pc}

080086e4 <LPS22HB_Set_LowPassFilterCutoff>:
* @param  *handle Device handle.
* @param  Filter Cutoff ODR/9 or ODR/20
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_LowPassFilterCutoff(void *handle, LPS22HB_LPF_Cutoff_et cutoff)
{
 80086e4:	b530      	push	{r4, r5, lr}
 80086e6:	b083      	sub	sp, #12
 80086e8:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80086ea:	f10d 0207 	add.w	r2, sp, #7
 80086ee:	2301      	movs	r3, #1
 80086f0:	2110      	movs	r1, #16
{
 80086f2:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80086f4:	f005 ffa4 	bl	800e640 <Sensor_IO_Read>
 80086f8:	b110      	cbz	r0, 8008700 <LPS22HB_Set_LowPassFilterCutoff+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_LPF_Cutoff(cutoff));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_ERROR;
 80086fa:	2001      	movs	r0, #1
    return LPS22HB_ERROR;


  return LPS22HB_OK;

}
 80086fc:	b003      	add	sp, #12
 80086fe:	bd30      	pop	{r4, r5, pc}
  tmp &= ~LPS22HB_LPFP_CUTOFF_MASK;
 8008700:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8008704:	f023 0304 	bic.w	r3, r3, #4
  tmp |= (uint8_t)cutoff;
 8008708:	431c      	orrs	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800870a:	f10d 0207 	add.w	r2, sp, #7
 800870e:	4628      	mov	r0, r5
 8008710:	2301      	movs	r3, #1
 8008712:	2110      	movs	r1, #16
  tmp |= (uint8_t)cutoff;
 8008714:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008718:	f005 fea4 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 800871c:	3000      	adds	r0, #0
 800871e:	bf18      	it	ne
 8008720:	2001      	movne	r0, #1
}
 8008722:	b003      	add	sp, #12
 8008724:	bd30      	pop	{r4, r5, pc}
 8008726:	bf00      	nop

08008728 <LPS22HB_Set_Bdu>:
* @param  LPS22HB_BDU_CONTINUOUS_UPDATE, LPS22HB_BDU_NO_UPDATE
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/

LPS22HB_Error_et LPS22HB_Set_Bdu(void *handle, LPS22HB_Bdu_et bdu)
{
 8008728:	b570      	push	{r4, r5, r6, lr}
 800872a:	b082      	sub	sp, #8
 800872c:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800872e:	f10d 0207 	add.w	r2, sp, #7
 8008732:	2301      	movs	r3, #1
 8008734:	2110      	movs	r1, #16
{
 8008736:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008738:	f005 ff82 	bl	800e640 <Sensor_IO_Read>
 800873c:	b110      	cbz	r0, 8008744 <LPS22HB_Set_Bdu+0x1c>


  LPS22HB_assert_param(IS_LPS22HB_BDUMode(bdu));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_ERROR;
 800873e:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_OK;

  return LPS22HB_OK;
}
 8008740:	b002      	add	sp, #8
 8008742:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_BDU_MASK;
 8008744:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8008748:	f023 0302 	bic.w	r3, r3, #2
 800874c:	4604      	mov	r4, r0
  tmp |= ((uint8_t)bdu);
 800874e:	431d      	orrs	r5, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008750:	f10d 0207 	add.w	r2, sp, #7
 8008754:	4630      	mov	r0, r6
 8008756:	2301      	movs	r3, #1
 8008758:	2110      	movs	r1, #16
  tmp |= ((uint8_t)bdu);
 800875a:	f88d 5007 	strb.w	r5, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800875e:	f005 fe81 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_OK;
 8008762:	4620      	mov	r0, r4
}
 8008764:	b002      	add	sp, #8
 8008766:	bd70      	pop	{r4, r5, r6, pc}

08008768 <LPS22HB_SwResetAndMemoryBoot>:
 + and BOOT is set to 1; Self-clearing upon completion.
* @param  *handle Device handle.
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_SwResetAndMemoryBoot(void *handle)
{
 8008768:	b530      	push	{r4, r5, lr}
 800876a:	b083      	sub	sp, #12
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800876c:	f10d 0207 	add.w	r2, sp, #7
 8008770:	2301      	movs	r3, #1
 8008772:	2111      	movs	r1, #17
{
 8008774:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008776:	f005 ff63 	bl	800e640 <Sensor_IO_Read>
 800877a:	b110      	cbz	r0, 8008782 <LPS22HB_SwResetAndMemoryBoot+0x1a>
  uint8_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;
 800877c:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 800877e:	b003      	add	sp, #12
 8008780:	bd30      	pop	{r4, r5, pc}
  tmp |= ((0x01 << LPS22HB_SW_RESET_BIT) | (0x01 << LPS22HB_BOOT_BIT));
 8008782:	f89d 4007 	ldrb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008786:	f10d 0207 	add.w	r2, sp, #7
 800878a:	4628      	mov	r0, r5
  tmp |= ((0x01 << LPS22HB_SW_RESET_BIT) | (0x01 << LPS22HB_BOOT_BIT));
 800878c:	f064 047b 	orn	r4, r4, #123	; 0x7b
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008790:	2301      	movs	r3, #1
 8008792:	2111      	movs	r1, #17
  tmp |= ((0x01 << LPS22HB_SW_RESET_BIT) | (0x01 << LPS22HB_BOOT_BIT));
 8008794:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008798:	f005 fe64 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 800879c:	3000      	adds	r0, #0
 800879e:	bf18      	it	ne
 80087a0:	2001      	movne	r0, #1
}
 80087a2:	b003      	add	sp, #12
 80087a4:	bd30      	pop	{r4, r5, pc}
 80087a6:	bf00      	nop

080087a8 <LPS22HB_Set_FifoModeUse>:
* @param  *handle Device handle.
* @param LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FifoModeUse(void *handle, LPS22HB_State_et status)
{
 80087a8:	b570      	push	{r4, r5, r6, lr}
 80087aa:	b082      	sub	sp, #8
 80087ac:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80087ae:	f10d 0207 	add.w	r2, sp, #7
 80087b2:	2301      	movs	r3, #1
 80087b4:	2111      	movs	r1, #17
{
 80087b6:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80087b8:	f005 ff42 	bl	800e640 <Sensor_IO_Read>
 80087bc:	b110      	cbz	r0, 80087c4 <LPS22HB_Set_FifoModeUse+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;
 80087be:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 80087c0:	b002      	add	sp, #8
 80087c2:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_FIFO_EN_MASK;
 80087c4:	f89d 4007 	ldrb.w	r4, [sp, #7]
 80087c8:	f024 0440 	bic.w	r4, r4, #64	; 0x40
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80087cc:	f10d 0207 	add.w	r2, sp, #7
 80087d0:	4630      	mov	r0, r6
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_EN_BIT;
 80087d2:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80087d6:	2301      	movs	r3, #1
 80087d8:	2111      	movs	r1, #17
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_EN_BIT;
 80087da:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80087de:	f005 fe41 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 80087e2:	3000      	adds	r0, #0
 80087e4:	bf18      	it	ne
 80087e6:	2001      	movne	r0, #1
}
 80087e8:	b002      	add	sp, #8
 80087ea:	bd70      	pop	{r4, r5, r6, pc}

080087ec <LPS22HB_Set_FifoWatermarkLevelUse>:
* @param  *handle Device handle.
* @param   LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FifoWatermarkLevelUse(void *handle, LPS22HB_State_et status)
{
 80087ec:	b570      	push	{r4, r5, r6, lr}
 80087ee:	b082      	sub	sp, #8
 80087f0:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80087f2:	f10d 0207 	add.w	r2, sp, #7
 80087f6:	2301      	movs	r3, #1
 80087f8:	2111      	movs	r1, #17
{
 80087fa:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80087fc:	f005 ff20 	bl	800e640 <Sensor_IO_Read>
 8008800:	b110      	cbz	r0, 8008808 <LPS22HB_Set_FifoWatermarkLevelUse+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;
 8008802:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 8008804:	b002      	add	sp, #8
 8008806:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_WTM_EN_MASK;
 8008808:	f89d 4007 	ldrb.w	r4, [sp, #7]
 800880c:	f024 0420 	bic.w	r4, r4, #32
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008810:	f10d 0207 	add.w	r2, sp, #7
 8008814:	4630      	mov	r0, r6
  tmp |= ((uint8_t)status) << LPS22HB_WTM_EN_BIT;
 8008816:	ea44 1445 	orr.w	r4, r4, r5, lsl #5
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800881a:	2301      	movs	r3, #1
 800881c:	2111      	movs	r1, #17
  tmp |= ((uint8_t)status) << LPS22HB_WTM_EN_BIT;
 800881e:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008822:	f005 fe1f 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 8008826:	3000      	adds	r0, #0
 8008828:	bf18      	it	ne
 800882a:	2001      	movne	r0, #1
}
 800882c:	b002      	add	sp, #8
 800882e:	bd70      	pop	{r4, r5, r6, pc}

08008830 <LPS22HB_Set_AutomaticIncrementRegAddress>:
* @param  *handle Device handle.
* @param  LPS22HB_ENABLE/LPS22HB_DISABLE. Default is LPS22HB_ENABLE
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_AutomaticIncrementRegAddress(void *handle, LPS22HB_State_et status)
{
 8008830:	b570      	push	{r4, r5, r6, lr}
 8008832:	b082      	sub	sp, #8
 8008834:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008836:	f10d 0207 	add.w	r2, sp, #7
 800883a:	2301      	movs	r3, #1
 800883c:	2111      	movs	r1, #17
{
 800883e:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008840:	f005 fefe 	bl	800e640 <Sensor_IO_Read>
 8008844:	b110      	cbz	r0, 800884c <LPS22HB_Set_AutomaticIncrementRegAddress+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;
 8008846:	2001      	movs	r0, #1
  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;

}
 8008848:	b002      	add	sp, #8
 800884a:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_ADD_INC_MASK;
 800884c:	f89d 4007 	ldrb.w	r4, [sp, #7]
 8008850:	f024 0410 	bic.w	r4, r4, #16
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008854:	f10d 0207 	add.w	r2, sp, #7
 8008858:	4630      	mov	r0, r6
  tmp |= (((uint8_t)status) << LPS22HB_ADD_INC_BIT);
 800885a:	ea44 1405 	orr.w	r4, r4, r5, lsl #4
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800885e:	2301      	movs	r3, #1
 8008860:	2111      	movs	r1, #17
  tmp |= (((uint8_t)status) << LPS22HB_ADD_INC_BIT);
 8008862:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008866:	f005 fdfd 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 800886a:	3000      	adds	r0, #0
 800886c:	bf18      	it	ne
 800886e:	2001      	movne	r0, #1
}
 8008870:	b002      	add	sp, #8
 8008872:	bd70      	pop	{r4, r5, r6, pc}

08008874 <LPS22HB_Set_I2C>:
* @param  *handle Device handle.
* @param State: LPS22HB_ENABLE (reset bit)/ LPS22HB_DISABLE (set bit)
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_I2C(void *handle, LPS22HB_State_et statei2c)
{
 8008874:	b530      	push	{r4, r5, lr}
 8008876:	b083      	sub	sp, #12
 8008878:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800887a:	f10d 0207 	add.w	r2, sp, #7
 800887e:	2301      	movs	r3, #1
 8008880:	2111      	movs	r1, #17
{
 8008882:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008884:	f005 fedc 	bl	800e640 <Sensor_IO_Read>
 8008888:	b110      	cbz	r0, 8008890 <LPS22HB_Set_I2C+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(statei2c));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;
 800888a:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 800888c:	b003      	add	sp, #12
 800888e:	bd30      	pop	{r4, r5, pc}
  tmp &= ~LPS22HB_I2C_MASK;
 8008890:	f89d 3007 	ldrb.w	r3, [sp, #7]
  tmp |= ((uint8_t)~statei2c) << LPS22HB_I2C_BIT;
 8008894:	00e4      	lsls	r4, r4, #3
  tmp &= ~LPS22HB_I2C_MASK;
 8008896:	f023 0308 	bic.w	r3, r3, #8
  tmp |= ((uint8_t)~statei2c) << LPS22HB_I2C_BIT;
 800889a:	f484 64ff 	eor.w	r4, r4, #2040	; 0x7f8
 800889e:	431c      	orrs	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80088a0:	f10d 0207 	add.w	r2, sp, #7
 80088a4:	4628      	mov	r0, r5
 80088a6:	2301      	movs	r3, #1
 80088a8:	2111      	movs	r1, #17
  tmp |= ((uint8_t)~statei2c) << LPS22HB_I2C_BIT;
 80088aa:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80088ae:	f005 fdd9 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 80088b2:	3000      	adds	r0, #0
 80088b4:	bf18      	it	ne
 80088b6:	2001      	movne	r0, #1
}
 80088b8:	b003      	add	sp, #12
 80088ba:	bd30      	pop	{r4, r5, pc}

080088bc <LPS22HB_StartOneShotMeasurement>:
* @detail  Once the measurement is done, ONE_SHOT bit will self-clear.
* @param  *handle Device handle.
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_StartOneShotMeasurement(void *handle)
{
 80088bc:	b530      	push	{r4, r5, lr}
 80088be:	b083      	sub	sp, #12
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80088c0:	f10d 0207 	add.w	r2, sp, #7
 80088c4:	2301      	movs	r3, #1
 80088c6:	2111      	movs	r1, #17
{
 80088c8:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80088ca:	f005 feb9 	bl	800e640 <Sensor_IO_Read>
 80088ce:	b110      	cbz	r0, 80088d6 <LPS22HB_StartOneShotMeasurement+0x1a>
  uint8_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;
 80088d0:	2001      	movs	r0, #1
  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;

}
 80088d2:	b003      	add	sp, #12
 80088d4:	bd30      	pop	{r4, r5, pc}
  tmp |= LPS22HB_ONE_SHOT_MASK;
 80088d6:	f89d 4007 	ldrb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80088da:	f10d 0207 	add.w	r2, sp, #7
 80088de:	4628      	mov	r0, r5
  tmp |= LPS22HB_ONE_SHOT_MASK;
 80088e0:	f044 0401 	orr.w	r4, r4, #1
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80088e4:	2301      	movs	r3, #1
 80088e6:	2111      	movs	r1, #17
  tmp |= LPS22HB_ONE_SHOT_MASK;
 80088e8:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80088ec:	f005 fdba 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 80088f0:	3000      	adds	r0, #0
 80088f2:	bf18      	it	ne
 80088f4:	2001      	movne	r0, #1
}
 80088f6:	b003      	add	sp, #12
 80088f8:	bd30      	pop	{r4, r5, pc}
 80088fa:	bf00      	nop

080088fc <LPS22HB_Set_FIFO_OVR_Interrupt>:
* @param  *handle Device handle.
* @param  LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FIFO_OVR_Interrupt(void *handle, LPS22HB_State_et status)
{
 80088fc:	b570      	push	{r4, r5, r6, lr}
 80088fe:	b082      	sub	sp, #8
 8008900:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008902:	f10d 0207 	add.w	r2, sp, #7
 8008906:	2301      	movs	r3, #1
 8008908:	2112      	movs	r1, #18
{
 800890a:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800890c:	f005 fe98 	bl	800e640 <Sensor_IO_Read>
 8008910:	b110      	cbz	r0, 8008918 <LPS22HB_Set_FIFO_OVR_Interrupt+0x1c>


  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
    return LPS22HB_ERROR;
 8008912:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 8008914:	b002      	add	sp, #8
 8008916:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_FIFO_OVR_MASK;
 8008918:	f89d 4007 	ldrb.w	r4, [sp, #7]
 800891c:	f024 0408 	bic.w	r4, r4, #8
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008920:	f10d 0207 	add.w	r2, sp, #7
 8008924:	4630      	mov	r0, r6
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_OVR_BIT;
 8008926:	ea44 04c5 	orr.w	r4, r4, r5, lsl #3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800892a:	2301      	movs	r3, #1
 800892c:	2112      	movs	r1, #18
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_OVR_BIT;
 800892e:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008932:	f005 fd97 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 8008936:	3000      	adds	r0, #0
 8008938:	bf18      	it	ne
 800893a:	2001      	movne	r0, #1
}
 800893c:	b002      	add	sp, #8
 800893e:	bd70      	pop	{r4, r5, r6, pc}

08008940 <LPS22HB_Set_FIFO_FTH_Interrupt>:
* @param  *handle Device handle.
* @param  LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FIFO_FTH_Interrupt(void *handle, LPS22HB_State_et status)
{
 8008940:	b570      	push	{r4, r5, r6, lr}
 8008942:	b082      	sub	sp, #8
 8008944:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008946:	f10d 0207 	add.w	r2, sp, #7
 800894a:	2301      	movs	r3, #1
 800894c:	2112      	movs	r1, #18
{
 800894e:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008950:	f005 fe76 	bl	800e640 <Sensor_IO_Read>
 8008954:	b110      	cbz	r0, 800895c <LPS22HB_Set_FIFO_FTH_Interrupt+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
    return LPS22HB_ERROR;
 8008956:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 8008958:	b002      	add	sp, #8
 800895a:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_FIFO_FTH_MASK;
 800895c:	f89d 4007 	ldrb.w	r4, [sp, #7]
 8008960:	f024 0410 	bic.w	r4, r4, #16
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008964:	f10d 0207 	add.w	r2, sp, #7
 8008968:	4630      	mov	r0, r6
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_FTH_BIT;
 800896a:	ea44 1405 	orr.w	r4, r4, r5, lsl #4
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800896e:	2301      	movs	r3, #1
 8008970:	2112      	movs	r1, #18
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_FTH_BIT;
 8008972:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008976:	f005 fd75 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 800897a:	3000      	adds	r0, #0
 800897c:	bf18      	it	ne
 800897e:	2001      	movne	r0, #1
}
 8008980:	b002      	add	sp, #8
 8008982:	bd70      	pop	{r4, r5, r6, pc}

08008984 <LPS22HB_Set_FIFO_FULL_Interrupt>:
* @param  *handle Device handle.
* @param  LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FIFO_FULL_Interrupt(void *handle, LPS22HB_State_et status)
{
 8008984:	b570      	push	{r4, r5, r6, lr}
 8008986:	b082      	sub	sp, #8
 8008988:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800898a:	f10d 0207 	add.w	r2, sp, #7
 800898e:	2301      	movs	r3, #1
 8008990:	2112      	movs	r1, #18
{
 8008992:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008994:	f005 fe54 	bl	800e640 <Sensor_IO_Read>
 8008998:	b110      	cbz	r0, 80089a0 <LPS22HB_Set_FIFO_FULL_Interrupt+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
    return LPS22HB_ERROR;
 800899a:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 800899c:	b002      	add	sp, #8
 800899e:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_FIFO_FULL_MASK;
 80089a0:	f89d 4007 	ldrb.w	r4, [sp, #7]
 80089a4:	f024 0420 	bic.w	r4, r4, #32
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80089a8:	f10d 0207 	add.w	r2, sp, #7
 80089ac:	4630      	mov	r0, r6
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_FULL_BIT;
 80089ae:	ea44 1445 	orr.w	r4, r4, r5, lsl #5
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80089b2:	2301      	movs	r3, #1
 80089b4:	2112      	movs	r1, #18
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_FULL_BIT;
 80089b6:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80089ba:	f005 fd53 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 80089be:	3000      	adds	r0, #0
 80089c0:	bf18      	it	ne
 80089c2:	2001      	movne	r0, #1
}
 80089c4:	b002      	add	sp, #8
 80089c6:	bd70      	pop	{r4, r5, r6, pc}

080089c8 <LPS22HB_Get_DataStatus>:
* @param  *handle Device handle.
* @param  Data Status Flag:  TempDataAvailable, TempDataOverrun, PressDataAvailable, PressDataOverrun
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_DataStatus(void *handle, LPS22HB_DataStatus_st* datastatus)
{
 80089c8:	b530      	push	{r4, r5, lr}
 80089ca:	b083      	sub	sp, #12
 80089cc:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80089ce:	2301      	movs	r3, #1
 80089d0:	f10d 0207 	add.w	r2, sp, #7
 80089d4:	2127      	movs	r1, #39	; 0x27
 80089d6:	f005 fe33 	bl	800e640 <Sensor_IO_Read>
 80089da:	b978      	cbnz	r0, 80089fc <LPS22HB_Get_DataStatus+0x34>
  uint8_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_STATUS_REG, 1, &tmp))
    return LPS22HB_ERROR;

  datastatus->PressDataAvailable = (uint8_t)(tmp & LPS22HB_PDA_MASK);
 80089dc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80089e0:	f003 0501 	and.w	r5, r3, #1
  datastatus->TempDataAvailable = (uint8_t)((tmp & LPS22HB_TDA_MASK) >> LPS22HB_PDA_BIT);
 80089e4:	f003 0102 	and.w	r1, r3, #2
  datastatus->TempDataOverrun = (uint8_t)((tmp & LPS22HB_TOR_MASK) >> LPS22HB_TOR_BIT);
 80089e8:	f3c3 1240 	ubfx	r2, r3, #5, #1
  datastatus->PressDataOverrun = (uint8_t)((tmp & LPS22HB_POR_MASK) >> LPS22HB_POR_BIT);
 80089ec:	f3c3 1300 	ubfx	r3, r3, #4, #1
  datastatus->PressDataAvailable = (uint8_t)(tmp & LPS22HB_PDA_MASK);
 80089f0:	7065      	strb	r5, [r4, #1]
  datastatus->TempDataAvailable = (uint8_t)((tmp & LPS22HB_TDA_MASK) >> LPS22HB_PDA_BIT);
 80089f2:	7021      	strb	r1, [r4, #0]
  datastatus->TempDataOverrun = (uint8_t)((tmp & LPS22HB_TOR_MASK) >> LPS22HB_TOR_BIT);
 80089f4:	70a2      	strb	r2, [r4, #2]
  datastatus->PressDataOverrun = (uint8_t)((tmp & LPS22HB_POR_MASK) >> LPS22HB_POR_BIT);
 80089f6:	70e3      	strb	r3, [r4, #3]

  return LPS22HB_OK;
}
 80089f8:	b003      	add	sp, #12
 80089fa:	bd30      	pop	{r4, r5, pc}
    return LPS22HB_ERROR;
 80089fc:	2001      	movs	r0, #1
}
 80089fe:	b003      	add	sp, #12
 8008a00:	bd30      	pop	{r4, r5, pc}
 8008a02:	bf00      	nop

08008a04 <LPS22HB_Get_RawPressure>:
* @param  *handle Device handle.
* @param  The buffer to empty with the pressure raw value
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_RawPressure(void *handle, int32_t *raw_press)
{
 8008a04:	b510      	push	{r4, lr}
 8008a06:	b082      	sub	sp, #8
 8008a08:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008a0a:	2303      	movs	r3, #3
 8008a0c:	aa01      	add	r2, sp, #4
 8008a0e:	2128      	movs	r1, #40	; 0x28
 8008a10:	f005 fe16 	bl	800e640 <Sensor_IO_Read>
 8008a14:	b988      	cbnz	r0, 8008a3a <LPS22HB_Get_RawPressure+0x36>
  if(LPS22HB_ReadReg(handle, LPS22HB_PRESS_OUT_XL_REG, 3, buffer))
    return LPS22HB_ERROR;

  /* Build the raw data */
  for(i = 0; i < 3; i++)
    tmp |= (((uint32_t)buffer[i]) << (8 * i));
 8008a16:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8008a1a:	f89d 1005 	ldrb.w	r1, [sp, #5]
 8008a1e:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8008a22:	041b      	lsls	r3, r3, #16
 8008a24:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8008a28:	4313      	orrs	r3, r2

  /* convert the 2's complement 24 bit to 2's complement 32 bit */
  if(tmp & 0x00800000)
 8008a2a:	021a      	lsls	r2, r3, #8
    tmp |= 0xFF000000;
 8008a2c:	bf48      	it	mi
 8008a2e:	f043 437f 	orrmi.w	r3, r3, #4278190080	; 0xff000000

  *raw_press = ((int32_t)tmp);

  return LPS22HB_OK;
 8008a32:	2000      	movs	r0, #0
  *raw_press = ((int32_t)tmp);
 8008a34:	6023      	str	r3, [r4, #0]
}
 8008a36:	b002      	add	sp, #8
 8008a38:	bd10      	pop	{r4, pc}
    return LPS22HB_ERROR;
 8008a3a:	2001      	movs	r0, #1
}
 8008a3c:	b002      	add	sp, #8
 8008a3e:	bd10      	pop	{r4, pc}

08008a40 <LPS22HB_Get_Pressure>:
* @param  *handle Device handle.
* @param      The buffer to empty with the pressure value that must be divided by 100 to get the value in hPA
* @retval   Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_Pressure(void *handle, int32_t* Pout)
{
 8008a40:	b510      	push	{r4, lr}
 8008a42:	b082      	sub	sp, #8
 8008a44:	460c      	mov	r4, r1
  int32_t raw_press;

  if(LPS22HB_Get_RawPressure(handle, &raw_press))
 8008a46:	a901      	add	r1, sp, #4
 8008a48:	f7ff ffdc 	bl	8008a04 <LPS22HB_Get_RawPressure>
 8008a4c:	b958      	cbnz	r0, 8008a66 <LPS22HB_Get_Pressure+0x26>
    return LPS22HB_ERROR;

  *Pout = (raw_press * 100) / 4096;
 8008a4e:	9a01      	ldr	r2, [sp, #4]
 8008a50:	2364      	movs	r3, #100	; 0x64
 8008a52:	fb03 f302 	mul.w	r3, r3, r2
 8008a56:	2b00      	cmp	r3, #0
 8008a58:	bfb8      	it	lt
 8008a5a:	f603 73ff 	addwlt	r3, r3, #4095	; 0xfff
 8008a5e:	131b      	asrs	r3, r3, #12
 8008a60:	6023      	str	r3, [r4, #0]

  return LPS22HB_OK;
}
 8008a62:	b002      	add	sp, #8
 8008a64:	bd10      	pop	{r4, pc}
    return LPS22HB_ERROR;
 8008a66:	2001      	movs	r0, #1
}
 8008a68:	b002      	add	sp, #8
 8008a6a:	bd10      	pop	{r4, pc}

08008a6c <LPS22HB_Get_RawTemperature>:
* @param  *handle Device handle.
* @param     Buffer to empty with the temperature raw tmp.
* @retval   Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_RawTemperature(void *handle, int16_t* raw_data)
{
 8008a6c:	b510      	push	{r4, lr}
 8008a6e:	b082      	sub	sp, #8
 8008a70:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008a72:	2302      	movs	r3, #2
 8008a74:	aa01      	add	r2, sp, #4
 8008a76:	212b      	movs	r1, #43	; 0x2b
 8008a78:	f005 fde2 	bl	800e640 <Sensor_IO_Read>
 8008a7c:	b940      	cbnz	r0, 8008a90 <LPS22HB_Get_RawTemperature+0x24>

  if(LPS22HB_ReadReg(handle, LPS22HB_TEMP_OUT_L_REG, 2, buffer))
    return LPS22HB_ERROR;

  /* Build the raw tmp */
  tmp = (((uint16_t)buffer[1]) << 8) + (uint16_t)buffer[0];
 8008a7e:	f89d 2005 	ldrb.w	r2, [sp, #5]
 8008a82:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8008a86:	eb03 2302 	add.w	r3, r3, r2, lsl #8

  *raw_data = ((int16_t)tmp);
 8008a8a:	8023      	strh	r3, [r4, #0]

  return LPS22HB_OK;
}
 8008a8c:	b002      	add	sp, #8
 8008a8e:	bd10      	pop	{r4, pc}
    return LPS22HB_ERROR;
 8008a90:	2001      	movs	r0, #1
}
 8008a92:	b002      	add	sp, #8
 8008a94:	bd10      	pop	{r4, pc}
 8008a96:	bf00      	nop

08008a98 <LPS22HB_Get_Temperature>:
* @param  *handle Device handle.
* @param Buffer to empty with the temperature value that must be divided by 10 to get the value in C
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_Temperature(void *handle, int16_t* Tout)
{
 8008a98:	b510      	push	{r4, lr}
 8008a9a:	b082      	sub	sp, #8
 8008a9c:	460c      	mov	r4, r1
  int16_t raw_data;

  if(LPS22HB_Get_RawTemperature(handle, &raw_data))
 8008a9e:	f10d 0106 	add.w	r1, sp, #6
 8008aa2:	f7ff ffe3 	bl	8008a6c <LPS22HB_Get_RawTemperature>
 8008aa6:	b950      	cbnz	r0, 8008abe <LPS22HB_Get_Temperature+0x26>
    return LPS22HB_ERROR;

  *Tout = (raw_data * 10) / 100;
 8008aa8:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 8008aac:	4905      	ldr	r1, [pc, #20]	; (8008ac4 <LPS22HB_Get_Temperature+0x2c>)
 8008aae:	17da      	asrs	r2, r3, #31
 8008ab0:	fb81 1303 	smull	r1, r3, r1, r3
 8008ab4:	ebc2 03a3 	rsb	r3, r2, r3, asr #2
 8008ab8:	8023      	strh	r3, [r4, #0]

  return LPS22HB_OK;
}
 8008aba:	b002      	add	sp, #8
 8008abc:	bd10      	pop	{r4, pc}
    return LPS22HB_ERROR;
 8008abe:	2001      	movs	r0, #1
}
 8008ac0:	b002      	add	sp, #8
 8008ac2:	bd10      	pop	{r4, pc}
 8008ac4:	66666667 	.word	0x66666667

08008ac8 <LPS22HB_Set_FifoMode>:
* @param  *handle Device handle.
* @param  Fifo Mode struct
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FifoMode(void *handle, LPS22HB_FifoMode_et fifomode)
{
 8008ac8:	b530      	push	{r4, r5, lr}
 8008aca:	b083      	sub	sp, #12
 8008acc:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008ace:	f10d 0207 	add.w	r2, sp, #7
 8008ad2:	2301      	movs	r3, #1
 8008ad4:	2114      	movs	r1, #20
{
 8008ad6:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008ad8:	f005 fdb2 	bl	800e640 <Sensor_IO_Read>
 8008adc:	b110      	cbz	r0, 8008ae4 <LPS22HB_Set_FifoMode+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_FifoMode(fifomode));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
    return LPS22HB_ERROR;
 8008ade:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 8008ae0:	b003      	add	sp, #12
 8008ae2:	bd30      	pop	{r4, r5, pc}
  tmp &= ~LPS22HB_FIFO_MODE_MASK;
 8008ae4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8008ae8:	f003 031f 	and.w	r3, r3, #31
  tmp |= (uint8_t)fifomode;
 8008aec:	431c      	orrs	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008aee:	f10d 0207 	add.w	r2, sp, #7
 8008af2:	4628      	mov	r0, r5
 8008af4:	2301      	movs	r3, #1
 8008af6:	2114      	movs	r1, #20
  tmp |= (uint8_t)fifomode;
 8008af8:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008afc:	f005 fcb2 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 8008b00:	3000      	adds	r0, #0
 8008b02:	bf18      	it	ne
 8008b04:	2001      	movne	r0, #1
}
 8008b06:	b003      	add	sp, #12
 8008b08:	bd30      	pop	{r4, r5, pc}
 8008b0a:	bf00      	nop

08008b0c <LPS22HB_Get_FifoMode>:
* @param  *handle Device handle.
* @param   buffer to empty with fifo mode tmp
* @retval   Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_FifoMode(void *handle, LPS22HB_FifoMode_et* fifomode)
{
 8008b0c:	b510      	push	{r4, lr}
 8008b0e:	b082      	sub	sp, #8
 8008b10:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008b12:	2301      	movs	r3, #1
 8008b14:	f10d 0207 	add.w	r2, sp, #7
 8008b18:	2114      	movs	r1, #20
 8008b1a:	f005 fd91 	bl	800e640 <Sensor_IO_Read>
 8008b1e:	b930      	cbnz	r0, 8008b2e <LPS22HB_Get_FifoMode+0x22>
  uint8_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
    return LPS22HB_ERROR;

  tmp &= LPS22HB_FIFO_MODE_MASK;
 8008b20:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8008b24:	f023 031f 	bic.w	r3, r3, #31
  *fifomode = (LPS22HB_FifoMode_et)tmp;
 8008b28:	7023      	strb	r3, [r4, #0]

  return LPS22HB_OK;
}
 8008b2a:	b002      	add	sp, #8
 8008b2c:	bd10      	pop	{r4, pc}
    return LPS22HB_ERROR;
 8008b2e:	2001      	movs	r0, #1
}
 8008b30:	b002      	add	sp, #8
 8008b32:	bd10      	pop	{r4, pc}

08008b34 <LPS22HB_Set_FifoWatermarkLevel>:
* @param  *handle Device handle.
* @param    Watermark level value [0 31]
* @retval   Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FifoWatermarkLevel(void *handle, uint8_t wtmlevel)
{
 8008b34:	b530      	push	{r4, r5, lr}
 8008b36:	b083      	sub	sp, #12
 8008b38:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008b3a:	f10d 0207 	add.w	r2, sp, #7
 8008b3e:	2301      	movs	r3, #1
 8008b40:	2114      	movs	r1, #20
{
 8008b42:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008b44:	f005 fd7c 	bl	800e640 <Sensor_IO_Read>
 8008b48:	b110      	cbz	r0, 8008b50 <LPS22HB_Set_FifoWatermarkLevel+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_WtmLevel(wtmlevel));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
    return LPS22HB_ERROR;
 8008b4a:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 8008b4c:	b003      	add	sp, #12
 8008b4e:	bd30      	pop	{r4, r5, pc}
  tmp &= ~LPS22HB_WTM_POINT_MASK;
 8008b50:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8008b54:	f023 031f 	bic.w	r3, r3, #31
  tmp |= wtmlevel;
 8008b58:	431c      	orrs	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008b5a:	f10d 0207 	add.w	r2, sp, #7
 8008b5e:	4628      	mov	r0, r5
 8008b60:	2301      	movs	r3, #1
 8008b62:	2114      	movs	r1, #20
  tmp |= wtmlevel;
 8008b64:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8008b68:	f005 fc7c 	bl	800e464 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 8008b6c:	3000      	adds	r0, #0
 8008b6e:	bf18      	it	ne
 8008b70:	2001      	movne	r0, #1
}
 8008b72:	b003      	add	sp, #12
 8008b74:	bd30      	pop	{r4, r5, pc}
 8008b76:	bf00      	nop

08008b78 <LPS22HB_Get_FifoWatermarkLevel>:
* @param  *handle Device handle.
* @param   buffer to empty with watermak level[0,31] value read from sensor
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_FifoWatermarkLevel(void *handle, uint8_t *wtmlevel)
{
 8008b78:	b510      	push	{r4, lr}
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008b7a:	460a      	mov	r2, r1
{
 8008b7c:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008b7e:	2301      	movs	r3, #1
 8008b80:	2114      	movs	r1, #20
 8008b82:	f005 fd5d 	bl	800e640 <Sensor_IO_Read>
 8008b86:	b920      	cbnz	r0, 8008b92 <LPS22HB_Get_FifoWatermarkLevel+0x1a>
  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_FIFO_REG, 1, wtmlevel))
    return LPS22HB_ERROR;

  *wtmlevel &= LPS22HB_WTM_POINT_MASK;
 8008b88:	7823      	ldrb	r3, [r4, #0]
 8008b8a:	f003 031f 	and.w	r3, r3, #31
 8008b8e:	7023      	strb	r3, [r4, #0]

  return LPS22HB_OK;
}
 8008b90:	bd10      	pop	{r4, pc}
    return LPS22HB_ERROR;
 8008b92:	2001      	movs	r0, #1
}
 8008b94:	bd10      	pop	{r4, pc}
 8008b96:	bf00      	nop

08008b98 <LPS22HB_Get_FifoStatus>:
* @param  *handle Device handle.
* @param    Status Flag: FIFO_FTH,FIFO_EMPTY,FIFO_FULL,FIFO_OVR and level of the FIFO->FIFO_LEVEL
* @retval   Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_FifoStatus(void *handle, LPS22HB_FifoStatus_st* status)
{
 8008b98:	b510      	push	{r4, lr}
 8008b9a:	b082      	sub	sp, #8
 8008b9c:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8008b9e:	2301      	movs	r3, #1
 8008ba0:	f10d 0207 	add.w	r2, sp, #7
 8008ba4:	2126      	movs	r1, #38	; 0x26
 8008ba6:	f005 fd4b 	bl	800e640 <Sensor_IO_Read>
 8008baa:	b9b8      	cbnz	r0, 8008bdc <LPS22HB_Get_FifoStatus+0x44>
  uint8_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_STATUS_FIFO_REG, 1, &tmp))
    return LPS22HB_ERROR;

  status->FIFO_FTH = (uint8_t)((tmp & LPS22HB_FTH_FIFO_MASK) >> LPS22HB_FTH_FIFO_BIT);
 8008bac:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8008bb0:	09d9      	lsrs	r1, r3, #7
  status->FIFO_OVR = (uint8_t)((tmp & LPS22HB_OVR_FIFO_MASK) >> LPS22HB_OVR_FIFO_BIT);
 8008bb2:	f3c3 1280 	ubfx	r2, r3, #6, #1
  status->FIFO_LEVEL = (uint8_t)(tmp & LPS22HB_LEVEL_FIFO_MASK);
 8008bb6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  status->FIFO_FTH = (uint8_t)((tmp & LPS22HB_FTH_FIFO_MASK) >> LPS22HB_FTH_FIFO_BIT);
 8008bba:	7121      	strb	r1, [r4, #4]
  status->FIFO_OVR = (uint8_t)((tmp & LPS22HB_OVR_FIFO_MASK) >> LPS22HB_OVR_FIFO_BIT);
 8008bbc:	70e2      	strb	r2, [r4, #3]
  status->FIFO_LEVEL = (uint8_t)(tmp & LPS22HB_LEVEL_FIFO_MASK);
 8008bbe:	7023      	strb	r3, [r4, #0]

  if(status->FIFO_LEVEL == LPS22HB_FIFO_EMPTY)
 8008bc0:	b92b      	cbnz	r3, 8008bce <LPS22HB_Get_FifoStatus+0x36>
    status->FIFO_EMPTY = 0x01;
 8008bc2:	2301      	movs	r3, #1
 8008bc4:	7063      	strb	r3, [r4, #1]
    status->FIFO_EMPTY = 0x00;

  if (status->FIFO_LEVEL == LPS22HB_FIFO_FULL)
    status->FIFO_FULL = 0x01;
  else
    status->FIFO_FULL = 0x00;
 8008bc6:	2000      	movs	r0, #0
 8008bc8:	70a0      	strb	r0, [r4, #2]


  return LPS22HB_OK;
}
 8008bca:	b002      	add	sp, #8
 8008bcc:	bd10      	pop	{r4, pc}
  if (status->FIFO_LEVEL == LPS22HB_FIFO_FULL)
 8008bce:	2b20      	cmp	r3, #32
    status->FIFO_EMPTY = 0x00;
 8008bd0:	7060      	strb	r0, [r4, #1]
  if (status->FIFO_LEVEL == LPS22HB_FIFO_FULL)
 8008bd2:	d1f8      	bne.n	8008bc6 <LPS22HB_Get_FifoStatus+0x2e>
    status->FIFO_FULL = 0x01;
 8008bd4:	2301      	movs	r3, #1
 8008bd6:	70a3      	strb	r3, [r4, #2]
}
 8008bd8:	b002      	add	sp, #8
 8008bda:	bd10      	pop	{r4, pc}
    return LPS22HB_ERROR;
 8008bdc:	2001      	movs	r0, #1
}
 8008bde:	b002      	add	sp, #8
 8008be0:	bd10      	pop	{r4, pc}
 8008be2:	bf00      	nop

08008be4 <LPS22HB_P_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 8008be4:	b510      	push	{r4, lr}
 8008be6:	b082      	sub	sp, #8
 8008be8:	460c      	mov	r4, r1

  LPS22HB_DataStatus_st status_raw;

  if ( LPS22HB_Get_DataStatus( (void *)handle, &status_raw ) == LPS22HB_ERROR )
 8008bea:	a901      	add	r1, sp, #4
 8008bec:	f7ff feec 	bl	80089c8 <LPS22HB_Get_DataStatus>
 8008bf0:	2801      	cmp	r0, #1
 8008bf2:	d003      	beq.n	8008bfc <LPS22HB_P_Get_DRDY_Status+0x18>
  {
    return COMPONENT_ERROR;
  }

  *status = status_raw.PressDataAvailable;
 8008bf4:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8008bf8:	7023      	strb	r3, [r4, #0]

  return COMPONENT_OK;
 8008bfa:	2000      	movs	r0, #0
}
 8008bfc:	b002      	add	sp, #8
 8008bfe:	bd10      	pop	{r4, pc}

08008c00 <LPS22HB_T_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 8008c00:	b510      	push	{r4, lr}
 8008c02:	b082      	sub	sp, #8
 8008c04:	460c      	mov	r4, r1

  LPS22HB_DataStatus_st status_raw;

  if ( LPS22HB_Get_DataStatus( (void *)handle, &status_raw ) == LPS22HB_ERROR )
 8008c06:	a901      	add	r1, sp, #4
 8008c08:	f7ff fede 	bl	80089c8 <LPS22HB_Get_DataStatus>
 8008c0c:	2801      	cmp	r0, #1
 8008c0e:	d003      	beq.n	8008c18 <LPS22HB_T_Get_DRDY_Status+0x18>
  {
    return COMPONENT_ERROR;
  }

  *status = status_raw.TempDataAvailable;
 8008c10:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8008c14:	7023      	strb	r3, [r4, #0]

  return COMPONENT_OK;
 8008c16:	2000      	movs	r0, #0
}
 8008c18:	b002      	add	sp, #8
 8008c1a:	bd10      	pop	{r4, pc}

08008c1c <LPS22HB_P_Write_Reg>:
{
 8008c1c:	b500      	push	{lr}
 8008c1e:	b083      	sub	sp, #12
 8008c20:	ab02      	add	r3, sp, #8
 8008c22:	f803 2d01 	strb.w	r2, [r3, #-1]!
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_Write_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t data )
{

  if ( LPS22HB_WriteReg( (void *)handle, reg, 1, &data ) == LPS22HB_ERROR )
 8008c26:	2201      	movs	r2, #1
 8008c28:	f7ff fcce 	bl	80085c8 <LPS22HB_WriteReg>
}
 8008c2c:	f1a0 0001 	sub.w	r0, r0, #1
 8008c30:	fab0 f080 	clz	r0, r0
 8008c34:	0940      	lsrs	r0, r0, #5
 8008c36:	b003      	add	sp, #12
 8008c38:	f85d fb04 	ldr.w	pc, [sp], #4

08008c3c <LPS22HB_T_Write_Reg>:
 8008c3c:	f7ff bfee 	b.w	8008c1c <LPS22HB_P_Write_Reg>

08008c40 <LPS22HB_P_Read_Reg>:
{
 8008c40:	b508      	push	{r3, lr}
  if ( LPS22HB_ReadReg( (void *)handle, reg, 1, data ) == LPS22HB_ERROR )
 8008c42:	4613      	mov	r3, r2
 8008c44:	2201      	movs	r2, #1
 8008c46:	f7ff fcb5 	bl	80085b4 <LPS22HB_ReadReg>
}
 8008c4a:	f1a0 0001 	sub.w	r0, r0, #1
 8008c4e:	fab0 f080 	clz	r0, r0
 8008c52:	0940      	lsrs	r0, r0, #5
 8008c54:	bd08      	pop	{r3, pc}
 8008c56:	bf00      	nop

08008c58 <LPS22HB_T_Read_Reg>:
 8008c58:	f7ff bff2 	b.w	8008c40 <LPS22HB_P_Read_Reg>

08008c5c <LPS22HB_P_Sensor_Disable>:
{
 8008c5c:	b538      	push	{r3, r4, r5, lr}
  if ( handle->isEnabled == 0 )
 8008c5e:	7983      	ldrb	r3, [r0, #6]
 8008c60:	b153      	cbz	r3, 8008c78 <LPS22HB_P_Sensor_Disable+0x1c>
                                       handle->pData))->pComponentData))->comboData;
 8008c62:	6883      	ldr	r3, [r0, #8]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 8008c64:	681b      	ldr	r3, [r3, #0]
 8008c66:	681d      	ldr	r5, [r3, #0]
  if(comboData->isTempEnabled == 0)
 8008c68:	78e9      	ldrb	r1, [r5, #3]
 8008c6a:	4604      	mov	r4, r0
 8008c6c:	b131      	cbz	r1, 8008c7c <LPS22HB_P_Sensor_Disable+0x20>
  comboData->isPressEnabled = 0;
 8008c6e:	2300      	movs	r3, #0
 8008c70:	70ab      	strb	r3, [r5, #2]
  return COMPONENT_OK;
 8008c72:	4618      	mov	r0, r3
  handle->isEnabled = 0;
 8008c74:	71a3      	strb	r3, [r4, #6]
}
 8008c76:	bd38      	pop	{r3, r4, r5, pc}
    return COMPONENT_OK;
 8008c78:	4618      	mov	r0, r3
}
 8008c7a:	bd38      	pop	{r3, r4, r5, pc}
    if ( LPS22HB_Set_Odr( (void *)handle, LPS22HB_ODR_ONE_SHOT ) == LPS22HB_ERROR )
 8008c7c:	f7ff fcda 	bl	8008634 <LPS22HB_Set_Odr>
 8008c80:	2801      	cmp	r0, #1
 8008c82:	d0f8      	beq.n	8008c76 <LPS22HB_P_Sensor_Disable+0x1a>
  comboData->isPressEnabled = 0;
 8008c84:	2300      	movs	r3, #0
 8008c86:	70ab      	strb	r3, [r5, #2]
  return COMPONENT_OK;
 8008c88:	4618      	mov	r0, r3
  handle->isEnabled = 0;
 8008c8a:	71a3      	strb	r3, [r4, #6]
 8008c8c:	e7f3      	b.n	8008c76 <LPS22HB_P_Sensor_Disable+0x1a>
 8008c8e:	bf00      	nop

08008c90 <LPS22HB_P_DeInit>:
{
 8008c90:	b538      	push	{r3, r4, r5, lr}
                                       handle->pData))->pComponentData))->comboData;
 8008c92:	6883      	ldr	r3, [r0, #8]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 8008c94:	681b      	ldr	r3, [r3, #0]
 8008c96:	681c      	ldr	r4, [r3, #0]
  if(comboData->isTempInitialized == 0)
 8008c98:	7863      	ldrb	r3, [r4, #1]
{
 8008c9a:	4605      	mov	r5, r0
  if(comboData->isTempInitialized == 0)
 8008c9c:	b123      	cbz	r3, 8008ca8 <LPS22HB_P_DeInit+0x18>
  comboData->isPressInitialized = 0;
 8008c9e:	2300      	movs	r3, #0
 8008ca0:	7023      	strb	r3, [r4, #0]
  handle->isInitialized = 0;
 8008ca2:	716b      	strb	r3, [r5, #5]
  return COMPONENT_OK;
 8008ca4:	4618      	mov	r0, r3
}
 8008ca6:	bd38      	pop	{r3, r4, r5, pc}
    if(LPS22HB_P_Sensor_Disable(handle) == COMPONENT_ERROR)
 8008ca8:	f7ff ffd8 	bl	8008c5c <LPS22HB_P_Sensor_Disable>
 8008cac:	2801      	cmp	r0, #1
 8008cae:	d1f6      	bne.n	8008c9e <LPS22HB_P_DeInit+0xe>
}
 8008cb0:	bd38      	pop	{r3, r4, r5, pc}
 8008cb2:	bf00      	nop

08008cb4 <LPS22HB_T_Sensor_Disable>:
{
 8008cb4:	b538      	push	{r3, r4, r5, lr}
  if ( handle->isEnabled == 0 )
 8008cb6:	7983      	ldrb	r3, [r0, #6]
 8008cb8:	b153      	cbz	r3, 8008cd0 <LPS22HB_T_Sensor_Disable+0x1c>
                                       handle->pData))->pComponentData))->comboData;
 8008cba:	6883      	ldr	r3, [r0, #8]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 8008cbc:	681b      	ldr	r3, [r3, #0]
 8008cbe:	681d      	ldr	r5, [r3, #0]
  if(comboData->isPressEnabled == 0)
 8008cc0:	78a9      	ldrb	r1, [r5, #2]
 8008cc2:	4604      	mov	r4, r0
 8008cc4:	b131      	cbz	r1, 8008cd4 <LPS22HB_T_Sensor_Disable+0x20>
  comboData->isTempEnabled = 0;
 8008cc6:	2300      	movs	r3, #0
 8008cc8:	70eb      	strb	r3, [r5, #3]
  return COMPONENT_OK;
 8008cca:	4618      	mov	r0, r3
  handle->isEnabled = 0;
 8008ccc:	71a3      	strb	r3, [r4, #6]
}
 8008cce:	bd38      	pop	{r3, r4, r5, pc}
    return COMPONENT_OK;
 8008cd0:	4618      	mov	r0, r3
}
 8008cd2:	bd38      	pop	{r3, r4, r5, pc}
    if ( LPS22HB_Set_Odr( (void *)handle, LPS22HB_ODR_ONE_SHOT ) == LPS22HB_ERROR )
 8008cd4:	f7ff fcae 	bl	8008634 <LPS22HB_Set_Odr>
 8008cd8:	2801      	cmp	r0, #1
 8008cda:	d0f8      	beq.n	8008cce <LPS22HB_T_Sensor_Disable+0x1a>
  comboData->isTempEnabled = 0;
 8008cdc:	2300      	movs	r3, #0
 8008cde:	70eb      	strb	r3, [r5, #3]
  return COMPONENT_OK;
 8008ce0:	4618      	mov	r0, r3
  handle->isEnabled = 0;
 8008ce2:	71a3      	strb	r3, [r4, #6]
 8008ce4:	e7f3      	b.n	8008cce <LPS22HB_T_Sensor_Disable+0x1a>
 8008ce6:	bf00      	nop

08008ce8 <LPS22HB_T_DeInit>:
{
 8008ce8:	b538      	push	{r3, r4, r5, lr}
                                       handle->pData))->pComponentData))->comboData;
 8008cea:	6883      	ldr	r3, [r0, #8]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 8008cec:	681b      	ldr	r3, [r3, #0]
 8008cee:	681c      	ldr	r4, [r3, #0]
  if(comboData->isPressInitialized == 0)
 8008cf0:	7823      	ldrb	r3, [r4, #0]
{
 8008cf2:	4605      	mov	r5, r0
  if(comboData->isPressInitialized == 0)
 8008cf4:	b123      	cbz	r3, 8008d00 <LPS22HB_T_DeInit+0x18>
  comboData->isTempInitialized = 0;
 8008cf6:	2300      	movs	r3, #0
 8008cf8:	7063      	strb	r3, [r4, #1]
  handle->isInitialized = 0;
 8008cfa:	716b      	strb	r3, [r5, #5]
  return COMPONENT_OK;
 8008cfc:	4618      	mov	r0, r3
}
 8008cfe:	bd38      	pop	{r3, r4, r5, pc}
    if(LPS22HB_T_Sensor_Disable(handle) == COMPONENT_ERROR)
 8008d00:	f7ff ffd8 	bl	8008cb4 <LPS22HB_T_Sensor_Disable>
 8008d04:	2801      	cmp	r0, #1
 8008d06:	d1f6      	bne.n	8008cf6 <LPS22HB_T_DeInit+0xe>
}
 8008d08:	bd38      	pop	{r3, r4, r5, pc}
 8008d0a:	bf00      	nop

08008d0c <LPS22HB_Get_ODR>:
{
 8008d0c:	b510      	push	{r4, lr}
 8008d0e:	b082      	sub	sp, #8
 8008d10:	460c      	mov	r4, r1
  if ( LPS22HB_Get_Odr( (void *)handle, &odr_low_level ) == LPS22HB_ERROR )
 8008d12:	f10d 0107 	add.w	r1, sp, #7
 8008d16:	f7ff fcaf 	bl	8008678 <LPS22HB_Get_Odr>
 8008d1a:	2801      	cmp	r0, #1
 8008d1c:	d00d      	beq.n	8008d3a <LPS22HB_Get_ODR+0x2e>
  switch( odr_low_level )
 8008d1e:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8008d22:	2820      	cmp	r0, #32
 8008d24:	d022      	beq.n	8008d6c <LPS22HB_Get_ODR+0x60>
 8008d26:	d90a      	bls.n	8008d3e <LPS22HB_Get_ODR+0x32>
 8008d28:	2840      	cmp	r0, #64	; 0x40
 8008d2a:	d01b      	beq.n	8008d64 <LPS22HB_Get_ODR+0x58>
 8008d2c:	2850      	cmp	r0, #80	; 0x50
 8008d2e:	d011      	beq.n	8008d54 <LPS22HB_Get_ODR+0x48>
 8008d30:	2830      	cmp	r0, #48	; 0x30
 8008d32:	d013      	beq.n	8008d5c <LPS22HB_Get_ODR+0x50>
      *odr = -1.0f;
 8008d34:	4b0f      	ldr	r3, [pc, #60]	; (8008d74 <LPS22HB_Get_ODR+0x68>)
 8008d36:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 8008d38:	2001      	movs	r0, #1
}
 8008d3a:	b002      	add	sp, #8
 8008d3c:	bd10      	pop	{r4, pc}
  switch( odr_low_level )
 8008d3e:	b130      	cbz	r0, 8008d4e <LPS22HB_Get_ODR+0x42>
 8008d40:	2810      	cmp	r0, #16
 8008d42:	d1f7      	bne.n	8008d34 <LPS22HB_Get_ODR+0x28>
      *odr = 1.0f;
 8008d44:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8008d48:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8008d4a:	2000      	movs	r0, #0
      break;
 8008d4c:	e7f5      	b.n	8008d3a <LPS22HB_Get_ODR+0x2e>
      *odr = 0.0f;
 8008d4e:	2300      	movs	r3, #0
 8008d50:	6023      	str	r3, [r4, #0]
      break;
 8008d52:	e7f2      	b.n	8008d3a <LPS22HB_Get_ODR+0x2e>
      *odr = 75.0f;
 8008d54:	4b08      	ldr	r3, [pc, #32]	; (8008d78 <LPS22HB_Get_ODR+0x6c>)
 8008d56:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8008d58:	2000      	movs	r0, #0
      break;
 8008d5a:	e7ee      	b.n	8008d3a <LPS22HB_Get_ODR+0x2e>
      *odr = 25.0f;
 8008d5c:	4b07      	ldr	r3, [pc, #28]	; (8008d7c <LPS22HB_Get_ODR+0x70>)
 8008d5e:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8008d60:	2000      	movs	r0, #0
      break;
 8008d62:	e7ea      	b.n	8008d3a <LPS22HB_Get_ODR+0x2e>
      *odr = 50.0f;
 8008d64:	4b06      	ldr	r3, [pc, #24]	; (8008d80 <LPS22HB_Get_ODR+0x74>)
 8008d66:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8008d68:	2000      	movs	r0, #0
      break;
 8008d6a:	e7e6      	b.n	8008d3a <LPS22HB_Get_ODR+0x2e>
      *odr = 10.0f;
 8008d6c:	4b05      	ldr	r3, [pc, #20]	; (8008d84 <LPS22HB_Get_ODR+0x78>)
 8008d6e:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8008d70:	2000      	movs	r0, #0
      break;
 8008d72:	e7e2      	b.n	8008d3a <LPS22HB_Get_ODR+0x2e>
 8008d74:	bf800000 	.word	0xbf800000
 8008d78:	42960000 	.word	0x42960000
 8008d7c:	41c80000 	.word	0x41c80000
 8008d80:	42480000 	.word	0x42480000
 8008d84:	41200000 	.word	0x41200000

08008d88 <LPS22HB_P_Get_ODR>:
  return LPS22HB_Get_ODR( handle, odr );
 8008d88:	f7ff bfc0 	b.w	8008d0c <LPS22HB_Get_ODR>

08008d8c <LPS22HB_P_Get_Press>:
{
 8008d8c:	b530      	push	{r4, r5, lr}
 8008d8e:	b083      	sub	sp, #12
  int32_t int32data = 0;
 8008d90:	ab02      	add	r3, sp, #8
 8008d92:	2400      	movs	r4, #0
 8008d94:	f843 4d04 	str.w	r4, [r3, #-4]!
{
 8008d98:	460d      	mov	r5, r1
  if ( LPS22HB_Get_Pressure( (void *)handle, &int32data ) == LPS22HB_ERROR )
 8008d9a:	4619      	mov	r1, r3
 8008d9c:	f7ff fe50 	bl	8008a40 <LPS22HB_Get_Pressure>
 8008da0:	2801      	cmp	r0, #1
 8008da2:	d00a      	beq.n	8008dba <LPS22HB_P_Get_Press+0x2e>
  *pressure = ( float )int32data / 100.0f;
 8008da4:	eddd 7a01 	vldr	s15, [sp, #4]
 8008da8:	eddf 6a05 	vldr	s13, [pc, #20]	; 8008dc0 <LPS22HB_P_Get_Press+0x34>
 8008dac:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  return COMPONENT_OK;
 8008db0:	4620      	mov	r0, r4
  *pressure = ( float )int32data / 100.0f;
 8008db2:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8008db6:	ed85 7a00 	vstr	s14, [r5]
}
 8008dba:	b003      	add	sp, #12
 8008dbc:	bd30      	pop	{r4, r5, pc}
 8008dbe:	bf00      	nop
 8008dc0:	42c80000 	.word	0x42c80000

08008dc4 <LPS22HB_Check_WhoAmI>:
{
 8008dc4:	b510      	push	{r4, lr}
 8008dc6:	b082      	sub	sp, #8
  uint8_t who_am_i = 0x00;
 8008dc8:	a902      	add	r1, sp, #8
 8008dca:	2300      	movs	r3, #0
 8008dcc:	f801 3d01 	strb.w	r3, [r1, #-1]!
{
 8008dd0:	4604      	mov	r4, r0
  if ( LPS22HB_Get_DeviceID( (void *)handle, who_am_i ) == LPS22HB_ERROR )
 8008dd2:	f7ff fc03 	bl	80085dc <LPS22HB_Get_DeviceID>
 8008dd6:	2801      	cmp	r0, #1
 8008dd8:	d005      	beq.n	8008de6 <LPS22HB_Check_WhoAmI+0x22>
  if ( who_am_i != handle->who_am_i )
 8008dda:	7820      	ldrb	r0, [r4, #0]
 8008ddc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    return COMPONENT_ERROR;
 8008de0:	1ac0      	subs	r0, r0, r3
 8008de2:	bf18      	it	ne
 8008de4:	2001      	movne	r0, #1
}
 8008de6:	b002      	add	sp, #8
 8008de8:	bd10      	pop	{r4, pc}
 8008dea:	bf00      	nop

08008dec <LPS22HB_P_Check_WhoAmI>:
  return LPS22HB_Check_WhoAmI( handle );
 8008dec:	f7ff bfea 	b.w	8008dc4 <LPS22HB_Check_WhoAmI>

08008df0 <LPS22HB_P_Get_WhoAmI>:
{
 8008df0:	b508      	push	{r3, lr}
  if ( LPS22HB_Get_DeviceID( (void *)handle, who_am_i ) == LPS22HB_ERROR )
 8008df2:	f7ff fbf3 	bl	80085dc <LPS22HB_Get_DeviceID>
}
 8008df6:	f1a0 0001 	sub.w	r0, r0, #1
 8008dfa:	fab0 f080 	clz	r0, r0
 8008dfe:	0940      	lsrs	r0, r0, #5
 8008e00:	bd08      	pop	{r3, pc}
 8008e02:	bf00      	nop

08008e04 <LPS22HB_T_Get_WhoAmI>:
 8008e04:	f7ff bff4 	b.w	8008df0 <LPS22HB_P_Get_WhoAmI>

08008e08 <LPS22HB_T_Get_Temp>:
{
 8008e08:	b530      	push	{r4, r5, lr}
 8008e0a:	b083      	sub	sp, #12
  int16_t int16data = 0;
 8008e0c:	ab02      	add	r3, sp, #8
 8008e0e:	2400      	movs	r4, #0
 8008e10:	f823 4d02 	strh.w	r4, [r3, #-2]!
{
 8008e14:	460d      	mov	r5, r1
  if ( LPS22HB_Get_Temperature( (void *)handle, &int16data ) == LPS22HB_ERROR )
 8008e16:	4619      	mov	r1, r3
 8008e18:	f7ff fe3e 	bl	8008a98 <LPS22HB_Get_Temperature>
 8008e1c:	2801      	cmp	r0, #1
 8008e1e:	d00c      	beq.n	8008e3a <LPS22HB_T_Get_Temp+0x32>
  *temperature = ( float )int16data / 10.0f;
 8008e20:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 8008e24:	ee07 3a90 	vmov	s15, r3
 8008e28:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8008e2c:	eef2 6a04 	vmov.f32	s13, #36	; 0x41200000  10.0
 8008e30:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  return COMPONENT_OK;
 8008e34:	4620      	mov	r0, r4
  *temperature = ( float )int16data / 10.0f;
 8008e36:	ed85 7a00 	vstr	s14, [r5]
}
 8008e3a:	b003      	add	sp, #12
 8008e3c:	bd30      	pop	{r4, r5, pc}
 8008e3e:	bf00      	nop

08008e40 <LPS22HB_FIFO_Get_Data>:
 * @param temperature the pointer where the temperature part of FIFO sample is stored
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Get_Data( DrvContextTypeDef *handle, float *pressure, float *temperature )
{
 8008e40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008e44:	b082      	sub	sp, #8
  int32_t int32data = 0;
 8008e46:	ac02      	add	r4, sp, #8
 8008e48:	2500      	movs	r5, #0
 8008e4a:	f844 5d04 	str.w	r5, [r4, #-4]!
{
 8008e4e:	460e      	mov	r6, r1
  if ( LPS22HB_Get_Pressure( (void *)handle, &int32data ) == LPS22HB_ERROR )
 8008e50:	4621      	mov	r1, r4
{
 8008e52:	4617      	mov	r7, r2
 8008e54:	4680      	mov	r8, r0
  if ( LPS22HB_Get_Pressure( (void *)handle, &int32data ) == LPS22HB_ERROR )
 8008e56:	f7ff fdf3 	bl	8008a40 <LPS22HB_Get_Pressure>
 8008e5a:	2801      	cmp	r0, #1
 8008e5c:	d01e      	beq.n	8008e9c <LPS22HB_FIFO_Get_Data+0x5c>
  *pressure = ( float )int32data / 100.0f;
 8008e5e:	eddd 7a01 	vldr	s15, [sp, #4]
 8008e62:	eddf 6a10 	vldr	s13, [pc, #64]	; 8008ea4 <LPS22HB_FIFO_Get_Data+0x64>
  int16_t int16data = 0;
 8008e66:	f8ad 5004 	strh.w	r5, [sp, #4]
  *pressure = ( float )int32data / 100.0f;
 8008e6a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  if ( LPS22HB_Get_Temperature( (void *)handle, &int16data ) == LPS22HB_ERROR )
 8008e6e:	4621      	mov	r1, r4
  *pressure = ( float )int32data / 100.0f;
 8008e70:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  if ( LPS22HB_Get_Temperature( (void *)handle, &int16data ) == LPS22HB_ERROR )
 8008e74:	4640      	mov	r0, r8
  *pressure = ( float )int32data / 100.0f;
 8008e76:	ed86 7a00 	vstr	s14, [r6]
  if ( LPS22HB_Get_Temperature( (void *)handle, &int16data ) == LPS22HB_ERROR )
 8008e7a:	f7ff fe0d 	bl	8008a98 <LPS22HB_Get_Temperature>
 8008e7e:	2801      	cmp	r0, #1
 8008e80:	d00c      	beq.n	8008e9c <LPS22HB_FIFO_Get_Data+0x5c>
  *temperature = ( float )int16data / 10.0f;
 8008e82:	f9bd 3004 	ldrsh.w	r3, [sp, #4]
 8008e86:	ee07 3a90 	vmov	s15, r3
 8008e8a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8008e8e:	eef2 6a04 	vmov.f32	s13, #36	; 0x41200000  10.0
 8008e92:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  if ( LPS22HB_Get_Temp( handle, temperature ) == COMPONENT_ERROR )
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
 8008e96:	4628      	mov	r0, r5
  *temperature = ( float )int16data / 10.0f;
 8008e98:	ed87 7a00 	vstr	s14, [r7]
}
 8008e9c:	b002      	add	sp, #8
 8008e9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008ea2:	bf00      	nop
 8008ea4:	42c80000 	.word	0x42c80000

08008ea8 <LPS22HB_FIFO_Set_Watermark_Level>:
 * @param watermark The FIFO watermark level to be set; values: from 0 to 31
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Set_Watermark_Level( DrvContextTypeDef *handle, uint8_t watermark )
{
 8008ea8:	b508      	push	{r3, lr}

  if ( LPS22HB_Set_FifoWatermarkLevel( handle, watermark ) == LPS22HB_ERROR )
 8008eaa:	f7ff fe43 	bl	8008b34 <LPS22HB_Set_FifoWatermarkLevel>
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8008eae:	f1a0 0001 	sub.w	r0, r0, #1
 8008eb2:	fab0 f080 	clz	r0, r0
 8008eb6:	0940      	lsrs	r0, r0, #5
 8008eb8:	bd08      	pop	{r3, pc}
 8008eba:	bf00      	nop

08008ebc <LPS22HB_FIFO_Get_Watermark_Level>:
{
 8008ebc:	b508      	push	{r3, lr}
  if ( LPS22HB_Get_FifoWatermarkLevel( handle, watermark ) == LPS22HB_ERROR )
 8008ebe:	f7ff fe5b 	bl	8008b78 <LPS22HB_Get_FifoWatermarkLevel>
}
 8008ec2:	f1a0 0001 	sub.w	r0, r0, #1
 8008ec6:	fab0 f080 	clz	r0, r0
 8008eca:	0940      	lsrs	r0, r0, #5
 8008ecc:	bd08      	pop	{r3, pc}
 8008ece:	bf00      	nop

08008ed0 <LPS22HB_FIFO_Get_Mode>:
{
 8008ed0:	b510      	push	{r4, lr}
 8008ed2:	b082      	sub	sp, #8
 8008ed4:	460c      	mov	r4, r1
  if ( LPS22HB_Get_FifoMode( handle, &mode_raw ) == LPS22HB_ERROR )
 8008ed6:	f10d 0107 	add.w	r1, sp, #7
 8008eda:	f7ff fe17 	bl	8008b0c <LPS22HB_Get_FifoMode>
 8008ede:	2801      	cmp	r0, #1
 8008ee0:	d003      	beq.n	8008eea <LPS22HB_FIFO_Get_Mode+0x1a>
  *mode = ( uint8_t )mode_raw;
 8008ee2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8008ee6:	7023      	strb	r3, [r4, #0]
  return COMPONENT_OK;
 8008ee8:	2000      	movs	r0, #0
}
 8008eea:	b002      	add	sp, #8
 8008eec:	bd10      	pop	{r4, pc}
 8008eee:	bf00      	nop

08008ef0 <LPS22HB_FIFO_Get_Num_Of_Samples>:
{
 8008ef0:	b510      	push	{r4, lr}
 8008ef2:	b082      	sub	sp, #8
 8008ef4:	460c      	mov	r4, r1
  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8008ef6:	4669      	mov	r1, sp
 8008ef8:	f7ff fe4e 	bl	8008b98 <LPS22HB_Get_FifoStatus>
 8008efc:	2801      	cmp	r0, #1
 8008efe:	d003      	beq.n	8008f08 <LPS22HB_FIFO_Get_Num_Of_Samples+0x18>
  *nSamples = status_raw.FIFO_LEVEL;
 8008f00:	f89d 3000 	ldrb.w	r3, [sp]
 8008f04:	7023      	strb	r3, [r4, #0]
  return COMPONENT_OK;
 8008f06:	2000      	movs	r0, #0
}
 8008f08:	b002      	add	sp, #8
 8008f0a:	bd10      	pop	{r4, pc}

08008f0c <LPS22HB_FIFO_Get_Fth_Status>:
{
 8008f0c:	b510      	push	{r4, lr}
 8008f0e:	b082      	sub	sp, #8
 8008f10:	460c      	mov	r4, r1
  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8008f12:	4669      	mov	r1, sp
 8008f14:	f7ff fe40 	bl	8008b98 <LPS22HB_Get_FifoStatus>
 8008f18:	2801      	cmp	r0, #1
 8008f1a:	d003      	beq.n	8008f24 <LPS22HB_FIFO_Get_Fth_Status+0x18>
  *status = status_raw.FIFO_FTH;
 8008f1c:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8008f20:	7023      	strb	r3, [r4, #0]
  return COMPONENT_OK;
 8008f22:	2000      	movs	r0, #0
}
 8008f24:	b002      	add	sp, #8
 8008f26:	bd10      	pop	{r4, pc}

08008f28 <LPS22HB_FIFO_Get_Ovr_Status>:
{
 8008f28:	b510      	push	{r4, lr}
 8008f2a:	b082      	sub	sp, #8
 8008f2c:	460c      	mov	r4, r1
  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8008f2e:	4669      	mov	r1, sp
 8008f30:	f7ff fe32 	bl	8008b98 <LPS22HB_Get_FifoStatus>
 8008f34:	2801      	cmp	r0, #1
 8008f36:	d003      	beq.n	8008f40 <LPS22HB_FIFO_Get_Ovr_Status+0x18>
  *status = status_raw.FIFO_OVR;
 8008f38:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008f3c:	7023      	strb	r3, [r4, #0]
  return COMPONENT_OK;
 8008f3e:	2000      	movs	r0, #0
}
 8008f40:	b002      	add	sp, #8
 8008f42:	bd10      	pop	{r4, pc}

08008f44 <LPS22HB_FIFO_Get_Full_Status>:
{
 8008f44:	b510      	push	{r4, lr}
 8008f46:	b082      	sub	sp, #8
 8008f48:	460c      	mov	r4, r1
  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8008f4a:	4669      	mov	r1, sp
 8008f4c:	f7ff fe24 	bl	8008b98 <LPS22HB_Get_FifoStatus>
 8008f50:	2801      	cmp	r0, #1
 8008f52:	d003      	beq.n	8008f5c <LPS22HB_FIFO_Get_Full_Status+0x18>
  *status = status_raw.FIFO_FULL;
 8008f54:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8008f58:	7023      	strb	r3, [r4, #0]
  return COMPONENT_OK;
 8008f5a:	2000      	movs	r0, #0
}
 8008f5c:	b002      	add	sp, #8
 8008f5e:	bd10      	pop	{r4, pc}

08008f60 <LPS22HB_FIFO_Get_Empty_Status>:
{
 8008f60:	b510      	push	{r4, lr}
 8008f62:	b082      	sub	sp, #8
 8008f64:	460c      	mov	r4, r1
  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8008f66:	4669      	mov	r1, sp
 8008f68:	f7ff fe16 	bl	8008b98 <LPS22HB_Get_FifoStatus>
 8008f6c:	2801      	cmp	r0, #1
 8008f6e:	d003      	beq.n	8008f78 <LPS22HB_FIFO_Get_Empty_Status+0x18>
  *status = status_raw.FIFO_EMPTY;
 8008f70:	f89d 3001 	ldrb.w	r3, [sp, #1]
 8008f74:	7023      	strb	r3, [r4, #0]
  return COMPONENT_OK;
 8008f76:	2000      	movs	r0, #0
}
 8008f78:	b002      	add	sp, #8
 8008f7a:	bd10      	pop	{r4, pc}

08008f7c <LPS22HB_Set_ODR_Value_When_Enabled>:
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 8008f7c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8008f80:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8008f84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 8008f88:	b538      	push	{r3, r4, r5, lr}
 8008f8a:	4604      	mov	r4, r0
 8008f8c:	460d      	mov	r5, r1
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 8008f8e:	d91f      	bls.n	8008fd0 <LPS22HB_Set_ODR_Value_When_Enabled+0x54>
 8008f90:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 8008f94:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8008f98:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008f9c:	d80f      	bhi.n	8008fbe <LPS22HB_Set_ODR_Value_When_Enabled+0x42>
 8008f9e:	2120      	movs	r1, #32
  if ( LPS22HB_Set_Odr( (void *)handle, new_odr ) == LPS22HB_ERROR )
 8008fa0:	4620      	mov	r0, r4
 8008fa2:	f7ff fb47 	bl	8008634 <LPS22HB_Set_Odr>
 8008fa6:	2801      	cmp	r0, #1
 8008fa8:	d008      	beq.n	8008fbc <LPS22HB_Set_ODR_Value_When_Enabled+0x40>
  if ( LPS22HB_Get_ODR( handle, &combo->Last_ODR ) == COMPONENT_ERROR )
 8008faa:	1d29      	adds	r1, r5, #4
 8008fac:	4620      	mov	r0, r4
 8008fae:	f7ff fead 	bl	8008d0c <LPS22HB_Get_ODR>
    return COMPONENT_ERROR;
 8008fb2:	f1a0 0001 	sub.w	r0, r0, #1
 8008fb6:	fab0 f080 	clz	r0, r0
 8008fba:	0940      	lsrs	r0, r0, #5
}
 8008fbc:	bd38      	pop	{r3, r4, r5, pc}
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 8008fbe:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
 8008fc2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8008fc6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008fca:	d803      	bhi.n	8008fd4 <LPS22HB_Set_ODR_Value_When_Enabled+0x58>
 8008fcc:	2130      	movs	r1, #48	; 0x30
 8008fce:	e7e7      	b.n	8008fa0 <LPS22HB_Set_ODR_Value_When_Enabled+0x24>
 8008fd0:	2110      	movs	r1, #16
 8008fd2:	e7e5      	b.n	8008fa0 <LPS22HB_Set_ODR_Value_When_Enabled+0x24>
 8008fd4:	eddf 7a04 	vldr	s15, [pc, #16]	; 8008fe8 <LPS22HB_Set_ODR_Value_When_Enabled+0x6c>
 8008fd8:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8008fdc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008fe0:	bf94      	ite	ls
 8008fe2:	2140      	movls	r1, #64	; 0x40
 8008fe4:	2150      	movhi	r1, #80	; 0x50
 8008fe6:	e7db      	b.n	8008fa0 <LPS22HB_Set_ODR_Value_When_Enabled+0x24>
 8008fe8:	42480000 	.word	0x42480000

08008fec <LPS22HB_P_Set_ODR_Value>:
{
 8008fec:	b508      	push	{r3, lr}
                                       handle->pData))->pComponentData))->comboData;
 8008fee:	6882      	ldr	r2, [r0, #8]
  if(handle->isEnabled == 1)
 8008ff0:	7983      	ldrb	r3, [r0, #6]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 8008ff2:	6812      	ldr	r2, [r2, #0]
  if(handle->isEnabled == 1)
 8008ff4:	2b01      	cmp	r3, #1
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 8008ff6:	6811      	ldr	r1, [r2, #0]
  if(handle->isEnabled == 1)
 8008ff8:	d027      	beq.n	800904a <LPS22HB_P_Set_ODR_Value+0x5e>
                    : ( odr <= 10.0f ) ? 10.0f
 8008ffa:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8008ffe:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009002:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009006:	d906      	bls.n	8009016 <LPS22HB_P_Set_ODR_Value+0x2a>
                    : ( odr <= 25.0f ) ? 25.0f
 8009008:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 800900c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009010:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009014:	d803      	bhi.n	800901e <LPS22HB_P_Set_ODR_Value+0x32>
  combo->Last_ODR = ( odr <=  1.0f ) ? 1.0f
 8009016:	edc1 7a01 	vstr	s15, [r1, #4]
  return COMPONENT_OK;
 800901a:	2000      	movs	r0, #0
}
 800901c:	bd08      	pop	{r3, pc}
                    : ( odr <= 50.0f ) ? 50.0f
 800901e:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
 8009022:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009026:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800902a:	d9f4      	bls.n	8009016 <LPS22HB_P_Set_ODR_Value+0x2a>
                    :                    75.0f;
 800902c:	eddf 7a0b 	vldr	s15, [pc, #44]	; 800905c <LPS22HB_P_Set_ODR_Value+0x70>
 8009030:	eddf 6a0b 	vldr	s13, [pc, #44]	; 8009060 <LPS22HB_P_Set_ODR_Value+0x74>
 8009034:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009038:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800903c:	bf88      	it	hi
 800903e:	eef0 7a66 	vmovhi.f32	s15, s13
  combo->Last_ODR = ( odr <=  1.0f ) ? 1.0f
 8009042:	edc1 7a01 	vstr	s15, [r1, #4]
  return COMPONENT_OK;
 8009046:	2000      	movs	r0, #0
 8009048:	e7e8      	b.n	800901c <LPS22HB_P_Set_ODR_Value+0x30>
    if(LPS22HB_Set_ODR_Value_When_Enabled(handle, odr, comboData) == COMPONENT_ERROR)
 800904a:	f7ff ff97 	bl	8008f7c <LPS22HB_Set_ODR_Value_When_Enabled>
      return COMPONENT_ERROR;
 800904e:	f1a0 0001 	sub.w	r0, r0, #1
 8009052:	fab0 f080 	clz	r0, r0
 8009056:	0940      	lsrs	r0, r0, #5
}
 8009058:	bd08      	pop	{r3, pc}
 800905a:	bf00      	nop
 800905c:	42480000 	.word	0x42480000
 8009060:	42960000 	.word	0x42960000

08009064 <LPS22HB_P_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 8009064:	7982      	ldrb	r2, [r0, #6]
 8009066:	2a01      	cmp	r2, #1
 8009068:	d010      	beq.n	800908c <LPS22HB_P_Sensor_Enable+0x28>
{
 800906a:	b538      	push	{r3, r4, r5, lr}
                                       handle->pData))->pComponentData))->comboData;
 800906c:	6883      	ldr	r3, [r0, #8]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 800906e:	681b      	ldr	r3, [r3, #0]
 8009070:	681d      	ldr	r5, [r3, #0]
  if(LPS22HB_Set_ODR_Value_When_Enabled(handle, comboData->Last_ODR, comboData) == COMPONENT_ERROR)
 8009072:	4629      	mov	r1, r5
 8009074:	ed95 0a01 	vldr	s0, [r5, #4]
 8009078:	4604      	mov	r4, r0
 800907a:	f7ff ff7f 	bl	8008f7c <LPS22HB_Set_ODR_Value_When_Enabled>
 800907e:	2801      	cmp	r0, #1
 8009080:	d003      	beq.n	800908a <LPS22HB_P_Sensor_Enable+0x26>
  comboData->isPressEnabled = 1;
 8009082:	2301      	movs	r3, #1
 8009084:	70ab      	strb	r3, [r5, #2]
  return COMPONENT_OK;
 8009086:	2000      	movs	r0, #0
  handle->isEnabled = 1;
 8009088:	71a3      	strb	r3, [r4, #6]
}
 800908a:	bd38      	pop	{r3, r4, r5, pc}
    return COMPONENT_OK;
 800908c:	2000      	movs	r0, #0
}
 800908e:	4770      	bx	lr

08009090 <LPS22HB_T_Set_ODR_Value>:
{
 8009090:	b508      	push	{r3, lr}
                                       handle->pData))->pComponentData))->comboData;
 8009092:	6882      	ldr	r2, [r0, #8]
  if(handle->isEnabled == 1)
 8009094:	7983      	ldrb	r3, [r0, #6]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 8009096:	6812      	ldr	r2, [r2, #0]
  if(handle->isEnabled == 1)
 8009098:	2b01      	cmp	r3, #1
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 800909a:	6811      	ldr	r1, [r2, #0]
  if(handle->isEnabled == 1)
 800909c:	d027      	beq.n	80090ee <LPS22HB_T_Set_ODR_Value+0x5e>
                    : ( odr <= 10.0f ) ? 10.0f
 800909e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80090a2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80090a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80090aa:	d906      	bls.n	80090ba <LPS22HB_T_Set_ODR_Value+0x2a>
                    : ( odr <= 25.0f ) ? 25.0f
 80090ac:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 80090b0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80090b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80090b8:	d803      	bhi.n	80090c2 <LPS22HB_T_Set_ODR_Value+0x32>
  combo->Last_ODR = ( odr <=  1.0f ) ? 1.0f
 80090ba:	edc1 7a01 	vstr	s15, [r1, #4]
  return COMPONENT_OK;
 80090be:	2000      	movs	r0, #0
}
 80090c0:	bd08      	pop	{r3, pc}
                    : ( odr <= 50.0f ) ? 50.0f
 80090c2:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
 80090c6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80090ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80090ce:	d9f4      	bls.n	80090ba <LPS22HB_T_Set_ODR_Value+0x2a>
                    :                    75.0f;
 80090d0:	eddf 7a0b 	vldr	s15, [pc, #44]	; 8009100 <LPS22HB_T_Set_ODR_Value+0x70>
 80090d4:	eddf 6a0b 	vldr	s13, [pc, #44]	; 8009104 <LPS22HB_T_Set_ODR_Value+0x74>
 80090d8:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80090dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80090e0:	bf88      	it	hi
 80090e2:	eef0 7a66 	vmovhi.f32	s15, s13
  combo->Last_ODR = ( odr <=  1.0f ) ? 1.0f
 80090e6:	edc1 7a01 	vstr	s15, [r1, #4]
  return COMPONENT_OK;
 80090ea:	2000      	movs	r0, #0
 80090ec:	e7e8      	b.n	80090c0 <LPS22HB_T_Set_ODR_Value+0x30>
    if(LPS22HB_Set_ODR_Value_When_Enabled(handle, odr, comboData) == COMPONENT_ERROR)
 80090ee:	f7ff ff45 	bl	8008f7c <LPS22HB_Set_ODR_Value_When_Enabled>
      return COMPONENT_ERROR;
 80090f2:	f1a0 0001 	sub.w	r0, r0, #1
 80090f6:	fab0 f080 	clz	r0, r0
 80090fa:	0940      	lsrs	r0, r0, #5
}
 80090fc:	bd08      	pop	{r3, pc}
 80090fe:	bf00      	nop
 8009100:	42480000 	.word	0x42480000
 8009104:	42960000 	.word	0x42960000

08009108 <LPS22HB_T_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 8009108:	7982      	ldrb	r2, [r0, #6]
 800910a:	2a01      	cmp	r2, #1
 800910c:	d010      	beq.n	8009130 <LPS22HB_T_Sensor_Enable+0x28>
{
 800910e:	b538      	push	{r3, r4, r5, lr}
                                       handle->pData))->pComponentData))->comboData;
 8009110:	6883      	ldr	r3, [r0, #8]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 8009112:	681b      	ldr	r3, [r3, #0]
 8009114:	681d      	ldr	r5, [r3, #0]
  if(LPS22HB_Set_ODR_Value_When_Enabled(handle, comboData->Last_ODR, comboData) == COMPONENT_ERROR)
 8009116:	4629      	mov	r1, r5
 8009118:	ed95 0a01 	vldr	s0, [r5, #4]
 800911c:	4604      	mov	r4, r0
 800911e:	f7ff ff2d 	bl	8008f7c <LPS22HB_Set_ODR_Value_When_Enabled>
 8009122:	2801      	cmp	r0, #1
 8009124:	d003      	beq.n	800912e <LPS22HB_T_Sensor_Enable+0x26>
  comboData->isTempEnabled = 1;
 8009126:	2301      	movs	r3, #1
 8009128:	70eb      	strb	r3, [r5, #3]
  return COMPONENT_OK;
 800912a:	2000      	movs	r0, #0
  handle->isEnabled = 1;
 800912c:	71a3      	strb	r3, [r4, #6]
}
 800912e:	bd38      	pop	{r3, r4, r5, pc}
    return COMPONENT_OK;
 8009130:	2000      	movs	r0, #0
}
 8009132:	4770      	bx	lr

08009134 <LPS22HB_Set_ODR_When_Enabled>:
{
 8009134:	b538      	push	{r3, r4, r5, lr}
  switch( odr )
 8009136:	2904      	cmp	r1, #4
 8009138:	d81d      	bhi.n	8009176 <LPS22HB_Set_ODR_When_Enabled+0x42>
 800913a:	e8df f001 	tbb	[pc, r1]
 800913e:	1603      	.short	0x1603
 8009140:	1a18      	.short	0x1a18
 8009142:	14          	.byte	0x14
 8009143:	00          	.byte	0x00
      new_odr = LPS22HB_ODR_1HZ;
 8009144:	2110      	movs	r1, #16
 8009146:	4615      	mov	r5, r2
 8009148:	4604      	mov	r4, r0
  if ( LPS22HB_Set_Odr( (void *)handle, new_odr ) == LPS22HB_ERROR )
 800914a:	f7ff fa73 	bl	8008634 <LPS22HB_Set_Odr>
 800914e:	2801      	cmp	r0, #1
 8009150:	d008      	beq.n	8009164 <LPS22HB_Set_ODR_When_Enabled+0x30>
  if ( LPS22HB_Get_ODR( handle, &combo->Last_ODR ) == COMPONENT_ERROR )
 8009152:	1d29      	adds	r1, r5, #4
 8009154:	4620      	mov	r0, r4
 8009156:	f7ff fdd9 	bl	8008d0c <LPS22HB_Get_ODR>
      return COMPONENT_ERROR;
 800915a:	f1a0 0001 	sub.w	r0, r0, #1
 800915e:	fab0 f080 	clz	r0, r0
 8009162:	0940      	lsrs	r0, r0, #5
}
 8009164:	bd38      	pop	{r3, r4, r5, pc}
      new_odr = LPS22HB_ODR_75HZ;
 8009166:	2150      	movs	r1, #80	; 0x50
      break;
 8009168:	e7ed      	b.n	8009146 <LPS22HB_Set_ODR_When_Enabled+0x12>
      new_odr = LPS22HB_ODR_10HZ;
 800916a:	2120      	movs	r1, #32
 800916c:	e7eb      	b.n	8009146 <LPS22HB_Set_ODR_When_Enabled+0x12>
      new_odr = LPS22HB_ODR_25HZ;
 800916e:	2130      	movs	r1, #48	; 0x30
      break;
 8009170:	e7e9      	b.n	8009146 <LPS22HB_Set_ODR_When_Enabled+0x12>
      new_odr = LPS22HB_ODR_50HZ;
 8009172:	2140      	movs	r1, #64	; 0x40
      break;
 8009174:	e7e7      	b.n	8009146 <LPS22HB_Set_ODR_When_Enabled+0x12>
      return COMPONENT_ERROR;
 8009176:	2001      	movs	r0, #1
}
 8009178:	bd38      	pop	{r3, r4, r5, pc}
 800917a:	bf00      	nop

0800917c <LPS22HB_P_Set_ODR>:
{
 800917c:	b510      	push	{r4, lr}
                                       handle->pData))->pComponentData))->comboData;
 800917e:	6882      	ldr	r2, [r0, #8]
  if(handle->isEnabled == 1)
 8009180:	7983      	ldrb	r3, [r0, #6]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 8009182:	6812      	ldr	r2, [r2, #0]
  if(handle->isEnabled == 1)
 8009184:	2b01      	cmp	r3, #1
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 8009186:	6812      	ldr	r2, [r2, #0]
  if(handle->isEnabled == 1)
 8009188:	d006      	beq.n	8009198 <LPS22HB_P_Set_ODR+0x1c>
  switch( odr )
 800918a:	2904      	cmp	r1, #4
 800918c:	d821      	bhi.n	80091d2 <LPS22HB_P_Set_ODR+0x56>
 800918e:	e8df f001 	tbb	[pc, r1]
 8009192:	140f      	.short	0x140f
 8009194:	1c18      	.short	0x1c18
 8009196:	0b          	.byte	0x0b
 8009197:	00          	.byte	0x00
    if(LPS22HB_Set_ODR_When_Enabled(handle, odr, comboData) == COMPONENT_ERROR)
 8009198:	f7ff ffcc 	bl	8009134 <LPS22HB_Set_ODR_When_Enabled>
      return COMPONENT_ERROR;
 800919c:	f1a0 0001 	sub.w	r0, r0, #1
 80091a0:	fab0 f080 	clz	r0, r0
 80091a4:	0940      	lsrs	r0, r0, #5
}
 80091a6:	bd10      	pop	{r4, pc}
      combo->Last_ODR = 75.0f;
 80091a8:	4b0b      	ldr	r3, [pc, #44]	; (80091d8 <LPS22HB_P_Set_ODR+0x5c>)
 80091aa:	6053      	str	r3, [r2, #4]
  return COMPONENT_OK;
 80091ac:	2000      	movs	r0, #0
}
 80091ae:	bd10      	pop	{r4, pc}
      combo->Last_ODR = 1.0f;
 80091b0:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 80091b4:	6053      	str	r3, [r2, #4]
  return COMPONENT_OK;
 80091b6:	2000      	movs	r0, #0
}
 80091b8:	bd10      	pop	{r4, pc}
      combo->Last_ODR = 10.0f;
 80091ba:	4b08      	ldr	r3, [pc, #32]	; (80091dc <LPS22HB_P_Set_ODR+0x60>)
 80091bc:	6053      	str	r3, [r2, #4]
  return COMPONENT_OK;
 80091be:	2000      	movs	r0, #0
}
 80091c0:	bd10      	pop	{r4, pc}
      combo->Last_ODR = 25.0f;
 80091c2:	4b07      	ldr	r3, [pc, #28]	; (80091e0 <LPS22HB_P_Set_ODR+0x64>)
 80091c4:	6053      	str	r3, [r2, #4]
  return COMPONENT_OK;
 80091c6:	2000      	movs	r0, #0
}
 80091c8:	bd10      	pop	{r4, pc}
      combo->Last_ODR = 50.0f;
 80091ca:	4b06      	ldr	r3, [pc, #24]	; (80091e4 <LPS22HB_P_Set_ODR+0x68>)
 80091cc:	6053      	str	r3, [r2, #4]
  return COMPONENT_OK;
 80091ce:	2000      	movs	r0, #0
}
 80091d0:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 80091d2:	2001      	movs	r0, #1
}
 80091d4:	bd10      	pop	{r4, pc}
 80091d6:	bf00      	nop
 80091d8:	42960000 	.word	0x42960000
 80091dc:	41200000 	.word	0x41200000
 80091e0:	41c80000 	.word	0x41c80000
 80091e4:	42480000 	.word	0x42480000

080091e8 <LPS22HB_T_Set_ODR>:
{
 80091e8:	b510      	push	{r4, lr}
                                       handle->pData))->pComponentData))->comboData;
 80091ea:	6882      	ldr	r2, [r0, #8]
  if(handle->isEnabled == 1)
 80091ec:	7983      	ldrb	r3, [r0, #6]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 80091ee:	6812      	ldr	r2, [r2, #0]
  if(handle->isEnabled == 1)
 80091f0:	2b01      	cmp	r3, #1
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 80091f2:	6812      	ldr	r2, [r2, #0]
  if(handle->isEnabled == 1)
 80091f4:	d006      	beq.n	8009204 <LPS22HB_T_Set_ODR+0x1c>
  switch( odr )
 80091f6:	2904      	cmp	r1, #4
 80091f8:	d821      	bhi.n	800923e <LPS22HB_T_Set_ODR+0x56>
 80091fa:	e8df f001 	tbb	[pc, r1]
 80091fe:	140f      	.short	0x140f
 8009200:	1c18      	.short	0x1c18
 8009202:	0b          	.byte	0x0b
 8009203:	00          	.byte	0x00
    if(LPS22HB_Set_ODR_When_Enabled(handle, odr, comboData) == COMPONENT_ERROR)
 8009204:	f7ff ff96 	bl	8009134 <LPS22HB_Set_ODR_When_Enabled>
      return COMPONENT_ERROR;
 8009208:	f1a0 0001 	sub.w	r0, r0, #1
 800920c:	fab0 f080 	clz	r0, r0
 8009210:	0940      	lsrs	r0, r0, #5
}
 8009212:	bd10      	pop	{r4, pc}
      combo->Last_ODR = 75.0f;
 8009214:	4b0b      	ldr	r3, [pc, #44]	; (8009244 <LPS22HB_T_Set_ODR+0x5c>)
 8009216:	6053      	str	r3, [r2, #4]
  return COMPONENT_OK;
 8009218:	2000      	movs	r0, #0
}
 800921a:	bd10      	pop	{r4, pc}
      combo->Last_ODR = 1.0f;
 800921c:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8009220:	6053      	str	r3, [r2, #4]
  return COMPONENT_OK;
 8009222:	2000      	movs	r0, #0
}
 8009224:	bd10      	pop	{r4, pc}
      combo->Last_ODR = 10.0f;
 8009226:	4b08      	ldr	r3, [pc, #32]	; (8009248 <LPS22HB_T_Set_ODR+0x60>)
 8009228:	6053      	str	r3, [r2, #4]
  return COMPONENT_OK;
 800922a:	2000      	movs	r0, #0
}
 800922c:	bd10      	pop	{r4, pc}
      combo->Last_ODR = 25.0f;
 800922e:	4b07      	ldr	r3, [pc, #28]	; (800924c <LPS22HB_T_Set_ODR+0x64>)
 8009230:	6053      	str	r3, [r2, #4]
  return COMPONENT_OK;
 8009232:	2000      	movs	r0, #0
}
 8009234:	bd10      	pop	{r4, pc}
      combo->Last_ODR = 50.0f;
 8009236:	4b06      	ldr	r3, [pc, #24]	; (8009250 <LPS22HB_T_Set_ODR+0x68>)
 8009238:	6053      	str	r3, [r2, #4]
  return COMPONENT_OK;
 800923a:	2000      	movs	r0, #0
}
 800923c:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 800923e:	2001      	movs	r0, #1
}
 8009240:	bd10      	pop	{r4, pc}
 8009242:	bf00      	nop
 8009244:	42960000 	.word	0x42960000
 8009248:	41200000 	.word	0x41200000
 800924c:	41c80000 	.word	0x41c80000
 8009250:	42480000 	.word	0x42480000

08009254 <LPS22HB_Initialize.isra.4>:
static DrvStatusTypeDef LPS22HB_Initialize( DrvContextTypeDef *handle, LPS22HB_Combo_Data_t *combo )
 8009254:	b538      	push	{r3, r4, r5, lr}
 8009256:	460d      	mov	r5, r1
 8009258:	4604      	mov	r4, r0
  if ( LPS22HB_Check_WhoAmI( handle ) == COMPONENT_ERROR )
 800925a:	f7ff fdb3 	bl	8008dc4 <LPS22HB_Check_WhoAmI>
 800925e:	2801      	cmp	r0, #1
 8009260:	d025      	beq.n	80092ae <LPS22HB_Initialize.isra.4+0x5a>
  combo->Last_ODR = 25.0f;
 8009262:	4b18      	ldr	r3, [pc, #96]	; (80092c4 <LPS22HB_Initialize.isra.4+0x70>)
 8009264:	602b      	str	r3, [r5, #0]
  if ( LPS22HB_Set_PowerMode( (void *)handle, LPS22HB_LowPower) == LPS22HB_ERROR )
 8009266:	2101      	movs	r1, #1
 8009268:	4620      	mov	r0, r4
 800926a:	f7ff f9c1 	bl	80085f0 <LPS22HB_Set_PowerMode>
 800926e:	2801      	cmp	r0, #1
 8009270:	d01d      	beq.n	80092ae <LPS22HB_Initialize.isra.4+0x5a>
  if ( LPS22HB_Set_Odr( (void *)handle, LPS22HB_ODR_ONE_SHOT ) == LPS22HB_ERROR )
 8009272:	2100      	movs	r1, #0
 8009274:	4620      	mov	r0, r4
 8009276:	f7ff f9dd 	bl	8008634 <LPS22HB_Set_Odr>
 800927a:	2801      	cmp	r0, #1
 800927c:	d017      	beq.n	80092ae <LPS22HB_Initialize.isra.4+0x5a>
  if( LPS22HB_Set_LowPassFilter( (void *)handle, LPS22HB_DISABLE) == LPS22HB_ERROR )
 800927e:	2100      	movs	r1, #0
 8009280:	4620      	mov	r0, r4
 8009282:	f7ff fa0d 	bl	80086a0 <LPS22HB_Set_LowPassFilter>
 8009286:	2801      	cmp	r0, #1
 8009288:	d011      	beq.n	80092ae <LPS22HB_Initialize.isra.4+0x5a>
  if( LPS22HB_Set_LowPassFilterCutoff( (void *)handle, LPS22HB_ODR_9) == LPS22HB_ERROR )
 800928a:	2100      	movs	r1, #0
 800928c:	4620      	mov	r0, r4
 800928e:	f7ff fa29 	bl	80086e4 <LPS22HB_Set_LowPassFilterCutoff>
 8009292:	2801      	cmp	r0, #1
 8009294:	d00b      	beq.n	80092ae <LPS22HB_Initialize.isra.4+0x5a>
  if ( LPS22HB_Set_Bdu( (void *)handle, LPS22HB_BDU_NO_UPDATE ) == LPS22HB_ERROR )
 8009296:	2102      	movs	r1, #2
 8009298:	4620      	mov	r0, r4
 800929a:	f7ff fa45 	bl	8008728 <LPS22HB_Set_Bdu>
 800929e:	2801      	cmp	r0, #1
 80092a0:	d005      	beq.n	80092ae <LPS22HB_Initialize.isra.4+0x5a>
  if(handle->ifType == 0) // I2C mode
 80092a2:	7861      	ldrb	r1, [r4, #1]
 80092a4:	b129      	cbz	r1, 80092b2 <LPS22HB_Initialize.isra.4+0x5e>
    if(handle->ifType == 1) // SPI mode
 80092a6:	2901      	cmp	r1, #1
 80092a8:	d003      	beq.n	80092b2 <LPS22HB_Initialize.isra.4+0x5e>
  return COMPONENT_OK;
 80092aa:	2000      	movs	r0, #0
}
 80092ac:	bd38      	pop	{r3, r4, r5, pc}
    return COMPONENT_ERROR;
 80092ae:	2001      	movs	r0, #1
}
 80092b0:	bd38      	pop	{r3, r4, r5, pc}
      if( LPS22HB_Set_AutomaticIncrementRegAddress( (void *)handle, LPS22HB_ENABLE) == LPS22HB_ERROR )
 80092b2:	4620      	mov	r0, r4
 80092b4:	f7ff fabc 	bl	8008830 <LPS22HB_Set_AutomaticIncrementRegAddress>
    return COMPONENT_ERROR;
 80092b8:	f1a0 0001 	sub.w	r0, r0, #1
 80092bc:	fab0 f080 	clz	r0, r0
 80092c0:	0940      	lsrs	r0, r0, #5
}
 80092c2:	bd38      	pop	{r3, r4, r5, pc}
 80092c4:	41c80000 	.word	0x41c80000

080092c8 <LPS22HB_P_Init>:
{
 80092c8:	b538      	push	{r3, r4, r5, lr}
                                       handle->pData))->pComponentData))->comboData;
 80092ca:	6883      	ldr	r3, [r0, #8]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 80092cc:	681b      	ldr	r3, [r3, #0]
 80092ce:	681c      	ldr	r4, [r3, #0]
  if(comboData->isTempInitialized == 0)
 80092d0:	7863      	ldrb	r3, [r4, #1]
{
 80092d2:	4605      	mov	r5, r0
  if(comboData->isTempInitialized == 0)
 80092d4:	b123      	cbz	r3, 80092e0 <LPS22HB_P_Init+0x18>
  comboData->isPressInitialized = 1;
 80092d6:	2301      	movs	r3, #1
 80092d8:	7023      	strb	r3, [r4, #0]
  handle->isInitialized = 1;
 80092da:	716b      	strb	r3, [r5, #5]
  return COMPONENT_OK;
 80092dc:	2000      	movs	r0, #0
}
 80092de:	bd38      	pop	{r3, r4, r5, pc}
    if(LPS22HB_Initialize(handle, comboData) == COMPONENT_ERROR)
 80092e0:	1d21      	adds	r1, r4, #4
 80092e2:	f7ff ffb7 	bl	8009254 <LPS22HB_Initialize.isra.4>
 80092e6:	2801      	cmp	r0, #1
 80092e8:	d1f5      	bne.n	80092d6 <LPS22HB_P_Init+0xe>
}
 80092ea:	bd38      	pop	{r3, r4, r5, pc}

080092ec <LPS22HB_T_Init>:
{
 80092ec:	b538      	push	{r3, r4, r5, lr}
                                       handle->pData))->pComponentData))->comboData;
 80092ee:	6883      	ldr	r3, [r0, #8]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 80092f0:	681b      	ldr	r3, [r3, #0]
 80092f2:	681c      	ldr	r4, [r3, #0]
  if(comboData->isPressInitialized == 0)
 80092f4:	7823      	ldrb	r3, [r4, #0]
{
 80092f6:	4605      	mov	r5, r0
  if(comboData->isPressInitialized == 0)
 80092f8:	b123      	cbz	r3, 8009304 <LPS22HB_T_Init+0x18>
  comboData->isTempInitialized = 1;
 80092fa:	2301      	movs	r3, #1
 80092fc:	7063      	strb	r3, [r4, #1]
  handle->isInitialized = 1;
 80092fe:	716b      	strb	r3, [r5, #5]
  return COMPONENT_OK;
 8009300:	2000      	movs	r0, #0
}
 8009302:	bd38      	pop	{r3, r4, r5, pc}
    if(LPS22HB_Initialize(handle, comboData) == COMPONENT_ERROR)
 8009304:	1d21      	adds	r1, r4, #4
 8009306:	f7ff ffa5 	bl	8009254 <LPS22HB_Initialize.isra.4>
 800930a:	2801      	cmp	r0, #1
 800930c:	d1f5      	bne.n	80092fa <LPS22HB_T_Init+0xe>
}
 800930e:	bd38      	pop	{r3, r4, r5, pc}

08009310 <LPS22HB_FIFO_Reset_Interrupt>:
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Reset_Interrupt( DrvContextTypeDef *handle, uint8_t interrupt )
{

  switch( interrupt )
 8009310:	2901      	cmp	r1, #1
{
 8009312:	b508      	push	{r3, lr}
  switch( interrupt )
 8009314:	d016      	beq.n	8009344 <LPS22HB_FIFO_Reset_Interrupt+0x34>
 8009316:	d30c      	bcc.n	8009332 <LPS22HB_FIFO_Reset_Interrupt+0x22>
 8009318:	2902      	cmp	r1, #2
 800931a:	d108      	bne.n	800932e <LPS22HB_FIFO_Reset_Interrupt+0x1e>
      {
        return COMPONENT_ERROR;
      }
      break;
    case 2:
      if ( LPS22HB_Set_FIFO_OVR_Interrupt( handle, LPS22HB_DISABLE ) == LPS22HB_ERROR )
 800931c:	2100      	movs	r1, #0
 800931e:	f7ff faed 	bl	80088fc <LPS22HB_Set_FIFO_OVR_Interrupt>
      break;
    default:
      return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
 8009322:	f1a0 0001 	sub.w	r0, r0, #1
 8009326:	fab0 f080 	clz	r0, r0
 800932a:	0940      	lsrs	r0, r0, #5
}
 800932c:	bd08      	pop	{r3, pc}
      return COMPONENT_ERROR;
 800932e:	2001      	movs	r0, #1
}
 8009330:	bd08      	pop	{r3, pc}
      if ( LPS22HB_Set_FIFO_FTH_Interrupt( handle, LPS22HB_DISABLE ) == LPS22HB_ERROR )
 8009332:	2100      	movs	r1, #0
 8009334:	f7ff fb04 	bl	8008940 <LPS22HB_Set_FIFO_FTH_Interrupt>
        return COMPONENT_ERROR;
 8009338:	f1a0 0001 	sub.w	r0, r0, #1
 800933c:	fab0 f080 	clz	r0, r0
 8009340:	0940      	lsrs	r0, r0, #5
}
 8009342:	bd08      	pop	{r3, pc}
      if ( LPS22HB_Set_FIFO_FULL_Interrupt( handle, LPS22HB_DISABLE ) == LPS22HB_ERROR )
 8009344:	2100      	movs	r1, #0
 8009346:	f7ff fb1d 	bl	8008984 <LPS22HB_Set_FIFO_FULL_Interrupt>
        return COMPONENT_ERROR;
 800934a:	f1a0 0001 	sub.w	r0, r0, #1
 800934e:	fab0 f080 	clz	r0, r0
 8009352:	0940      	lsrs	r0, r0, #5
}
 8009354:	bd08      	pop	{r3, pc}
 8009356:	bf00      	nop

08009358 <LPS22HB_FIFO_Set_Interrupt>:
  switch( interrupt )
 8009358:	2901      	cmp	r1, #1
{
 800935a:	b508      	push	{r3, lr}
  switch( interrupt )
 800935c:	d016      	beq.n	800938c <LPS22HB_FIFO_Set_Interrupt+0x34>
 800935e:	d30c      	bcc.n	800937a <LPS22HB_FIFO_Set_Interrupt+0x22>
 8009360:	2902      	cmp	r1, #2
 8009362:	d108      	bne.n	8009376 <LPS22HB_FIFO_Set_Interrupt+0x1e>
      if ( LPS22HB_Set_FIFO_OVR_Interrupt( handle, LPS22HB_ENABLE ) == LPS22HB_ERROR )
 8009364:	2101      	movs	r1, #1
 8009366:	f7ff fac9 	bl	80088fc <LPS22HB_Set_FIFO_OVR_Interrupt>
  return COMPONENT_OK;
 800936a:	f1a0 0001 	sub.w	r0, r0, #1
 800936e:	fab0 f080 	clz	r0, r0
 8009372:	0940      	lsrs	r0, r0, #5
}
 8009374:	bd08      	pop	{r3, pc}
      return COMPONENT_ERROR;
 8009376:	2001      	movs	r0, #1
}
 8009378:	bd08      	pop	{r3, pc}
      if ( LPS22HB_Set_FIFO_FTH_Interrupt( handle, LPS22HB_ENABLE ) == LPS22HB_ERROR )
 800937a:	2101      	movs	r1, #1
 800937c:	f7ff fae0 	bl	8008940 <LPS22HB_Set_FIFO_FTH_Interrupt>
        return COMPONENT_ERROR;
 8009380:	f1a0 0001 	sub.w	r0, r0, #1
 8009384:	fab0 f080 	clz	r0, r0
 8009388:	0940      	lsrs	r0, r0, #5
}
 800938a:	bd08      	pop	{r3, pc}
      if ( LPS22HB_Set_FIFO_FULL_Interrupt( handle, LPS22HB_ENABLE ) == LPS22HB_ERROR )
 800938c:	f7ff fafa 	bl	8008984 <LPS22HB_Set_FIFO_FULL_Interrupt>
        return COMPONENT_ERROR;
 8009390:	f1a0 0001 	sub.w	r0, r0, #1
 8009394:	fab0 f080 	clz	r0, r0
 8009398:	0940      	lsrs	r0, r0, #5
}
 800939a:	bd08      	pop	{r3, pc}

0800939c <LPS22HB_FIFO_Watermark_Usage>:
  switch ( ( LPS22HB_State_et )usage )
 800939c:	2901      	cmp	r1, #1
 800939e:	d901      	bls.n	80093a4 <LPS22HB_FIFO_Watermark_Usage+0x8>
      return COMPONENT_ERROR;
 80093a0:	2001      	movs	r0, #1
}
 80093a2:	4770      	bx	lr
{
 80093a4:	b508      	push	{r3, lr}
  if ( LPS22HB_Set_FifoWatermarkLevelUse( handle, ( LPS22HB_State_et )usage ) == LPS22HB_ERROR )
 80093a6:	f7ff fa21 	bl	80087ec <LPS22HB_Set_FifoWatermarkLevelUse>
      return COMPONENT_ERROR;
 80093aa:	f1a0 0001 	sub.w	r0, r0, #1
 80093ae:	fab0 f080 	clz	r0, r0
 80093b2:	0940      	lsrs	r0, r0, #5
}
 80093b4:	bd08      	pop	{r3, pc}
 80093b6:	bf00      	nop

080093b8 <LPS22HB_FIFO_Set_Mode>:
  switch ( ( LPS22HB_FifoMode_et )mode )
 80093b8:	2940      	cmp	r1, #64	; 0x40
 80093ba:	d00b      	beq.n	80093d4 <LPS22HB_FIFO_Set_Mode+0x1c>
 80093bc:	d907      	bls.n	80093ce <LPS22HB_FIFO_Set_Mode+0x16>
 80093be:	2980      	cmp	r1, #128	; 0x80
 80093c0:	d008      	beq.n	80093d4 <LPS22HB_FIFO_Set_Mode+0x1c>
 80093c2:	29e0      	cmp	r1, #224	; 0xe0
 80093c4:	d006      	beq.n	80093d4 <LPS22HB_FIFO_Set_Mode+0x1c>
 80093c6:	2960      	cmp	r1, #96	; 0x60
 80093c8:	d004      	beq.n	80093d4 <LPS22HB_FIFO_Set_Mode+0x1c>
      return COMPONENT_ERROR;
 80093ca:	2001      	movs	r0, #1
}
 80093cc:	4770      	bx	lr
  switch ( ( LPS22HB_FifoMode_et )mode )
 80093ce:	b109      	cbz	r1, 80093d4 <LPS22HB_FIFO_Set_Mode+0x1c>
 80093d0:	2920      	cmp	r1, #32
 80093d2:	d1fa      	bne.n	80093ca <LPS22HB_FIFO_Set_Mode+0x12>
{
 80093d4:	b508      	push	{r3, lr}
  if ( LPS22HB_Set_FifoMode( handle, ( LPS22HB_FifoMode_et )mode ) == LPS22HB_ERROR )
 80093d6:	f7ff fb77 	bl	8008ac8 <LPS22HB_Set_FifoMode>
      return COMPONENT_ERROR;
 80093da:	f1a0 0001 	sub.w	r0, r0, #1
 80093de:	fab0 f080 	clz	r0, r0
 80093e2:	0940      	lsrs	r0, r0, #5
}
 80093e4:	bd08      	pop	{r3, pc}
 80093e6:	bf00      	nop

080093e8 <LPS22HB_FIFO_Usage>:
  switch ( ( LPS22HB_State_et )status )
 80093e8:	2901      	cmp	r1, #1
 80093ea:	d901      	bls.n	80093f0 <LPS22HB_FIFO_Usage+0x8>
      return COMPONENT_ERROR;
 80093ec:	2001      	movs	r0, #1
}
 80093ee:	4770      	bx	lr
{
 80093f0:	b508      	push	{r3, lr}
  if ( LPS22HB_Set_FifoModeUse( handle, ( LPS22HB_State_et )status ) == LPS22HB_ERROR )
 80093f2:	f7ff f9d9 	bl	80087a8 <LPS22HB_Set_FifoModeUse>
      return COMPONENT_ERROR;
 80093f6:	f1a0 0001 	sub.w	r0, r0, #1
 80093fa:	fab0 f080 	clz	r0, r0
 80093fe:	0940      	lsrs	r0, r0, #5
}
 8009400:	bd08      	pop	{r3, pc}
 8009402:	bf00      	nop

08009404 <LPS22HB_T_Get_ODR>:
 8009404:	f7ff bc82 	b.w	8008d0c <LPS22HB_Get_ODR>

08009408 <LPS22HB_T_Check_WhoAmI>:
 8009408:	f7ff bcdc 	b.w	8008dc4 <LPS22HB_Check_WhoAmI>

0800940c <LPS22HB_FIFO_Stop_On_Fth>:
  switch ( ( LPS22HB_State_et )status )
 800940c:	2901      	cmp	r1, #1
 800940e:	d901      	bls.n	8009414 <LPS22HB_FIFO_Stop_On_Fth+0x8>
      return COMPONENT_ERROR;
 8009410:	2001      	movs	r0, #1
}
 8009412:	4770      	bx	lr
{
 8009414:	b508      	push	{r3, lr}
  if ( LPS22HB_Set_FifoWatermarkLevelUse( handle, ( LPS22HB_State_et )usage ) == LPS22HB_ERROR )
 8009416:	f7ff f9e9 	bl	80087ec <LPS22HB_Set_FifoWatermarkLevelUse>
      return COMPONENT_ERROR;
 800941a:	f1a0 0001 	sub.w	r0, r0, #1
 800941e:	fab0 f080 	clz	r0, r0
 8009422:	0940      	lsrs	r0, r0, #5
}
 8009424:	bd08      	pop	{r3, pc}
 8009426:	bf00      	nop

08009428 <LSM303AGR_ACC_WriteReg>:
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_ACC_WriteReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len)
{
 8009428:	b508      	push	{r3, lr}

  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800942a:	f005 f81b 	bl	800e464 <Sensor_IO_Write>
  }
  else
  {
    return MEMS_SUCCESS;
  }
}
 800942e:	fab0 f080 	clz	r0, r0
 8009432:	0940      	lsrs	r0, r0, #5
 8009434:	bd08      	pop	{r3, pc}
 8009436:	bf00      	nop

08009438 <LSM303AGR_ACC_ReadReg>:
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_ACC_ReadReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len)
{
 8009438:	b508      	push	{r3, lr}

  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800943a:	f005 f901 	bl	800e640 <Sensor_IO_Read>
  }
  else
  {
    return MEMS_SUCCESS;
  }
}
 800943e:	fab0 f080 	clz	r0, r0
 8009442:	0940      	lsrs	r0, r0, #5
 8009444:	bd08      	pop	{r3, pc}
 8009446:	bf00      	nop

08009448 <LSM303AGR_ACC_R_WHO_AM_I>:
* Input          : Pointer to u8_t
* Output         : Status of WHO_AM_I
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_WHO_AM_I(void *handle, u8_t *value)
{
 8009448:	b508      	push	{r3, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800944a:	460a      	mov	r2, r1
 800944c:	2301      	movs	r3, #1
 800944e:	210f      	movs	r1, #15
 8009450:	f005 f8f6 	bl	800e640 <Sensor_IO_Read>

  *value &= LSM303AGR_ACC_WHO_AM_I_MASK; //coerce
  *value = *value >> LSM303AGR_ACC_WHO_AM_I_POSITION; //mask

  return MEMS_SUCCESS;
}
 8009454:	fab0 f080 	clz	r0, r0
 8009458:	0940      	lsrs	r0, r0, #5
 800945a:	bd08      	pop	{r3, pc}

0800945c <LSM303AGR_ACC_W_BlockDataUpdate>:
* Input          : LSM303AGR_ACC_BDU_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_BlockDataUpdate(void *handle, LSM303AGR_ACC_BDU_t newValue)
{
 800945c:	b530      	push	{r4, r5, lr}
 800945e:	b083      	sub	sp, #12
 8009460:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8009462:	f10d 0207 	add.w	r2, sp, #7
 8009466:	2301      	movs	r3, #1
 8009468:	2123      	movs	r1, #35	; 0x23
{
 800946a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800946c:	f005 f8e8 	bl	800e640 <Sensor_IO_Read>
 8009470:	b110      	cbz	r0, 8009478 <LSM303AGR_ACC_W_BlockDataUpdate+0x1c>
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
    return MEMS_ERROR;
 8009472:	2000      	movs	r0, #0

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8009474:	b003      	add	sp, #12
 8009476:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_ACC_BDU_MASK;
 8009478:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800947c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  value |= newValue;
 8009480:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8009482:	f10d 0207 	add.w	r2, sp, #7
 8009486:	4628      	mov	r0, r5
 8009488:	2301      	movs	r3, #1
 800948a:	2123      	movs	r1, #35	; 0x23
  value |= newValue;
 800948c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8009490:	f004 ffe8 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 8009494:	fab0 f080 	clz	r0, r0
 8009498:	0940      	lsrs	r0, r0, #5
}
 800949a:	b003      	add	sp, #12
 800949c:	bd30      	pop	{r4, r5, pc}
 800949e:	bf00      	nop

080094a0 <LSM303AGR_ACC_W_FullScale>:
* Input          : LSM303AGR_ACC_FS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FullScale(void *handle, LSM303AGR_ACC_FS_t newValue)
{
 80094a0:	b530      	push	{r4, r5, lr}
 80094a2:	b083      	sub	sp, #12
 80094a4:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80094a6:	f10d 0207 	add.w	r2, sp, #7
 80094aa:	2301      	movs	r3, #1
 80094ac:	2123      	movs	r1, #35	; 0x23
{
 80094ae:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80094b0:	f005 f8c6 	bl	800e640 <Sensor_IO_Read>
 80094b4:	b110      	cbz	r0, 80094bc <LSM303AGR_ACC_W_FullScale+0x1c>
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
    return MEMS_ERROR;
 80094b6:	2000      	movs	r0, #0

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80094b8:	b003      	add	sp, #12
 80094ba:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_ACC_FS_MASK;
 80094bc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80094c0:	f023 0330 	bic.w	r3, r3, #48	; 0x30
  value |= newValue;
 80094c4:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 80094c6:	f10d 0207 	add.w	r2, sp, #7
 80094ca:	4628      	mov	r0, r5
 80094cc:	2301      	movs	r3, #1
 80094ce:	2123      	movs	r1, #35	; 0x23
  value |= newValue;
 80094d0:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 80094d4:	f004 ffc6 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 80094d8:	fab0 f080 	clz	r0, r0
 80094dc:	0940      	lsrs	r0, r0, #5
}
 80094de:	b003      	add	sp, #12
 80094e0:	bd30      	pop	{r4, r5, pc}
 80094e2:	bf00      	nop

080094e4 <LSM303AGR_ACC_R_FullScale>:
* Input          : Pointer to LSM303AGR_ACC_FS_t
* Output         : Status of FS see LSM303AGR_ACC_FS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FullScale(void *handle, LSM303AGR_ACC_FS_t *value)
{
 80094e4:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80094e6:	460a      	mov	r2, r1
{
 80094e8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80094ea:	2301      	movs	r3, #1
 80094ec:	2123      	movs	r1, #35	; 0x23
 80094ee:	f005 f8a7 	bl	800e640 <Sensor_IO_Read>
 80094f2:	b928      	cbnz	r0, 8009500 <LSM303AGR_ACC_R_FullScale+0x1c>
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM303AGR_ACC_FS_MASK; //mask
 80094f4:	7823      	ldrb	r3, [r4, #0]
 80094f6:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80094fa:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 80094fc:	2001      	movs	r0, #1
}
 80094fe:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 8009500:	2000      	movs	r0, #0
}
 8009502:	bd10      	pop	{r4, pc}

08009504 <LSM303AGR_ACC_Get_Raw_Acceleration>:
* Input          : pointer to [u8_t]
* Output         : Acceleration buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_Get_Raw_Acceleration(void *handle, u8_t *buff)
{
 8009504:	b508      	push	{r3, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8009506:	460a      	mov	r2, r1
 8009508:	2306      	movs	r3, #6
 800950a:	2128      	movs	r1, #40	; 0x28
 800950c:	f005 f898 	bl	800e640 <Sensor_IO_Read>
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_OUT_X_L, buff, 6 ) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8009510:	fab0 f080 	clz	r0, r0
 8009514:	0940      	lsrs	r0, r0, #5
 8009516:	bd08      	pop	{r3, pc}

08009518 <LSM303AGR_ACC_Get_Acceleration>:
    62520,  /* FS @8g */
    187580, /* FS @16g */
  },
};
status_t LSM303AGR_ACC_Get_Acceleration(void *handle, int *buff)
{
 8009518:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800951c:	b085      	sub	sp, #20
 800951e:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8009520:	2301      	movs	r3, #1
 8009522:	f10d 0206 	add.w	r2, sp, #6
 8009526:	2123      	movs	r1, #35	; 0x23
{
 8009528:	4607      	mov	r7, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800952a:	f005 f889 	bl	800e640 <Sensor_IO_Read>
 800952e:	b928      	cbnz	r0, 800953c <LSM303AGR_ACC_Get_Acceleration+0x24>
status_t LSM303AGR_ACC_R_HiRes(void *handle, LSM303AGR_ACC_HR_t *value)
{
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM303AGR_ACC_HR_MASK; //mask
 8009530:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8009534:	f003 0308 	and.w	r3, r3, #8
 8009538:	f88d 3006 	strb.w	r3, [sp, #6]
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800953c:	2301      	movs	r3, #1
 800953e:	f10d 0205 	add.w	r2, sp, #5
 8009542:	2120      	movs	r1, #32
 8009544:	4638      	mov	r0, r7
 8009546:	f005 f87b 	bl	800e640 <Sensor_IO_Read>
 800954a:	2800      	cmp	r0, #0
 800954c:	d079      	beq.n	8009642 <LSM303AGR_ACC_Get_Acceleration+0x12a>
 800954e:	f89d 4005 	ldrb.w	r4, [sp, #5]
  if (lp == LSM303AGR_ACC_LPEN_ENABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8009552:	2c08      	cmp	r4, #8
 8009554:	d07d      	beq.n	8009652 <LSM303AGR_ACC_Get_Acceleration+0x13a>
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8009556:	2c00      	cmp	r4, #0
 8009558:	f040 8081 	bne.w	800965e <LSM303AGR_ACC_Get_Acceleration+0x146>
 800955c:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8009560:	2b00      	cmp	r3, #0
 8009562:	f040 8081 	bne.w	8009668 <LSM303AGR_ACC_Get_Acceleration+0x150>
 8009566:	f04f 0801 	mov.w	r8, #1
 800956a:	2406      	movs	r4, #6
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800956c:	2301      	movs	r3, #1
 800956e:	f10d 0207 	add.w	r2, sp, #7
 8009572:	2123      	movs	r1, #35	; 0x23
 8009574:	4638      	mov	r0, r7
 8009576:	f005 f863 	bl	800e640 <Sensor_IO_Read>
 800957a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800957e:	b918      	cbnz	r0, 8009588 <LSM303AGR_ACC_Get_Acceleration+0x70>
  *value &= LSM303AGR_ACC_FS_MASK; //mask
 8009580:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8009584:	f88d 3007 	strb.w	r3, [sp, #7]
  switch (fs)
 8009588:	2b20      	cmp	r3, #32
 800958a:	d079      	beq.n	8009680 <LSM303AGR_ACC_Get_Acceleration+0x168>
 800958c:	2b30      	cmp	r3, #48	; 0x30
 800958e:	d075      	beq.n	800967c <LSM303AGR_ACC_Get_Acceleration+0x164>
 8009590:	f1a3 0610 	sub.w	r6, r3, #16
 8009594:	fab6 f686 	clz	r6, r6
 8009598:	0976      	lsrs	r6, r6, #5
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800959a:	aa02      	add	r2, sp, #8
 800959c:	4638      	mov	r0, r7
 800959e:	2306      	movs	r3, #6
 80095a0:	2128      	movs	r1, #40	; 0x28
 80095a2:	f005 f84d 	bl	800e640 <Sensor_IO_Read>
  buff[0] = ((raw_data_tmp.i16bit[0] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 80095a6:	4a37      	ldr	r2, [pc, #220]	; (8009684 <LSM303AGR_ACC_Get_Acceleration+0x16c>)
 80095a8:	f9bd 0008 	ldrsh.w	r0, [sp, #8]
 80095ac:	eb06 0388 	add.w	r3, r6, r8, lsl #2
 80095b0:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
 80095b4:	f852 7033 	ldr.w	r7, [r2, r3, lsl #3]
 80095b8:	684e      	ldr	r6, [r1, #4]
 80095ba:	4120      	asrs	r0, r4
 80095bc:	fb00 f106 	mul.w	r1, r0, r6
 80095c0:	17c3      	asrs	r3, r0, #31
 80095c2:	fb07 1303 	mla	r3, r7, r3, r1
 80095c6:	fba0 8907 	umull	r8, r9, r0, r7
 80095ca:	f518 70fa 	adds.w	r0, r8, #500	; 0x1f4
 80095ce:	4499      	add	r9, r3
 80095d0:	f149 0100 	adc.w	r1, r9, #0
 80095d4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80095d8:	2300      	movs	r3, #0
 80095da:	f7fe fa3d 	bl	8007a58 <__aeabi_ldivmod>
  buff[1] = ((raw_data_tmp.i16bit[1] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 80095de:	f9bd 300a 	ldrsh.w	r3, [sp, #10]
  buff[0] = ((raw_data_tmp.i16bit[0] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 80095e2:	6028      	str	r0, [r5, #0]
  buff[1] = ((raw_data_tmp.i16bit[1] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 80095e4:	fa43 f004 	asr.w	r0, r3, r4
 80095e8:	fb00 f106 	mul.w	r1, r0, r6
 80095ec:	17c3      	asrs	r3, r0, #31
 80095ee:	fb07 1303 	mla	r3, r7, r3, r1
 80095f2:	fba0 8907 	umull	r8, r9, r0, r7
 80095f6:	f518 70fa 	adds.w	r0, r8, #500	; 0x1f4
 80095fa:	4499      	add	r9, r3
 80095fc:	f149 0100 	adc.w	r1, r9, #0
 8009600:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8009604:	2300      	movs	r3, #0
 8009606:	f7fe fa27 	bl	8007a58 <__aeabi_ldivmod>
  buff[2] = ((raw_data_tmp.i16bit[2] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 800960a:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
  buff[1] = ((raw_data_tmp.i16bit[1] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 800960e:	6068      	str	r0, [r5, #4]
  buff[2] = ((raw_data_tmp.i16bit[2] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 8009610:	fa43 f004 	asr.w	r0, r3, r4
 8009614:	17c3      	asrs	r3, r0, #31
 8009616:	fb00 f606 	mul.w	r6, r0, r6
 800961a:	fb07 6603 	mla	r6, r7, r3, r6
 800961e:	fba0 3407 	umull	r3, r4, r0, r7
 8009622:	f513 70fa 	adds.w	r0, r3, #500	; 0x1f4
 8009626:	4434      	add	r4, r6
 8009628:	f144 0100 	adc.w	r1, r4, #0
 800962c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8009630:	2300      	movs	r3, #0
 8009632:	f7fe fa11 	bl	8007a58 <__aeabi_ldivmod>
  return MEMS_SUCCESS;
 8009636:	2301      	movs	r3, #1
  buff[2] = ((raw_data_tmp.i16bit[2] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 8009638:	60a8      	str	r0, [r5, #8]
}
 800963a:	4618      	mov	r0, r3
 800963c:	b005      	add	sp, #20
 800963e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  *value &= LSM303AGR_ACC_LPEN_MASK; //mask
 8009642:	f89d 0005 	ldrb.w	r0, [sp, #5]
 8009646:	f000 0408 	and.w	r4, r0, #8
  if (lp == LSM303AGR_ACC_LPEN_ENABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 800964a:	2c08      	cmp	r4, #8
  *value &= LSM303AGR_ACC_LPEN_MASK; //mask
 800964c:	f88d 4005 	strb.w	r4, [sp, #5]
  if (lp == LSM303AGR_ACC_LPEN_ENABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8009650:	d181      	bne.n	8009556 <LSM303AGR_ACC_Get_Acceleration+0x3e>
 8009652:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8009656:	b913      	cbnz	r3, 800965e <LSM303AGR_ACC_Get_Acceleration+0x146>
 8009658:	f04f 0802 	mov.w	r8, #2
 800965c:	e786      	b.n	800956c <LSM303AGR_ACC_Get_Acceleration+0x54>
    return MEMS_ERROR;
 800965e:	2300      	movs	r3, #0
}
 8009660:	4618      	mov	r0, r3
 8009662:	b005      	add	sp, #20
 8009664:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_ENABLED)
 8009668:	2b08      	cmp	r3, #8
 800966a:	d004      	beq.n	8009676 <LSM303AGR_ACC_Get_Acceleration+0x15e>
    return MEMS_ERROR;
 800966c:	4623      	mov	r3, r4
}
 800966e:	4618      	mov	r0, r3
 8009670:	b005      	add	sp, #20
 8009672:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8009676:	46a0      	mov	r8, r4
 8009678:	2404      	movs	r4, #4
 800967a:	e777      	b.n	800956c <LSM303AGR_ACC_Get_Acceleration+0x54>
      break;
 800967c:	2603      	movs	r6, #3
 800967e:	e78c      	b.n	800959a <LSM303AGR_ACC_Get_Acceleration+0x82>
      break;
 8009680:	2602      	movs	r6, #2
 8009682:	e78a      	b.n	800959a <LSM303AGR_ACC_Get_Acceleration+0x82>
 8009684:	08022a08 	.word	0x08022a08

08009688 <LSM303AGR_ACC_W_ODR>:
{
 8009688:	b530      	push	{r4, r5, lr}
 800968a:	b083      	sub	sp, #12
 800968c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800968e:	f10d 0207 	add.w	r2, sp, #7
 8009692:	2301      	movs	r3, #1
 8009694:	2120      	movs	r1, #32
{
 8009696:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8009698:	f004 ffd2 	bl	800e640 <Sensor_IO_Read>
 800969c:	b110      	cbz	r0, 80096a4 <LSM303AGR_ACC_W_ODR+0x1c>
    return MEMS_ERROR;
 800969e:	2000      	movs	r0, #0
}
 80096a0:	b003      	add	sp, #12
 80096a2:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_ACC_ODR_MASK;
 80096a4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80096a8:	f003 030f 	and.w	r3, r3, #15
  value |= newValue;
 80096ac:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 80096ae:	f10d 0207 	add.w	r2, sp, #7
 80096b2:	4628      	mov	r0, r5
 80096b4:	2301      	movs	r3, #1
 80096b6:	2120      	movs	r1, #32
  value |= newValue;
 80096b8:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 80096bc:	f004 fed2 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 80096c0:	fab0 f080 	clz	r0, r0
 80096c4:	0940      	lsrs	r0, r0, #5
}
 80096c6:	b003      	add	sp, #12
 80096c8:	bd30      	pop	{r4, r5, pc}
 80096ca:	bf00      	nop

080096cc <LSM303AGR_ACC_R_ODR>:
{
 80096cc:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80096ce:	460a      	mov	r2, r1
{
 80096d0:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80096d2:	2301      	movs	r3, #1
 80096d4:	2120      	movs	r1, #32
 80096d6:	f004 ffb3 	bl	800e640 <Sensor_IO_Read>
 80096da:	b928      	cbnz	r0, 80096e8 <LSM303AGR_ACC_R_ODR+0x1c>
  *value &= LSM303AGR_ACC_ODR_MASK; //mask
 80096dc:	7823      	ldrb	r3, [r4, #0]
 80096de:	f023 030f 	bic.w	r3, r3, #15
 80096e2:	7023      	strb	r3, [r4, #0]
  return MEMS_SUCCESS;
 80096e4:	2001      	movs	r0, #1
}
 80096e6:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 80096e8:	2000      	movs	r0, #0
}
 80096ea:	bd10      	pop	{r4, pc}

080096ec <LSM303AGR_ACC_W_XEN>:
{
 80096ec:	b530      	push	{r4, r5, lr}
 80096ee:	b083      	sub	sp, #12
 80096f0:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80096f2:	f10d 0207 	add.w	r2, sp, #7
 80096f6:	2301      	movs	r3, #1
 80096f8:	2120      	movs	r1, #32
{
 80096fa:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80096fc:	f004 ffa0 	bl	800e640 <Sensor_IO_Read>
 8009700:	b110      	cbz	r0, 8009708 <LSM303AGR_ACC_W_XEN+0x1c>
    return MEMS_ERROR;
 8009702:	2000      	movs	r0, #0
}
 8009704:	b003      	add	sp, #12
 8009706:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_ACC_XEN_MASK;
 8009708:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800970c:	f023 0301 	bic.w	r3, r3, #1
  value |= newValue;
 8009710:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8009712:	f10d 0207 	add.w	r2, sp, #7
 8009716:	4628      	mov	r0, r5
 8009718:	2301      	movs	r3, #1
 800971a:	2120      	movs	r1, #32
  value |= newValue;
 800971c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8009720:	f004 fea0 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 8009724:	fab0 f080 	clz	r0, r0
 8009728:	0940      	lsrs	r0, r0, #5
}
 800972a:	b003      	add	sp, #12
 800972c:	bd30      	pop	{r4, r5, pc}
 800972e:	bf00      	nop

08009730 <LSM303AGR_ACC_R_XEN>:
{
 8009730:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8009732:	460a      	mov	r2, r1
{
 8009734:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8009736:	2301      	movs	r3, #1
 8009738:	2120      	movs	r1, #32
 800973a:	f004 ff81 	bl	800e640 <Sensor_IO_Read>
 800973e:	b928      	cbnz	r0, 800974c <LSM303AGR_ACC_R_XEN+0x1c>
  *value &= LSM303AGR_ACC_XEN_MASK; //mask
 8009740:	7823      	ldrb	r3, [r4, #0]
 8009742:	f003 0301 	and.w	r3, r3, #1
 8009746:	7023      	strb	r3, [r4, #0]
  return MEMS_SUCCESS;
 8009748:	2001      	movs	r0, #1
}
 800974a:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800974c:	2000      	movs	r0, #0
}
 800974e:	bd10      	pop	{r4, pc}

08009750 <LSM303AGR_ACC_W_YEN>:
{
 8009750:	b530      	push	{r4, r5, lr}
 8009752:	b083      	sub	sp, #12
 8009754:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8009756:	f10d 0207 	add.w	r2, sp, #7
 800975a:	2301      	movs	r3, #1
 800975c:	2120      	movs	r1, #32
{
 800975e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8009760:	f004 ff6e 	bl	800e640 <Sensor_IO_Read>
 8009764:	b110      	cbz	r0, 800976c <LSM303AGR_ACC_W_YEN+0x1c>
    return MEMS_ERROR;
 8009766:	2000      	movs	r0, #0
}
 8009768:	b003      	add	sp, #12
 800976a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_ACC_YEN_MASK;
 800976c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009770:	f023 0302 	bic.w	r3, r3, #2
  value |= newValue;
 8009774:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8009776:	f10d 0207 	add.w	r2, sp, #7
 800977a:	4628      	mov	r0, r5
 800977c:	2301      	movs	r3, #1
 800977e:	2120      	movs	r1, #32
  value |= newValue;
 8009780:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8009784:	f004 fe6e 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 8009788:	fab0 f080 	clz	r0, r0
 800978c:	0940      	lsrs	r0, r0, #5
}
 800978e:	b003      	add	sp, #12
 8009790:	bd30      	pop	{r4, r5, pc}
 8009792:	bf00      	nop

08009794 <LSM303AGR_ACC_R_YEN>:
{
 8009794:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8009796:	460a      	mov	r2, r1
{
 8009798:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800979a:	2301      	movs	r3, #1
 800979c:	2120      	movs	r1, #32
 800979e:	f004 ff4f 	bl	800e640 <Sensor_IO_Read>
 80097a2:	b928      	cbnz	r0, 80097b0 <LSM303AGR_ACC_R_YEN+0x1c>
  *value &= LSM303AGR_ACC_YEN_MASK; //mask
 80097a4:	7823      	ldrb	r3, [r4, #0]
 80097a6:	f003 0302 	and.w	r3, r3, #2
 80097aa:	7023      	strb	r3, [r4, #0]
  return MEMS_SUCCESS;
 80097ac:	2001      	movs	r0, #1
}
 80097ae:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 80097b0:	2000      	movs	r0, #0
}
 80097b2:	bd10      	pop	{r4, pc}

080097b4 <LSM303AGR_ACC_W_ZEN>:
{
 80097b4:	b530      	push	{r4, r5, lr}
 80097b6:	b083      	sub	sp, #12
 80097b8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80097ba:	f10d 0207 	add.w	r2, sp, #7
 80097be:	2301      	movs	r3, #1
 80097c0:	2120      	movs	r1, #32
{
 80097c2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80097c4:	f004 ff3c 	bl	800e640 <Sensor_IO_Read>
 80097c8:	b110      	cbz	r0, 80097d0 <LSM303AGR_ACC_W_ZEN+0x1c>
    return MEMS_ERROR;
 80097ca:	2000      	movs	r0, #0
}
 80097cc:	b003      	add	sp, #12
 80097ce:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_ACC_ZEN_MASK;
 80097d0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80097d4:	f023 0304 	bic.w	r3, r3, #4
  value |= newValue;
 80097d8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 80097da:	f10d 0207 	add.w	r2, sp, #7
 80097de:	4628      	mov	r0, r5
 80097e0:	2301      	movs	r3, #1
 80097e2:	2120      	movs	r1, #32
  value |= newValue;
 80097e4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 80097e8:	f004 fe3c 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 80097ec:	fab0 f080 	clz	r0, r0
 80097f0:	0940      	lsrs	r0, r0, #5
}
 80097f2:	b003      	add	sp, #12
 80097f4:	bd30      	pop	{r4, r5, pc}
 80097f6:	bf00      	nop

080097f8 <LSM303AGR_ACC_R_ZEN>:
{
 80097f8:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80097fa:	460a      	mov	r2, r1
{
 80097fc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80097fe:	2301      	movs	r3, #1
 8009800:	2120      	movs	r1, #32
 8009802:	f004 ff1d 	bl	800e640 <Sensor_IO_Read>
 8009806:	b928      	cbnz	r0, 8009814 <LSM303AGR_ACC_R_ZEN+0x1c>
  *value &= LSM303AGR_ACC_ZEN_MASK; //mask
 8009808:	7823      	ldrb	r3, [r4, #0]
 800980a:	f003 0304 	and.w	r3, r3, #4
 800980e:	7023      	strb	r3, [r4, #0]
  return MEMS_SUCCESS;
 8009810:	2001      	movs	r0, #1
}
 8009812:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 8009814:	2000      	movs	r0, #0
}
 8009816:	bd10      	pop	{r4, pc}

08009818 <LSM303AGR_ACC_R_LOWPWR_EN>:
{
 8009818:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800981a:	460a      	mov	r2, r1
{
 800981c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800981e:	2301      	movs	r3, #1
 8009820:	2120      	movs	r1, #32
 8009822:	f004 ff0d 	bl	800e640 <Sensor_IO_Read>
 8009826:	b928      	cbnz	r0, 8009834 <LSM303AGR_ACC_R_LOWPWR_EN+0x1c>
  *value &= LSM303AGR_ACC_LPEN_MASK; //mask
 8009828:	7823      	ldrb	r3, [r4, #0]
 800982a:	f003 0308 	and.w	r3, r3, #8
 800982e:	7023      	strb	r3, [r4, #0]
  return MEMS_SUCCESS;
 8009830:	2001      	movs	r0, #1
}
 8009832:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 8009834:	2000      	movs	r0, #0
}
 8009836:	bd10      	pop	{r4, pc}

08009838 <LSM303AGR_ACC_R_HiRes>:
{
 8009838:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800983a:	460a      	mov	r2, r1
{
 800983c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800983e:	2301      	movs	r3, #1
 8009840:	2123      	movs	r1, #35	; 0x23
 8009842:	f004 fefd 	bl	800e640 <Sensor_IO_Read>
 8009846:	b928      	cbnz	r0, 8009854 <LSM303AGR_ACC_R_HiRes+0x1c>
  *value &= LSM303AGR_ACC_HR_MASK; //mask
 8009848:	7823      	ldrb	r3, [r4, #0]
 800984a:	f003 0308 	and.w	r3, r3, #8
 800984e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8009850:	2001      	movs	r0, #1
}
 8009852:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 8009854:	2000      	movs	r0, #0
}
 8009856:	bd10      	pop	{r4, pc}

08009858 <LSM303AGR_ACC_R_XDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_XDA_t
* Output         : Status of XDA see LSM303AGR_ACC_XDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XDataAvail(void *handle, LSM303AGR_ACC_XDA_t *value)
{
 8009858:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800985a:	460a      	mov	r2, r1
{
 800985c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800985e:	2301      	movs	r3, #1
 8009860:	2127      	movs	r1, #39	; 0x27
 8009862:	f004 feed 	bl	800e640 <Sensor_IO_Read>
 8009866:	b928      	cbnz	r0, 8009874 <LSM303AGR_ACC_R_XDataAvail+0x1c>
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM303AGR_ACC_XDA_MASK; //mask
 8009868:	7823      	ldrb	r3, [r4, #0]
 800986a:	f003 0301 	and.w	r3, r3, #1
 800986e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8009870:	2001      	movs	r0, #1
}
 8009872:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 8009874:	2000      	movs	r0, #0
}
 8009876:	bd10      	pop	{r4, pc}

08009878 <LSM303AGR_ACC_W_FifoMode>:
* Input          : LSM303AGR_ACC_FM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FifoMode(void *handle, LSM303AGR_ACC_FM_t newValue)
{
 8009878:	b530      	push	{r4, r5, lr}
 800987a:	b083      	sub	sp, #12
 800987c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800987e:	f10d 0207 	add.w	r2, sp, #7
 8009882:	2301      	movs	r3, #1
 8009884:	212e      	movs	r1, #46	; 0x2e
{
 8009886:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8009888:	f004 feda 	bl	800e640 <Sensor_IO_Read>
 800988c:	b110      	cbz	r0, 8009894 <LSM303AGR_ACC_W_FifoMode+0x1c>
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
    return MEMS_ERROR;
 800988e:	2000      	movs	r0, #0

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8009890:	b003      	add	sp, #12
 8009892:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_ACC_FM_MASK;
 8009894:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009898:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  value |= newValue;
 800989c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800989e:	f10d 0207 	add.w	r2, sp, #7
 80098a2:	4628      	mov	r0, r5
 80098a4:	2301      	movs	r3, #1
 80098a6:	212e      	movs	r1, #46	; 0x2e
  value |= newValue;
 80098a8:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 80098ac:	f004 fdda 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 80098b0:	fab0 f080 	clz	r0, r0
 80098b4:	0940      	lsrs	r0, r0, #5
}
 80098b6:	b003      	add	sp, #12
 80098b8:	bd30      	pop	{r4, r5, pc}
 80098ba:	bf00      	nop

080098bc <LSM303AGR_X_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LSM303AGR_X_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 80098bc:	b510      	push	{r4, lr}
 80098be:	b082      	sub	sp, #8
 80098c0:	460c      	mov	r4, r1

  LSM303AGR_ACC_XDA_t status_raw;

  if ( LSM303AGR_ACC_R_XDataAvail( (void *)handle, &status_raw ) == MEMS_ERROR )
 80098c2:	f10d 0107 	add.w	r1, sp, #7
 80098c6:	f7ff ffc7 	bl	8009858 <LSM303AGR_ACC_R_XDataAvail>
 80098ca:	b120      	cbz	r0, 80098d6 <LSM303AGR_X_Get_DRDY_Status+0x1a>
  {
    return COMPONENT_ERROR;
  }

  switch( status_raw )
 80098cc:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80098d0:	b140      	cbz	r0, 80098e4 <LSM303AGR_X_Get_DRDY_Status+0x28>
 80098d2:	2801      	cmp	r0, #1
 80098d4:	d002      	beq.n	80098dc <LSM303AGR_X_Get_DRDY_Status+0x20>
      break;
    case LSM303AGR_ACC_XDA_NOT_AVAILABLE:
      *status = 0;
      break;
    default:
      return COMPONENT_ERROR;
 80098d6:	2001      	movs	r0, #1
  }

  return COMPONENT_OK;
}
 80098d8:	b002      	add	sp, #8
 80098da:	bd10      	pop	{r4, pc}
      *status = 1;
 80098dc:	7020      	strb	r0, [r4, #0]
  return COMPONENT_OK;
 80098de:	2000      	movs	r0, #0
}
 80098e0:	b002      	add	sp, #8
 80098e2:	bd10      	pop	{r4, pc}
      *status = 0;
 80098e4:	7020      	strb	r0, [r4, #0]
}
 80098e6:	b002      	add	sp, #8
 80098e8:	bd10      	pop	{r4, pc}
 80098ea:	bf00      	nop

080098ec <LSM303AGR_X_Write_Reg>:
{
 80098ec:	b510      	push	{r4, lr}
 80098ee:	b082      	sub	sp, #8
 80098f0:	ac02      	add	r4, sp, #8
  if ( LSM303AGR_ACC_WriteReg( (void *)handle, reg, &data, 1 ) == MEMS_ERROR )
 80098f2:	2301      	movs	r3, #1
{
 80098f4:	f804 2d01 	strb.w	r2, [r4, #-1]!
  if ( LSM303AGR_ACC_WriteReg( (void *)handle, reg, &data, 1 ) == MEMS_ERROR )
 80098f8:	4622      	mov	r2, r4
 80098fa:	f7ff fd95 	bl	8009428 <LSM303AGR_ACC_WriteReg>
}
 80098fe:	fab0 f080 	clz	r0, r0
 8009902:	0940      	lsrs	r0, r0, #5
 8009904:	b002      	add	sp, #8
 8009906:	bd10      	pop	{r4, pc}

08009908 <LSM303AGR_X_Read_Reg>:
{
 8009908:	b508      	push	{r3, lr}
  if ( LSM303AGR_ACC_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 800990a:	2301      	movs	r3, #1
 800990c:	f7ff fd94 	bl	8009438 <LSM303AGR_ACC_ReadReg>
}
 8009910:	fab0 f080 	clz	r0, r0
 8009914:	0940      	lsrs	r0, r0, #5
 8009916:	bd08      	pop	{r3, pc}

08009918 <LSM303AGR_X_Get_Axes_Status>:
{
 8009918:	b530      	push	{r4, r5, lr}
 800991a:	b083      	sub	sp, #12
 800991c:	460d      	mov	r5, r1
  if ( LSM303AGR_ACC_R_XEN( (void *)handle, &xStatus ) == MEMS_ERROR )
 800991e:	f10d 0105 	add.w	r1, sp, #5
{
 8009922:	4604      	mov	r4, r0
  if ( LSM303AGR_ACC_R_XEN( (void *)handle, &xStatus ) == MEMS_ERROR )
 8009924:	f7ff ff04 	bl	8009730 <LSM303AGR_ACC_R_XEN>
 8009928:	b910      	cbnz	r0, 8009930 <LSM303AGR_X_Get_Axes_Status+0x18>
    return COMPONENT_ERROR;
 800992a:	2001      	movs	r0, #1
}
 800992c:	b003      	add	sp, #12
 800992e:	bd30      	pop	{r4, r5, pc}
  if ( LSM303AGR_ACC_R_YEN( (void *)handle, &yStatus ) == MEMS_ERROR )
 8009930:	f10d 0106 	add.w	r1, sp, #6
 8009934:	4620      	mov	r0, r4
 8009936:	f7ff ff2d 	bl	8009794 <LSM303AGR_ACC_R_YEN>
 800993a:	2800      	cmp	r0, #0
 800993c:	d0f5      	beq.n	800992a <LSM303AGR_X_Get_Axes_Status+0x12>
  if ( LSM303AGR_ACC_R_ZEN( (void *)handle, &zStatus ) == MEMS_ERROR )
 800993e:	4620      	mov	r0, r4
 8009940:	f10d 0107 	add.w	r1, sp, #7
 8009944:	f7ff ff58 	bl	80097f8 <LSM303AGR_ACC_R_ZEN>
 8009948:	2800      	cmp	r0, #0
 800994a:	d0ee      	beq.n	800992a <LSM303AGR_X_Get_Axes_Status+0x12>
  xyz_enabled[0] = ( xStatus == LSM303AGR_ACC_XEN_ENABLED ) ? 1 : 0;
 800994c:	f89d 1005 	ldrb.w	r1, [sp, #5]
  xyz_enabled[1] = ( yStatus == LSM303AGR_ACC_YEN_ENABLED ) ? 1 : 0;
 8009950:	f89d 2006 	ldrb.w	r2, [sp, #6]
  xyz_enabled[2] = ( zStatus == LSM303AGR_ACC_ZEN_ENABLED ) ? 1 : 0;
 8009954:	f89d 3007 	ldrb.w	r3, [sp, #7]
  xyz_enabled[0] = ( xStatus == LSM303AGR_ACC_XEN_ENABLED ) ? 1 : 0;
 8009958:	f1a1 0101 	sub.w	r1, r1, #1
  xyz_enabled[1] = ( yStatus == LSM303AGR_ACC_YEN_ENABLED ) ? 1 : 0;
 800995c:	f1a2 0202 	sub.w	r2, r2, #2
  xyz_enabled[2] = ( zStatus == LSM303AGR_ACC_ZEN_ENABLED ) ? 1 : 0;
 8009960:	f1a3 0304 	sub.w	r3, r3, #4
  xyz_enabled[0] = ( xStatus == LSM303AGR_ACC_XEN_ENABLED ) ? 1 : 0;
 8009964:	fab1 f181 	clz	r1, r1
  xyz_enabled[1] = ( yStatus == LSM303AGR_ACC_YEN_ENABLED ) ? 1 : 0;
 8009968:	fab2 f282 	clz	r2, r2
  xyz_enabled[2] = ( zStatus == LSM303AGR_ACC_ZEN_ENABLED ) ? 1 : 0;
 800996c:	fab3 f383 	clz	r3, r3
  xyz_enabled[0] = ( xStatus == LSM303AGR_ACC_XEN_ENABLED ) ? 1 : 0;
 8009970:	0949      	lsrs	r1, r1, #5
  xyz_enabled[1] = ( yStatus == LSM303AGR_ACC_YEN_ENABLED ) ? 1 : 0;
 8009972:	0952      	lsrs	r2, r2, #5
  xyz_enabled[2] = ( zStatus == LSM303AGR_ACC_ZEN_ENABLED ) ? 1 : 0;
 8009974:	095b      	lsrs	r3, r3, #5
  xyz_enabled[0] = ( xStatus == LSM303AGR_ACC_XEN_ENABLED ) ? 1 : 0;
 8009976:	7029      	strb	r1, [r5, #0]
  xyz_enabled[1] = ( yStatus == LSM303AGR_ACC_YEN_ENABLED ) ? 1 : 0;
 8009978:	706a      	strb	r2, [r5, #1]
  xyz_enabled[2] = ( zStatus == LSM303AGR_ACC_ZEN_ENABLED ) ? 1 : 0;
 800997a:	70ab      	strb	r3, [r5, #2]
  return COMPONENT_OK;
 800997c:	2000      	movs	r0, #0
 800997e:	e7d5      	b.n	800992c <LSM303AGR_X_Get_Axes_Status+0x14>

08009980 <LSM303AGR_X_Set_FS_Value>:
           : ( fullScale <= 4.0f ) ? LSM303AGR_ACC_FS_4G
 8009980:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 8009984:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009988:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 800998c:	b508      	push	{r3, lr}
           : ( fullScale <= 4.0f ) ? LSM303AGR_ACC_FS_4G
 800998e:	d90d      	bls.n	80099ac <LSM303AGR_X_Set_FS_Value+0x2c>
 8009990:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
 8009994:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009998:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800999c:	d80d      	bhi.n	80099ba <LSM303AGR_X_Set_FS_Value+0x3a>
 800999e:	2110      	movs	r1, #16
  if ( LSM303AGR_ACC_W_FullScale( (void *)handle, new_fs ) == MEMS_ERROR )
 80099a0:	f7ff fd7e 	bl	80094a0 <LSM303AGR_ACC_W_FullScale>
}
 80099a4:	fab0 f080 	clz	r0, r0
 80099a8:	0940      	lsrs	r0, r0, #5
 80099aa:	bd08      	pop	{r3, pc}
           : ( fullScale <= 4.0f ) ? LSM303AGR_ACC_FS_4G
 80099ac:	2100      	movs	r1, #0
  if ( LSM303AGR_ACC_W_FullScale( (void *)handle, new_fs ) == MEMS_ERROR )
 80099ae:	f7ff fd77 	bl	80094a0 <LSM303AGR_ACC_W_FullScale>
}
 80099b2:	fab0 f080 	clz	r0, r0
 80099b6:	0940      	lsrs	r0, r0, #5
 80099b8:	bd08      	pop	{r3, pc}
           : ( fullScale <= 4.0f ) ? LSM303AGR_ACC_FS_4G
 80099ba:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 80099be:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80099c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80099c6:	bf94      	ite	ls
 80099c8:	2120      	movls	r1, #32
 80099ca:	2130      	movhi	r1, #48	; 0x30
  if ( LSM303AGR_ACC_W_FullScale( (void *)handle, new_fs ) == MEMS_ERROR )
 80099cc:	f7ff fd68 	bl	80094a0 <LSM303AGR_ACC_W_FullScale>
}
 80099d0:	fab0 f080 	clz	r0, r0
 80099d4:	0940      	lsrs	r0, r0, #5
 80099d6:	bd08      	pop	{r3, pc}

080099d8 <LSM303AGR_X_Set_FS>:
  switch( fullScale )
 80099d8:	2902      	cmp	r1, #2
 80099da:	d00c      	beq.n	80099f6 <LSM303AGR_X_Set_FS+0x1e>
 80099dc:	2904      	cmp	r1, #4
 80099de:	d002      	beq.n	80099e6 <LSM303AGR_X_Set_FS+0xe>
 80099e0:	b111      	cbz	r1, 80099e8 <LSM303AGR_X_Set_FS+0x10>
      return COMPONENT_ERROR;
 80099e2:	2001      	movs	r0, #1
}
 80099e4:	4770      	bx	lr
      new_fs = LSM303AGR_ACC_FS_8G;
 80099e6:	2120      	movs	r1, #32
{
 80099e8:	b508      	push	{r3, lr}
  if ( LSM303AGR_ACC_W_FullScale( (void *)handle, new_fs ) == MEMS_ERROR )
 80099ea:	f7ff fd59 	bl	80094a0 <LSM303AGR_ACC_W_FullScale>
      return COMPONENT_ERROR;
 80099ee:	fab0 f080 	clz	r0, r0
 80099f2:	0940      	lsrs	r0, r0, #5
}
 80099f4:	bd08      	pop	{r3, pc}
      new_fs = LSM303AGR_ACC_FS_4G;
 80099f6:	2110      	movs	r1, #16
{
 80099f8:	b508      	push	{r3, lr}
  if ( LSM303AGR_ACC_W_FullScale( (void *)handle, new_fs ) == MEMS_ERROR )
 80099fa:	f7ff fd51 	bl	80094a0 <LSM303AGR_ACC_W_FullScale>
      return COMPONENT_ERROR;
 80099fe:	fab0 f080 	clz	r0, r0
 8009a02:	0940      	lsrs	r0, r0, #5
}
 8009a04:	bd08      	pop	{r3, pc}
 8009a06:	bf00      	nop

08009a08 <LSM303AGR_X_Get_FS>:
{
 8009a08:	b510      	push	{r4, lr}
 8009a0a:	b082      	sub	sp, #8
 8009a0c:	460c      	mov	r4, r1
  if ( LSM303AGR_ACC_R_FullScale( (void *)handle, &fs_low_level ) == MEMS_ERROR )
 8009a0e:	f10d 0107 	add.w	r1, sp, #7
 8009a12:	f7ff fd67 	bl	80094e4 <LSM303AGR_ACC_R_FullScale>
 8009a16:	b170      	cbz	r0, 8009a36 <LSM303AGR_X_Get_FS+0x2e>
  switch( fs_low_level )
 8009a18:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8009a1c:	2810      	cmp	r0, #16
 8009a1e:	d013      	beq.n	8009a48 <LSM303AGR_X_Get_FS+0x40>
 8009a20:	d918      	bls.n	8009a54 <LSM303AGR_X_Get_FS+0x4c>
 8009a22:	2820      	cmp	r0, #32
 8009a24:	d00a      	beq.n	8009a3c <LSM303AGR_X_Get_FS+0x34>
 8009a26:	2830      	cmp	r0, #48	; 0x30
 8009a28:	d11a      	bne.n	8009a60 <LSM303AGR_X_Get_FS+0x58>
      *fullScale = 16.0f;
 8009a2a:	f04f 4383 	mov.w	r3, #1098907648	; 0x41800000
  return COMPONENT_OK;
 8009a2e:	2000      	movs	r0, #0
      *fullScale = 16.0f;
 8009a30:	6023      	str	r3, [r4, #0]
}
 8009a32:	b002      	add	sp, #8
 8009a34:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 8009a36:	2001      	movs	r0, #1
}
 8009a38:	b002      	add	sp, #8
 8009a3a:	bd10      	pop	{r4, pc}
      *fullScale =  8.0f;
 8009a3c:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
  return COMPONENT_OK;
 8009a40:	2000      	movs	r0, #0
      *fullScale =  8.0f;
 8009a42:	6023      	str	r3, [r4, #0]
}
 8009a44:	b002      	add	sp, #8
 8009a46:	bd10      	pop	{r4, pc}
      *fullScale =  4.0f;
 8009a48:	f04f 4381 	mov.w	r3, #1082130432	; 0x40800000
  return COMPONENT_OK;
 8009a4c:	2000      	movs	r0, #0
      *fullScale =  4.0f;
 8009a4e:	6023      	str	r3, [r4, #0]
}
 8009a50:	b002      	add	sp, #8
 8009a52:	bd10      	pop	{r4, pc}
  switch( fs_low_level )
 8009a54:	b920      	cbnz	r0, 8009a60 <LSM303AGR_X_Get_FS+0x58>
      *fullScale =  2.0f;
 8009a56:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009a5a:	6023      	str	r3, [r4, #0]
}
 8009a5c:	b002      	add	sp, #8
 8009a5e:	bd10      	pop	{r4, pc}
      *fullScale = -1.0f;
 8009a60:	4b02      	ldr	r3, [pc, #8]	; (8009a6c <LSM303AGR_X_Get_FS+0x64>)
 8009a62:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 8009a64:	2001      	movs	r0, #1
}
 8009a66:	b002      	add	sp, #8
 8009a68:	bd10      	pop	{r4, pc}
 8009a6a:	bf00      	nop
 8009a6c:	bf800000 	.word	0xbf800000

08009a70 <LSM303AGR_X_Set_ODR_Value_When_Enabled>:
{

  LSM303AGR_ACC_ODR_t new_odr;

  new_odr = ( odr <=    1.0f ) ? LSM303AGR_ACC_ODR_DO_1Hz
            : ( odr <=   10.0f ) ? LSM303AGR_ACC_ODR_DO_10Hz
 8009a70:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8009a74:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009a78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 8009a7c:	b508      	push	{r3, lr}
            : ( odr <=   10.0f ) ? LSM303AGR_ACC_ODR_DO_10Hz
 8009a7e:	d924      	bls.n	8009aca <LSM303AGR_X_Set_ODR_Value_When_Enabled+0x5a>
 8009a80:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 8009a84:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009a88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009a8c:	d806      	bhi.n	8009a9c <LSM303AGR_X_Set_ODR_Value_When_Enabled+0x2c>
 8009a8e:	2120      	movs	r1, #32
            : ( odr <=   50.0f ) ? LSM303AGR_ACC_ODR_DO_50Hz
            : ( odr <=  100.0f ) ? LSM303AGR_ACC_ODR_DO_100Hz
            : ( odr <=  200.0f ) ? LSM303AGR_ACC_ODR_DO_200Hz
            :                      LSM303AGR_ACC_ODR_DO_400Hz;

  if ( LSM303AGR_ACC_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 8009a90:	f7ff fdfa 	bl	8009688 <LSM303AGR_ACC_W_ODR>
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8009a94:	fab0 f080 	clz	r0, r0
 8009a98:	0940      	lsrs	r0, r0, #5
 8009a9a:	bd08      	pop	{r3, pc}
            : ( odr <=   10.0f ) ? LSM303AGR_ACC_ODR_DO_10Hz
 8009a9c:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
 8009aa0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009aa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009aa8:	d916      	bls.n	8009ad8 <LSM303AGR_X_Set_ODR_Value_When_Enabled+0x68>
 8009aaa:	eddf 7a15 	vldr	s15, [pc, #84]	; 8009b00 <LSM303AGR_X_Set_ODR_Value_When_Enabled+0x90>
 8009aae:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009ab2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009ab6:	d916      	bls.n	8009ae6 <LSM303AGR_X_Set_ODR_Value_When_Enabled+0x76>
 8009ab8:	eddf 7a12 	vldr	s15, [pc, #72]	; 8009b04 <LSM303AGR_X_Set_ODR_Value_When_Enabled+0x94>
 8009abc:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009ac0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009ac4:	d811      	bhi.n	8009aea <LSM303AGR_X_Set_ODR_Value_When_Enabled+0x7a>
 8009ac6:	2150      	movs	r1, #80	; 0x50
 8009ac8:	e7e2      	b.n	8009a90 <LSM303AGR_X_Set_ODR_Value_When_Enabled+0x20>
 8009aca:	2110      	movs	r1, #16
  if ( LSM303AGR_ACC_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 8009acc:	f7ff fddc 	bl	8009688 <LSM303AGR_ACC_W_ODR>
}
 8009ad0:	fab0 f080 	clz	r0, r0
 8009ad4:	0940      	lsrs	r0, r0, #5
 8009ad6:	bd08      	pop	{r3, pc}
            : ( odr <=   10.0f ) ? LSM303AGR_ACC_ODR_DO_10Hz
 8009ad8:	2130      	movs	r1, #48	; 0x30
  if ( LSM303AGR_ACC_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 8009ada:	f7ff fdd5 	bl	8009688 <LSM303AGR_ACC_W_ODR>
}
 8009ade:	fab0 f080 	clz	r0, r0
 8009ae2:	0940      	lsrs	r0, r0, #5
 8009ae4:	bd08      	pop	{r3, pc}
            : ( odr <=   10.0f ) ? LSM303AGR_ACC_ODR_DO_10Hz
 8009ae6:	2140      	movs	r1, #64	; 0x40
 8009ae8:	e7d2      	b.n	8009a90 <LSM303AGR_X_Set_ODR_Value_When_Enabled+0x20>
 8009aea:	eddf 7a07 	vldr	s15, [pc, #28]	; 8009b08 <LSM303AGR_X_Set_ODR_Value_When_Enabled+0x98>
 8009aee:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009af2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009af6:	bf94      	ite	ls
 8009af8:	2160      	movls	r1, #96	; 0x60
 8009afa:	2170      	movhi	r1, #112	; 0x70
 8009afc:	e7c8      	b.n	8009a90 <LSM303AGR_X_Set_ODR_Value_When_Enabled+0x20>
 8009afe:	bf00      	nop
 8009b00:	42480000 	.word	0x42480000
 8009b04:	42c80000 	.word	0x42c80000
 8009b08:	43480000 	.word	0x43480000

08009b0c <LSM303AGR_X_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 8009b0c:	7982      	ldrb	r2, [r0, #6]
 8009b0e:	2a01      	cmp	r2, #1
 8009b10:	d00d      	beq.n	8009b2e <LSM303AGR_X_Sensor_Enable+0x22>
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 8009b12:	6883      	ldr	r3, [r0, #8]
  if ( LSM303AGR_X_Set_ODR_Value_When_Enabled( handle, pComponentData->Previous_ODR ) == COMPONENT_ERROR )
 8009b14:	681b      	ldr	r3, [r3, #0]
{
 8009b16:	b510      	push	{r4, lr}
  if ( LSM303AGR_X_Set_ODR_Value_When_Enabled( handle, pComponentData->Previous_ODR ) == COMPONENT_ERROR )
 8009b18:	ed93 0a01 	vldr	s0, [r3, #4]
 8009b1c:	4604      	mov	r4, r0
 8009b1e:	f7ff ffa7 	bl	8009a70 <LSM303AGR_X_Set_ODR_Value_When_Enabled>
 8009b22:	2801      	cmp	r0, #1
 8009b24:	d002      	beq.n	8009b2c <LSM303AGR_X_Sensor_Enable+0x20>
  handle->isEnabled = 1;
 8009b26:	2301      	movs	r3, #1
 8009b28:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 8009b2a:	2000      	movs	r0, #0
}
 8009b2c:	bd10      	pop	{r4, pc}
    return COMPONENT_OK;
 8009b2e:	2000      	movs	r0, #0
}
 8009b30:	4770      	bx	lr
 8009b32:	bf00      	nop

08009b34 <LSM303AGR_X_Get_ODR>:
{
 8009b34:	b510      	push	{r4, lr}
 8009b36:	b082      	sub	sp, #8
 8009b38:	460c      	mov	r4, r1
  if ( LSM303AGR_ACC_R_ODR( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 8009b3a:	f10d 0107 	add.w	r1, sp, #7
 8009b3e:	f7ff fdc5 	bl	80096cc <LSM303AGR_ACC_R_ODR>
 8009b42:	b178      	cbz	r0, 8009b64 <LSM303AGR_X_Get_ODR+0x30>
  switch( odr_low_level )
 8009b44:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8009b48:	2830      	cmp	r0, #48	; 0x30
 8009b4a:	d022      	beq.n	8009b92 <LSM303AGR_X_Get_ODR+0x5e>
 8009b4c:	d90d      	bls.n	8009b6a <LSM303AGR_X_Get_ODR+0x36>
 8009b4e:	2850      	cmp	r0, #80	; 0x50
 8009b50:	d023      	beq.n	8009b9a <LSM303AGR_X_Get_ODR+0x66>
 8009b52:	d913      	bls.n	8009b7c <LSM303AGR_X_Get_ODR+0x48>
 8009b54:	2860      	cmp	r0, #96	; 0x60
 8009b56:	d024      	beq.n	8009ba2 <LSM303AGR_X_Get_ODR+0x6e>
 8009b58:	2870      	cmp	r0, #112	; 0x70
 8009b5a:	d10b      	bne.n	8009b74 <LSM303AGR_X_Get_ODR+0x40>
      *odr =   400.0f;
 8009b5c:	4b16      	ldr	r3, [pc, #88]	; (8009bb8 <LSM303AGR_X_Get_ODR+0x84>)
 8009b5e:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8009b60:	2000      	movs	r0, #0
      break;
 8009b62:	e000      	b.n	8009b66 <LSM303AGR_X_Get_ODR+0x32>
    return COMPONENT_ERROR;
 8009b64:	2001      	movs	r0, #1
}
 8009b66:	b002      	add	sp, #8
 8009b68:	bd10      	pop	{r4, pc}
  switch( odr_low_level )
 8009b6a:	2810      	cmp	r0, #16
 8009b6c:	d00c      	beq.n	8009b88 <LSM303AGR_X_Get_ODR+0x54>
 8009b6e:	2820      	cmp	r0, #32
 8009b70:	d01e      	beq.n	8009bb0 <LSM303AGR_X_Get_ODR+0x7c>
 8009b72:	b1d0      	cbz	r0, 8009baa <LSM303AGR_X_Get_ODR+0x76>
      *odr =    -1.0f;
 8009b74:	4b11      	ldr	r3, [pc, #68]	; (8009bbc <LSM303AGR_X_Get_ODR+0x88>)
 8009b76:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 8009b78:	2001      	movs	r0, #1
 8009b7a:	e7f4      	b.n	8009b66 <LSM303AGR_X_Get_ODR+0x32>
  switch( odr_low_level )
 8009b7c:	2840      	cmp	r0, #64	; 0x40
 8009b7e:	d1f9      	bne.n	8009b74 <LSM303AGR_X_Get_ODR+0x40>
      *odr =    50.0f;
 8009b80:	4b0f      	ldr	r3, [pc, #60]	; (8009bc0 <LSM303AGR_X_Get_ODR+0x8c>)
 8009b82:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8009b84:	2000      	movs	r0, #0
      break;
 8009b86:	e7ee      	b.n	8009b66 <LSM303AGR_X_Get_ODR+0x32>
      *odr =    1.0f;
 8009b88:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8009b8c:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8009b8e:	2000      	movs	r0, #0
      break;
 8009b90:	e7e9      	b.n	8009b66 <LSM303AGR_X_Get_ODR+0x32>
      *odr =    25.0f;
 8009b92:	4b0c      	ldr	r3, [pc, #48]	; (8009bc4 <LSM303AGR_X_Get_ODR+0x90>)
 8009b94:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8009b96:	2000      	movs	r0, #0
      break;
 8009b98:	e7e5      	b.n	8009b66 <LSM303AGR_X_Get_ODR+0x32>
      *odr =   100.0f;
 8009b9a:	4b0b      	ldr	r3, [pc, #44]	; (8009bc8 <LSM303AGR_X_Get_ODR+0x94>)
 8009b9c:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8009b9e:	2000      	movs	r0, #0
      break;
 8009ba0:	e7e1      	b.n	8009b66 <LSM303AGR_X_Get_ODR+0x32>
      *odr =   200.0f;
 8009ba2:	4b0a      	ldr	r3, [pc, #40]	; (8009bcc <LSM303AGR_X_Get_ODR+0x98>)
 8009ba4:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8009ba6:	2000      	movs	r0, #0
      break;
 8009ba8:	e7dd      	b.n	8009b66 <LSM303AGR_X_Get_ODR+0x32>
      *odr =     0.0f;
 8009baa:	2300      	movs	r3, #0
 8009bac:	6023      	str	r3, [r4, #0]
      break;
 8009bae:	e7da      	b.n	8009b66 <LSM303AGR_X_Get_ODR+0x32>
      *odr =    10.0f;
 8009bb0:	4b07      	ldr	r3, [pc, #28]	; (8009bd0 <LSM303AGR_X_Get_ODR+0x9c>)
 8009bb2:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8009bb4:	2000      	movs	r0, #0
      break;
 8009bb6:	e7d6      	b.n	8009b66 <LSM303AGR_X_Get_ODR+0x32>
 8009bb8:	43c80000 	.word	0x43c80000
 8009bbc:	bf800000 	.word	0xbf800000
 8009bc0:	42480000 	.word	0x42480000
 8009bc4:	41c80000 	.word	0x41c80000
 8009bc8:	42c80000 	.word	0x42c80000
 8009bcc:	43480000 	.word	0x43480000
 8009bd0:	41200000 	.word	0x41200000

08009bd4 <LSM303AGR_X_Get_Sensitivity>:
{
 8009bd4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009bd6:	b083      	sub	sp, #12
 8009bd8:	460e      	mov	r6, r1
  if( LSM303AGR_ACC_R_LOWPWR_EN( (void *)handle, &lp_value ) == MEMS_ERROR )
 8009bda:	f10d 0105 	add.w	r1, sp, #5
{
 8009bde:	4605      	mov	r5, r0
  if( LSM303AGR_ACC_R_LOWPWR_EN( (void *)handle, &lp_value ) == MEMS_ERROR )
 8009be0:	f7ff fe1a 	bl	8009818 <LSM303AGR_ACC_R_LOWPWR_EN>
 8009be4:	b910      	cbnz	r0, 8009bec <LSM303AGR_X_Get_Sensitivity+0x18>
  LSM303AGR_ACC_FS_t fullScale;

  /* Read actual full scale selection from sensor. */
  if ( LSM303AGR_ACC_R_FullScale( (void *)handle, &fullScale ) == MEMS_ERROR )
  {
    return COMPONENT_ERROR;
 8009be6:	2001      	movs	r0, #1
}
 8009be8:	b003      	add	sp, #12
 8009bea:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if( LSM303AGR_ACC_R_HiRes( (void *)handle, &hr_value ) == MEMS_ERROR )
 8009bec:	f10d 0106 	add.w	r1, sp, #6
 8009bf0:	4628      	mov	r0, r5
 8009bf2:	f7ff fe21 	bl	8009838 <LSM303AGR_ACC_R_HiRes>
 8009bf6:	2800      	cmp	r0, #0
 8009bf8:	d0f5      	beq.n	8009be6 <LSM303AGR_X_Get_Sensitivity+0x12>
  if( lp_value == LSM303AGR_ACC_LPEN_DISABLED && hr_value == LSM303AGR_ACC_HR_DISABLED )
 8009bfa:	f89d 7005 	ldrb.w	r7, [sp, #5]
 8009bfe:	b9c7      	cbnz	r7, 8009c32 <LSM303AGR_X_Get_Sensitivity+0x5e>
 8009c00:	f89d 4006 	ldrb.w	r4, [sp, #6]
 8009c04:	b37c      	cbz	r4, 8009c66 <LSM303AGR_X_Get_Sensitivity+0x92>
  else if ( lp_value == LSM303AGR_ACC_LPEN_DISABLED && hr_value == LSM303AGR_ACC_HR_ENABLED )
 8009c06:	2c08      	cmp	r4, #8
 8009c08:	d1ed      	bne.n	8009be6 <LSM303AGR_X_Get_Sensitivity+0x12>
  if ( LSM303AGR_ACC_R_FullScale( (void *)handle, &fullScale ) == MEMS_ERROR )
 8009c0a:	4628      	mov	r0, r5
 8009c0c:	f10d 0107 	add.w	r1, sp, #7
 8009c10:	f7ff fc68 	bl	80094e4 <LSM303AGR_ACC_R_FullScale>
 8009c14:	2800      	cmp	r0, #0
 8009c16:	d0e6      	beq.n	8009be6 <LSM303AGR_X_Get_Sensitivity+0x12>
  }

  /* Store the sensitivity based on actual full scale. */
  switch( fullScale )
 8009c18:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8009c1c:	2810      	cmp	r0, #16
 8009c1e:	d051      	beq.n	8009cc4 <LSM303AGR_X_Get_Sensitivity+0xf0>
 8009c20:	d946      	bls.n	8009cb0 <LSM303AGR_X_Get_Sensitivity+0xdc>
 8009c22:	2820      	cmp	r0, #32
 8009c24:	d052      	beq.n	8009ccc <LSM303AGR_X_Get_Sensitivity+0xf8>
 8009c26:	2830      	cmp	r0, #48	; 0x30
 8009c28:	d131      	bne.n	8009c8e <LSM303AGR_X_Get_Sensitivity+0xba>
      break;
    case LSM303AGR_ACC_FS_8G:
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_8G_HIGH_RESOLUTION_MODE;
      break;
    case LSM303AGR_ACC_FS_16G:
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_16G_HIGH_RESOLUTION_MODE;
 8009c2a:	4b2e      	ldr	r3, [pc, #184]	; (8009ce4 <LSM303AGR_X_Get_Sensitivity+0x110>)
 8009c2c:	6033      	str	r3, [r6, #0]
    default:
      *sensitivity = -1.0f;
      return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
 8009c2e:	2000      	movs	r0, #0
 8009c30:	e7da      	b.n	8009be8 <LSM303AGR_X_Get_Sensitivity+0x14>
  else if ( lp_value == LSM303AGR_ACC_LPEN_ENABLED && hr_value == LSM303AGR_ACC_HR_DISABLED )
 8009c32:	2f08      	cmp	r7, #8
 8009c34:	d1d7      	bne.n	8009be6 <LSM303AGR_X_Get_Sensitivity+0x12>
 8009c36:	f89d 4006 	ldrb.w	r4, [sp, #6]
 8009c3a:	2c00      	cmp	r4, #0
 8009c3c:	d1d3      	bne.n	8009be6 <LSM303AGR_X_Get_Sensitivity+0x12>
  if ( LSM303AGR_ACC_R_FullScale( (void *)handle, &fullScale ) == MEMS_ERROR )
 8009c3e:	4628      	mov	r0, r5
 8009c40:	f10d 0107 	add.w	r1, sp, #7
 8009c44:	f7ff fc4e 	bl	80094e4 <LSM303AGR_ACC_R_FullScale>
 8009c48:	2800      	cmp	r0, #0
 8009c4a:	d0cc      	beq.n	8009be6 <LSM303AGR_X_Get_Sensitivity+0x12>
  switch( fullScale )
 8009c4c:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8009c50:	2810      	cmp	r0, #16
 8009c52:	d03f      	beq.n	8009cd4 <LSM303AGR_X_Get_Sensitivity+0x100>
 8009c54:	d931      	bls.n	8009cba <LSM303AGR_X_Get_Sensitivity+0xe6>
 8009c56:	2820      	cmp	r0, #32
 8009c58:	d040      	beq.n	8009cdc <LSM303AGR_X_Get_Sensitivity+0x108>
 8009c5a:	2830      	cmp	r0, #48	; 0x30
 8009c5c:	d117      	bne.n	8009c8e <LSM303AGR_X_Get_Sensitivity+0xba>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_16G_LOW_POWER_MODE;
 8009c5e:	4b22      	ldr	r3, [pc, #136]	; (8009ce8 <LSM303AGR_X_Get_Sensitivity+0x114>)
 8009c60:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 8009c62:	2000      	movs	r0, #0
 8009c64:	e7c0      	b.n	8009be8 <LSM303AGR_X_Get_Sensitivity+0x14>
  if ( LSM303AGR_ACC_R_FullScale( (void *)handle, &fullScale ) == MEMS_ERROR )
 8009c66:	4628      	mov	r0, r5
 8009c68:	f10d 0107 	add.w	r1, sp, #7
 8009c6c:	f7ff fc3a 	bl	80094e4 <LSM303AGR_ACC_R_FullScale>
 8009c70:	2800      	cmp	r0, #0
 8009c72:	d0b8      	beq.n	8009be6 <LSM303AGR_X_Get_Sensitivity+0x12>
  switch( fullScale )
 8009c74:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8009c78:	2810      	cmp	r0, #16
 8009c7a:	d011      	beq.n	8009ca0 <LSM303AGR_X_Get_Sensitivity+0xcc>
 8009c7c:	d90b      	bls.n	8009c96 <LSM303AGR_X_Get_Sensitivity+0xc2>
 8009c7e:	2820      	cmp	r0, #32
 8009c80:	d012      	beq.n	8009ca8 <LSM303AGR_X_Get_Sensitivity+0xd4>
 8009c82:	2830      	cmp	r0, #48	; 0x30
 8009c84:	d103      	bne.n	8009c8e <LSM303AGR_X_Get_Sensitivity+0xba>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_16G_NORMAL_MODE;
 8009c86:	4b19      	ldr	r3, [pc, #100]	; (8009cec <LSM303AGR_X_Get_Sensitivity+0x118>)
 8009c88:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 8009c8a:	4620      	mov	r0, r4
 8009c8c:	e7ac      	b.n	8009be8 <LSM303AGR_X_Get_Sensitivity+0x14>
      *sensitivity = -1.0f;
 8009c8e:	4b18      	ldr	r3, [pc, #96]	; (8009cf0 <LSM303AGR_X_Get_Sensitivity+0x11c>)
 8009c90:	6033      	str	r3, [r6, #0]
      return COMPONENT_ERROR;
 8009c92:	2001      	movs	r0, #1
 8009c94:	e7a8      	b.n	8009be8 <LSM303AGR_X_Get_Sensitivity+0x14>
  switch( fullScale )
 8009c96:	2800      	cmp	r0, #0
 8009c98:	d1f9      	bne.n	8009c8e <LSM303AGR_X_Get_Sensitivity+0xba>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_2G_NORMAL_MODE;
 8009c9a:	4b16      	ldr	r3, [pc, #88]	; (8009cf4 <LSM303AGR_X_Get_Sensitivity+0x120>)
 8009c9c:	6033      	str	r3, [r6, #0]
 8009c9e:	e7a3      	b.n	8009be8 <LSM303AGR_X_Get_Sensitivity+0x14>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_4G_NORMAL_MODE;
 8009ca0:	4b15      	ldr	r3, [pc, #84]	; (8009cf8 <LSM303AGR_X_Get_Sensitivity+0x124>)
 8009ca2:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 8009ca4:	4620      	mov	r0, r4
 8009ca6:	e79f      	b.n	8009be8 <LSM303AGR_X_Get_Sensitivity+0x14>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_8G_NORMAL_MODE;
 8009ca8:	4b14      	ldr	r3, [pc, #80]	; (8009cfc <LSM303AGR_X_Get_Sensitivity+0x128>)
 8009caa:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 8009cac:	4620      	mov	r0, r4
 8009cae:	e79b      	b.n	8009be8 <LSM303AGR_X_Get_Sensitivity+0x14>
  switch( fullScale )
 8009cb0:	2800      	cmp	r0, #0
 8009cb2:	d1ec      	bne.n	8009c8e <LSM303AGR_X_Get_Sensitivity+0xba>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_2G_HIGH_RESOLUTION_MODE;
 8009cb4:	4b12      	ldr	r3, [pc, #72]	; (8009d00 <LSM303AGR_X_Get_Sensitivity+0x12c>)
 8009cb6:	6033      	str	r3, [r6, #0]
 8009cb8:	e796      	b.n	8009be8 <LSM303AGR_X_Get_Sensitivity+0x14>
  switch( fullScale )
 8009cba:	2800      	cmp	r0, #0
 8009cbc:	d1e7      	bne.n	8009c8e <LSM303AGR_X_Get_Sensitivity+0xba>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_2G_LOW_POWER_MODE;
 8009cbe:	4b0f      	ldr	r3, [pc, #60]	; (8009cfc <LSM303AGR_X_Get_Sensitivity+0x128>)
 8009cc0:	6033      	str	r3, [r6, #0]
 8009cc2:	e791      	b.n	8009be8 <LSM303AGR_X_Get_Sensitivity+0x14>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_4G_HIGH_RESOLUTION_MODE;
 8009cc4:	4b0f      	ldr	r3, [pc, #60]	; (8009d04 <LSM303AGR_X_Get_Sensitivity+0x130>)
 8009cc6:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 8009cc8:	4638      	mov	r0, r7
 8009cca:	e78d      	b.n	8009be8 <LSM303AGR_X_Get_Sensitivity+0x14>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_8G_HIGH_RESOLUTION_MODE;
 8009ccc:	4b09      	ldr	r3, [pc, #36]	; (8009cf4 <LSM303AGR_X_Get_Sensitivity+0x120>)
 8009cce:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 8009cd0:	4638      	mov	r0, r7
 8009cd2:	e789      	b.n	8009be8 <LSM303AGR_X_Get_Sensitivity+0x14>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_4G_LOW_POWER_MODE;
 8009cd4:	4b0c      	ldr	r3, [pc, #48]	; (8009d08 <LSM303AGR_X_Get_Sensitivity+0x134>)
 8009cd6:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 8009cd8:	4620      	mov	r0, r4
 8009cda:	e785      	b.n	8009be8 <LSM303AGR_X_Get_Sensitivity+0x14>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_8G_LOW_POWER_MODE;
 8009cdc:	4b0b      	ldr	r3, [pc, #44]	; (8009d0c <LSM303AGR_X_Get_Sensitivity+0x138>)
 8009cde:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 8009ce0:	4620      	mov	r0, r4
 8009ce2:	e781      	b.n	8009be8 <LSM303AGR_X_Get_Sensitivity+0x14>
 8009ce4:	413b851f 	.word	0x413b851f
 8009ce8:	433b947b 	.word	0x433b947b
 8009cec:	423b999a 	.word	0x423b999a
 8009cf0:	bf800000 	.word	0xbf800000
 8009cf4:	4079999a 	.word	0x4079999a
 8009cf8:	40fa3d71 	.word	0x40fa3d71
 8009cfc:	417a147b 	.word	0x417a147b
 8009d00:	3f7ae148 	.word	0x3f7ae148
 8009d04:	3ff9999a 	.word	0x3ff9999a
 8009d08:	41fa147b 	.word	0x41fa147b
 8009d0c:	427a147b 	.word	0x427a147b

08009d10 <LSM303AGR_X_Get_AxesRaw>:
{
 8009d10:	b570      	push	{r4, r5, r6, lr}
 8009d12:	b084      	sub	sp, #16
 8009d14:	460c      	mov	r4, r1
  if(!LSM303AGR_ACC_R_HiRes( (void *)handle, &hr ))
 8009d16:	f10d 0107 	add.w	r1, sp, #7
{
 8009d1a:	4606      	mov	r6, r0
  if(!LSM303AGR_ACC_R_HiRes( (void *)handle, &hr ))
 8009d1c:	f7ff fd8c 	bl	8009838 <LSM303AGR_ACC_R_HiRes>
 8009d20:	b910      	cbnz	r0, 8009d28 <LSM303AGR_X_Get_AxesRaw+0x18>
    return COMPONENT_ERROR;
 8009d22:	2001      	movs	r0, #1
}
 8009d24:	b004      	add	sp, #16
 8009d26:	bd70      	pop	{r4, r5, r6, pc}
  if(!LSM303AGR_ACC_R_LOWPWR_EN( (void *)handle, &lp ))
 8009d28:	f10d 0106 	add.w	r1, sp, #6
 8009d2c:	4630      	mov	r0, r6
 8009d2e:	f7ff fd73 	bl	8009818 <LSM303AGR_ACC_R_LOWPWR_EN>
 8009d32:	2800      	cmp	r0, #0
 8009d34:	d0f5      	beq.n	8009d22 <LSM303AGR_X_Get_AxesRaw+0x12>
  if (lp == LSM303AGR_ACC_LPEN_ENABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8009d36:	f89d 5006 	ldrb.w	r5, [sp, #6]
 8009d3a:	2d08      	cmp	r5, #8
 8009d3c:	d01e      	beq.n	8009d7c <LSM303AGR_X_Get_AxesRaw+0x6c>
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8009d3e:	2d00      	cmp	r5, #0
 8009d40:	d1ef      	bne.n	8009d22 <LSM303AGR_X_Get_AxesRaw+0x12>
 8009d42:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009d46:	b9ab      	cbnz	r3, 8009d74 <LSM303AGR_X_Get_AxesRaw+0x64>
    shift = 6;
 8009d48:	2506      	movs	r5, #6
  if (!LSM303AGR_ACC_Get_Raw_Acceleration( (void *)handle, raw_data_tmp.u8bit ))
 8009d4a:	4630      	mov	r0, r6
 8009d4c:	a902      	add	r1, sp, #8
 8009d4e:	f7ff fbd9 	bl	8009504 <LSM303AGR_ACC_Get_Raw_Acceleration>
 8009d52:	2800      	cmp	r0, #0
 8009d54:	d0e5      	beq.n	8009d22 <LSM303AGR_X_Get_AxesRaw+0x12>
  pData[0] = ( raw_data_tmp.i16bit[0] >> shift );
 8009d56:	f9bd 1008 	ldrsh.w	r1, [sp, #8]
  pData[1] = ( raw_data_tmp.i16bit[1] >> shift );
 8009d5a:	f9bd 200a 	ldrsh.w	r2, [sp, #10]
  pData[2] = ( raw_data_tmp.i16bit[2] >> shift );
 8009d5e:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
  pData[0] = ( raw_data_tmp.i16bit[0] >> shift );
 8009d62:	4129      	asrs	r1, r5
  pData[1] = ( raw_data_tmp.i16bit[1] >> shift );
 8009d64:	412a      	asrs	r2, r5
  pData[2] = ( raw_data_tmp.i16bit[2] >> shift );
 8009d66:	412b      	asrs	r3, r5
  return COMPONENT_OK;
 8009d68:	2000      	movs	r0, #0
  value->AXIS_X = dataRaw[0];
 8009d6a:	8021      	strh	r1, [r4, #0]
  value->AXIS_Y = dataRaw[1];
 8009d6c:	8062      	strh	r2, [r4, #2]
  value->AXIS_Z = dataRaw[2];
 8009d6e:	80a3      	strh	r3, [r4, #4]
}
 8009d70:	b004      	add	sp, #16
 8009d72:	bd70      	pop	{r4, r5, r6, pc}
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_ENABLED)
 8009d74:	2b08      	cmp	r3, #8
 8009d76:	d1d4      	bne.n	8009d22 <LSM303AGR_X_Get_AxesRaw+0x12>
    shift = 4;
 8009d78:	2504      	movs	r5, #4
 8009d7a:	e7e6      	b.n	8009d4a <LSM303AGR_X_Get_AxesRaw+0x3a>
  if (lp == LSM303AGR_ACC_LPEN_ENABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8009d7c:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8009d80:	2a00      	cmp	r2, #0
 8009d82:	d0e2      	beq.n	8009d4a <LSM303AGR_X_Get_AxesRaw+0x3a>
 8009d84:	e7cd      	b.n	8009d22 <LSM303AGR_X_Get_AxesRaw+0x12>
 8009d86:	bf00      	nop

08009d88 <LSM303AGR_X_Get_Axes>:
{
 8009d88:	b510      	push	{r4, lr}
 8009d8a:	b084      	sub	sp, #16
 8009d8c:	460c      	mov	r4, r1
  if ( !LSM303AGR_ACC_Get_Acceleration((void *)handle, data) )
 8009d8e:	a901      	add	r1, sp, #4
 8009d90:	f7ff fbc2 	bl	8009518 <LSM303AGR_ACC_Get_Acceleration>
 8009d94:	b140      	cbz	r0, 8009da8 <LSM303AGR_X_Get_Axes+0x20>
  acceleration->AXIS_Y = data[1];
 8009d96:	e9dd 1201 	ldrd	r1, r2, [sp, #4]
  acceleration->AXIS_Z = data[2];
 8009d9a:	9b03      	ldr	r3, [sp, #12]
 8009d9c:	60a3      	str	r3, [r4, #8]
  return COMPONENT_OK;
 8009d9e:	2000      	movs	r0, #0
  acceleration->AXIS_Y = data[1];
 8009da0:	e9c4 1200 	strd	r1, r2, [r4]
}
 8009da4:	b004      	add	sp, #16
 8009da6:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 8009da8:	2001      	movs	r0, #1
}
 8009daa:	b004      	add	sp, #16
 8009dac:	bd10      	pop	{r4, pc}
 8009dae:	bf00      	nop

08009db0 <LSM303AGR_X_Get_WhoAmI>:
{
 8009db0:	b508      	push	{r3, lr}
  if ( LSM303AGR_ACC_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 8009db2:	f7ff fb49 	bl	8009448 <LSM303AGR_ACC_R_WHO_AM_I>
}
 8009db6:	fab0 f080 	clz	r0, r0
 8009dba:	0940      	lsrs	r0, r0, #5
 8009dbc:	bd08      	pop	{r3, pc}
 8009dbe:	bf00      	nop

08009dc0 <LSM303AGR_X_Check_WhoAmI>:
{
 8009dc0:	b510      	push	{r4, lr}
 8009dc2:	b082      	sub	sp, #8
  uint8_t who_am_i = 0x00;
 8009dc4:	a902      	add	r1, sp, #8
 8009dc6:	2300      	movs	r3, #0
 8009dc8:	f801 3d01 	strb.w	r3, [r1, #-1]!
{
 8009dcc:	4604      	mov	r4, r0
  if ( LSM303AGR_ACC_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 8009dce:	f7ff fb3b 	bl	8009448 <LSM303AGR_ACC_R_WHO_AM_I>
 8009dd2:	b138      	cbz	r0, 8009de4 <LSM303AGR_X_Check_WhoAmI+0x24>
  if ( who_am_i != handle->who_am_i )
 8009dd4:	7820      	ldrb	r0, [r4, #0]
 8009dd6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    return COMPONENT_ERROR;
 8009dda:	1ac0      	subs	r0, r0, r3
 8009ddc:	bf18      	it	ne
 8009dde:	2001      	movne	r0, #1
}
 8009de0:	b002      	add	sp, #8
 8009de2:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 8009de4:	2001      	movs	r0, #1
}
 8009de6:	b002      	add	sp, #8
 8009de8:	bd10      	pop	{r4, pc}
 8009dea:	bf00      	nop

08009dec <LSM303AGR_X_Set_Axes_Status>:
{
 8009dec:	b538      	push	{r3, r4, r5, lr}
 8009dee:	460c      	mov	r4, r1
  if ( LSM303AGR_ACC_W_XEN( (void *)handle,
 8009df0:	7809      	ldrb	r1, [r1, #0]
 8009df2:	f1a1 0101 	sub.w	r1, r1, #1
 8009df6:	fab1 f181 	clz	r1, r1
 8009dfa:	0949      	lsrs	r1, r1, #5
{
 8009dfc:	4605      	mov	r5, r0
  if ( LSM303AGR_ACC_W_XEN( (void *)handle,
 8009dfe:	f7ff fc75 	bl	80096ec <LSM303AGR_ACC_W_XEN>
 8009e02:	b1a0      	cbz	r0, 8009e2e <LSM303AGR_X_Set_Axes_Status+0x42>
  if ( LSM303AGR_ACC_W_YEN ( (void *)handle,
 8009e04:	7863      	ldrb	r3, [r4, #1]
 8009e06:	2b01      	cmp	r3, #1
 8009e08:	bf0c      	ite	eq
 8009e0a:	2102      	moveq	r1, #2
 8009e0c:	2100      	movne	r1, #0
 8009e0e:	4628      	mov	r0, r5
 8009e10:	f7ff fc9e 	bl	8009750 <LSM303AGR_ACC_W_YEN>
 8009e14:	b158      	cbz	r0, 8009e2e <LSM303AGR_X_Set_Axes_Status+0x42>
  if ( LSM303AGR_ACC_W_ZEN ( (void *)handle,
 8009e16:	78a3      	ldrb	r3, [r4, #2]
 8009e18:	2b01      	cmp	r3, #1
 8009e1a:	4628      	mov	r0, r5
 8009e1c:	bf0c      	ite	eq
 8009e1e:	2104      	moveq	r1, #4
 8009e20:	2100      	movne	r1, #0
 8009e22:	f7ff fcc7 	bl	80097b4 <LSM303AGR_ACC_W_ZEN>
    return COMPONENT_ERROR;
 8009e26:	fab0 f080 	clz	r0, r0
 8009e2a:	0940      	lsrs	r0, r0, #5
}
 8009e2c:	bd38      	pop	{r3, r4, r5, pc}
    return COMPONENT_ERROR;
 8009e2e:	2001      	movs	r0, #1
}
 8009e30:	bd38      	pop	{r3, r4, r5, pc}
 8009e32:	bf00      	nop

08009e34 <LSM303AGR_X_Init>:
{
 8009e34:	b570      	push	{r4, r5, r6, lr}
  uint8_t axes_status[] = { 1, 1, 1 };
 8009e36:	4b1b      	ldr	r3, [pc, #108]	; (8009ea4 <LSM303AGR_X_Init+0x70>)
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 8009e38:	6882      	ldr	r2, [r0, #8]
  uint8_t axes_status[] = { 1, 1, 1 };
 8009e3a:	681b      	ldr	r3, [r3, #0]
{
 8009e3c:	b082      	sub	sp, #8
 8009e3e:	4604      	mov	r4, r0
  uint8_t axes_status[] = { 1, 1, 1 };
 8009e40:	f8ad 3004 	strh.w	r3, [sp, #4]
 8009e44:	0c1b      	lsrs	r3, r3, #16
 8009e46:	f88d 3006 	strb.w	r3, [sp, #6]
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 8009e4a:	6815      	ldr	r5, [r2, #0]
  LSM303AGR_Combo_Data_t *comboData = pComponentData->comboData;
 8009e4c:	682e      	ldr	r6, [r5, #0]
  if ( LSM303AGR_X_Check_WhoAmI( handle ) == COMPONENT_ERROR )
 8009e4e:	f7ff ffb7 	bl	8009dc0 <LSM303AGR_X_Check_WhoAmI>
 8009e52:	2801      	cmp	r0, #1
 8009e54:	d004      	beq.n	8009e60 <LSM303AGR_X_Init+0x2c>
  if ( LSM303AGR_ACC_W_BlockDataUpdate( (void *)handle, LSM303AGR_ACC_BDU_ENABLED ) == MEMS_ERROR )
 8009e56:	2180      	movs	r1, #128	; 0x80
 8009e58:	4620      	mov	r0, r4
 8009e5a:	f7ff faff 	bl	800945c <LSM303AGR_ACC_W_BlockDataUpdate>
 8009e5e:	b910      	cbnz	r0, 8009e66 <LSM303AGR_X_Init+0x32>
    return COMPONENT_ERROR;
 8009e60:	2001      	movs	r0, #1
}
 8009e62:	b002      	add	sp, #8
 8009e64:	bd70      	pop	{r4, r5, r6, pc}
  if ( LSM303AGR_ACC_W_FifoMode( (void *)handle, LSM303AGR_ACC_FM_BYPASS ) == MEMS_ERROR )
 8009e66:	2100      	movs	r1, #0
 8009e68:	4620      	mov	r0, r4
 8009e6a:	f7ff fd05 	bl	8009878 <LSM303AGR_ACC_W_FifoMode>
 8009e6e:	2800      	cmp	r0, #0
 8009e70:	d0f6      	beq.n	8009e60 <LSM303AGR_X_Init+0x2c>
  pComponentData->Previous_ODR = 100.0f;
 8009e72:	4b0d      	ldr	r3, [pc, #52]	; (8009ea8 <LSM303AGR_X_Init+0x74>)
 8009e74:	606b      	str	r3, [r5, #4]
  if ( LSM303AGR_ACC_W_ODR( (void *)handle, LSM303AGR_ACC_ODR_DO_PWR_DOWN ) == MEMS_ERROR )
 8009e76:	2100      	movs	r1, #0
 8009e78:	4620      	mov	r0, r4
 8009e7a:	f7ff fc05 	bl	8009688 <LSM303AGR_ACC_W_ODR>
 8009e7e:	2800      	cmp	r0, #0
 8009e80:	d0ee      	beq.n	8009e60 <LSM303AGR_X_Init+0x2c>
  if ( LSM303AGR_ACC_W_FullScale( (void *)handle, new_fs ) == MEMS_ERROR )
 8009e82:	2100      	movs	r1, #0
 8009e84:	4620      	mov	r0, r4
 8009e86:	f7ff fb0b 	bl	80094a0 <LSM303AGR_ACC_W_FullScale>
 8009e8a:	2800      	cmp	r0, #0
 8009e8c:	d0e8      	beq.n	8009e60 <LSM303AGR_X_Init+0x2c>
  if ( LSM303AGR_X_Set_Axes_Status( handle, axes_status ) == COMPONENT_ERROR )
 8009e8e:	a901      	add	r1, sp, #4
 8009e90:	4620      	mov	r0, r4
 8009e92:	f7ff ffab 	bl	8009dec <LSM303AGR_X_Set_Axes_Status>
 8009e96:	2801      	cmp	r0, #1
 8009e98:	d0e2      	beq.n	8009e60 <LSM303AGR_X_Init+0x2c>
  comboData->isAccInitialized = 1;
 8009e9a:	2301      	movs	r3, #1
 8009e9c:	7033      	strb	r3, [r6, #0]
  return COMPONENT_OK;
 8009e9e:	2000      	movs	r0, #0
  handle->isInitialized = 1;
 8009ea0:	7163      	strb	r3, [r4, #5]
  return COMPONENT_OK;
 8009ea2:	e7de      	b.n	8009e62 <LSM303AGR_X_Init+0x2e>
 8009ea4:	08022a68 	.word	0x08022a68
 8009ea8:	42c80000 	.word	0x42c80000

08009eac <LSM303AGR_X_Set_ODR_Value>:
{
 8009eac:	b508      	push	{r3, lr}
  if(handle->isEnabled == 1)
 8009eae:	7982      	ldrb	r2, [r0, #6]
 8009eb0:	2a01      	cmp	r2, #1
 8009eb2:	d034      	beq.n	8009f1e <LSM303AGR_X_Set_ODR_Value+0x72>
                                 : ( odr <=   10.0f ) ? 10.0f
 8009eb4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 8009eb8:	6883      	ldr	r3, [r0, #8]
                                 : ( odr <=   10.0f ) ? 10.0f
 8009eba:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009ebe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 8009ec2:	681b      	ldr	r3, [r3, #0]
                                 : ( odr <=   10.0f ) ? 10.0f
 8009ec4:	d906      	bls.n	8009ed4 <LSM303AGR_X_Set_ODR_Value+0x28>
                                 : ( odr <=   25.0f ) ? 25.0f
 8009ec6:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 8009eca:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009ece:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009ed2:	d803      	bhi.n	8009edc <LSM303AGR_X_Set_ODR_Value+0x30>
  pComponentData->Previous_ODR = ( odr <=    1.0f ) ?  1.0f
 8009ed4:	edc3 7a01 	vstr	s15, [r3, #4]
  return COMPONENT_OK;
 8009ed8:	2000      	movs	r0, #0
}
 8009eda:	bd08      	pop	{r3, pc}
                                 : ( odr <=   50.0f ) ? 50.0f
 8009edc:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
 8009ee0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009ee4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009ee8:	d9f4      	bls.n	8009ed4 <LSM303AGR_X_Set_ODR_Value+0x28>
                                 : ( odr <=  100.0f ) ? 100.0f
 8009eea:	eddf 7a11 	vldr	s15, [pc, #68]	; 8009f30 <LSM303AGR_X_Set_ODR_Value+0x84>
 8009eee:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009ef2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009ef6:	d9ed      	bls.n	8009ed4 <LSM303AGR_X_Set_ODR_Value+0x28>
                                 : ( odr <=  200.0f ) ? 200.0f
 8009ef8:	eddf 7a0e 	vldr	s15, [pc, #56]	; 8009f34 <LSM303AGR_X_Set_ODR_Value+0x88>
 8009efc:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009f00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009f04:	d9e6      	bls.n	8009ed4 <LSM303AGR_X_Set_ODR_Value+0x28>
                                 :                      400.0f;
 8009f06:	eddf 7a0c 	vldr	s15, [pc, #48]	; 8009f38 <LSM303AGR_X_Set_ODR_Value+0x8c>
 8009f0a:	eddf 6a0c 	vldr	s13, [pc, #48]	; 8009f3c <LSM303AGR_X_Set_ODR_Value+0x90>
 8009f0e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8009f12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009f16:	bf88      	it	hi
 8009f18:	eef0 7a66 	vmovhi.f32	s15, s13
 8009f1c:	e7da      	b.n	8009ed4 <LSM303AGR_X_Set_ODR_Value+0x28>
    if(LSM303AGR_X_Set_ODR_Value_When_Enabled(handle, odr) == COMPONENT_ERROR)
 8009f1e:	f7ff fda7 	bl	8009a70 <LSM303AGR_X_Set_ODR_Value_When_Enabled>
  return COMPONENT_OK;
 8009f22:	f1a0 0001 	sub.w	r0, r0, #1
 8009f26:	fab0 f080 	clz	r0, r0
 8009f2a:	0940      	lsrs	r0, r0, #5
}
 8009f2c:	bd08      	pop	{r3, pc}
 8009f2e:	bf00      	nop
 8009f30:	42480000 	.word	0x42480000
 8009f34:	42c80000 	.word	0x42c80000
 8009f38:	43480000 	.word	0x43480000
 8009f3c:	43c80000 	.word	0x43c80000

08009f40 <LSM303AGR_X_Set_ODR>:
{
 8009f40:	b508      	push	{r3, lr}
  if(handle->isEnabled == 1)
 8009f42:	7983      	ldrb	r3, [r0, #6]
 8009f44:	2b01      	cmp	r3, #1
 8009f46:	d008      	beq.n	8009f5a <LSM303AGR_X_Set_ODR+0x1a>
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 8009f48:	6883      	ldr	r3, [r0, #8]
 8009f4a:	681b      	ldr	r3, [r3, #0]
  switch( odr )
 8009f4c:	2904      	cmp	r1, #4
 8009f4e:	d82f      	bhi.n	8009fb0 <LSM303AGR_X_Set_ODR+0x70>
 8009f50:	e8df f001 	tbb	[pc, r1]
 8009f54:	17131b0e 	.word	0x17131b0e
 8009f58:	0a          	.byte	0x0a
 8009f59:	00          	.byte	0x00
  switch( odr )
 8009f5a:	2904      	cmp	r1, #4
 8009f5c:	d828      	bhi.n	8009fb0 <LSM303AGR_X_Set_ODR+0x70>
 8009f5e:	e8df f001 	tbb	[pc, r1]
 8009f62:	2518      	.short	0x2518
 8009f64:	211f      	.short	0x211f
 8009f66:	23          	.byte	0x23
 8009f67:	00          	.byte	0x00
      pComponentData->Previous_ODR = 100.0f;
 8009f68:	4a12      	ldr	r2, [pc, #72]	; (8009fb4 <LSM303AGR_X_Set_ODR+0x74>)
 8009f6a:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 8009f6c:	2000      	movs	r0, #0
}
 8009f6e:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 1.0f;
 8009f70:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8009f74:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 8009f76:	2000      	movs	r0, #0
}
 8009f78:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 25.0f;
 8009f7a:	4a0f      	ldr	r2, [pc, #60]	; (8009fb8 <LSM303AGR_X_Set_ODR+0x78>)
 8009f7c:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 8009f7e:	2000      	movs	r0, #0
}
 8009f80:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 50.0f;
 8009f82:	4a0e      	ldr	r2, [pc, #56]	; (8009fbc <LSM303AGR_X_Set_ODR+0x7c>)
 8009f84:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 8009f86:	2000      	movs	r0, #0
}
 8009f88:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 10.0f;
 8009f8a:	4a0d      	ldr	r2, [pc, #52]	; (8009fc0 <LSM303AGR_X_Set_ODR+0x80>)
 8009f8c:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 8009f8e:	2000      	movs	r0, #0
}
 8009f90:	bd08      	pop	{r3, pc}
      new_odr = LSM303AGR_ACC_ODR_DO_1Hz;
 8009f92:	2110      	movs	r1, #16
  if ( LSM303AGR_ACC_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 8009f94:	f7ff fb78 	bl	8009688 <LSM303AGR_ACC_W_ODR>
  return COMPONENT_OK;
 8009f98:	fab0 f080 	clz	r0, r0
 8009f9c:	0940      	lsrs	r0, r0, #5
}
 8009f9e:	bd08      	pop	{r3, pc}
      new_odr = LSM303AGR_ACC_ODR_DO_25Hz;
 8009fa0:	2130      	movs	r1, #48	; 0x30
 8009fa2:	e7f7      	b.n	8009f94 <LSM303AGR_X_Set_ODR+0x54>
      new_odr = LSM303AGR_ACC_ODR_DO_50Hz;
 8009fa4:	2140      	movs	r1, #64	; 0x40
 8009fa6:	e7f5      	b.n	8009f94 <LSM303AGR_X_Set_ODR+0x54>
      new_odr = LSM303AGR_ACC_ODR_DO_100Hz;
 8009fa8:	2150      	movs	r1, #80	; 0x50
 8009faa:	e7f3      	b.n	8009f94 <LSM303AGR_X_Set_ODR+0x54>
      new_odr = LSM303AGR_ACC_ODR_DO_10Hz;
 8009fac:	2120      	movs	r1, #32
 8009fae:	e7f1      	b.n	8009f94 <LSM303AGR_X_Set_ODR+0x54>
      return COMPONENT_ERROR;
 8009fb0:	2001      	movs	r0, #1
}
 8009fb2:	bd08      	pop	{r3, pc}
 8009fb4:	42c80000 	.word	0x42c80000
 8009fb8:	41c80000 	.word	0x41c80000
 8009fbc:	42480000 	.word	0x42480000
 8009fc0:	41200000 	.word	0x41200000

08009fc4 <LSM303AGR_X_Sensor_Disable>:
  if ( handle->isEnabled == 0 )
 8009fc4:	7983      	ldrb	r3, [r0, #6]
 8009fc6:	b90b      	cbnz	r3, 8009fcc <LSM303AGR_X_Sensor_Disable+0x8>
    return COMPONENT_OK;
 8009fc8:	4618      	mov	r0, r3
}
 8009fca:	4770      	bx	lr
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 8009fcc:	6883      	ldr	r3, [r0, #8]
  if ( LSM303AGR_X_Get_ODR( handle, &( pComponentData->Previous_ODR ) ) == COMPONENT_ERROR )
 8009fce:	6819      	ldr	r1, [r3, #0]
{
 8009fd0:	b510      	push	{r4, lr}
  if ( LSM303AGR_X_Get_ODR( handle, &( pComponentData->Previous_ODR ) ) == COMPONENT_ERROR )
 8009fd2:	3104      	adds	r1, #4
 8009fd4:	4604      	mov	r4, r0
 8009fd6:	f7ff fdad 	bl	8009b34 <LSM303AGR_X_Get_ODR>
 8009fda:	2801      	cmp	r0, #1
 8009fdc:	d008      	beq.n	8009ff0 <LSM303AGR_X_Sensor_Disable+0x2c>
  if ( LSM303AGR_ACC_W_ODR( (void *)handle, LSM303AGR_ACC_ODR_DO_PWR_DOWN ) == MEMS_ERROR )
 8009fde:	2100      	movs	r1, #0
 8009fe0:	4620      	mov	r0, r4
 8009fe2:	f7ff fb51 	bl	8009688 <LSM303AGR_ACC_W_ODR>
 8009fe6:	b118      	cbz	r0, 8009ff0 <LSM303AGR_X_Sensor_Disable+0x2c>
  handle->isEnabled = 0;
 8009fe8:	2300      	movs	r3, #0
 8009fea:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 8009fec:	4618      	mov	r0, r3
}
 8009fee:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 8009ff0:	2001      	movs	r0, #1
}
 8009ff2:	bd10      	pop	{r4, pc}

08009ff4 <LSM303AGR_X_DeInit>:
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 8009ff4:	6883      	ldr	r3, [r0, #8]
{
 8009ff6:	b570      	push	{r4, r5, r6, lr}
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 8009ff8:	681d      	ldr	r5, [r3, #0]
{
 8009ffa:	4604      	mov	r4, r0
  LSM303AGR_Combo_Data_t *comboData = pComponentData->comboData;
 8009ffc:	682e      	ldr	r6, [r5, #0]
  if ( LSM303AGR_X_Check_WhoAmI( handle ) == COMPONENT_ERROR )
 8009ffe:	f7ff fedf 	bl	8009dc0 <LSM303AGR_X_Check_WhoAmI>
 800a002:	2801      	cmp	r0, #1
 800a004:	d00b      	beq.n	800a01e <LSM303AGR_X_DeInit+0x2a>
  if( LSM303AGR_X_Sensor_Disable( handle ) == COMPONENT_ERROR )
 800a006:	4620      	mov	r0, r4
 800a008:	f7ff ffdc 	bl	8009fc4 <LSM303AGR_X_Sensor_Disable>
 800a00c:	2801      	cmp	r0, #1
 800a00e:	d006      	beq.n	800a01e <LSM303AGR_X_DeInit+0x2a>
  comboData->isAccInitialized = 0;
 800a010:	2300      	movs	r3, #0
  pComponentData->Previous_ODR = 0.0f;
 800a012:	2200      	movs	r2, #0
 800a014:	606a      	str	r2, [r5, #4]
  comboData->isAccInitialized = 0;
 800a016:	7033      	strb	r3, [r6, #0]
  handle->isInitialized = 0;
 800a018:	7163      	strb	r3, [r4, #5]
  return COMPONENT_OK;
 800a01a:	4618      	mov	r0, r3
}
 800a01c:	bd70      	pop	{r4, r5, r6, pc}
    return COMPONENT_ERROR;
 800a01e:	2001      	movs	r0, #1
}
 800a020:	bd70      	pop	{r4, r5, r6, pc}
 800a022:	bf00      	nop

0800a024 <LSM303AGR_MAG_WriteReg>:
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_MAG_WriteReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len)
{
 800a024:	b508      	push	{r3, lr}

  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800a026:	f004 fa1d 	bl	800e464 <Sensor_IO_Write>
  }
  else
  {
    return MEMS_SUCCESS;
  }
}
 800a02a:	fab0 f080 	clz	r0, r0
 800a02e:	0940      	lsrs	r0, r0, #5
 800a030:	bd08      	pop	{r3, pc}
 800a032:	bf00      	nop

0800a034 <LSM303AGR_MAG_ReadReg>:
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_MAG_ReadReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len)
{
 800a034:	b508      	push	{r3, lr}

  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a036:	f004 fb03 	bl	800e640 <Sensor_IO_Read>
  }
  else
  {
    return MEMS_SUCCESS;
  }
}
 800a03a:	fab0 f080 	clz	r0, r0
 800a03e:	0940      	lsrs	r0, r0, #5
 800a040:	bd08      	pop	{r3, pc}
 800a042:	bf00      	nop

0800a044 <LSM303AGR_MAG_R_WHO_AM_I>:
* Input          : Pointer to u8_t
* Output         : Status of WHO_AM_I
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_MAG_R_WHO_AM_I(void *handle, u8_t *value)
{
 800a044:	b508      	push	{r3, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a046:	460a      	mov	r2, r1
 800a048:	2301      	movs	r3, #1
 800a04a:	214f      	movs	r1, #79	; 0x4f
 800a04c:	f004 faf8 	bl	800e640 <Sensor_IO_Read>

  *value &= LSM303AGR_MAG_WHO_AM_I_MASK; //coerce
  *value = *value >> LSM303AGR_MAG_WHO_AM_I_POSITION; //mask

  return MEMS_SUCCESS;
}
 800a050:	fab0 f080 	clz	r0, r0
 800a054:	0940      	lsrs	r0, r0, #5
 800a056:	bd08      	pop	{r3, pc}

0800a058 <LSM303AGR_MAG_W_BDU>:
* Input          : LSM303AGR_MAG_BDU_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_MAG_W_BDU(void *handle, LSM303AGR_MAG_BDU_t newValue)
{
 800a058:	b530      	push	{r4, r5, lr}
 800a05a:	b083      	sub	sp, #12
 800a05c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a05e:	f10d 0207 	add.w	r2, sp, #7
 800a062:	2301      	movs	r3, #1
 800a064:	2162      	movs	r1, #98	; 0x62
{
 800a066:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a068:	f004 faea 	bl	800e640 <Sensor_IO_Read>
 800a06c:	b110      	cbz	r0, 800a074 <LSM303AGR_MAG_W_BDU+0x1c>
  u8_t value;

  if( !LSM303AGR_MAG_ReadReg(handle, LSM303AGR_MAG_CFG_REG_C, &value, 1) )
    return MEMS_ERROR;
 800a06e:	2000      	movs	r0, #0

  if( !LSM303AGR_MAG_WriteReg( handle, LSM303AGR_MAG_CFG_REG_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a070:	b003      	add	sp, #12
 800a072:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_MAG_BDU_MASK;
 800a074:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a078:	f023 0310 	bic.w	r3, r3, #16
  value |= newValue;
 800a07c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800a07e:	f10d 0207 	add.w	r2, sp, #7
 800a082:	4628      	mov	r0, r5
 800a084:	2301      	movs	r3, #1
 800a086:	2162      	movs	r1, #98	; 0x62
  value |= newValue;
 800a088:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800a08c:	f004 f9ea 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a090:	fab0 f080 	clz	r0, r0
 800a094:	0940      	lsrs	r0, r0, #5
}
 800a096:	b003      	add	sp, #12
 800a098:	bd30      	pop	{r4, r5, pc}
 800a09a:	bf00      	nop

0800a09c <LSM303AGR_MAG_W_MD>:
* Input          : LSM303AGR_MAG_MD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_MAG_W_MD(void *handle, LSM303AGR_MAG_MD_t newValue)
{
 800a09c:	b530      	push	{r4, r5, lr}
 800a09e:	b083      	sub	sp, #12
 800a0a0:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a0a2:	f10d 0207 	add.w	r2, sp, #7
 800a0a6:	2301      	movs	r3, #1
 800a0a8:	2160      	movs	r1, #96	; 0x60
{
 800a0aa:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a0ac:	f004 fac8 	bl	800e640 <Sensor_IO_Read>
 800a0b0:	b110      	cbz	r0, 800a0b8 <LSM303AGR_MAG_W_MD+0x1c>
  u8_t value;

  if( !LSM303AGR_MAG_ReadReg(handle, LSM303AGR_MAG_CFG_REG_A, &value, 1) )
    return MEMS_ERROR;
 800a0b2:	2000      	movs	r0, #0

  if( !LSM303AGR_MAG_WriteReg( handle, LSM303AGR_MAG_CFG_REG_A, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a0b4:	b003      	add	sp, #12
 800a0b6:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_MAG_MD_MASK;
 800a0b8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a0bc:	f023 0303 	bic.w	r3, r3, #3
  value |= newValue;
 800a0c0:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800a0c2:	f10d 0207 	add.w	r2, sp, #7
 800a0c6:	4628      	mov	r0, r5
 800a0c8:	2301      	movs	r3, #1
 800a0ca:	2160      	movs	r1, #96	; 0x60
  value |= newValue;
 800a0cc:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800a0d0:	f004 f9c8 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a0d4:	fab0 f080 	clz	r0, r0
 800a0d8:	0940      	lsrs	r0, r0, #5
}
 800a0da:	b003      	add	sp, #12
 800a0dc:	bd30      	pop	{r4, r5, pc}
 800a0de:	bf00      	nop

0800a0e0 <LSM303AGR_MAG_Get_Raw_Magnetic>:
* Input          : pointer to [u8_t]
* Output         : Magnetic buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_MAG_Get_Raw_Magnetic(void *handle, u8_t *buff)
{
 800a0e0:	b508      	push	{r3, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a0e2:	460a      	mov	r2, r1
 800a0e4:	2306      	movs	r3, #6
 800a0e6:	2168      	movs	r1, #104	; 0x68
 800a0e8:	f004 faaa 	bl	800e640 <Sensor_IO_Read>
  if( !LSM303AGR_MAG_ReadReg( handle, LSM303AGR_MAG_OUTX_L_REG, buff, 6 ) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a0ec:	fab0 f080 	clz	r0, r0
 800a0f0:	0940      	lsrs	r0, r0, #5
 800a0f2:	bd08      	pop	{r3, pc}

0800a0f4 <LSM303AGR_MAG_W_ODR>:
* Input          : LSM303AGR_MAG_ODR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_MAG_W_ODR(void *handle, LSM303AGR_MAG_ODR_t newValue)
{
 800a0f4:	b530      	push	{r4, r5, lr}
 800a0f6:	b083      	sub	sp, #12
 800a0f8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a0fa:	f10d 0207 	add.w	r2, sp, #7
 800a0fe:	2301      	movs	r3, #1
 800a100:	2160      	movs	r1, #96	; 0x60
{
 800a102:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a104:	f004 fa9c 	bl	800e640 <Sensor_IO_Read>
 800a108:	b110      	cbz	r0, 800a110 <LSM303AGR_MAG_W_ODR+0x1c>
  u8_t value;

  if( !LSM303AGR_MAG_ReadReg(handle, LSM303AGR_MAG_CFG_REG_A, &value, 1) )
    return MEMS_ERROR;
 800a10a:	2000      	movs	r0, #0

  if( !LSM303AGR_MAG_WriteReg( handle, LSM303AGR_MAG_CFG_REG_A, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a10c:	b003      	add	sp, #12
 800a10e:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_MAG_ODR_MASK;
 800a110:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a114:	f023 030c 	bic.w	r3, r3, #12
  value |= newValue;
 800a118:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800a11a:	f10d 0207 	add.w	r2, sp, #7
 800a11e:	4628      	mov	r0, r5
 800a120:	2301      	movs	r3, #1
 800a122:	2160      	movs	r1, #96	; 0x60
  value |= newValue;
 800a124:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800a128:	f004 f99c 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a12c:	fab0 f080 	clz	r0, r0
 800a130:	0940      	lsrs	r0, r0, #5
}
 800a132:	b003      	add	sp, #12
 800a134:	bd30      	pop	{r4, r5, pc}
 800a136:	bf00      	nop

0800a138 <LSM303AGR_MAG_R_ODR>:
* Input          : Pointer to LSM303AGR_MAG_ODR_t
* Output         : Status of ODR see LSM303AGR_MAG_ODR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_MAG_R_ODR(void *handle, LSM303AGR_MAG_ODR_t *value)
{
 800a138:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a13a:	460a      	mov	r2, r1
{
 800a13c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a13e:	2301      	movs	r3, #1
 800a140:	2160      	movs	r1, #96	; 0x60
 800a142:	f004 fa7d 	bl	800e640 <Sensor_IO_Read>
 800a146:	b928      	cbnz	r0, 800a154 <LSM303AGR_MAG_R_ODR+0x1c>
  if( !LSM303AGR_MAG_ReadReg(handle, LSM303AGR_MAG_CFG_REG_A, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM303AGR_MAG_ODR_MASK; //mask
 800a148:	7823      	ldrb	r3, [r4, #0]
 800a14a:	f003 030c 	and.w	r3, r3, #12
 800a14e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800a150:	2001      	movs	r0, #1
}
 800a152:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800a154:	2000      	movs	r0, #0
}
 800a156:	bd10      	pop	{r4, pc}

0800a158 <LSM303AGR_MAG_W_ST>:
* Input          : LSM303AGR_MAG_ST_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_MAG_W_ST(void *handle, LSM303AGR_MAG_ST_t newValue)
{
 800a158:	b530      	push	{r4, r5, lr}
 800a15a:	b083      	sub	sp, #12
 800a15c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a15e:	f10d 0207 	add.w	r2, sp, #7
 800a162:	2301      	movs	r3, #1
 800a164:	2162      	movs	r1, #98	; 0x62
{
 800a166:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a168:	f004 fa6a 	bl	800e640 <Sensor_IO_Read>
 800a16c:	b110      	cbz	r0, 800a174 <LSM303AGR_MAG_W_ST+0x1c>
  u8_t value;

  if( !LSM303AGR_MAG_ReadReg(handle, LSM303AGR_MAG_CFG_REG_C, &value, 1) )
    return MEMS_ERROR;
 800a16e:	2000      	movs	r0, #0

  if( !LSM303AGR_MAG_WriteReg( handle, LSM303AGR_MAG_CFG_REG_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a170:	b003      	add	sp, #12
 800a172:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_MAG_ST_MASK;
 800a174:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a178:	f023 0302 	bic.w	r3, r3, #2
  value |= newValue;
 800a17c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800a17e:	f10d 0207 	add.w	r2, sp, #7
 800a182:	4628      	mov	r0, r5
 800a184:	2301      	movs	r3, #1
 800a186:	2162      	movs	r1, #98	; 0x62
  value |= newValue;
 800a188:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800a18c:	f004 f96a 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a190:	fab0 f080 	clz	r0, r0
 800a194:	0940      	lsrs	r0, r0, #5
}
 800a196:	b003      	add	sp, #12
 800a198:	bd30      	pop	{r4, r5, pc}
 800a19a:	bf00      	nop

0800a19c <LSM303AGR_MAG_W_I2C_DIS>:
* Input          : LSM303AGR_MAG_I2C_DIS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_MAG_W_I2C_DIS(void *handle, LSM303AGR_MAG_I2C_DIS_t newValue)
{
 800a19c:	b530      	push	{r4, r5, lr}
 800a19e:	b083      	sub	sp, #12
 800a1a0:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a1a2:	f10d 0207 	add.w	r2, sp, #7
 800a1a6:	2301      	movs	r3, #1
 800a1a8:	2162      	movs	r1, #98	; 0x62
{
 800a1aa:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a1ac:	f004 fa48 	bl	800e640 <Sensor_IO_Read>
 800a1b0:	b110      	cbz	r0, 800a1b8 <LSM303AGR_MAG_W_I2C_DIS+0x1c>
  u8_t value;

  if( !LSM303AGR_MAG_ReadReg(handle, LSM303AGR_MAG_CFG_REG_C, &value, 1) )
    return MEMS_ERROR;
 800a1b2:	2000      	movs	r0, #0

  if( !LSM303AGR_MAG_WriteReg( handle, LSM303AGR_MAG_CFG_REG_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a1b4:	b003      	add	sp, #12
 800a1b6:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_MAG_I2C_DIS_MASK;
 800a1b8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a1bc:	f023 0320 	bic.w	r3, r3, #32
  value |= newValue;
 800a1c0:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800a1c2:	f10d 0207 	add.w	r2, sp, #7
 800a1c6:	4628      	mov	r0, r5
 800a1c8:	2301      	movs	r3, #1
 800a1ca:	2162      	movs	r1, #98	; 0x62
  value |= newValue;
 800a1cc:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800a1d0:	f004 f948 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a1d4:	fab0 f080 	clz	r0, r0
 800a1d8:	0940      	lsrs	r0, r0, #5
}
 800a1da:	b003      	add	sp, #12
 800a1dc:	bd30      	pop	{r4, r5, pc}
 800a1de:	bf00      	nop

0800a1e0 <LSM303AGR_MAG_R_ZYXDA>:
* Input          : Pointer to LSM303AGR_MAG_ZYXDA_t
* Output         : Status of ZYXDA see LSM303AGR_MAG_ZYXDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_MAG_R_ZYXDA(void *handle, LSM303AGR_MAG_ZYXDA_t *value)
{
 800a1e0:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a1e2:	460a      	mov	r2, r1
{
 800a1e4:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800a1e6:	2301      	movs	r3, #1
 800a1e8:	2167      	movs	r1, #103	; 0x67
 800a1ea:	f004 fa29 	bl	800e640 <Sensor_IO_Read>
 800a1ee:	b928      	cbnz	r0, 800a1fc <LSM303AGR_MAG_R_ZYXDA+0x1c>
  if( !LSM303AGR_MAG_ReadReg(handle, LSM303AGR_MAG_STATUS_REG, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM303AGR_MAG_ZYXDA_MASK; //mask
 800a1f0:	7823      	ldrb	r3, [r4, #0]
 800a1f2:	f003 0308 	and.w	r3, r3, #8
 800a1f6:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800a1f8:	2001      	movs	r0, #1
}
 800a1fa:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800a1fc:	2000      	movs	r0, #0
}
 800a1fe:	bd10      	pop	{r4, pc}

0800a200 <LSM303AGR_M_Get_Sensitivity>:
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LSM303AGR_M_Get_Sensitivity( DrvContextTypeDef *handle, float *sensitivity )
{
  *sensitivity = ( float )LSM303AGR_MAG_SENSITIVITY_FOR_FS_50G;
 800a200:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
 800a204:	600b      	str	r3, [r1, #0]

  return COMPONENT_OK;
}
 800a206:	2000      	movs	r0, #0
 800a208:	4770      	bx	lr
 800a20a:	bf00      	nop

0800a20c <LSM303AGR_M_Get_FS>:
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LSM303AGR_M_Get_FS( DrvContextTypeDef *handle, float *fullScale )
{
  *fullScale = 50.0f;
 800a20c:	4b01      	ldr	r3, [pc, #4]	; (800a214 <LSM303AGR_M_Get_FS+0x8>)
 800a20e:	600b      	str	r3, [r1, #0]

  return COMPONENT_OK;
}
 800a210:	2000      	movs	r0, #0
 800a212:	4770      	bx	lr
 800a214:	42480000 	.word	0x42480000

0800a218 <LSM303AGR_M_Set_FS>:
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LSM303AGR_M_Set_FS( DrvContextTypeDef *handle, SensorFs_t fullScale )
{
  return COMPONENT_OK;
}
 800a218:	2000      	movs	r0, #0
 800a21a:	4770      	bx	lr

0800a21c <LSM303AGR_M_Set_FS_Value>:
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LSM303AGR_M_Set_FS_Value( DrvContextTypeDef *handle, float fullScale )
{
  return COMPONENT_OK;
}
 800a21c:	2000      	movs	r0, #0
 800a21e:	4770      	bx	lr

0800a220 <LSM303AGR_M_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LSM303AGR_M_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 800a220:	b510      	push	{r4, lr}
 800a222:	b082      	sub	sp, #8
 800a224:	460c      	mov	r4, r1

  LSM303AGR_MAG_ZYXDA_t status_raw;

  if ( LSM303AGR_MAG_R_ZYXDA( (void *)handle, &status_raw ) == MEMS_ERROR )
 800a226:	f10d 0107 	add.w	r1, sp, #7
 800a22a:	f7ff ffd9 	bl	800a1e0 <LSM303AGR_MAG_R_ZYXDA>
 800a22e:	b120      	cbz	r0, 800a23a <LSM303AGR_M_Get_DRDY_Status+0x1a>
  {
    return COMPONENT_ERROR;
  }

  switch( status_raw )
 800a230:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800a234:	b148      	cbz	r0, 800a24a <LSM303AGR_M_Get_DRDY_Status+0x2a>
 800a236:	2808      	cmp	r0, #8
 800a238:	d002      	beq.n	800a240 <LSM303AGR_M_Get_DRDY_Status+0x20>
      break;
    case LSM303AGR_MAG_ZYXDA_EV_OFF:
      *status = 0;
      break;
    default:
      return COMPONENT_ERROR;
 800a23a:	2001      	movs	r0, #1
  }

  return COMPONENT_OK;
}
 800a23c:	b002      	add	sp, #8
 800a23e:	bd10      	pop	{r4, pc}
      *status = 1;
 800a240:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800a242:	2000      	movs	r0, #0
      *status = 1;
 800a244:	7023      	strb	r3, [r4, #0]
}
 800a246:	b002      	add	sp, #8
 800a248:	bd10      	pop	{r4, pc}
      *status = 0;
 800a24a:	7020      	strb	r0, [r4, #0]
}
 800a24c:	b002      	add	sp, #8
 800a24e:	bd10      	pop	{r4, pc}

0800a250 <LSM303AGR_M_Write_Reg>:
{
 800a250:	b510      	push	{r4, lr}
 800a252:	b082      	sub	sp, #8
 800a254:	ac02      	add	r4, sp, #8
  if ( LSM303AGR_MAG_WriteReg( (void *)handle, reg, &data, 1 ) == MEMS_ERROR )
 800a256:	2301      	movs	r3, #1
{
 800a258:	f804 2d01 	strb.w	r2, [r4, #-1]!
  if ( LSM303AGR_MAG_WriteReg( (void *)handle, reg, &data, 1 ) == MEMS_ERROR )
 800a25c:	4622      	mov	r2, r4
 800a25e:	f7ff fee1 	bl	800a024 <LSM303AGR_MAG_WriteReg>
}
 800a262:	fab0 f080 	clz	r0, r0
 800a266:	0940      	lsrs	r0, r0, #5
 800a268:	b002      	add	sp, #8
 800a26a:	bd10      	pop	{r4, pc}

0800a26c <LSM303AGR_M_Read_Reg>:
{
 800a26c:	b508      	push	{r3, lr}
  if ( LSM303AGR_MAG_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 800a26e:	2301      	movs	r3, #1
 800a270:	f7ff fee0 	bl	800a034 <LSM303AGR_MAG_ReadReg>
}
 800a274:	fab0 f080 	clz	r0, r0
 800a278:	0940      	lsrs	r0, r0, #5
 800a27a:	bd08      	pop	{r3, pc}

0800a27c <LSM303AGR_M_Set_ODR_Value>:
              : ( odr <= 20.000f ) ? LSM303AGR_MAG_ODR_20Hz
 800a27c:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 800a280:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800a284:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 800a288:	b508      	push	{r3, lr}
              : ( odr <= 20.000f ) ? LSM303AGR_MAG_ODR_20Hz
 800a28a:	d90d      	bls.n	800a2a8 <LSM303AGR_M_Set_ODR_Value+0x2c>
 800a28c:	eef3 7a04 	vmov.f32	s15, #52	; 0x41a00000  20.0
 800a290:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800a294:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a298:	d80d      	bhi.n	800a2b6 <LSM303AGR_M_Set_ODR_Value+0x3a>
 800a29a:	2104      	movs	r1, #4
  if ( LSM303AGR_MAG_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 800a29c:	f7ff ff2a 	bl	800a0f4 <LSM303AGR_MAG_W_ODR>
}
 800a2a0:	fab0 f080 	clz	r0, r0
 800a2a4:	0940      	lsrs	r0, r0, #5
 800a2a6:	bd08      	pop	{r3, pc}
              : ( odr <= 20.000f ) ? LSM303AGR_MAG_ODR_20Hz
 800a2a8:	2100      	movs	r1, #0
  if ( LSM303AGR_MAG_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 800a2aa:	f7ff ff23 	bl	800a0f4 <LSM303AGR_MAG_W_ODR>
}
 800a2ae:	fab0 f080 	clz	r0, r0
 800a2b2:	0940      	lsrs	r0, r0, #5
 800a2b4:	bd08      	pop	{r3, pc}
              : ( odr <= 20.000f ) ? LSM303AGR_MAG_ODR_20Hz
 800a2b6:	eddf 7a07 	vldr	s15, [pc, #28]	; 800a2d4 <LSM303AGR_M_Set_ODR_Value+0x58>
 800a2ba:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800a2be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a2c2:	bf94      	ite	ls
 800a2c4:	2108      	movls	r1, #8
 800a2c6:	210c      	movhi	r1, #12
  if ( LSM303AGR_MAG_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 800a2c8:	f7ff ff14 	bl	800a0f4 <LSM303AGR_MAG_W_ODR>
}
 800a2cc:	fab0 f080 	clz	r0, r0
 800a2d0:	0940      	lsrs	r0, r0, #5
 800a2d2:	bd08      	pop	{r3, pc}
 800a2d4:	42480000 	.word	0x42480000

0800a2d8 <LSM303AGR_M_Set_ODR>:
{
 800a2d8:	b508      	push	{r3, lr}
  switch( odr )
 800a2da:	2904      	cmp	r1, #4
 800a2dc:	d811      	bhi.n	800a302 <LSM303AGR_M_Set_ODR+0x2a>
 800a2de:	e8df f001 	tbb	[pc, r1]
 800a2e2:	0e0a      	.short	0x0e0a
 800a2e4:	030c      	.short	0x030c
 800a2e6:	03          	.byte	0x03
 800a2e7:	00          	.byte	0x00
      new_odr = LSM303AGR_MAG_ODR_100Hz;
 800a2e8:	210c      	movs	r1, #12
  if ( LSM303AGR_MAG_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 800a2ea:	f7ff ff03 	bl	800a0f4 <LSM303AGR_MAG_W_ODR>
      return COMPONENT_ERROR;
 800a2ee:	fab0 f080 	clz	r0, r0
 800a2f2:	0940      	lsrs	r0, r0, #5
}
 800a2f4:	bd08      	pop	{r3, pc}
      new_odr = LSM303AGR_MAG_ODR_10Hz;
 800a2f6:	2100      	movs	r1, #0
 800a2f8:	e7f7      	b.n	800a2ea <LSM303AGR_M_Set_ODR+0x12>
      new_odr = LSM303AGR_MAG_ODR_50Hz;
 800a2fa:	2108      	movs	r1, #8
      break;
 800a2fc:	e7f5      	b.n	800a2ea <LSM303AGR_M_Set_ODR+0x12>
      new_odr = LSM303AGR_MAG_ODR_20Hz;
 800a2fe:	2104      	movs	r1, #4
 800a300:	e7f3      	b.n	800a2ea <LSM303AGR_M_Set_ODR+0x12>
      return COMPONENT_ERROR;
 800a302:	2001      	movs	r0, #1
}
 800a304:	bd08      	pop	{r3, pc}
 800a306:	bf00      	nop

0800a308 <LSM303AGR_M_Get_ODR>:
{
 800a308:	b510      	push	{r4, lr}
 800a30a:	b082      	sub	sp, #8
 800a30c:	460c      	mov	r4, r1
  if ( LSM303AGR_MAG_R_ODR( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 800a30e:	f10d 0107 	add.w	r1, sp, #7
 800a312:	f7ff ff11 	bl	800a138 <LSM303AGR_MAG_R_ODR>
 800a316:	b160      	cbz	r0, 800a332 <LSM303AGR_M_Get_ODR+0x2a>
  switch( odr_low_level )
 800a318:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a31c:	2b0c      	cmp	r3, #12
 800a31e:	d81f      	bhi.n	800a360 <LSM303AGR_M_Get_ODR+0x58>
 800a320:	e8df f003 	tbb	[pc, r3]
 800a324:	1e1e1e0f 	.word	0x1e1e1e0f
 800a328:	1e1e1e14 	.word	0x1e1e1e14
 800a32c:	1e1e1e19 	.word	0x1e1e1e19
 800a330:	0a          	.byte	0x0a
 800a331:	00          	.byte	0x00
    return COMPONENT_ERROR;
 800a332:	2001      	movs	r0, #1
}
 800a334:	b002      	add	sp, #8
 800a336:	bd10      	pop	{r4, pc}
      *odr = 100.000f;
 800a338:	4b0c      	ldr	r3, [pc, #48]	; (800a36c <LSM303AGR_M_Get_ODR+0x64>)
 800a33a:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800a33c:	2000      	movs	r0, #0
}
 800a33e:	b002      	add	sp, #8
 800a340:	bd10      	pop	{r4, pc}
      *odr = 10.000f;
 800a342:	4b0b      	ldr	r3, [pc, #44]	; (800a370 <LSM303AGR_M_Get_ODR+0x68>)
 800a344:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800a346:	2000      	movs	r0, #0
}
 800a348:	b002      	add	sp, #8
 800a34a:	bd10      	pop	{r4, pc}
      *odr = 20.000f;
 800a34c:	4b09      	ldr	r3, [pc, #36]	; (800a374 <LSM303AGR_M_Get_ODR+0x6c>)
 800a34e:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800a350:	2000      	movs	r0, #0
}
 800a352:	b002      	add	sp, #8
 800a354:	bd10      	pop	{r4, pc}
      *odr = 50.000f;
 800a356:	4b08      	ldr	r3, [pc, #32]	; (800a378 <LSM303AGR_M_Get_ODR+0x70>)
 800a358:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800a35a:	2000      	movs	r0, #0
}
 800a35c:	b002      	add	sp, #8
 800a35e:	bd10      	pop	{r4, pc}
      *odr = -1.000f;
 800a360:	4b06      	ldr	r3, [pc, #24]	; (800a37c <LSM303AGR_M_Get_ODR+0x74>)
 800a362:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 800a364:	2001      	movs	r0, #1
}
 800a366:	b002      	add	sp, #8
 800a368:	bd10      	pop	{r4, pc}
 800a36a:	bf00      	nop
 800a36c:	42c80000 	.word	0x42c80000
 800a370:	41200000 	.word	0x41200000
 800a374:	41a00000 	.word	0x41a00000
 800a378:	42480000 	.word	0x42480000
 800a37c:	bf800000 	.word	0xbf800000

0800a380 <LSM303AGR_M_Get_Axes_Raw>:
 * @param pData pointer where the raw values of the axes are written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LSM303AGR_M_Get_Axes_Raw( DrvContextTypeDef *handle, int16_t* pData )
{
 800a380:	b530      	push	{r4, r5, lr}
 800a382:	b083      	sub	sp, #12

  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 800a384:	2400      	movs	r4, #0
{
 800a386:	460d      	mov	r5, r1
  int16_t *regValueInt16;

  /* Read output registers from LSM303AGR_MAG_OUTX_L to LSM303AGR_MAG_OUTZ_H. */
  if ( LSM303AGR_MAG_Get_Raw_Magnetic( (void *)handle, regValue ) == MEMS_ERROR )
 800a388:	4669      	mov	r1, sp
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 800a38a:	f8ad 4004 	strh.w	r4, [sp, #4]
 800a38e:	9400      	str	r4, [sp, #0]
  if ( LSM303AGR_MAG_Get_Raw_Magnetic( (void *)handle, regValue ) == MEMS_ERROR )
 800a390:	f7ff fea6 	bl	800a0e0 <LSM303AGR_MAG_Get_Raw_Magnetic>
 800a394:	b158      	cbz	r0, 800a3ae <LSM303AGR_M_Get_Axes_Raw+0x2e>
  }

  regValueInt16 = (int16_t *)regValue;

  /* Format the data. */
  pData[0] = regValueInt16[0];
 800a396:	f8bd 1000 	ldrh.w	r1, [sp]
  pData[1] = regValueInt16[1];
 800a39a:	f8bd 2002 	ldrh.w	r2, [sp, #2]
  pData[2] = regValueInt16[2];
 800a39e:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  pData[0] = regValueInt16[0];
 800a3a2:	8029      	strh	r1, [r5, #0]

  return COMPONENT_OK;
 800a3a4:	4620      	mov	r0, r4
  pData[1] = regValueInt16[1];
 800a3a6:	806a      	strh	r2, [r5, #2]
  pData[2] = regValueInt16[2];
 800a3a8:	80ab      	strh	r3, [r5, #4]
}
 800a3aa:	b003      	add	sp, #12
 800a3ac:	bd30      	pop	{r4, r5, pc}
    return COMPONENT_ERROR;
 800a3ae:	2001      	movs	r0, #1
}
 800a3b0:	b003      	add	sp, #12
 800a3b2:	bd30      	pop	{r4, r5, pc}

0800a3b4 <LSM303AGR_M_Get_AxesRaw>:
{
 800a3b4:	b510      	push	{r4, lr}
 800a3b6:	b082      	sub	sp, #8
 800a3b8:	460c      	mov	r4, r1
  if ( LSM303AGR_M_Get_Axes_Raw( handle, pDataRaw ) == COMPONENT_ERROR )
 800a3ba:	4669      	mov	r1, sp
 800a3bc:	f7ff ffe0 	bl	800a380 <LSM303AGR_M_Get_Axes_Raw>
 800a3c0:	2801      	cmp	r0, #1
 800a3c2:	d009      	beq.n	800a3d8 <LSM303AGR_M_Get_AxesRaw+0x24>
  value->AXIS_X = pDataRaw[0];
 800a3c4:	f8bd 1000 	ldrh.w	r1, [sp]
  value->AXIS_Y = pDataRaw[1];
 800a3c8:	f8bd 2002 	ldrh.w	r2, [sp, #2]
  value->AXIS_Z = pDataRaw[2];
 800a3cc:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  value->AXIS_X = pDataRaw[0];
 800a3d0:	8021      	strh	r1, [r4, #0]
  value->AXIS_Y = pDataRaw[1];
 800a3d2:	8062      	strh	r2, [r4, #2]
  value->AXIS_Z = pDataRaw[2];
 800a3d4:	80a3      	strh	r3, [r4, #4]
  return COMPONENT_OK;
 800a3d6:	2000      	movs	r0, #0
}
 800a3d8:	b002      	add	sp, #8
 800a3da:	bd10      	pop	{r4, pc}

0800a3dc <LSM303AGR_M_Get_Axes>:
{
 800a3dc:	b510      	push	{r4, lr}
 800a3de:	b082      	sub	sp, #8
 800a3e0:	460c      	mov	r4, r1
  if ( LSM303AGR_M_Get_Axes_Raw( handle, pDataRaw ) == COMPONENT_ERROR )
 800a3e2:	4669      	mov	r1, sp
 800a3e4:	f7ff ffcc 	bl	800a380 <LSM303AGR_M_Get_Axes_Raw>
 800a3e8:	2801      	cmp	r0, #1
 800a3ea:	d026      	beq.n	800a43a <LSM303AGR_M_Get_Axes+0x5e>
  magnetic_field->AXIS_X = ( int32_t )( pDataRaw[0] * sensitivity );
 800a3ec:	f9bd 3000 	ldrsh.w	r3, [sp]
 800a3f0:	ee06 3a90 	vmov	s13, r3
  magnetic_field->AXIS_Y = ( int32_t )( pDataRaw[1] * sensitivity );
 800a3f4:	f9bd 3002 	ldrsh.w	r3, [sp, #2]
 800a3f8:	ee07 3a10 	vmov	s14, r3
  magnetic_field->AXIS_Z = ( int32_t )( pDataRaw[2] * sensitivity );
 800a3fc:	f9bd 3004 	ldrsh.w	r3, [sp, #4]
 800a400:	ee07 3a90 	vmov	s15, r3
  magnetic_field->AXIS_X = ( int32_t )( pDataRaw[0] * sensitivity );
 800a404:	eef8 6ae6 	vcvt.f32.s32	s13, s13
  magnetic_field->AXIS_Y = ( int32_t )( pDataRaw[1] * sensitivity );
 800a408:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  magnetic_field->AXIS_Z = ( int32_t )( pDataRaw[2] * sensitivity );
 800a40c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  magnetic_field->AXIS_X = ( int32_t )( pDataRaw[0] * sensitivity );
 800a410:	eeb7 6a08 	vmov.f32	s12, #120	; 0x3fc00000  1.5
 800a414:	ee66 6a86 	vmul.f32	s13, s13, s12
  magnetic_field->AXIS_Y = ( int32_t )( pDataRaw[1] * sensitivity );
 800a418:	ee27 7a06 	vmul.f32	s14, s14, s12
  magnetic_field->AXIS_Z = ( int32_t )( pDataRaw[2] * sensitivity );
 800a41c:	ee67 7a86 	vmul.f32	s15, s15, s12
  magnetic_field->AXIS_X = ( int32_t )( pDataRaw[0] * sensitivity );
 800a420:	eefd 6ae6 	vcvt.s32.f32	s13, s13
  magnetic_field->AXIS_Y = ( int32_t )( pDataRaw[1] * sensitivity );
 800a424:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  magnetic_field->AXIS_Z = ( int32_t )( pDataRaw[2] * sensitivity );
 800a428:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  magnetic_field->AXIS_X = ( int32_t )( pDataRaw[0] * sensitivity );
 800a42c:	edc4 6a00 	vstr	s13, [r4]
  magnetic_field->AXIS_Y = ( int32_t )( pDataRaw[1] * sensitivity );
 800a430:	ed84 7a01 	vstr	s14, [r4, #4]
  magnetic_field->AXIS_Z = ( int32_t )( pDataRaw[2] * sensitivity );
 800a434:	edc4 7a02 	vstr	s15, [r4, #8]
  return COMPONENT_OK;
 800a438:	2000      	movs	r0, #0
}
 800a43a:	b002      	add	sp, #8
 800a43c:	bd10      	pop	{r4, pc}
 800a43e:	bf00      	nop

0800a440 <LSM303AGR_M_Get_WhoAmI>:
{
 800a440:	b508      	push	{r3, lr}
  if ( LSM303AGR_MAG_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 800a442:	f7ff fdff 	bl	800a044 <LSM303AGR_MAG_R_WHO_AM_I>
}
 800a446:	fab0 f080 	clz	r0, r0
 800a44a:	0940      	lsrs	r0, r0, #5
 800a44c:	bd08      	pop	{r3, pc}
 800a44e:	bf00      	nop

0800a450 <LSM303AGR_M_Check_WhoAmI>:
{
 800a450:	b510      	push	{r4, lr}
 800a452:	b082      	sub	sp, #8
  uint8_t who_am_i = 0x00;
 800a454:	a902      	add	r1, sp, #8
 800a456:	2300      	movs	r3, #0
 800a458:	f801 3d01 	strb.w	r3, [r1, #-1]!
{
 800a45c:	4604      	mov	r4, r0
  if ( LSM303AGR_MAG_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 800a45e:	f7ff fdf1 	bl	800a044 <LSM303AGR_MAG_R_WHO_AM_I>
 800a462:	b138      	cbz	r0, 800a474 <LSM303AGR_M_Check_WhoAmI+0x24>
  if ( who_am_i != handle->who_am_i )
 800a464:	7820      	ldrb	r0, [r4, #0]
 800a466:	f89d 3007 	ldrb.w	r3, [sp, #7]
    return COMPONENT_ERROR;
 800a46a:	1ac0      	subs	r0, r0, r3
 800a46c:	bf18      	it	ne
 800a46e:	2001      	movne	r0, #1
}
 800a470:	b002      	add	sp, #8
 800a472:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 800a474:	2001      	movs	r0, #1
}
 800a476:	b002      	add	sp, #8
 800a478:	bd10      	pop	{r4, pc}
 800a47a:	bf00      	nop

0800a47c <LSM303AGR_M_Init>:
{
 800a47c:	b538      	push	{r3, r4, r5, lr}
  LSM303AGR_M_Data_t *pComponentData = ( LSM303AGR_M_Data_t * )pData->pComponentData;
 800a47e:	6883      	ldr	r3, [r0, #8]
  LSM303AGR_Combo_Data_t *comboData = pComponentData->comboData;
 800a480:	681b      	ldr	r3, [r3, #0]
{
 800a482:	4604      	mov	r4, r0
  LSM303AGR_Combo_Data_t *comboData = pComponentData->comboData;
 800a484:	681d      	ldr	r5, [r3, #0]
  if ( LSM303AGR_M_Check_WhoAmI( handle ) == COMPONENT_ERROR )
 800a486:	f7ff ffe3 	bl	800a450 <LSM303AGR_M_Check_WhoAmI>
 800a48a:	2801      	cmp	r0, #1
 800a48c:	d004      	beq.n	800a498 <LSM303AGR_M_Init+0x1c>
  if ( LSM303AGR_MAG_W_MD( (void *)handle, LSM303AGR_MAG_MD_IDLE1_MODE ) == MEMS_ERROR )
 800a48e:	2102      	movs	r1, #2
 800a490:	4620      	mov	r0, r4
 800a492:	f7ff fe03 	bl	800a09c <LSM303AGR_MAG_W_MD>
 800a496:	b908      	cbnz	r0, 800a49c <LSM303AGR_M_Init+0x20>
    return COMPONENT_ERROR;
 800a498:	2001      	movs	r0, #1
}
 800a49a:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM303AGR_MAG_W_BDU( (void *)handle, LSM303AGR_MAG_BDU_ENABLED ) == MEMS_ERROR )
 800a49c:	2110      	movs	r1, #16
 800a49e:	4620      	mov	r0, r4
 800a4a0:	f7ff fdda 	bl	800a058 <LSM303AGR_MAG_W_BDU>
 800a4a4:	2800      	cmp	r0, #0
 800a4a6:	d0f7      	beq.n	800a498 <LSM303AGR_M_Init+0x1c>
  if ( LSM303AGR_MAG_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 800a4a8:	210c      	movs	r1, #12
 800a4aa:	4620      	mov	r0, r4
 800a4ac:	f7ff fe22 	bl	800a0f4 <LSM303AGR_MAG_W_ODR>
 800a4b0:	2800      	cmp	r0, #0
 800a4b2:	d0f1      	beq.n	800a498 <LSM303AGR_M_Init+0x1c>
  if ( LSM303AGR_MAG_W_ST( (void *)handle, LSM303AGR_MAG_ST_DISABLED ) == MEMS_ERROR )
 800a4b4:	2100      	movs	r1, #0
 800a4b6:	4620      	mov	r0, r4
 800a4b8:	f7ff fe4e 	bl	800a158 <LSM303AGR_MAG_W_ST>
 800a4bc:	2800      	cmp	r0, #0
 800a4be:	d0eb      	beq.n	800a498 <LSM303AGR_M_Init+0x1c>
  comboData->isMagInitialized = 1;
 800a4c0:	2301      	movs	r3, #1
 800a4c2:	706b      	strb	r3, [r5, #1]
  handle->isInitialized = 1;
 800a4c4:	7163      	strb	r3, [r4, #5]
  return COMPONENT_OK;
 800a4c6:	2000      	movs	r0, #0
}
 800a4c8:	bd38      	pop	{r3, r4, r5, pc}
 800a4ca:	bf00      	nop

0800a4cc <LSM303AGR_M_DeInit>:
{
 800a4cc:	b538      	push	{r3, r4, r5, lr}
  LSM303AGR_M_Data_t *pComponentData = ( LSM303AGR_M_Data_t * )pData->pComponentData;
 800a4ce:	6883      	ldr	r3, [r0, #8]
  LSM303AGR_Combo_Data_t *comboData = pComponentData->comboData;
 800a4d0:	681b      	ldr	r3, [r3, #0]
{
 800a4d2:	4604      	mov	r4, r0
  LSM303AGR_Combo_Data_t *comboData = pComponentData->comboData;
 800a4d4:	681d      	ldr	r5, [r3, #0]
  if ( LSM303AGR_M_Check_WhoAmI( handle ) == COMPONENT_ERROR )
 800a4d6:	f7ff ffbb 	bl	800a450 <LSM303AGR_M_Check_WhoAmI>
 800a4da:	2801      	cmp	r0, #1
 800a4dc:	d012      	beq.n	800a504 <LSM303AGR_M_DeInit+0x38>
  if ( handle->isEnabled == 0 )
 800a4de:	79a3      	ldrb	r3, [r4, #6]
 800a4e0:	b923      	cbnz	r3, 800a4ec <LSM303AGR_M_DeInit+0x20>
  comboData->isMagInitialized = 0;
 800a4e2:	2300      	movs	r3, #0
 800a4e4:	706b      	strb	r3, [r5, #1]
  return COMPONENT_OK;
 800a4e6:	4618      	mov	r0, r3
  handle->isInitialized = 0;
 800a4e8:	7163      	strb	r3, [r4, #5]
}
 800a4ea:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM303AGR_MAG_W_MD( (void *)handle, LSM303AGR_MAG_MD_IDLE1_MODE ) == MEMS_ERROR )
 800a4ec:	2102      	movs	r1, #2
 800a4ee:	4620      	mov	r0, r4
 800a4f0:	f7ff fdd4 	bl	800a09c <LSM303AGR_MAG_W_MD>
 800a4f4:	b130      	cbz	r0, 800a504 <LSM303AGR_M_DeInit+0x38>
  handle->isEnabled = 0;
 800a4f6:	2300      	movs	r3, #0
 800a4f8:	71a3      	strb	r3, [r4, #6]
  comboData->isMagInitialized = 0;
 800a4fa:	2300      	movs	r3, #0
 800a4fc:	706b      	strb	r3, [r5, #1]
  return COMPONENT_OK;
 800a4fe:	4618      	mov	r0, r3
  handle->isInitialized = 0;
 800a500:	7163      	strb	r3, [r4, #5]
 800a502:	e7f2      	b.n	800a4ea <LSM303AGR_M_DeInit+0x1e>
    return COMPONENT_ERROR;
 800a504:	2001      	movs	r0, #1
}
 800a506:	bd38      	pop	{r3, r4, r5, pc}

0800a508 <LSM303AGR_M_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 800a508:	7982      	ldrb	r2, [r0, #6]
 800a50a:	2a01      	cmp	r2, #1
 800a50c:	d00b      	beq.n	800a526 <LSM303AGR_M_Sensor_Enable+0x1e>
{
 800a50e:	b510      	push	{r4, lr}
  if ( LSM303AGR_MAG_W_MD( (void *)handle, LSM303AGR_MAG_MD_CONTINUOS_MODE ) == MEMS_ERROR )
 800a510:	2100      	movs	r1, #0
 800a512:	4604      	mov	r4, r0
 800a514:	f7ff fdc2 	bl	800a09c <LSM303AGR_MAG_W_MD>
 800a518:	b118      	cbz	r0, 800a522 <LSM303AGR_M_Sensor_Enable+0x1a>
  handle->isEnabled = 1;
 800a51a:	2301      	movs	r3, #1
 800a51c:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 800a51e:	2000      	movs	r0, #0
}
 800a520:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 800a522:	2001      	movs	r0, #1
}
 800a524:	bd10      	pop	{r4, pc}
    return COMPONENT_OK;
 800a526:	2000      	movs	r0, #0
}
 800a528:	4770      	bx	lr
 800a52a:	bf00      	nop

0800a52c <LSM303AGR_M_Sensor_Disable>:
  if ( handle->isEnabled == 0 )
 800a52c:	7983      	ldrb	r3, [r0, #6]
 800a52e:	b90b      	cbnz	r3, 800a534 <LSM303AGR_M_Sensor_Disable+0x8>
    return COMPONENT_OK;
 800a530:	4618      	mov	r0, r3
}
 800a532:	4770      	bx	lr
{
 800a534:	b510      	push	{r4, lr}
  if ( LSM303AGR_MAG_W_MD( (void *)handle, LSM303AGR_MAG_MD_IDLE1_MODE ) == MEMS_ERROR )
 800a536:	2102      	movs	r1, #2
 800a538:	4604      	mov	r4, r0
 800a53a:	f7ff fdaf 	bl	800a09c <LSM303AGR_MAG_W_MD>
 800a53e:	b118      	cbz	r0, 800a548 <LSM303AGR_M_Sensor_Disable+0x1c>
  handle->isEnabled = 0;
 800a540:	2300      	movs	r3, #0
 800a542:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 800a544:	4618      	mov	r0, r3
}
 800a546:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 800a548:	2001      	movs	r0, #1
}
 800a54a:	bd10      	pop	{r4, pc}

0800a54c <LSM6DSM_ACC_GYRO_ReadReg>:
* Input       : Register Address, length of buffer
* Output      : Data REad
* Return      : None
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_ReadReg(void *handle, u8_t Reg, u8_t* Data, u16_t len)
{
 800a54c:	b508      	push	{r3, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a54e:	f004 f877 	bl	800e640 <Sensor_IO_Read>
  }
  else
  {
    return MEMS_SUCCESS;
  }
}
 800a552:	fab0 f080 	clz	r0, r0
 800a556:	0940      	lsrs	r0, r0, #5
 800a558:	bd08      	pop	{r3, pc}
 800a55a:	bf00      	nop

0800a55c <LSM6DSM_ACC_GYRO_WriteReg>:
* Input       : Register Address, Data to be written, length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_WriteReg(void *handle, u8_t Reg, u8_t *Data, u16_t len)
{
 800a55c:	b508      	push	{r3, lr}
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a55e:	f003 ff81 	bl	800e464 <Sensor_IO_Write>
  }
  else
  {
    return MEMS_SUCCESS;
  }
}
 800a562:	fab0 f080 	clz	r0, r0
 800a566:	0940      	lsrs	r0, r0, #5
 800a568:	bd08      	pop	{r3, pc}
 800a56a:	bf00      	nop

0800a56c <LSM6DSM_ACC_GYRO_R_WHO_AM_I>:
* Input          : Pointer to u8_t
* Output         : Status of WHO_AM_I_BIT
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_WHO_AM_I(void *handle, u8_t *value)
{
 800a56c:	b508      	push	{r3, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a56e:	460a      	mov	r2, r1
 800a570:	2301      	movs	r3, #1
 800a572:	210f      	movs	r1, #15
 800a574:	f004 f864 	bl	800e640 <Sensor_IO_Read>

  *value &= LSM6DSM_ACC_GYRO_WHO_AM_I_BIT_MASK; //coerce
  *value = *value >> LSM6DSM_ACC_GYRO_WHO_AM_I_BIT_POSITION; //mask

  return MEMS_SUCCESS;
}
 800a578:	fab0 f080 	clz	r0, r0
 800a57c:	0940      	lsrs	r0, r0, #5
 800a57e:	bd08      	pop	{r3, pc}

0800a580 <LSM6DSM_ACC_GYRO_W_BDU>:
* Input          : LSM6DSM_ACC_GYRO_BDU_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_BDU(void *handle, LSM6DSM_ACC_GYRO_BDU_t newValue)
{
 800a580:	b530      	push	{r4, r5, lr}
 800a582:	b083      	sub	sp, #12
 800a584:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a586:	f10d 0207 	add.w	r2, sp, #7
 800a58a:	2301      	movs	r3, #1
 800a58c:	2112      	movs	r1, #18
{
 800a58e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a590:	f004 f856 	bl	800e640 <Sensor_IO_Read>
 800a594:	b110      	cbz	r0, 800a59c <LSM6DSM_ACC_GYRO_W_BDU+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL3_C, &value, 1))
    return MEMS_ERROR;
 800a596:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CTRL3_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a598:	b003      	add	sp, #12
 800a59a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_BDU_MASK;
 800a59c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a5a0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  value |= newValue;
 800a5a4:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a5a6:	f10d 0207 	add.w	r2, sp, #7
 800a5aa:	4628      	mov	r0, r5
 800a5ac:	2301      	movs	r3, #1
 800a5ae:	2112      	movs	r1, #18
  value |= newValue;
 800a5b0:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a5b4:	f003 ff56 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a5b8:	fab0 f080 	clz	r0, r0
 800a5bc:	0940      	lsrs	r0, r0, #5
}
 800a5be:	b003      	add	sp, #12
 800a5c0:	bd30      	pop	{r4, r5, pc}
 800a5c2:	bf00      	nop

0800a5c4 <LSM6DSM_ACC_GYRO_W_FS_XL>:
* Input          : LSM6DSM_ACC_GYRO_FS_XL_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_FS_XL(void *handle, LSM6DSM_ACC_GYRO_FS_XL_t newValue)
{
 800a5c4:	b530      	push	{r4, r5, lr}
 800a5c6:	b083      	sub	sp, #12
 800a5c8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a5ca:	f10d 0207 	add.w	r2, sp, #7
 800a5ce:	2301      	movs	r3, #1
 800a5d0:	2110      	movs	r1, #16
{
 800a5d2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a5d4:	f004 f834 	bl	800e640 <Sensor_IO_Read>
 800a5d8:	b110      	cbz	r0, 800a5e0 <LSM6DSM_ACC_GYRO_W_FS_XL+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL1_XL, &value, 1))
    return MEMS_ERROR;
 800a5da:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CTRL1_XL, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a5dc:	b003      	add	sp, #12
 800a5de:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_FS_XL_MASK;
 800a5e0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a5e4:	f023 030c 	bic.w	r3, r3, #12
  value |= newValue;
 800a5e8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a5ea:	f10d 0207 	add.w	r2, sp, #7
 800a5ee:	4628      	mov	r0, r5
 800a5f0:	2301      	movs	r3, #1
 800a5f2:	2110      	movs	r1, #16
  value |= newValue;
 800a5f4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a5f8:	f003 ff34 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a5fc:	fab0 f080 	clz	r0, r0
 800a600:	0940      	lsrs	r0, r0, #5
}
 800a602:	b003      	add	sp, #12
 800a604:	bd30      	pop	{r4, r5, pc}
 800a606:	bf00      	nop

0800a608 <LSM6DSM_ACC_GYRO_R_FS_XL>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_FS_XL_t
* Output         : Status of FS_XL see LSM6DSM_ACC_GYRO_FS_XL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_FS_XL(void *handle, LSM6DSM_ACC_GYRO_FS_XL_t *value)
{
 800a608:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a60a:	460a      	mov	r2, r1
{
 800a60c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a60e:	2301      	movs	r3, #1
 800a610:	2110      	movs	r1, #16
 800a612:	f004 f815 	bl	800e640 <Sensor_IO_Read>
 800a616:	b928      	cbnz	r0, 800a624 <LSM6DSM_ACC_GYRO_R_FS_XL+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL1_XL, (u8_t *)value, 1))
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_FS_XL_MASK; //mask
 800a618:	7823      	ldrb	r3, [r4, #0]
 800a61a:	f003 030c 	and.w	r3, r3, #12
 800a61e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800a620:	2001      	movs	r0, #1
}
 800a622:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800a624:	2000      	movs	r0, #0
}
 800a626:	bd10      	pop	{r4, pc}

0800a628 <LSM6DSM_ACC_GYRO_GetRawAccData>:
* Input          : pointer to [u8_t]
* Output         : GetAccData buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_GetRawAccData(void *handle, u8_t *buff)
{
 800a628:	b570      	push	{r4, r5, r6, lr}
 800a62a:	4606      	mov	r6, r0
 800a62c:	460d      	mov	r5, r1
 800a62e:	2428      	movs	r4, #40	; 0x28
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a630:	462a      	mov	r2, r5
 800a632:	2301      	movs	r3, #1
 800a634:	4621      	mov	r1, r4
 800a636:	4630      	mov	r0, r6
 800a638:	f004 f802 	bl	800e640 <Sensor_IO_Read>
  k = 0;
  for (i = 0; i < 3; i++ )
  {
    for (j = 0; j < numberOfByteForDimension; j++ )
    {
      if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_OUTX_L_XL + k, &buff[k], 1))
 800a63c:	1c61      	adds	r1, r4, #1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a63e:	1c6a      	adds	r2, r5, #1
 800a640:	2301      	movs	r3, #1
 800a642:	b2c9      	uxtb	r1, r1
 800a644:	3502      	adds	r5, #2
 800a646:	b948      	cbnz	r0, 800a65c <LSM6DSM_ACC_GYRO_GetRawAccData+0x34>
 800a648:	4630      	mov	r0, r6
 800a64a:	f003 fff9 	bl	800e640 <Sensor_IO_Read>
 800a64e:	3402      	adds	r4, #2
 800a650:	b2e4      	uxtb	r4, r4
 800a652:	b918      	cbnz	r0, 800a65c <LSM6DSM_ACC_GYRO_GetRawAccData+0x34>
  for (i = 0; i < 3; i++ )
 800a654:	2c2e      	cmp	r4, #46	; 0x2e
 800a656:	d1eb      	bne.n	800a630 <LSM6DSM_ACC_GYRO_GetRawAccData+0x8>
        return MEMS_ERROR;
      k++;
    }
  }

  return MEMS_SUCCESS;
 800a658:	2001      	movs	r0, #1
}
 800a65a:	bd70      	pop	{r4, r5, r6, pc}
        return MEMS_ERROR;
 800a65c:	2000      	movs	r0, #0
}
 800a65e:	bd70      	pop	{r4, r5, r6, pc}

0800a660 <LSM6DSM_ACC_GYRO_W_ODR_XL>:
* Input          : LSM6DSM_ACC_GYRO_ODR_XL_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_ODR_XL(void *handle, LSM6DSM_ACC_GYRO_ODR_XL_t newValue)
{
 800a660:	b530      	push	{r4, r5, lr}
 800a662:	b083      	sub	sp, #12
 800a664:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a666:	f10d 0207 	add.w	r2, sp, #7
 800a66a:	2301      	movs	r3, #1
 800a66c:	2110      	movs	r1, #16
{
 800a66e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a670:	f003 ffe6 	bl	800e640 <Sensor_IO_Read>
 800a674:	b110      	cbz	r0, 800a67c <LSM6DSM_ACC_GYRO_W_ODR_XL+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL1_XL, &value, 1))
    return MEMS_ERROR;
 800a676:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CTRL1_XL, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a678:	b003      	add	sp, #12
 800a67a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_ODR_XL_MASK;
 800a67c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a680:	f003 030f 	and.w	r3, r3, #15
  value |= newValue;
 800a684:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a686:	f10d 0207 	add.w	r2, sp, #7
 800a68a:	4628      	mov	r0, r5
 800a68c:	2301      	movs	r3, #1
 800a68e:	2110      	movs	r1, #16
  value |= newValue;
 800a690:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a694:	f003 fee6 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a698:	fab0 f080 	clz	r0, r0
 800a69c:	0940      	lsrs	r0, r0, #5
}
 800a69e:	b003      	add	sp, #12
 800a6a0:	bd30      	pop	{r4, r5, pc}
 800a6a2:	bf00      	nop

0800a6a4 <LSM6DSM_ACC_GYRO_R_ODR_XL>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_ODR_XL_t
* Output         : Status of ODR_XL see LSM6DSM_ACC_GYRO_ODR_XL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_ODR_XL(void *handle, LSM6DSM_ACC_GYRO_ODR_XL_t *value)
{
 800a6a4:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a6a6:	460a      	mov	r2, r1
{
 800a6a8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a6aa:	2301      	movs	r3, #1
 800a6ac:	2110      	movs	r1, #16
 800a6ae:	f003 ffc7 	bl	800e640 <Sensor_IO_Read>
 800a6b2:	b928      	cbnz	r0, 800a6c0 <LSM6DSM_ACC_GYRO_R_ODR_XL+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL1_XL, (u8_t *)value, 1))
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_ODR_XL_MASK; //mask
 800a6b4:	7823      	ldrb	r3, [r4, #0]
 800a6b6:	f023 030f 	bic.w	r3, r3, #15
 800a6ba:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800a6bc:	2001      	movs	r0, #1
}
 800a6be:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800a6c0:	2000      	movs	r0, #0
}
 800a6c2:	bd10      	pop	{r4, pc}

0800a6c4 <LSM6DSM_ACC_GYRO_W_FS_G>:
* Input          : LSM6DSM_ACC_GYRO_FS_G_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_FS_G(void *handle, LSM6DSM_ACC_GYRO_FS_G_t newValue)
{
 800a6c4:	b530      	push	{r4, r5, lr}
 800a6c6:	b083      	sub	sp, #12
 800a6c8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a6ca:	f10d 0207 	add.w	r2, sp, #7
 800a6ce:	2301      	movs	r3, #1
 800a6d0:	2111      	movs	r1, #17
{
 800a6d2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a6d4:	f003 ffb4 	bl	800e640 <Sensor_IO_Read>
 800a6d8:	b110      	cbz	r0, 800a6e0 <LSM6DSM_ACC_GYRO_W_FS_G+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL2_G, &value, 1))
    return MEMS_ERROR;
 800a6da:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CTRL2_G, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a6dc:	b003      	add	sp, #12
 800a6de:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_FS_G_MASK;
 800a6e0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a6e4:	f023 030c 	bic.w	r3, r3, #12
  value |= newValue;
 800a6e8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a6ea:	f10d 0207 	add.w	r2, sp, #7
 800a6ee:	4628      	mov	r0, r5
 800a6f0:	2301      	movs	r3, #1
 800a6f2:	2111      	movs	r1, #17
  value |= newValue;
 800a6f4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a6f8:	f003 feb4 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a6fc:	fab0 f080 	clz	r0, r0
 800a700:	0940      	lsrs	r0, r0, #5
}
 800a702:	b003      	add	sp, #12
 800a704:	bd30      	pop	{r4, r5, pc}
 800a706:	bf00      	nop

0800a708 <LSM6DSM_ACC_GYRO_R_FS_G>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_FS_G_t
* Output         : Status of FS_G see LSM6DSM_ACC_GYRO_FS_G_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_FS_G(void *handle, LSM6DSM_ACC_GYRO_FS_G_t *value)
{
 800a708:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a70a:	460a      	mov	r2, r1
{
 800a70c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a70e:	2301      	movs	r3, #1
 800a710:	2111      	movs	r1, #17
 800a712:	f003 ff95 	bl	800e640 <Sensor_IO_Read>
 800a716:	b928      	cbnz	r0, 800a724 <LSM6DSM_ACC_GYRO_R_FS_G+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL2_G, (u8_t *)value, 1))
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_FS_G_MASK; //mask
 800a718:	7823      	ldrb	r3, [r4, #0]
 800a71a:	f003 030c 	and.w	r3, r3, #12
 800a71e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800a720:	2001      	movs	r0, #1
}
 800a722:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800a724:	2000      	movs	r0, #0
}
 800a726:	bd10      	pop	{r4, pc}

0800a728 <LSM6DSM_ACC_GYRO_GetRawGyroData>:
* Input          : pointer to [u8_t]
* Output         : GetGyroData buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_GetRawGyroData(void *handle, u8_t *buff)
{
 800a728:	b570      	push	{r4, r5, r6, lr}
 800a72a:	4606      	mov	r6, r0
 800a72c:	460d      	mov	r5, r1
 800a72e:	2422      	movs	r4, #34	; 0x22
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a730:	462a      	mov	r2, r5
 800a732:	2301      	movs	r3, #1
 800a734:	4621      	mov	r1, r4
 800a736:	4630      	mov	r0, r6
 800a738:	f003 ff82 	bl	800e640 <Sensor_IO_Read>
  k = 0;
  for (i = 0; i < 3; i++ )
  {
    for (j = 0; j < numberOfByteForDimension; j++ )
    {
      if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_OUTX_L_G + k, &buff[k], 1))
 800a73c:	1c61      	adds	r1, r4, #1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a73e:	1c6a      	adds	r2, r5, #1
 800a740:	2301      	movs	r3, #1
 800a742:	b2c9      	uxtb	r1, r1
 800a744:	3502      	adds	r5, #2
 800a746:	b948      	cbnz	r0, 800a75c <LSM6DSM_ACC_GYRO_GetRawGyroData+0x34>
 800a748:	4630      	mov	r0, r6
 800a74a:	f003 ff79 	bl	800e640 <Sensor_IO_Read>
 800a74e:	3402      	adds	r4, #2
 800a750:	b2e4      	uxtb	r4, r4
 800a752:	b918      	cbnz	r0, 800a75c <LSM6DSM_ACC_GYRO_GetRawGyroData+0x34>
  for (i = 0; i < 3; i++ )
 800a754:	2c28      	cmp	r4, #40	; 0x28
 800a756:	d1eb      	bne.n	800a730 <LSM6DSM_ACC_GYRO_GetRawGyroData+0x8>
        return MEMS_ERROR;
      k++;
    }
  }

  return MEMS_SUCCESS;
 800a758:	2001      	movs	r0, #1
}
 800a75a:	bd70      	pop	{r4, r5, r6, pc}
        return MEMS_ERROR;
 800a75c:	2000      	movs	r0, #0
}
 800a75e:	bd70      	pop	{r4, r5, r6, pc}

0800a760 <LSM6DSM_ACC_GYRO_W_ODR_G>:
* Input          : LSM6DSM_ACC_GYRO_ODR_G_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_ODR_G(void *handle, LSM6DSM_ACC_GYRO_ODR_G_t newValue)
{
 800a760:	b530      	push	{r4, r5, lr}
 800a762:	b083      	sub	sp, #12
 800a764:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a766:	f10d 0207 	add.w	r2, sp, #7
 800a76a:	2301      	movs	r3, #1
 800a76c:	2111      	movs	r1, #17
{
 800a76e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a770:	f003 ff66 	bl	800e640 <Sensor_IO_Read>
 800a774:	b110      	cbz	r0, 800a77c <LSM6DSM_ACC_GYRO_W_ODR_G+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL2_G, &value, 1))
    return MEMS_ERROR;
 800a776:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CTRL2_G, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a778:	b003      	add	sp, #12
 800a77a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_ODR_G_MASK;
 800a77c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a780:	f003 030f 	and.w	r3, r3, #15
  value |= newValue;
 800a784:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a786:	f10d 0207 	add.w	r2, sp, #7
 800a78a:	4628      	mov	r0, r5
 800a78c:	2301      	movs	r3, #1
 800a78e:	2111      	movs	r1, #17
  value |= newValue;
 800a790:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a794:	f003 fe66 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a798:	fab0 f080 	clz	r0, r0
 800a79c:	0940      	lsrs	r0, r0, #5
}
 800a79e:	b003      	add	sp, #12
 800a7a0:	bd30      	pop	{r4, r5, pc}
 800a7a2:	bf00      	nop

0800a7a4 <LSM6DSM_ACC_GYRO_R_ODR_G>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_ODR_G_t
* Output         : Status of ODR_G see LSM6DSM_ACC_GYRO_ODR_G_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_ODR_G(void *handle, LSM6DSM_ACC_GYRO_ODR_G_t *value)
{
 800a7a4:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a7a6:	460a      	mov	r2, r1
{
 800a7a8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a7aa:	2301      	movs	r3, #1
 800a7ac:	2111      	movs	r1, #17
 800a7ae:	f003 ff47 	bl	800e640 <Sensor_IO_Read>
 800a7b2:	b928      	cbnz	r0, 800a7c0 <LSM6DSM_ACC_GYRO_R_ODR_G+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL2_G, (u8_t *)value, 1))
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_ODR_G_MASK; //mask
 800a7b4:	7823      	ldrb	r3, [r4, #0]
 800a7b6:	f023 030f 	bic.w	r3, r3, #15
 800a7ba:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800a7bc:	2001      	movs	r0, #1
}
 800a7be:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800a7c0:	2000      	movs	r0, #0
}
 800a7c2:	bd10      	pop	{r4, pc}

0800a7c4 <LSM6DSM_ACC_GYRO_W_FS_125>:
* Input          : LSM6DSM_ACC_GYRO_FS_125_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_FS_125(void *handle, LSM6DSM_ACC_GYRO_FS_125_t newValue)
{
 800a7c4:	b530      	push	{r4, r5, lr}
 800a7c6:	b083      	sub	sp, #12
 800a7c8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a7ca:	f10d 0207 	add.w	r2, sp, #7
 800a7ce:	2301      	movs	r3, #1
 800a7d0:	2111      	movs	r1, #17
{
 800a7d2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a7d4:	f003 ff34 	bl	800e640 <Sensor_IO_Read>
 800a7d8:	b110      	cbz	r0, 800a7e0 <LSM6DSM_ACC_GYRO_W_FS_125+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL2_G, &value, 1))
    return MEMS_ERROR;
 800a7da:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CTRL2_G, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a7dc:	b003      	add	sp, #12
 800a7de:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_FS_125_MASK;
 800a7e0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a7e4:	f023 0302 	bic.w	r3, r3, #2
  value |= newValue;
 800a7e8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a7ea:	f10d 0207 	add.w	r2, sp, #7
 800a7ee:	4628      	mov	r0, r5
 800a7f0:	2301      	movs	r3, #1
 800a7f2:	2111      	movs	r1, #17
  value |= newValue;
 800a7f4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a7f8:	f003 fe34 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a7fc:	fab0 f080 	clz	r0, r0
 800a800:	0940      	lsrs	r0, r0, #5
}
 800a802:	b003      	add	sp, #12
 800a804:	bd30      	pop	{r4, r5, pc}
 800a806:	bf00      	nop

0800a808 <LSM6DSM_ACC_GYRO_R_FS_125>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_FS_125_t
* Output         : Status of FS_125 see LSM6DSM_ACC_GYRO_FS_125_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_FS_125(void *handle, LSM6DSM_ACC_GYRO_FS_125_t *value)
{
 800a808:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a80a:	460a      	mov	r2, r1
{
 800a80c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a80e:	2301      	movs	r3, #1
 800a810:	2111      	movs	r1, #17
 800a812:	f003 ff15 	bl	800e640 <Sensor_IO_Read>
 800a816:	b928      	cbnz	r0, 800a824 <LSM6DSM_ACC_GYRO_R_FS_125+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL2_G, (u8_t *)value, 1))
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_FS_125_MASK; //mask
 800a818:	7823      	ldrb	r3, [r4, #0]
 800a81a:	f003 0302 	and.w	r3, r3, #2
 800a81e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800a820:	2001      	movs	r0, #1
}
 800a822:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800a824:	2000      	movs	r0, #0
}
 800a826:	bd10      	pop	{r4, pc}

0800a828 <LSM6DSM_ACC_GYRO_W_EmbeddedAccess>:
* Input          : LSM6DSM_ACC_GYRO_EMB_ACC_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_EmbeddedAccess(void *handle, LSM6DSM_ACC_GYRO_EMB_ACC_t newValue)
{
 800a828:	b530      	push	{r4, r5, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a82a:	2301      	movs	r3, #1
{
 800a82c:	b083      	sub	sp, #12
 800a82e:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a830:	f10d 0207 	add.w	r2, sp, #7
 800a834:	4619      	mov	r1, r3
{
 800a836:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a838:	f003 ff02 	bl	800e640 <Sensor_IO_Read>
 800a83c:	b110      	cbz	r0, 800a844 <LSM6DSM_ACC_GYRO_W_EmbeddedAccess+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FUNC_CFG_ACCESS, &value, 1) )
    return MEMS_ERROR;
 800a83e:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_FUNC_CFG_ACCESS, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a840:	b003      	add	sp, #12
 800a842:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_EMB_ACC_MASK;
 800a844:	f89d 1007 	ldrb.w	r1, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a848:	2301      	movs	r3, #1
  value &= ~LSM6DSM_ACC_GYRO_EMB_ACC_MASK;
 800a84a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
  value |= newValue;
 800a84e:	430c      	orrs	r4, r1
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a850:	f10d 0207 	add.w	r2, sp, #7
 800a854:	4628      	mov	r0, r5
 800a856:	4619      	mov	r1, r3
  value |= newValue;
 800a858:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a85c:	f003 fe02 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a860:	fab0 f080 	clz	r0, r0
 800a864:	0940      	lsrs	r0, r0, #5
}
 800a866:	b003      	add	sp, #12
 800a868:	bd30      	pop	{r4, r5, pc}
 800a86a:	bf00      	nop

0800a86c <LSM6DSM_ACC_GYRO_W_FIFO_Watermark>:
* Input          : u16_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_FIFO_Watermark(void *handle, u16_t newValue)
{
 800a86c:	b530      	push	{r4, r5, lr}
 800a86e:	b083      	sub	sp, #12
 800a870:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a872:	f10d 0207 	add.w	r2, sp, #7
 800a876:	2301      	movs	r3, #1
 800a878:	2106      	movs	r1, #6
{
 800a87a:	4604      	mov	r4, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a87c:	f003 fee0 	bl	800e640 <Sensor_IO_Read>
 800a880:	b110      	cbz	r0, 800a888 <LSM6DSM_ACC_GYRO_W_FIFO_Watermark+0x1c>
  /* Low part goes in FIFO_CTRL1 */
  valueL = valueL << LSM6DSM_ACC_GYRO_WTM_FIFO_CTRL1_POSITION; //mask
  valueL &= LSM6DSM_ACC_GYRO_WTM_FIFO_CTRL1_MASK; //coerce

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FIFO_CTRL1, &value, 1) )
    return MEMS_ERROR;
 800a882:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_FIFO_CTRL2, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a884:	b003      	add	sp, #12
 800a886:	bd30      	pop	{r4, r5, pc}
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a888:	2301      	movs	r3, #1
 800a88a:	f10d 0207 	add.w	r2, sp, #7
 800a88e:	2106      	movs	r1, #6
 800a890:	4620      	mov	r0, r4
  valueL = newValue & 0xFF;
 800a892:	f88d 5007 	strb.w	r5, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a896:	f003 fde5 	bl	800e464 <Sensor_IO_Write>
 800a89a:	2800      	cmp	r0, #0
 800a89c:	d1f1      	bne.n	800a882 <LSM6DSM_ACC_GYRO_W_FIFO_Watermark+0x16>
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a89e:	2301      	movs	r3, #1
 800a8a0:	f10d 0207 	add.w	r2, sp, #7
 800a8a4:	2107      	movs	r1, #7
 800a8a6:	4620      	mov	r0, r4
 800a8a8:	f003 feca 	bl	800e640 <Sensor_IO_Read>
 800a8ac:	2800      	cmp	r0, #0
 800a8ae:	d1e8      	bne.n	800a882 <LSM6DSM_ACC_GYRO_W_FIFO_Watermark+0x16>
  value &= ~LSM6DSM_ACC_GYRO_WTM_FIFO_CTRL2_MASK;
 800a8b0:	f89d 3007 	ldrb.w	r3, [sp, #7]
  valueH &= LSM6DSM_ACC_GYRO_WTM_FIFO_CTRL2_MASK; //coerce
 800a8b4:	f3c5 2502 	ubfx	r5, r5, #8, #3
  value &= ~LSM6DSM_ACC_GYRO_WTM_FIFO_CTRL2_MASK;
 800a8b8:	f023 0307 	bic.w	r3, r3, #7
  value |= valueH;
 800a8bc:	431d      	orrs	r5, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a8be:	f10d 0207 	add.w	r2, sp, #7
 800a8c2:	4620      	mov	r0, r4
 800a8c4:	2301      	movs	r3, #1
 800a8c6:	2107      	movs	r1, #7
  value |= valueH;
 800a8c8:	f88d 5007 	strb.w	r5, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a8cc:	f003 fdca 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a8d0:	fab0 f080 	clz	r0, r0
 800a8d4:	0940      	lsrs	r0, r0, #5
 800a8d6:	e7d5      	b.n	800a884 <LSM6DSM_ACC_GYRO_W_FIFO_Watermark+0x18>

0800a8d8 <LSM6DSM_ACC_GYRO_W_DEC_FIFO_XL>:
* Input          : LSM6DSM_ACC_GYRO_DEC_FIFO_XL_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_DEC_FIFO_XL(void *handle, LSM6DSM_ACC_GYRO_DEC_FIFO_XL_t newValue)
{
 800a8d8:	b530      	push	{r4, r5, lr}
 800a8da:	b083      	sub	sp, #12
 800a8dc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a8de:	f10d 0207 	add.w	r2, sp, #7
 800a8e2:	2301      	movs	r3, #1
 800a8e4:	2108      	movs	r1, #8
{
 800a8e6:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a8e8:	f003 feaa 	bl	800e640 <Sensor_IO_Read>
 800a8ec:	b110      	cbz	r0, 800a8f4 <LSM6DSM_ACC_GYRO_W_DEC_FIFO_XL+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FIFO_CTRL3, &value, 1) )
    return MEMS_ERROR;
 800a8ee:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_FIFO_CTRL3, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a8f0:	b003      	add	sp, #12
 800a8f2:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_DEC_FIFO_XL_MASK;
 800a8f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a8f8:	f023 0307 	bic.w	r3, r3, #7
  value |= newValue;
 800a8fc:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a8fe:	f10d 0207 	add.w	r2, sp, #7
 800a902:	4628      	mov	r0, r5
 800a904:	2301      	movs	r3, #1
 800a906:	2108      	movs	r1, #8
  value |= newValue;
 800a908:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a90c:	f003 fdaa 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a910:	fab0 f080 	clz	r0, r0
 800a914:	0940      	lsrs	r0, r0, #5
}
 800a916:	b003      	add	sp, #12
 800a918:	bd30      	pop	{r4, r5, pc}
 800a91a:	bf00      	nop

0800a91c <LSM6DSM_ACC_GYRO_W_DEC_FIFO_G>:
* Input          : LSM6DSM_ACC_GYRO_DEC_FIFO_G_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_DEC_FIFO_G(void *handle, LSM6DSM_ACC_GYRO_DEC_FIFO_G_t newValue)
{
 800a91c:	b530      	push	{r4, r5, lr}
 800a91e:	b083      	sub	sp, #12
 800a920:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a922:	f10d 0207 	add.w	r2, sp, #7
 800a926:	2301      	movs	r3, #1
 800a928:	2108      	movs	r1, #8
{
 800a92a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a92c:	f003 fe88 	bl	800e640 <Sensor_IO_Read>
 800a930:	b110      	cbz	r0, 800a938 <LSM6DSM_ACC_GYRO_W_DEC_FIFO_G+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FIFO_CTRL3, &value, 1))
    return MEMS_ERROR;
 800a932:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_FIFO_CTRL3, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a934:	b003      	add	sp, #12
 800a936:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_DEC_FIFO_G_MASK;
 800a938:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a93c:	f023 0338 	bic.w	r3, r3, #56	; 0x38
  value |= newValue;
 800a940:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a942:	f10d 0207 	add.w	r2, sp, #7
 800a946:	4628      	mov	r0, r5
 800a948:	2301      	movs	r3, #1
 800a94a:	2108      	movs	r1, #8
  value |= newValue;
 800a94c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a950:	f003 fd88 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a954:	fab0 f080 	clz	r0, r0
 800a958:	0940      	lsrs	r0, r0, #5
}
 800a95a:	b003      	add	sp, #12
 800a95c:	bd30      	pop	{r4, r5, pc}
 800a95e:	bf00      	nop

0800a960 <LSM6DSM_ACC_GYRO_W_STOP_ON_FTH>:
* Input          : LSM6DSM_ACC_GYRO_STOP_ON_FTH_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_STOP_ON_FTH(void *handle, LSM6DSM_ACC_GYRO_STOP_ON_FTH_t newValue)
{
 800a960:	b530      	push	{r4, r5, lr}
 800a962:	b083      	sub	sp, #12
 800a964:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a966:	f10d 0207 	add.w	r2, sp, #7
 800a96a:	2301      	movs	r3, #1
 800a96c:	2109      	movs	r1, #9
{
 800a96e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a970:	f003 fe66 	bl	800e640 <Sensor_IO_Read>
 800a974:	b110      	cbz	r0, 800a97c <LSM6DSM_ACC_GYRO_W_STOP_ON_FTH+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FIFO_CTRL4, &value, 1))
    return MEMS_ERROR;
 800a976:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_FIFO_CTRL4, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a978:	b003      	add	sp, #12
 800a97a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_STOP_ON_FTH_MASK;
 800a97c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a980:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  value |= newValue;
 800a984:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a986:	f10d 0207 	add.w	r2, sp, #7
 800a98a:	4628      	mov	r0, r5
 800a98c:	2301      	movs	r3, #1
 800a98e:	2109      	movs	r1, #9
  value |= newValue;
 800a990:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a994:	f003 fd66 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a998:	fab0 f080 	clz	r0, r0
 800a99c:	0940      	lsrs	r0, r0, #5
}
 800a99e:	b003      	add	sp, #12
 800a9a0:	bd30      	pop	{r4, r5, pc}
 800a9a2:	bf00      	nop

0800a9a4 <LSM6DSM_ACC_GYRO_W_FIFO_MODE>:
* Input          : LSM6DSM_ACC_GYRO_FIFO_MODE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_FIFO_MODE(void *handle, LSM6DSM_ACC_GYRO_FIFO_MODE_t newValue)
{
 800a9a4:	b530      	push	{r4, r5, lr}
 800a9a6:	b083      	sub	sp, #12
 800a9a8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a9aa:	f10d 0207 	add.w	r2, sp, #7
 800a9ae:	2301      	movs	r3, #1
 800a9b0:	210a      	movs	r1, #10
{
 800a9b2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a9b4:	f003 fe44 	bl	800e640 <Sensor_IO_Read>
 800a9b8:	b110      	cbz	r0, 800a9c0 <LSM6DSM_ACC_GYRO_W_FIFO_MODE+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FIFO_CTRL5, &value, 1))
    return MEMS_ERROR;
 800a9ba:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_FIFO_CTRL5, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800a9bc:	b003      	add	sp, #12
 800a9be:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_FIFO_MODE_MASK;
 800a9c0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a9c4:	f023 0307 	bic.w	r3, r3, #7
  value |= newValue;
 800a9c8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a9ca:	f10d 0207 	add.w	r2, sp, #7
 800a9ce:	4628      	mov	r0, r5
 800a9d0:	2301      	movs	r3, #1
 800a9d2:	210a      	movs	r1, #10
  value |= newValue;
 800a9d4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800a9d8:	f003 fd44 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800a9dc:	fab0 f080 	clz	r0, r0
 800a9e0:	0940      	lsrs	r0, r0, #5
}
 800a9e2:	b003      	add	sp, #12
 800a9e4:	bd30      	pop	{r4, r5, pc}
 800a9e6:	bf00      	nop

0800a9e8 <LSM6DSM_ACC_GYRO_W_ODR_FIFO>:
* Input          : LSM6DSM_ACC_GYRO_ODR_FIFO_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_ODR_FIFO(void *handle, LSM6DSM_ACC_GYRO_ODR_FIFO_t newValue)
{
 800a9e8:	b530      	push	{r4, r5, lr}
 800a9ea:	b083      	sub	sp, #12
 800a9ec:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a9ee:	f10d 0207 	add.w	r2, sp, #7
 800a9f2:	2301      	movs	r3, #1
 800a9f4:	210a      	movs	r1, #10
{
 800a9f6:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800a9f8:	f003 fe22 	bl	800e640 <Sensor_IO_Read>
 800a9fc:	b110      	cbz	r0, 800aa04 <LSM6DSM_ACC_GYRO_W_ODR_FIFO+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FIFO_CTRL5, &value, 1))
    return MEMS_ERROR;
 800a9fe:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_FIFO_CTRL5, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800aa00:	b003      	add	sp, #12
 800aa02:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_ODR_FIFO_MASK;
 800aa04:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800aa08:	f023 0378 	bic.w	r3, r3, #120	; 0x78
  value |= newValue;
 800aa0c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800aa0e:	f10d 0207 	add.w	r2, sp, #7
 800aa12:	4628      	mov	r0, r5
 800aa14:	2301      	movs	r3, #1
 800aa16:	210a      	movs	r1, #10
  value |= newValue;
 800aa18:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800aa1c:	f003 fd22 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800aa20:	fab0 f080 	clz	r0, r0
 800aa24:	0940      	lsrs	r0, r0, #5
}
 800aa26:	b003      	add	sp, #12
 800aa28:	bd30      	pop	{r4, r5, pc}
 800aa2a:	bf00      	nop

0800aa2c <LSM6DSM_ACC_GYRO_W_FULL_FLAG_on_INT1>:
* Input          : LSM6DSM_ACC_GYRO_INT1_FULL_FLAG_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_FULL_FLAG_on_INT1(void *handle, LSM6DSM_ACC_GYRO_INT1_FULL_FLAG_t newValue)
{
 800aa2c:	b530      	push	{r4, r5, lr}
 800aa2e:	b083      	sub	sp, #12
 800aa30:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800aa32:	f10d 0207 	add.w	r2, sp, #7
 800aa36:	2301      	movs	r3, #1
 800aa38:	210d      	movs	r1, #13
{
 800aa3a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800aa3c:	f003 fe00 	bl	800e640 <Sensor_IO_Read>
 800aa40:	b110      	cbz	r0, 800aa48 <LSM6DSM_ACC_GYRO_W_FULL_FLAG_on_INT1+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_INT1_CTRL, &value, 1))
    return MEMS_ERROR;
 800aa42:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_INT1_CTRL, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800aa44:	b003      	add	sp, #12
 800aa46:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT1_FULL_FLAG_MASK;
 800aa48:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800aa4c:	f023 0320 	bic.w	r3, r3, #32
  value |= newValue;
 800aa50:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800aa52:	f10d 0207 	add.w	r2, sp, #7
 800aa56:	4628      	mov	r0, r5
 800aa58:	2301      	movs	r3, #1
 800aa5a:	210d      	movs	r1, #13
  value |= newValue;
 800aa5c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800aa60:	f003 fd00 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800aa64:	fab0 f080 	clz	r0, r0
 800aa68:	0940      	lsrs	r0, r0, #5
}
 800aa6a:	b003      	add	sp, #12
 800aa6c:	bd30      	pop	{r4, r5, pc}
 800aa6e:	bf00      	nop

0800aa70 <LSM6DSM_ACC_GYRO_W_STEP_DET_on_INT1>:
* Input          : LSM6DSM_ACC_GYRO_INT1_PEDO_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_STEP_DET_on_INT1(void *handle, LSM6DSM_ACC_GYRO_INT1_PEDO_t newValue)
{
 800aa70:	b530      	push	{r4, r5, lr}
 800aa72:	b083      	sub	sp, #12
 800aa74:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800aa76:	f10d 0207 	add.w	r2, sp, #7
 800aa7a:	2301      	movs	r3, #1
 800aa7c:	210d      	movs	r1, #13
{
 800aa7e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800aa80:	f003 fdde 	bl	800e640 <Sensor_IO_Read>
 800aa84:	b110      	cbz	r0, 800aa8c <LSM6DSM_ACC_GYRO_W_STEP_DET_on_INT1+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_INT1_CTRL, &value, 1))
    return MEMS_ERROR;
 800aa86:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_INT1_CTRL, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800aa88:	b003      	add	sp, #12
 800aa8a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT1_PEDO_MASK;
 800aa8c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800aa90:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  value |= newValue;
 800aa94:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800aa96:	f10d 0207 	add.w	r2, sp, #7
 800aa9a:	4628      	mov	r0, r5
 800aa9c:	2301      	movs	r3, #1
 800aa9e:	210d      	movs	r1, #13
  value |= newValue;
 800aaa0:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800aaa4:	f003 fcde 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800aaa8:	fab0 f080 	clz	r0, r0
 800aaac:	0940      	lsrs	r0, r0, #5
}
 800aaae:	b003      	add	sp, #12
 800aab0:	bd30      	pop	{r4, r5, pc}
 800aab2:	bf00      	nop

0800aab4 <LSM6DSM_ACC_GYRO_W_STEP_DELTA_on_INT2>:
* Input          : LSM6DSM_ACC_GYRO_INT2_STEP_DELTA_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_STEP_DELTA_on_INT2(void *handle, LSM6DSM_ACC_GYRO_INT2_STEP_DELTA_t newValue)
{
 800aab4:	b530      	push	{r4, r5, lr}
 800aab6:	b083      	sub	sp, #12
 800aab8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800aaba:	f10d 0207 	add.w	r2, sp, #7
 800aabe:	2301      	movs	r3, #1
 800aac0:	210e      	movs	r1, #14
{
 800aac2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800aac4:	f003 fdbc 	bl	800e640 <Sensor_IO_Read>
 800aac8:	b110      	cbz	r0, 800aad0 <LSM6DSM_ACC_GYRO_W_STEP_DELTA_on_INT2+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_INT2_CTRL, &value, 1))
    return MEMS_ERROR;
 800aaca:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_INT2_CTRL, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800aacc:	b003      	add	sp, #12
 800aace:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT2_STEP_DELTA_MASK;
 800aad0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800aad4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  value |= newValue;
 800aad8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800aada:	f10d 0207 	add.w	r2, sp, #7
 800aade:	4628      	mov	r0, r5
 800aae0:	2301      	movs	r3, #1
 800aae2:	210e      	movs	r1, #14
  value |= newValue;
 800aae4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800aae8:	f003 fcbc 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800aaec:	fab0 f080 	clz	r0, r0
 800aaf0:	0940      	lsrs	r0, r0, #5
}
 800aaf2:	b003      	add	sp, #12
 800aaf4:	bd30      	pop	{r4, r5, pc}
 800aaf6:	bf00      	nop

0800aaf8 <LSM6DSM_ACC_GYRO_W_IF_Addr_Incr>:
* Input          : LSM6DSM_ACC_GYRO_IF_INC_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_IF_Addr_Incr(void *handle, LSM6DSM_ACC_GYRO_IF_INC_t newValue)
{
 800aaf8:	b530      	push	{r4, r5, lr}
 800aafa:	b083      	sub	sp, #12
 800aafc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800aafe:	f10d 0207 	add.w	r2, sp, #7
 800ab02:	2301      	movs	r3, #1
 800ab04:	2112      	movs	r1, #18
{
 800ab06:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ab08:	f003 fd9a 	bl	800e640 <Sensor_IO_Read>
 800ab0c:	b110      	cbz	r0, 800ab14 <LSM6DSM_ACC_GYRO_W_IF_Addr_Incr+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL3_C, &value, 1))
    return MEMS_ERROR;
 800ab0e:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CTRL3_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800ab10:	b003      	add	sp, #12
 800ab12:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_IF_INC_MASK;
 800ab14:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800ab18:	f023 0304 	bic.w	r3, r3, #4
  value |= newValue;
 800ab1c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800ab1e:	f10d 0207 	add.w	r2, sp, #7
 800ab22:	4628      	mov	r0, r5
 800ab24:	2301      	movs	r3, #1
 800ab26:	2112      	movs	r1, #18
  value |= newValue;
 800ab28:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800ab2c:	f003 fc9a 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800ab30:	fab0 f080 	clz	r0, r0
 800ab34:	0940      	lsrs	r0, r0, #5
}
 800ab36:	b003      	add	sp, #12
 800ab38:	bd30      	pop	{r4, r5, pc}
 800ab3a:	bf00      	nop

0800ab3c <LSM6DSM_ACC_GYRO_W_I2C_DISABLE>:
* Input          : LSM6DSM_ACC_GYRO_I2C_DISABLE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_I2C_DISABLE(void *handle, LSM6DSM_ACC_GYRO_I2C_DISABLE_t newValue)
{
 800ab3c:	b530      	push	{r4, r5, lr}
 800ab3e:	b083      	sub	sp, #12
 800ab40:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ab42:	f10d 0207 	add.w	r2, sp, #7
 800ab46:	2301      	movs	r3, #1
 800ab48:	2113      	movs	r1, #19
{
 800ab4a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ab4c:	f003 fd78 	bl	800e640 <Sensor_IO_Read>
 800ab50:	b110      	cbz	r0, 800ab58 <LSM6DSM_ACC_GYRO_W_I2C_DISABLE+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL4_C, &value, 1))
    return MEMS_ERROR;
 800ab52:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CTRL4_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800ab54:	b003      	add	sp, #12
 800ab56:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_I2C_DISABLE_MASK;
 800ab58:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800ab5c:	f023 0304 	bic.w	r3, r3, #4
  value |= newValue;
 800ab60:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800ab62:	f10d 0207 	add.w	r2, sp, #7
 800ab66:	4628      	mov	r0, r5
 800ab68:	2301      	movs	r3, #1
 800ab6a:	2113      	movs	r1, #19
  value |= newValue;
 800ab6c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800ab70:	f003 fc78 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800ab74:	fab0 f080 	clz	r0, r0
 800ab78:	0940      	lsrs	r0, r0, #5
}
 800ab7a:	b003      	add	sp, #12
 800ab7c:	bd30      	pop	{r4, r5, pc}
 800ab7e:	bf00      	nop

0800ab80 <LSM6DSM_ACC_GYRO_W_SelfTest_XL>:
* Input          : LSM6DSM_ACC_GYRO_ST_XL_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_SelfTest_XL(void *handle, LSM6DSM_ACC_GYRO_ST_XL_t newValue)
{
 800ab80:	b530      	push	{r4, r5, lr}
 800ab82:	b083      	sub	sp, #12
 800ab84:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ab86:	f10d 0207 	add.w	r2, sp, #7
 800ab8a:	2301      	movs	r3, #1
 800ab8c:	2114      	movs	r1, #20
{
 800ab8e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ab90:	f003 fd56 	bl	800e640 <Sensor_IO_Read>
 800ab94:	b110      	cbz	r0, 800ab9c <LSM6DSM_ACC_GYRO_W_SelfTest_XL+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL5_C, &value, 1))
    return MEMS_ERROR;
 800ab96:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CTRL5_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800ab98:	b003      	add	sp, #12
 800ab9a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_ST_XL_MASK;
 800ab9c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800aba0:	f023 0303 	bic.w	r3, r3, #3
  value |= newValue;
 800aba4:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800aba6:	f10d 0207 	add.w	r2, sp, #7
 800abaa:	4628      	mov	r0, r5
 800abac:	2301      	movs	r3, #1
 800abae:	2114      	movs	r1, #20
  value |= newValue;
 800abb0:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800abb4:	f003 fc56 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800abb8:	fab0 f080 	clz	r0, r0
 800abbc:	0940      	lsrs	r0, r0, #5
}
 800abbe:	b003      	add	sp, #12
 800abc0:	bd30      	pop	{r4, r5, pc}
 800abc2:	bf00      	nop

0800abc4 <LSM6DSM_ACC_GYRO_W_SelfTest_G>:
* Input          : LSM6DSM_ACC_GYRO_ST_G_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_SelfTest_G(void *handle, LSM6DSM_ACC_GYRO_ST_G_t newValue)
{
 800abc4:	b530      	push	{r4, r5, lr}
 800abc6:	b083      	sub	sp, #12
 800abc8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800abca:	f10d 0207 	add.w	r2, sp, #7
 800abce:	2301      	movs	r3, #1
 800abd0:	2114      	movs	r1, #20
{
 800abd2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800abd4:	f003 fd34 	bl	800e640 <Sensor_IO_Read>
 800abd8:	b110      	cbz	r0, 800abe0 <LSM6DSM_ACC_GYRO_W_SelfTest_G+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL5_C, &value, 1))
    return MEMS_ERROR;
 800abda:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CTRL5_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800abdc:	b003      	add	sp, #12
 800abde:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_ST_G_MASK;
 800abe0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800abe4:	f023 030c 	bic.w	r3, r3, #12
  value |= newValue;
 800abe8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800abea:	f10d 0207 	add.w	r2, sp, #7
 800abee:	4628      	mov	r0, r5
 800abf0:	2301      	movs	r3, #1
 800abf2:	2114      	movs	r1, #20
  value |= newValue;
 800abf4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800abf8:	f003 fc34 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800abfc:	fab0 f080 	clz	r0, r0
 800ac00:	0940      	lsrs	r0, r0, #5
}
 800ac02:	b003      	add	sp, #12
 800ac04:	bd30      	pop	{r4, r5, pc}
 800ac06:	bf00      	nop

0800ac08 <LSM6DSM_ACC_GYRO_W_PedoStepReset>:
* Input          : LSM6DSM_ACC_GYRO_PEDO_RST_STEP_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_PedoStepReset(void *handle, LSM6DSM_ACC_GYRO_PEDO_RST_STEP_t newValue)
{
 800ac08:	b530      	push	{r4, r5, lr}
 800ac0a:	b083      	sub	sp, #12
 800ac0c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ac0e:	f10d 0207 	add.w	r2, sp, #7
 800ac12:	2301      	movs	r3, #1
 800ac14:	2119      	movs	r1, #25
{
 800ac16:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ac18:	f003 fd12 	bl	800e640 <Sensor_IO_Read>
 800ac1c:	b110      	cbz	r0, 800ac24 <LSM6DSM_ACC_GYRO_W_PedoStepReset+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;
 800ac1e:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800ac20:	b003      	add	sp, #12
 800ac22:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_PEDO_RST_STEP_MASK;
 800ac24:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800ac28:	f023 0302 	bic.w	r3, r3, #2
  value |= newValue;
 800ac2c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800ac2e:	f10d 0207 	add.w	r2, sp, #7
 800ac32:	4628      	mov	r0, r5
 800ac34:	2301      	movs	r3, #1
 800ac36:	2119      	movs	r1, #25
  value |= newValue;
 800ac38:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800ac3c:	f003 fc12 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800ac40:	fab0 f080 	clz	r0, r0
 800ac44:	0940      	lsrs	r0, r0, #5
}
 800ac46:	b003      	add	sp, #12
 800ac48:	bd30      	pop	{r4, r5, pc}
 800ac4a:	bf00      	nop

0800ac4c <LSM6DSM_ACC_GYRO_W_TILT>:
* Input          : LSM6DSM_ACC_GYRO_TILT_G_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_TILT(void *handle, LSM6DSM_ACC_GYRO_TILT_G_t newValue)
{
 800ac4c:	b530      	push	{r4, r5, lr}
 800ac4e:	b083      	sub	sp, #12
 800ac50:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ac52:	f10d 0207 	add.w	r2, sp, #7
 800ac56:	2301      	movs	r3, #1
 800ac58:	2119      	movs	r1, #25
{
 800ac5a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ac5c:	f003 fcf0 	bl	800e640 <Sensor_IO_Read>
 800ac60:	b110      	cbz	r0, 800ac68 <LSM6DSM_ACC_GYRO_W_TILT+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;
 800ac62:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800ac64:	b003      	add	sp, #12
 800ac66:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_TILT_MASK;
 800ac68:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800ac6c:	f023 0308 	bic.w	r3, r3, #8
  value |= newValue;
 800ac70:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800ac72:	f10d 0207 	add.w	r2, sp, #7
 800ac76:	4628      	mov	r0, r5
 800ac78:	2301      	movs	r3, #1
 800ac7a:	2119      	movs	r1, #25
  value |= newValue;
 800ac7c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800ac80:	f003 fbf0 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800ac84:	fab0 f080 	clz	r0, r0
 800ac88:	0940      	lsrs	r0, r0, #5
}
 800ac8a:	b003      	add	sp, #12
 800ac8c:	bd30      	pop	{r4, r5, pc}
 800ac8e:	bf00      	nop

0800ac90 <LSM6DSM_ACC_GYRO_W_PEDO>:
* Input          : LSM6DSM_ACC_GYRO_PEDO_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_PEDO(void *handle, LSM6DSM_ACC_GYRO_PEDO_t newValue)
{
 800ac90:	b530      	push	{r4, r5, lr}
 800ac92:	b083      	sub	sp, #12
 800ac94:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ac96:	f10d 0207 	add.w	r2, sp, #7
 800ac9a:	2301      	movs	r3, #1
 800ac9c:	2119      	movs	r1, #25
{
 800ac9e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800aca0:	f003 fcce 	bl	800e640 <Sensor_IO_Read>
 800aca4:	b110      	cbz	r0, 800acac <LSM6DSM_ACC_GYRO_W_PEDO+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;
 800aca6:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800aca8:	b003      	add	sp, #12
 800acaa:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_PEDO_MASK;
 800acac:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800acb0:	f023 0310 	bic.w	r3, r3, #16
  value |= newValue;
 800acb4:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800acb6:	f10d 0207 	add.w	r2, sp, #7
 800acba:	4628      	mov	r0, r5
 800acbc:	2301      	movs	r3, #1
 800acbe:	2119      	movs	r1, #25
  value |= newValue;
 800acc0:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800acc4:	f003 fbce 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800acc8:	fab0 f080 	clz	r0, r0
 800accc:	0940      	lsrs	r0, r0, #5
}
 800acce:	b003      	add	sp, #12
 800acd0:	bd30      	pop	{r4, r5, pc}
 800acd2:	bf00      	nop

0800acd4 <LSM6DSM_ACC_GYRO_W_FUNC_EN>:
* Input          : LSM6DSM_ACC_GYRO_FUNC_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_FUNC_EN(void *handle, LSM6DSM_ACC_GYRO_FUNC_EN_t newValue)
{
 800acd4:	b530      	push	{r4, r5, lr}
 800acd6:	b083      	sub	sp, #12
 800acd8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800acda:	f10d 0207 	add.w	r2, sp, #7
 800acde:	2301      	movs	r3, #1
 800ace0:	2119      	movs	r1, #25
{
 800ace2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ace4:	f003 fcac 	bl	800e640 <Sensor_IO_Read>
 800ace8:	b110      	cbz	r0, 800acf0 <LSM6DSM_ACC_GYRO_W_FUNC_EN+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;
 800acea:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800acec:	b003      	add	sp, #12
 800acee:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_FUNC_EN_MASK;
 800acf0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800acf4:	f023 0304 	bic.w	r3, r3, #4
  value |= newValue;
 800acf8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800acfa:	f10d 0207 	add.w	r2, sp, #7
 800acfe:	4628      	mov	r0, r5
 800ad00:	2301      	movs	r3, #1
 800ad02:	2119      	movs	r1, #25
  value |= newValue;
 800ad04:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800ad08:	f003 fbac 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800ad0c:	fab0 f080 	clz	r0, r0
 800ad10:	0940      	lsrs	r0, r0, #5
}
 800ad12:	b003      	add	sp, #12
 800ad14:	bd30      	pop	{r4, r5, pc}
 800ad16:	bf00      	nop

0800ad18 <LSM6DSM_ACC_GYRO_R_WU_EV_STATUS>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_WU_EV_STATUS_t
* Output         : Status of WU_EV_STATUS see LSM6DSM_ACC_GYRO_WU_EV_STATUS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_WU_EV_STATUS(void *handle, LSM6DSM_ACC_GYRO_WU_EV_STATUS_t *value)
{
 800ad18:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ad1a:	460a      	mov	r2, r1
{
 800ad1c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ad1e:	2301      	movs	r3, #1
 800ad20:	211b      	movs	r1, #27
 800ad22:	f003 fc8d 	bl	800e640 <Sensor_IO_Read>
 800ad26:	b928      	cbnz	r0, 800ad34 <LSM6DSM_ACC_GYRO_R_WU_EV_STATUS+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_WAKE_UP_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_WU_EV_STATUS_MASK; //mask
 800ad28:	7823      	ldrb	r3, [r4, #0]
 800ad2a:	f003 0308 	and.w	r3, r3, #8
 800ad2e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800ad30:	2001      	movs	r0, #1
}
 800ad32:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800ad34:	2000      	movs	r0, #0
}
 800ad36:	bd10      	pop	{r4, pc}

0800ad38 <LSM6DSM_ACC_GYRO_R_FF_EV_STATUS>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_FF_EV_STATUS_t
* Output         : Status of FF_EV_STATUS see LSM6DSM_ACC_GYRO_FF_EV_STATUS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_FF_EV_STATUS(void *handle, LSM6DSM_ACC_GYRO_FF_EV_STATUS_t *value)
{
 800ad38:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ad3a:	460a      	mov	r2, r1
{
 800ad3c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ad3e:	2301      	movs	r3, #1
 800ad40:	211b      	movs	r1, #27
 800ad42:	f003 fc7d 	bl	800e640 <Sensor_IO_Read>
 800ad46:	b928      	cbnz	r0, 800ad54 <LSM6DSM_ACC_GYRO_R_FF_EV_STATUS+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_WAKE_UP_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_FF_EV_STATUS_MASK; //mask
 800ad48:	7823      	ldrb	r3, [r4, #0]
 800ad4a:	f003 0320 	and.w	r3, r3, #32
 800ad4e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800ad50:	2001      	movs	r0, #1
}
 800ad52:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800ad54:	2000      	movs	r0, #0
}
 800ad56:	bd10      	pop	{r4, pc}

0800ad58 <LSM6DSM_ACC_GYRO_R_DOUBLE_TAP_EV_STATUS>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_DOUBLE_TAP_EV_STATUS_t
* Output         : Status of DOUBLE_TAP_EV_STATUS see LSM6DSM_ACC_GYRO_DOUBLE_TAP_EV_STATUS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_DOUBLE_TAP_EV_STATUS(void *handle, LSM6DSM_ACC_GYRO_DOUBLE_TAP_EV_STATUS_t *value)
{
 800ad58:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ad5a:	460a      	mov	r2, r1
{
 800ad5c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ad5e:	2301      	movs	r3, #1
 800ad60:	211c      	movs	r1, #28
 800ad62:	f003 fc6d 	bl	800e640 <Sensor_IO_Read>
 800ad66:	b928      	cbnz	r0, 800ad74 <LSM6DSM_ACC_GYRO_R_DOUBLE_TAP_EV_STATUS+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_TAP_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_DOUBLE_TAP_EV_STATUS_MASK; //mask
 800ad68:	7823      	ldrb	r3, [r4, #0]
 800ad6a:	f003 0310 	and.w	r3, r3, #16
 800ad6e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800ad70:	2001      	movs	r0, #1
}
 800ad72:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800ad74:	2000      	movs	r0, #0
}
 800ad76:	bd10      	pop	{r4, pc}

0800ad78 <LSM6DSM_ACC_GYRO_R_SINGLE_TAP_EV_STATUS>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_SINGLE_TAP_EV_STATUS_t
* Output         : Status of SINGLE_TAP_EV_STATUS see LSM6DSM_ACC_GYRO_SINGLE_TAP_EV_STATUS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_SINGLE_TAP_EV_STATUS(void *handle, LSM6DSM_ACC_GYRO_SINGLE_TAP_EV_STATUS_t *value)
{
 800ad78:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ad7a:	460a      	mov	r2, r1
{
 800ad7c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ad7e:	2301      	movs	r3, #1
 800ad80:	211c      	movs	r1, #28
 800ad82:	f003 fc5d 	bl	800e640 <Sensor_IO_Read>
 800ad86:	b928      	cbnz	r0, 800ad94 <LSM6DSM_ACC_GYRO_R_SINGLE_TAP_EV_STATUS+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_TAP_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_SINGLE_TAP_EV_STATUS_MASK; //mask
 800ad88:	7823      	ldrb	r3, [r4, #0]
 800ad8a:	f003 0320 	and.w	r3, r3, #32
 800ad8e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800ad90:	2001      	movs	r0, #1
}
 800ad92:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800ad94:	2000      	movs	r0, #0
}
 800ad96:	bd10      	pop	{r4, pc}

0800ad98 <LSM6DSM_ACC_GYRO_R_DSD_XL>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_DSD_XL_t
* Output         : Status of DSD_XL see LSM6DSM_ACC_GYRO_DSD_XL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_DSD_XL(void *handle, LSM6DSM_ACC_GYRO_DSD_XL_t *value)
{
 800ad98:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ad9a:	460a      	mov	r2, r1
{
 800ad9c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ad9e:	2301      	movs	r3, #1
 800ada0:	211d      	movs	r1, #29
 800ada2:	f003 fc4d 	bl	800e640 <Sensor_IO_Read>
 800ada6:	b928      	cbnz	r0, 800adb4 <LSM6DSM_ACC_GYRO_R_DSD_XL+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_D6D_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_DSD_XL_MASK; //mask
 800ada8:	7823      	ldrb	r3, [r4, #0]
 800adaa:	f003 0301 	and.w	r3, r3, #1
 800adae:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800adb0:	2001      	movs	r0, #1
}
 800adb2:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800adb4:	2000      	movs	r0, #0
}
 800adb6:	bd10      	pop	{r4, pc}

0800adb8 <LSM6DSM_ACC_GYRO_R_DSD_XH>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_DSD_XH_t
* Output         : Status of DSD_XH see LSM6DSM_ACC_GYRO_DSD_XH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_DSD_XH(void *handle, LSM6DSM_ACC_GYRO_DSD_XH_t *value)
{
 800adb8:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800adba:	460a      	mov	r2, r1
{
 800adbc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800adbe:	2301      	movs	r3, #1
 800adc0:	211d      	movs	r1, #29
 800adc2:	f003 fc3d 	bl	800e640 <Sensor_IO_Read>
 800adc6:	b928      	cbnz	r0, 800add4 <LSM6DSM_ACC_GYRO_R_DSD_XH+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_D6D_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_DSD_XH_MASK; //mask
 800adc8:	7823      	ldrb	r3, [r4, #0]
 800adca:	f003 0302 	and.w	r3, r3, #2
 800adce:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800add0:	2001      	movs	r0, #1
}
 800add2:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800add4:	2000      	movs	r0, #0
}
 800add6:	bd10      	pop	{r4, pc}

0800add8 <LSM6DSM_ACC_GYRO_R_DSD_YL>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_DSD_YL_t
* Output         : Status of DSD_YL see LSM6DSM_ACC_GYRO_DSD_YL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_DSD_YL(void *handle, LSM6DSM_ACC_GYRO_DSD_YL_t *value)
{
 800add8:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800adda:	460a      	mov	r2, r1
{
 800addc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800adde:	2301      	movs	r3, #1
 800ade0:	211d      	movs	r1, #29
 800ade2:	f003 fc2d 	bl	800e640 <Sensor_IO_Read>
 800ade6:	b928      	cbnz	r0, 800adf4 <LSM6DSM_ACC_GYRO_R_DSD_YL+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_D6D_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_DSD_YL_MASK; //mask
 800ade8:	7823      	ldrb	r3, [r4, #0]
 800adea:	f003 0304 	and.w	r3, r3, #4
 800adee:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800adf0:	2001      	movs	r0, #1
}
 800adf2:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800adf4:	2000      	movs	r0, #0
}
 800adf6:	bd10      	pop	{r4, pc}

0800adf8 <LSM6DSM_ACC_GYRO_R_DSD_YH>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_DSD_YH_t
* Output         : Status of DSD_YH see LSM6DSM_ACC_GYRO_DSD_YH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_DSD_YH(void *handle, LSM6DSM_ACC_GYRO_DSD_YH_t *value)
{
 800adf8:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800adfa:	460a      	mov	r2, r1
{
 800adfc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800adfe:	2301      	movs	r3, #1
 800ae00:	211d      	movs	r1, #29
 800ae02:	f003 fc1d 	bl	800e640 <Sensor_IO_Read>
 800ae06:	b928      	cbnz	r0, 800ae14 <LSM6DSM_ACC_GYRO_R_DSD_YH+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_D6D_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_DSD_YH_MASK; //mask
 800ae08:	7823      	ldrb	r3, [r4, #0]
 800ae0a:	f003 0308 	and.w	r3, r3, #8
 800ae0e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800ae10:	2001      	movs	r0, #1
}
 800ae12:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800ae14:	2000      	movs	r0, #0
}
 800ae16:	bd10      	pop	{r4, pc}

0800ae18 <LSM6DSM_ACC_GYRO_R_DSD_ZL>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_DSD_ZL_t
* Output         : Status of DSD_ZL see LSM6DSM_ACC_GYRO_DSD_ZL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_DSD_ZL(void *handle, LSM6DSM_ACC_GYRO_DSD_ZL_t *value)
{
 800ae18:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ae1a:	460a      	mov	r2, r1
{
 800ae1c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ae1e:	2301      	movs	r3, #1
 800ae20:	211d      	movs	r1, #29
 800ae22:	f003 fc0d 	bl	800e640 <Sensor_IO_Read>
 800ae26:	b928      	cbnz	r0, 800ae34 <LSM6DSM_ACC_GYRO_R_DSD_ZL+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_D6D_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_DSD_ZL_MASK; //mask
 800ae28:	7823      	ldrb	r3, [r4, #0]
 800ae2a:	f003 0310 	and.w	r3, r3, #16
 800ae2e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800ae30:	2001      	movs	r0, #1
}
 800ae32:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800ae34:	2000      	movs	r0, #0
}
 800ae36:	bd10      	pop	{r4, pc}

0800ae38 <LSM6DSM_ACC_GYRO_R_DSD_ZH>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_DSD_ZH_t
* Output         : Status of DSD_ZH see LSM6DSM_ACC_GYRO_DSD_ZH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_DSD_ZH(void *handle, LSM6DSM_ACC_GYRO_DSD_ZH_t *value)
{
 800ae38:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ae3a:	460a      	mov	r2, r1
{
 800ae3c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ae3e:	2301      	movs	r3, #1
 800ae40:	211d      	movs	r1, #29
 800ae42:	f003 fbfd 	bl	800e640 <Sensor_IO_Read>
 800ae46:	b928      	cbnz	r0, 800ae54 <LSM6DSM_ACC_GYRO_R_DSD_ZH+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_D6D_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_DSD_ZH_MASK; //mask
 800ae48:	7823      	ldrb	r3, [r4, #0]
 800ae4a:	f003 0320 	and.w	r3, r3, #32
 800ae4e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800ae50:	2001      	movs	r0, #1
}
 800ae52:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800ae54:	2000      	movs	r0, #0
}
 800ae56:	bd10      	pop	{r4, pc}

0800ae58 <LSM6DSM_ACC_GYRO_R_D6D_EV_STATUS>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_D6D_EV_STATUS_t
* Output         : Status of D6D_EV_STATUS see LSM6DSM_ACC_GYRO_D6D_EV_STATUS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_D6D_EV_STATUS(void *handle, LSM6DSM_ACC_GYRO_D6D_EV_STATUS_t *value)
{
 800ae58:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ae5a:	460a      	mov	r2, r1
{
 800ae5c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ae5e:	2301      	movs	r3, #1
 800ae60:	211d      	movs	r1, #29
 800ae62:	f003 fbed 	bl	800e640 <Sensor_IO_Read>
 800ae66:	b928      	cbnz	r0, 800ae74 <LSM6DSM_ACC_GYRO_R_D6D_EV_STATUS+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_D6D_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_D6D_EV_STATUS_MASK; //mask
 800ae68:	7823      	ldrb	r3, [r4, #0]
 800ae6a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ae6e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800ae70:	2001      	movs	r0, #1
}
 800ae72:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800ae74:	2000      	movs	r0, #0
}
 800ae76:	bd10      	pop	{r4, pc}

0800ae78 <LSM6DSM_ACC_GYRO_R_XLDA>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_XLDA_t
* Output         : Status of XLDA see LSM6DSM_ACC_GYRO_XLDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_XLDA(void *handle, LSM6DSM_ACC_GYRO_XLDA_t *value)
{
 800ae78:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ae7a:	460a      	mov	r2, r1
{
 800ae7c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ae7e:	2301      	movs	r3, #1
 800ae80:	211e      	movs	r1, #30
 800ae82:	f003 fbdd 	bl	800e640 <Sensor_IO_Read>
 800ae86:	b928      	cbnz	r0, 800ae94 <LSM6DSM_ACC_GYRO_R_XLDA+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_STATUS_REG, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_XLDA_MASK; //mask
 800ae88:	7823      	ldrb	r3, [r4, #0]
 800ae8a:	f003 0301 	and.w	r3, r3, #1
 800ae8e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800ae90:	2001      	movs	r0, #1
}
 800ae92:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800ae94:	2000      	movs	r0, #0
}
 800ae96:	bd10      	pop	{r4, pc}

0800ae98 <LSM6DSM_ACC_GYRO_R_GDA>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_GDA_t
* Output         : Status of GDA see LSM6DSM_ACC_GYRO_GDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_GDA(void *handle, LSM6DSM_ACC_GYRO_GDA_t *value)
{
 800ae98:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ae9a:	460a      	mov	r2, r1
{
 800ae9c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800ae9e:	2301      	movs	r3, #1
 800aea0:	211e      	movs	r1, #30
 800aea2:	f003 fbcd 	bl	800e640 <Sensor_IO_Read>
 800aea6:	b928      	cbnz	r0, 800aeb4 <LSM6DSM_ACC_GYRO_R_GDA+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_STATUS_REG, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_GDA_MASK; //mask
 800aea8:	7823      	ldrb	r3, [r4, #0]
 800aeaa:	f003 0302 	and.w	r3, r3, #2
 800aeae:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800aeb0:	2001      	movs	r0, #1
}
 800aeb2:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800aeb4:	2000      	movs	r0, #0
}
 800aeb6:	bd10      	pop	{r4, pc}

0800aeb8 <LSM6DSM_ACC_GYRO_R_FIFONumOfEntries>:
* Input          : Pointer to u16_t
* Output         : Status of DIFF_FIFO
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_FIFONumOfEntries(void *handle, u16_t *value)
{
 800aeb8:	b530      	push	{r4, r5, lr}
 800aeba:	b083      	sub	sp, #12
 800aebc:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800aebe:	2301      	movs	r3, #1
 800aec0:	f10d 0207 	add.w	r2, sp, #7
 800aec4:	213a      	movs	r1, #58	; 0x3a
{
 800aec6:	4604      	mov	r4, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800aec8:	f003 fbba 	bl	800e640 <Sensor_IO_Read>
 800aecc:	b110      	cbz	r0, 800aed4 <LSM6DSM_ACC_GYRO_R_FIFONumOfEntries+0x1c>
  u8_t valueH, valueL;

  /* Low part from FIFO_STATUS1 */
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FIFO_STATUS1, (u8_t *)&valueL, 1) )
    return MEMS_ERROR;
 800aece:	2000      	movs	r0, #0
  valueH = valueH >> LSM6DSM_ACC_GYRO_DIFF_FIFO_STATUS2_POSITION; //mask

  *value = ((valueH << 8) & 0xFF00) | valueL;

  return MEMS_SUCCESS;
}
 800aed0:	b003      	add	sp, #12
 800aed2:	bd30      	pop	{r4, r5, pc}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800aed4:	4620      	mov	r0, r4
 800aed6:	2301      	movs	r3, #1
 800aed8:	f10d 0206 	add.w	r2, sp, #6
 800aedc:	213b      	movs	r1, #59	; 0x3b
 800aede:	f003 fbaf 	bl	800e640 <Sensor_IO_Read>
 800aee2:	2800      	cmp	r0, #0
 800aee4:	d1f3      	bne.n	800aece <LSM6DSM_ACC_GYRO_R_FIFONumOfEntries+0x16>
  valueH &= LSM6DSM_ACC_GYRO_DIFF_FIFO_STATUS2_MASK; //coerce
 800aee6:	f89d 2006 	ldrb.w	r2, [sp, #6]
  *value = ((valueH << 8) & 0xFF00) | valueL;
 800aeea:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800aeee:	f002 020f 	and.w	r2, r2, #15
 800aef2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  return MEMS_SUCCESS;
 800aef6:	2001      	movs	r0, #1
  *value = ((valueH << 8) & 0xFF00) | valueL;
 800aef8:	802b      	strh	r3, [r5, #0]
}
 800aefa:	b003      	add	sp, #12
 800aefc:	bd30      	pop	{r4, r5, pc}
 800aefe:	bf00      	nop

0800af00 <LSM6DSM_ACC_GYRO_R_FIFOEmpty>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_FIFO_EMPTY_t
* Output         : Status of FIFO_EMPTY see LSM6DSM_ACC_GYRO_FIFO_EMPTY_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_FIFOEmpty(void *handle, LSM6DSM_ACC_GYRO_FIFO_EMPTY_t *value)
{
 800af00:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800af02:	460a      	mov	r2, r1
{
 800af04:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800af06:	2301      	movs	r3, #1
 800af08:	213b      	movs	r1, #59	; 0x3b
 800af0a:	f003 fb99 	bl	800e640 <Sensor_IO_Read>
 800af0e:	b928      	cbnz	r0, 800af1c <LSM6DSM_ACC_GYRO_R_FIFOEmpty+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FIFO_STATUS2, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_FIFO_EMPTY_MASK; //mask
 800af10:	7823      	ldrb	r3, [r4, #0]
 800af12:	f003 0310 	and.w	r3, r3, #16
 800af16:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800af18:	2001      	movs	r0, #1
}
 800af1a:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800af1c:	2000      	movs	r0, #0
}
 800af1e:	bd10      	pop	{r4, pc}

0800af20 <LSM6DSM_ACC_GYRO_R_FIFOFull>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_FIFO_FULL_t
* Output         : Status of FIFO_FULL see LSM6DSM_ACC_GYRO_FIFO_FULL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_FIFOFull(void *handle, LSM6DSM_ACC_GYRO_FIFO_FULL_t *value)
{
 800af20:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800af22:	460a      	mov	r2, r1
{
 800af24:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800af26:	2301      	movs	r3, #1
 800af28:	213b      	movs	r1, #59	; 0x3b
 800af2a:	f003 fb89 	bl	800e640 <Sensor_IO_Read>
 800af2e:	b928      	cbnz	r0, 800af3c <LSM6DSM_ACC_GYRO_R_FIFOFull+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FIFO_STATUS2, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_FIFO_FULL_MASK; //mask
 800af30:	7823      	ldrb	r3, [r4, #0]
 800af32:	f003 0320 	and.w	r3, r3, #32
 800af36:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800af38:	2001      	movs	r0, #1
}
 800af3a:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800af3c:	2000      	movs	r0, #0
}
 800af3e:	bd10      	pop	{r4, pc}

0800af40 <LSM6DSM_ACC_GYRO_R_OVERRUN>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_OVERRUN_t
* Output         : Status of OVERRUN see LSM6DSM_ACC_GYRO_OVERRUN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_OVERRUN(void *handle, LSM6DSM_ACC_GYRO_OVERRUN_t *value)
{
 800af40:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800af42:	460a      	mov	r2, r1
{
 800af44:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800af46:	2301      	movs	r3, #1
 800af48:	213b      	movs	r1, #59	; 0x3b
 800af4a:	f003 fb79 	bl	800e640 <Sensor_IO_Read>
 800af4e:	b928      	cbnz	r0, 800af5c <LSM6DSM_ACC_GYRO_R_OVERRUN+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FIFO_STATUS2, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_OVERRUN_MASK; //mask
 800af50:	7823      	ldrb	r3, [r4, #0]
 800af52:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800af56:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800af58:	2001      	movs	r0, #1
}
 800af5a:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800af5c:	2000      	movs	r0, #0
}
 800af5e:	bd10      	pop	{r4, pc}

0800af60 <LSM6DSM_ACC_GYRO_R_FIFOPattern>:
* Input          : Pointer to u16_t
* Output         : Status of FIFO_PATTERN
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_FIFOPattern(void *handle, u16_t *value)
{
 800af60:	b530      	push	{r4, r5, lr}
 800af62:	b083      	sub	sp, #12
 800af64:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800af66:	2301      	movs	r3, #1
 800af68:	f10d 0207 	add.w	r2, sp, #7
 800af6c:	213c      	movs	r1, #60	; 0x3c
{
 800af6e:	4604      	mov	r4, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800af70:	f003 fb66 	bl	800e640 <Sensor_IO_Read>
 800af74:	b110      	cbz	r0, 800af7c <LSM6DSM_ACC_GYRO_R_FIFOPattern+0x1c>
  u8_t valueH, valueL;

  /* Low part from FIFO_STATUS3 */
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FIFO_STATUS3, (u8_t *)&valueL, 1) )
    return MEMS_ERROR;
 800af76:	2000      	movs	r0, #0
  valueH = valueH >> LSM6DSM_ACC_GYRO_FIFO_STATUS4_PATTERN_POSITION; //mask

  *value = ((valueH << 8) & 0xFF00) | valueL;

  return MEMS_SUCCESS;
}
 800af78:	b003      	add	sp, #12
 800af7a:	bd30      	pop	{r4, r5, pc}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800af7c:	4620      	mov	r0, r4
 800af7e:	2301      	movs	r3, #1
 800af80:	f10d 0206 	add.w	r2, sp, #6
 800af84:	213d      	movs	r1, #61	; 0x3d
 800af86:	f003 fb5b 	bl	800e640 <Sensor_IO_Read>
 800af8a:	2800      	cmp	r0, #0
 800af8c:	d1f3      	bne.n	800af76 <LSM6DSM_ACC_GYRO_R_FIFOPattern+0x16>
  valueH &= LSM6DSM_ACC_GYRO_FIFO_STATUS4_PATTERN_MASK; //coerce
 800af8e:	f89d 2006 	ldrb.w	r2, [sp, #6]
  *value = ((valueH << 8) & 0xFF00) | valueL;
 800af92:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800af96:	f002 0203 	and.w	r2, r2, #3
 800af9a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  return MEMS_SUCCESS;
 800af9e:	2001      	movs	r0, #1
  *value = ((valueH << 8) & 0xFF00) | valueL;
 800afa0:	802b      	strh	r3, [r5, #0]
}
 800afa2:	b003      	add	sp, #12
 800afa4:	bd30      	pop	{r4, r5, pc}
 800afa6:	bf00      	nop

0800afa8 <LSM6DSM_ACC_GYRO_R_PEDO_EV_STATUS>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_PEDO_EV_STATUS_t
* Output         : Status of PEDO_EV_STATUS see LSM6DSM_ACC_GYRO_PEDO_EV_STATUS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_PEDO_EV_STATUS(void *handle, LSM6DSM_ACC_GYRO_PEDO_EV_STATUS_t *value)
{
 800afa8:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800afaa:	460a      	mov	r2, r1
{
 800afac:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800afae:	2301      	movs	r3, #1
 800afb0:	2153      	movs	r1, #83	; 0x53
 800afb2:	f003 fb45 	bl	800e640 <Sensor_IO_Read>
 800afb6:	b928      	cbnz	r0, 800afc4 <LSM6DSM_ACC_GYRO_R_PEDO_EV_STATUS+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FUNC_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_PEDO_EV_STATUS_MASK; //mask
 800afb8:	7823      	ldrb	r3, [r4, #0]
 800afba:	f003 0310 	and.w	r3, r3, #16
 800afbe:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800afc0:	2001      	movs	r0, #1
}
 800afc2:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800afc4:	2000      	movs	r0, #0
}
 800afc6:	bd10      	pop	{r4, pc}

0800afc8 <LSM6DSM_ACC_GYRO_R_TILT_EV_STATUS>:
* Input          : Pointer to LSM6DSM_ACC_GYRO_TILT_EV_STATUS_t
* Output         : Status of TILT_EV_STATUS see LSM6DSM_ACC_GYRO_TILT_EV_STATUS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_R_TILT_EV_STATUS(void *handle, LSM6DSM_ACC_GYRO_TILT_EV_STATUS_t *value)
{
 800afc8:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800afca:	460a      	mov	r2, r1
{
 800afcc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800afce:	2301      	movs	r3, #1
 800afd0:	2153      	movs	r1, #83	; 0x53
 800afd2:	f003 fb35 	bl	800e640 <Sensor_IO_Read>
 800afd6:	b928      	cbnz	r0, 800afe4 <LSM6DSM_ACC_GYRO_R_TILT_EV_STATUS+0x1c>
  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FUNC_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM6DSM_ACC_GYRO_TILT_EV_STATUS_MASK; //mask
 800afd8:	7823      	ldrb	r3, [r4, #0]
 800afda:	f003 0320 	and.w	r3, r3, #32
 800afde:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800afe0:	2001      	movs	r0, #1
}
 800afe2:	bd10      	pop	{r4, pc}
    return MEMS_ERROR;
 800afe4:	2000      	movs	r0, #0
}
 800afe6:	bd10      	pop	{r4, pc}

0800afe8 <LSM6DSM_ACC_GYRO_W_LIR>:
* Input          : LSM6DSM_ACC_GYRO_LIR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_LIR(void *handle, LSM6DSM_ACC_GYRO_LIR_t newValue)
{
 800afe8:	b530      	push	{r4, r5, lr}
 800afea:	b083      	sub	sp, #12
 800afec:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800afee:	f10d 0207 	add.w	r2, sp, #7
 800aff2:	2301      	movs	r3, #1
 800aff4:	2158      	movs	r1, #88	; 0x58
{
 800aff6:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800aff8:	f003 fb22 	bl	800e640 <Sensor_IO_Read>
 800affc:	b110      	cbz	r0, 800b004 <LSM6DSM_ACC_GYRO_W_LIR+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;
 800affe:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b000:	b003      	add	sp, #12
 800b002:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_LIR_MASK;
 800b004:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b008:	f023 0301 	bic.w	r3, r3, #1
  value |= newValue;
 800b00c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b00e:	f10d 0207 	add.w	r2, sp, #7
 800b012:	4628      	mov	r0, r5
 800b014:	2301      	movs	r3, #1
 800b016:	2158      	movs	r1, #88	; 0x58
  value |= newValue;
 800b018:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b01c:	f003 fa22 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b020:	fab0 f080 	clz	r0, r0
 800b024:	0940      	lsrs	r0, r0, #5
}
 800b026:	b003      	add	sp, #12
 800b028:	bd30      	pop	{r4, r5, pc}
 800b02a:	bf00      	nop

0800b02c <LSM6DSM_ACC_GYRO_W_TAP_Z_EN>:
* Input          : LSM6DSM_ACC_GYRO_TAP_Z_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_TAP_Z_EN(void *handle, LSM6DSM_ACC_GYRO_TAP_Z_EN_t newValue)
{
 800b02c:	b530      	push	{r4, r5, lr}
 800b02e:	b083      	sub	sp, #12
 800b030:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b032:	f10d 0207 	add.w	r2, sp, #7
 800b036:	2301      	movs	r3, #1
 800b038:	2158      	movs	r1, #88	; 0x58
{
 800b03a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b03c:	f003 fb00 	bl	800e640 <Sensor_IO_Read>
 800b040:	b110      	cbz	r0, 800b048 <LSM6DSM_ACC_GYRO_W_TAP_Z_EN+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;
 800b042:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b044:	b003      	add	sp, #12
 800b046:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_TAP_Z_EN_MASK;
 800b048:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b04c:	f023 0302 	bic.w	r3, r3, #2
  value |= newValue;
 800b050:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b052:	f10d 0207 	add.w	r2, sp, #7
 800b056:	4628      	mov	r0, r5
 800b058:	2301      	movs	r3, #1
 800b05a:	2158      	movs	r1, #88	; 0x58
  value |= newValue;
 800b05c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b060:	f003 fa00 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b064:	fab0 f080 	clz	r0, r0
 800b068:	0940      	lsrs	r0, r0, #5
}
 800b06a:	b003      	add	sp, #12
 800b06c:	bd30      	pop	{r4, r5, pc}
 800b06e:	bf00      	nop

0800b070 <LSM6DSM_ACC_GYRO_W_TAP_Y_EN>:
* Input          : LSM6DSM_ACC_GYRO_TAP_Y_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_TAP_Y_EN(void *handle, LSM6DSM_ACC_GYRO_TAP_Y_EN_t newValue)
{
 800b070:	b530      	push	{r4, r5, lr}
 800b072:	b083      	sub	sp, #12
 800b074:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b076:	f10d 0207 	add.w	r2, sp, #7
 800b07a:	2301      	movs	r3, #1
 800b07c:	2158      	movs	r1, #88	; 0x58
{
 800b07e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b080:	f003 fade 	bl	800e640 <Sensor_IO_Read>
 800b084:	b110      	cbz	r0, 800b08c <LSM6DSM_ACC_GYRO_W_TAP_Y_EN+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;
 800b086:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b088:	b003      	add	sp, #12
 800b08a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_TAP_Y_EN_MASK;
 800b08c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b090:	f023 0304 	bic.w	r3, r3, #4
  value |= newValue;
 800b094:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b096:	f10d 0207 	add.w	r2, sp, #7
 800b09a:	4628      	mov	r0, r5
 800b09c:	2301      	movs	r3, #1
 800b09e:	2158      	movs	r1, #88	; 0x58
  value |= newValue;
 800b0a0:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b0a4:	f003 f9de 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b0a8:	fab0 f080 	clz	r0, r0
 800b0ac:	0940      	lsrs	r0, r0, #5
}
 800b0ae:	b003      	add	sp, #12
 800b0b0:	bd30      	pop	{r4, r5, pc}
 800b0b2:	bf00      	nop

0800b0b4 <LSM6DSM_ACC_GYRO_W_TAP_X_EN>:
* Input          : LSM6DSM_ACC_GYRO_TAP_X_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_TAP_X_EN(void *handle, LSM6DSM_ACC_GYRO_TAP_X_EN_t newValue)
{
 800b0b4:	b530      	push	{r4, r5, lr}
 800b0b6:	b083      	sub	sp, #12
 800b0b8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b0ba:	f10d 0207 	add.w	r2, sp, #7
 800b0be:	2301      	movs	r3, #1
 800b0c0:	2158      	movs	r1, #88	; 0x58
{
 800b0c2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b0c4:	f003 fabc 	bl	800e640 <Sensor_IO_Read>
 800b0c8:	b110      	cbz	r0, 800b0d0 <LSM6DSM_ACC_GYRO_W_TAP_X_EN+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;
 800b0ca:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b0cc:	b003      	add	sp, #12
 800b0ce:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_TAP_X_EN_MASK;
 800b0d0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b0d4:	f023 0308 	bic.w	r3, r3, #8
  value |= newValue;
 800b0d8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b0da:	f10d 0207 	add.w	r2, sp, #7
 800b0de:	4628      	mov	r0, r5
 800b0e0:	2301      	movs	r3, #1
 800b0e2:	2158      	movs	r1, #88	; 0x58
  value |= newValue;
 800b0e4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b0e8:	f003 f9bc 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b0ec:	fab0 f080 	clz	r0, r0
 800b0f0:	0940      	lsrs	r0, r0, #5
}
 800b0f2:	b003      	add	sp, #12
 800b0f4:	bd30      	pop	{r4, r5, pc}
 800b0f6:	bf00      	nop

0800b0f8 <LSM6DSM_ACC_GYRO_W_BASIC_INT>:
* Input          : LSM6DSM_ACC_GYRO_INT_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_BASIC_INT(void *handle, LSM6DSM_ACC_GYRO_INT_EN_t newValue)
{
 800b0f8:	b530      	push	{r4, r5, lr}
 800b0fa:	b083      	sub	sp, #12
 800b0fc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b0fe:	f10d 0207 	add.w	r2, sp, #7
 800b102:	2301      	movs	r3, #1
 800b104:	2158      	movs	r1, #88	; 0x58
{
 800b106:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b108:	f003 fa9a 	bl	800e640 <Sensor_IO_Read>
 800b10c:	b110      	cbz	r0, 800b114 <LSM6DSM_ACC_GYRO_W_BASIC_INT+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;
 800b10e:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b110:	b003      	add	sp, #12
 800b112:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT_EN_MASK;
 800b114:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b118:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  value |= newValue;
 800b11c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b11e:	f10d 0207 	add.w	r2, sp, #7
 800b122:	4628      	mov	r0, r5
 800b124:	2301      	movs	r3, #1
 800b126:	2158      	movs	r1, #88	; 0x58
  value |= newValue;
 800b128:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b12c:	f003 f99a 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b130:	fab0 f080 	clz	r0, r0
 800b134:	0940      	lsrs	r0, r0, #5
}
 800b136:	b003      	add	sp, #12
 800b138:	bd30      	pop	{r4, r5, pc}
 800b13a:	bf00      	nop

0800b13c <LSM6DSM_ACC_GYRO_W_TAP_THS>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_TAP_THS(void *handle, u8_t newValue)
{
 800b13c:	b570      	push	{r4, r5, r6, lr}
 800b13e:	b082      	sub	sp, #8
 800b140:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b142:	f10d 0207 	add.w	r2, sp, #7
 800b146:	2301      	movs	r3, #1
 800b148:	2159      	movs	r1, #89	; 0x59
{
 800b14a:	4606      	mov	r6, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b14c:	f003 fa78 	bl	800e640 <Sensor_IO_Read>
 800b150:	b110      	cbz	r0, 800b158 <LSM6DSM_ACC_GYRO_W_TAP_THS+0x1c>

  newValue = newValue << LSM6DSM_ACC_GYRO_TAP_THS_POSITION; //mask
  newValue &= LSM6DSM_ACC_GYRO_TAP_THS_MASK; //coerce

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_TAP_THS_6D, &value, 1) )
    return MEMS_ERROR;
 800b152:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_TAP_THS_6D, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b154:	b002      	add	sp, #8
 800b156:	bd70      	pop	{r4, r5, r6, pc}
  value &= ~LSM6DSM_ACC_GYRO_TAP_THS_MASK;
 800b158:	f89d 4007 	ldrb.w	r4, [sp, #7]
  newValue &= LSM6DSM_ACC_GYRO_TAP_THS_MASK; //coerce
 800b15c:	f005 051f 	and.w	r5, r5, #31
  value &= ~LSM6DSM_ACC_GYRO_TAP_THS_MASK;
 800b160:	f024 041f 	bic.w	r4, r4, #31
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b164:	f10d 0207 	add.w	r2, sp, #7
 800b168:	4630      	mov	r0, r6
  value |= newValue;
 800b16a:	432c      	orrs	r4, r5
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b16c:	2301      	movs	r3, #1
 800b16e:	2159      	movs	r1, #89	; 0x59
  value |= newValue;
 800b170:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b174:	f003 f976 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b178:	fab0 f080 	clz	r0, r0
 800b17c:	0940      	lsrs	r0, r0, #5
}
 800b17e:	b002      	add	sp, #8
 800b180:	bd70      	pop	{r4, r5, r6, pc}
 800b182:	bf00      	nop

0800b184 <LSM6DSM_ACC_GYRO_W_SIXD_THS>:
* Input          : LSM6DSM_ACC_GYRO_SIXD_THS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_SIXD_THS(void *handle, LSM6DSM_ACC_GYRO_SIXD_THS_t newValue)
{
 800b184:	b530      	push	{r4, r5, lr}
 800b186:	b083      	sub	sp, #12
 800b188:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b18a:	f10d 0207 	add.w	r2, sp, #7
 800b18e:	2301      	movs	r3, #1
 800b190:	2159      	movs	r1, #89	; 0x59
{
 800b192:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b194:	f003 fa54 	bl	800e640 <Sensor_IO_Read>
 800b198:	b110      	cbz	r0, 800b1a0 <LSM6DSM_ACC_GYRO_W_SIXD_THS+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_TAP_THS_6D, &value, 1) )
    return MEMS_ERROR;
 800b19a:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_TAP_THS_6D, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b19c:	b003      	add	sp, #12
 800b19e:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_SIXD_THS_MASK;
 800b1a0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b1a4:	f023 0360 	bic.w	r3, r3, #96	; 0x60
  value |= newValue;
 800b1a8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b1aa:	f10d 0207 	add.w	r2, sp, #7
 800b1ae:	4628      	mov	r0, r5
 800b1b0:	2301      	movs	r3, #1
 800b1b2:	2159      	movs	r1, #89	; 0x59
  value |= newValue;
 800b1b4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b1b8:	f003 f954 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b1bc:	fab0 f080 	clz	r0, r0
 800b1c0:	0940      	lsrs	r0, r0, #5
}
 800b1c2:	b003      	add	sp, #12
 800b1c4:	bd30      	pop	{r4, r5, pc}
 800b1c6:	bf00      	nop

0800b1c8 <LSM6DSM_ACC_GYRO_W_SHOCK_Duration>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_SHOCK_Duration(void *handle, u8_t newValue)
{
 800b1c8:	b570      	push	{r4, r5, r6, lr}
 800b1ca:	b082      	sub	sp, #8
 800b1cc:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b1ce:	f10d 0207 	add.w	r2, sp, #7
 800b1d2:	2301      	movs	r3, #1
 800b1d4:	215a      	movs	r1, #90	; 0x5a
{
 800b1d6:	4606      	mov	r6, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b1d8:	f003 fa32 	bl	800e640 <Sensor_IO_Read>
 800b1dc:	b110      	cbz	r0, 800b1e4 <LSM6DSM_ACC_GYRO_W_SHOCK_Duration+0x1c>

  newValue = newValue << LSM6DSM_ACC_GYRO_SHOCK_POSITION; //mask
  newValue &= LSM6DSM_ACC_GYRO_SHOCK_MASK; //coerce

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_INT_DUR2, &value, 1) )
    return MEMS_ERROR;
 800b1de:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_INT_DUR2, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b1e0:	b002      	add	sp, #8
 800b1e2:	bd70      	pop	{r4, r5, r6, pc}
  value &= ~LSM6DSM_ACC_GYRO_SHOCK_MASK;
 800b1e4:	f89d 4007 	ldrb.w	r4, [sp, #7]
  newValue &= LSM6DSM_ACC_GYRO_SHOCK_MASK; //coerce
 800b1e8:	f005 0503 	and.w	r5, r5, #3
  value &= ~LSM6DSM_ACC_GYRO_SHOCK_MASK;
 800b1ec:	f024 0403 	bic.w	r4, r4, #3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b1f0:	f10d 0207 	add.w	r2, sp, #7
 800b1f4:	4630      	mov	r0, r6
  value |= newValue;
 800b1f6:	432c      	orrs	r4, r5
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b1f8:	2301      	movs	r3, #1
 800b1fa:	215a      	movs	r1, #90	; 0x5a
  value |= newValue;
 800b1fc:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b200:	f003 f930 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b204:	fab0 f080 	clz	r0, r0
 800b208:	0940      	lsrs	r0, r0, #5
}
 800b20a:	b002      	add	sp, #8
 800b20c:	bd70      	pop	{r4, r5, r6, pc}
 800b20e:	bf00      	nop

0800b210 <LSM6DSM_ACC_GYRO_W_QUIET_Duration>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_QUIET_Duration(void *handle, u8_t newValue)
{
 800b210:	b530      	push	{r4, r5, lr}
 800b212:	b083      	sub	sp, #12
 800b214:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b216:	f10d 0207 	add.w	r2, sp, #7
 800b21a:	2301      	movs	r3, #1
 800b21c:	215a      	movs	r1, #90	; 0x5a
{
 800b21e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b220:	f003 fa0e 	bl	800e640 <Sensor_IO_Read>
 800b224:	b110      	cbz	r0, 800b22c <LSM6DSM_ACC_GYRO_W_QUIET_Duration+0x1c>

  newValue = newValue << LSM6DSM_ACC_GYRO_QUIET_POSITION; //mask
  newValue &= LSM6DSM_ACC_GYRO_QUIET_MASK; //coerce

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_INT_DUR2, &value, 1) )
    return MEMS_ERROR;
 800b226:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_INT_DUR2, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b228:	b003      	add	sp, #12
 800b22a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_QUIET_MASK;
 800b22c:	f89d 3007 	ldrb.w	r3, [sp, #7]
  newValue = newValue << LSM6DSM_ACC_GYRO_QUIET_POSITION; //mask
 800b230:	00a4      	lsls	r4, r4, #2
  value &= ~LSM6DSM_ACC_GYRO_QUIET_MASK;
 800b232:	f023 030c 	bic.w	r3, r3, #12
  newValue &= LSM6DSM_ACC_GYRO_QUIET_MASK; //coerce
 800b236:	f004 040c 	and.w	r4, r4, #12
  value |= newValue;
 800b23a:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b23c:	f10d 0207 	add.w	r2, sp, #7
 800b240:	4628      	mov	r0, r5
 800b242:	2301      	movs	r3, #1
 800b244:	215a      	movs	r1, #90	; 0x5a
  value |= newValue;
 800b246:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b24a:	f003 f90b 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b24e:	fab0 f080 	clz	r0, r0
 800b252:	0940      	lsrs	r0, r0, #5
}
 800b254:	b003      	add	sp, #12
 800b256:	bd30      	pop	{r4, r5, pc}

0800b258 <LSM6DSM_ACC_GYRO_W_DUR>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_DUR(void *handle, u8_t newValue)
{
 800b258:	b570      	push	{r4, r5, r6, lr}
 800b25a:	b082      	sub	sp, #8
 800b25c:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b25e:	f10d 0207 	add.w	r2, sp, #7
 800b262:	2301      	movs	r3, #1
 800b264:	215a      	movs	r1, #90	; 0x5a
{
 800b266:	4606      	mov	r6, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b268:	f003 f9ea 	bl	800e640 <Sensor_IO_Read>
 800b26c:	b110      	cbz	r0, 800b274 <LSM6DSM_ACC_GYRO_W_DUR+0x1c>

  newValue = newValue << LSM6DSM_ACC_GYRO_DUR_POSITION; //mask
  newValue &= LSM6DSM_ACC_GYRO_DUR_MASK; //coerce

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_INT_DUR2, &value, 1) )
    return MEMS_ERROR;
 800b26e:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_INT_DUR2, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b270:	b002      	add	sp, #8
 800b272:	bd70      	pop	{r4, r5, r6, pc}
  value &= ~LSM6DSM_ACC_GYRO_DUR_MASK;
 800b274:	f89d 4007 	ldrb.w	r4, [sp, #7]
 800b278:	f004 040f 	and.w	r4, r4, #15
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b27c:	f10d 0207 	add.w	r2, sp, #7
 800b280:	4630      	mov	r0, r6
  value |= newValue;
 800b282:	ea44 1405 	orr.w	r4, r4, r5, lsl #4
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b286:	2301      	movs	r3, #1
 800b288:	215a      	movs	r1, #90	; 0x5a
  value |= newValue;
 800b28a:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b28e:	f003 f8e9 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b292:	fab0 f080 	clz	r0, r0
 800b296:	0940      	lsrs	r0, r0, #5
}
 800b298:	b002      	add	sp, #8
 800b29a:	bd70      	pop	{r4, r5, r6, pc}

0800b29c <LSM6DSM_ACC_GYRO_W_WK_THS>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_WK_THS(void *handle, u8_t newValue)
{
 800b29c:	b570      	push	{r4, r5, r6, lr}
 800b29e:	b082      	sub	sp, #8
 800b2a0:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b2a2:	f10d 0207 	add.w	r2, sp, #7
 800b2a6:	2301      	movs	r3, #1
 800b2a8:	215b      	movs	r1, #91	; 0x5b
{
 800b2aa:	4606      	mov	r6, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b2ac:	f003 f9c8 	bl	800e640 <Sensor_IO_Read>
 800b2b0:	b110      	cbz	r0, 800b2b8 <LSM6DSM_ACC_GYRO_W_WK_THS+0x1c>

  newValue = newValue << LSM6DSM_ACC_GYRO_WK_THS_POSITION; //mask
  newValue &= LSM6DSM_ACC_GYRO_WK_THS_MASK; //coerce

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_WAKE_UP_THS, &value, 1) )
    return MEMS_ERROR;
 800b2b2:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_WAKE_UP_THS, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b2b4:	b002      	add	sp, #8
 800b2b6:	bd70      	pop	{r4, r5, r6, pc}
  value &= ~LSM6DSM_ACC_GYRO_WK_THS_MASK;
 800b2b8:	f89d 4007 	ldrb.w	r4, [sp, #7]
  newValue &= LSM6DSM_ACC_GYRO_WK_THS_MASK; //coerce
 800b2bc:	f005 053f 	and.w	r5, r5, #63	; 0x3f
  value &= ~LSM6DSM_ACC_GYRO_WK_THS_MASK;
 800b2c0:	f024 043f 	bic.w	r4, r4, #63	; 0x3f
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b2c4:	f10d 0207 	add.w	r2, sp, #7
 800b2c8:	4630      	mov	r0, r6
  value |= newValue;
 800b2ca:	432c      	orrs	r4, r5
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b2cc:	2301      	movs	r3, #1
 800b2ce:	215b      	movs	r1, #91	; 0x5b
  value |= newValue;
 800b2d0:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b2d4:	f003 f8c6 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b2d8:	fab0 f080 	clz	r0, r0
 800b2dc:	0940      	lsrs	r0, r0, #5
}
 800b2de:	b002      	add	sp, #8
 800b2e0:	bd70      	pop	{r4, r5, r6, pc}
 800b2e2:	bf00      	nop

0800b2e4 <LSM6DSM_ACC_GYRO_W_SINGLE_DOUBLE_TAP_EV>:
* Input          : LSM6DSM_ACC_GYRO_SINGLE_DOUBLE_TAP_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_SINGLE_DOUBLE_TAP_EV(void *handle, LSM6DSM_ACC_GYRO_SINGLE_DOUBLE_TAP_t newValue)
{
 800b2e4:	b530      	push	{r4, r5, lr}
 800b2e6:	b083      	sub	sp, #12
 800b2e8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b2ea:	f10d 0207 	add.w	r2, sp, #7
 800b2ee:	2301      	movs	r3, #1
 800b2f0:	215b      	movs	r1, #91	; 0x5b
{
 800b2f2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b2f4:	f003 f9a4 	bl	800e640 <Sensor_IO_Read>
 800b2f8:	b110      	cbz	r0, 800b300 <LSM6DSM_ACC_GYRO_W_SINGLE_DOUBLE_TAP_EV+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_WAKE_UP_THS, &value, 1) )
    return MEMS_ERROR;
 800b2fa:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_WAKE_UP_THS, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b2fc:	b003      	add	sp, #12
 800b2fe:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_SINGLE_DOUBLE_TAP_MASK;
 800b300:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b304:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  value |= newValue;
 800b308:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b30a:	f10d 0207 	add.w	r2, sp, #7
 800b30e:	4628      	mov	r0, r5
 800b310:	2301      	movs	r3, #1
 800b312:	215b      	movs	r1, #91	; 0x5b
  value |= newValue;
 800b314:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b318:	f003 f8a4 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b31c:	fab0 f080 	clz	r0, r0
 800b320:	0940      	lsrs	r0, r0, #5
}
 800b322:	b003      	add	sp, #12
 800b324:	bd30      	pop	{r4, r5, pc}
 800b326:	bf00      	nop

0800b328 <LSM6DSM_ACC_GYRO_W_SLEEP_DUR>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_SLEEP_DUR(void *handle, u8_t newValue)
{
 800b328:	b570      	push	{r4, r5, r6, lr}
 800b32a:	b082      	sub	sp, #8
 800b32c:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b32e:	f10d 0207 	add.w	r2, sp, #7
 800b332:	2301      	movs	r3, #1
 800b334:	215c      	movs	r1, #92	; 0x5c
{
 800b336:	4606      	mov	r6, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b338:	f003 f982 	bl	800e640 <Sensor_IO_Read>
 800b33c:	b110      	cbz	r0, 800b344 <LSM6DSM_ACC_GYRO_W_SLEEP_DUR+0x1c>

  newValue = newValue << LSM6DSM_ACC_GYRO_SLEEP_DUR_POSITION; //mask
  newValue &= LSM6DSM_ACC_GYRO_SLEEP_DUR_MASK; //coerce

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_WAKE_UP_DUR, &value, 1) )
    return MEMS_ERROR;
 800b33e:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_WAKE_UP_DUR, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b340:	b002      	add	sp, #8
 800b342:	bd70      	pop	{r4, r5, r6, pc}
  value &= ~LSM6DSM_ACC_GYRO_SLEEP_DUR_MASK;
 800b344:	f89d 4007 	ldrb.w	r4, [sp, #7]
  newValue &= LSM6DSM_ACC_GYRO_SLEEP_DUR_MASK; //coerce
 800b348:	f005 050f 	and.w	r5, r5, #15
  value &= ~LSM6DSM_ACC_GYRO_SLEEP_DUR_MASK;
 800b34c:	f024 040f 	bic.w	r4, r4, #15
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b350:	f10d 0207 	add.w	r2, sp, #7
 800b354:	4630      	mov	r0, r6
  value |= newValue;
 800b356:	432c      	orrs	r4, r5
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b358:	2301      	movs	r3, #1
 800b35a:	215c      	movs	r1, #92	; 0x5c
  value |= newValue;
 800b35c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b360:	f003 f880 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b364:	fab0 f080 	clz	r0, r0
 800b368:	0940      	lsrs	r0, r0, #5
}
 800b36a:	b002      	add	sp, #8
 800b36c:	bd70      	pop	{r4, r5, r6, pc}
 800b36e:	bf00      	nop

0800b370 <LSM6DSM_ACC_GYRO_W_TIMER_HR>:
* Input          : LSM6DSM_ACC_GYRO_TIMER_HR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_TIMER_HR(void *handle, LSM6DSM_ACC_GYRO_TIMER_HR_t newValue)
{
 800b370:	b530      	push	{r4, r5, lr}
 800b372:	b083      	sub	sp, #12
 800b374:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b376:	f10d 0207 	add.w	r2, sp, #7
 800b37a:	2301      	movs	r3, #1
 800b37c:	215c      	movs	r1, #92	; 0x5c
{
 800b37e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b380:	f003 f95e 	bl	800e640 <Sensor_IO_Read>
 800b384:	b110      	cbz	r0, 800b38c <LSM6DSM_ACC_GYRO_W_TIMER_HR+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_WAKE_UP_DUR, &value, 1) )
    return MEMS_ERROR;
 800b386:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_WAKE_UP_DUR, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b388:	b003      	add	sp, #12
 800b38a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_TIMER_HR_MASK;
 800b38c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b390:	f023 0310 	bic.w	r3, r3, #16
  value |= newValue;
 800b394:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b396:	f10d 0207 	add.w	r2, sp, #7
 800b39a:	4628      	mov	r0, r5
 800b39c:	2301      	movs	r3, #1
 800b39e:	215c      	movs	r1, #92	; 0x5c
  value |= newValue;
 800b3a0:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b3a4:	f003 f85e 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b3a8:	fab0 f080 	clz	r0, r0
 800b3ac:	0940      	lsrs	r0, r0, #5
}
 800b3ae:	b003      	add	sp, #12
 800b3b0:	bd30      	pop	{r4, r5, pc}
 800b3b2:	bf00      	nop

0800b3b4 <LSM6DSM_ACC_GYRO_W_WAKE_DUR>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_WAKE_DUR(void *handle, u8_t newValue)
{
 800b3b4:	b530      	push	{r4, r5, lr}
 800b3b6:	b083      	sub	sp, #12
 800b3b8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b3ba:	f10d 0207 	add.w	r2, sp, #7
 800b3be:	2301      	movs	r3, #1
 800b3c0:	215c      	movs	r1, #92	; 0x5c
{
 800b3c2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b3c4:	f003 f93c 	bl	800e640 <Sensor_IO_Read>
 800b3c8:	b110      	cbz	r0, 800b3d0 <LSM6DSM_ACC_GYRO_W_WAKE_DUR+0x1c>

  newValue = newValue << LSM6DSM_ACC_GYRO_WAKE_DUR_POSITION; //mask
  newValue &= LSM6DSM_ACC_GYRO_WAKE_DUR_MASK; //coerce

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_WAKE_UP_DUR, &value, 1) )
    return MEMS_ERROR;
 800b3ca:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_WAKE_UP_DUR, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b3cc:	b003      	add	sp, #12
 800b3ce:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_WAKE_DUR_MASK;
 800b3d0:	f89d 3007 	ldrb.w	r3, [sp, #7]
  newValue = newValue << LSM6DSM_ACC_GYRO_WAKE_DUR_POSITION; //mask
 800b3d4:	0164      	lsls	r4, r4, #5
  value &= ~LSM6DSM_ACC_GYRO_WAKE_DUR_MASK;
 800b3d6:	f023 0360 	bic.w	r3, r3, #96	; 0x60
  newValue &= LSM6DSM_ACC_GYRO_WAKE_DUR_MASK; //coerce
 800b3da:	f004 0460 	and.w	r4, r4, #96	; 0x60
  value |= newValue;
 800b3de:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b3e0:	f10d 0207 	add.w	r2, sp, #7
 800b3e4:	4628      	mov	r0, r5
 800b3e6:	2301      	movs	r3, #1
 800b3e8:	215c      	movs	r1, #92	; 0x5c
  value |= newValue;
 800b3ea:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b3ee:	f003 f839 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b3f2:	fab0 f080 	clz	r0, r0
 800b3f6:	0940      	lsrs	r0, r0, #5
}
 800b3f8:	b003      	add	sp, #12
 800b3fa:	bd30      	pop	{r4, r5, pc}

0800b3fc <LSM6DSM_ACC_GYRO_W_FF_THS>:
* Input          : LSM6DSM_ACC_GYRO_FF_THS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_FF_THS(void *handle, LSM6DSM_ACC_GYRO_FF_THS_t newValue)
{
 800b3fc:	b530      	push	{r4, r5, lr}
 800b3fe:	b083      	sub	sp, #12
 800b400:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b402:	f10d 0207 	add.w	r2, sp, #7
 800b406:	2301      	movs	r3, #1
 800b408:	215d      	movs	r1, #93	; 0x5d
{
 800b40a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b40c:	f003 f918 	bl	800e640 <Sensor_IO_Read>
 800b410:	b110      	cbz	r0, 800b418 <LSM6DSM_ACC_GYRO_W_FF_THS+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FREE_FALL, &value, 1) )
    return MEMS_ERROR;
 800b412:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_FREE_FALL, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b414:	b003      	add	sp, #12
 800b416:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_FF_THS_MASK;
 800b418:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b41c:	f023 0307 	bic.w	r3, r3, #7
  value |= newValue;
 800b420:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b422:	f10d 0207 	add.w	r2, sp, #7
 800b426:	4628      	mov	r0, r5
 800b428:	2301      	movs	r3, #1
 800b42a:	215d      	movs	r1, #93	; 0x5d
  value |= newValue;
 800b42c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b430:	f003 f818 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b434:	fab0 f080 	clz	r0, r0
 800b438:	0940      	lsrs	r0, r0, #5
}
 800b43a:	b003      	add	sp, #12
 800b43c:	bd30      	pop	{r4, r5, pc}
 800b43e:	bf00      	nop

0800b440 <LSM6DSM_ACC_GYRO_W_FF_Duration>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_FF_Duration(void *handle, u8_t newValue)
{
 800b440:	b570      	push	{r4, r5, r6, lr}
 800b442:	b082      	sub	sp, #8
 800b444:	460e      	mov	r6, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b446:	f10d 0207 	add.w	r2, sp, #7
 800b44a:	2301      	movs	r3, #1
 800b44c:	215d      	movs	r1, #93	; 0x5d
{
 800b44e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b450:	f003 f8f6 	bl	800e640 <Sensor_IO_Read>
 800b454:	b110      	cbz	r0, 800b45c <LSM6DSM_ACC_GYRO_W_FF_Duration+0x1c>
  /* Low part in FREE_FALL reg */
  valueL = valueL << LSM6DSM_ACC_GYRO_FF_FREE_FALL_DUR_POSITION; //mask
  valueL &= LSM6DSM_ACC_GYRO_FF_FREE_FALL_DUR_MASK; //coerce

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FREE_FALL, &value, 1) )
    return MEMS_ERROR;
 800b456:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_WAKE_UP_DUR, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b458:	b002      	add	sp, #8
 800b45a:	bd70      	pop	{r4, r5, r6, pc}
  value &= ~LSM6DSM_ACC_GYRO_FF_FREE_FALL_DUR_MASK;
 800b45c:	f89d 4007 	ldrb.w	r4, [sp, #7]
 800b460:	f004 0407 	and.w	r4, r4, #7
  value |= valueL;
 800b464:	ea44 04c6 	orr.w	r4, r4, r6, lsl #3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b468:	2301      	movs	r3, #1
 800b46a:	f10d 0207 	add.w	r2, sp, #7
 800b46e:	215d      	movs	r1, #93	; 0x5d
 800b470:	4628      	mov	r0, r5
  value |= valueL;
 800b472:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b476:	f002 fff5 	bl	800e464 <Sensor_IO_Write>
 800b47a:	2800      	cmp	r0, #0
 800b47c:	d1eb      	bne.n	800b456 <LSM6DSM_ACC_GYRO_W_FF_Duration+0x16>
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b47e:	2301      	movs	r3, #1
 800b480:	f10d 0207 	add.w	r2, sp, #7
 800b484:	215c      	movs	r1, #92	; 0x5c
 800b486:	4628      	mov	r0, r5
 800b488:	f003 f8da 	bl	800e640 <Sensor_IO_Read>
 800b48c:	2800      	cmp	r0, #0
 800b48e:	d1e2      	bne.n	800b456 <LSM6DSM_ACC_GYRO_W_FF_Duration+0x16>
  value &= ~LSM6DSM_ACC_GYRO_FF_WAKE_UP_DUR_MASK;
 800b490:	f89d 3007 	ldrb.w	r3, [sp, #7]
  valueH = (newValue >> 5) & 0x1;
 800b494:	0976      	lsrs	r6, r6, #5
  value &= ~LSM6DSM_ACC_GYRO_FF_WAKE_UP_DUR_MASK;
 800b496:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  value |= valueH;
 800b49a:	ea43 16c6 	orr.w	r6, r3, r6, lsl #7
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b49e:	f10d 0207 	add.w	r2, sp, #7
 800b4a2:	4628      	mov	r0, r5
 800b4a4:	2301      	movs	r3, #1
 800b4a6:	215c      	movs	r1, #92	; 0x5c
  value |= valueH;
 800b4a8:	f88d 6007 	strb.w	r6, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b4ac:	f002 ffda 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b4b0:	fab0 f080 	clz	r0, r0
 800b4b4:	0940      	lsrs	r0, r0, #5
 800b4b6:	e7cf      	b.n	800b458 <LSM6DSM_ACC_GYRO_W_FF_Duration+0x18>

0800b4b8 <LSM6DSM_ACC_GYRO_W_TiltEvOnInt1>:
* Input          : LSM6DSM_ACC_GYRO_INT1_TILT_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_TiltEvOnInt1(void *handle, LSM6DSM_ACC_GYRO_INT1_TILT_t newValue)
{
 800b4b8:	b530      	push	{r4, r5, lr}
 800b4ba:	b083      	sub	sp, #12
 800b4bc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b4be:	f10d 0207 	add.w	r2, sp, #7
 800b4c2:	2301      	movs	r3, #1
 800b4c4:	215e      	movs	r1, #94	; 0x5e
{
 800b4c6:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b4c8:	f003 f8ba 	bl	800e640 <Sensor_IO_Read>
 800b4cc:	b110      	cbz	r0, 800b4d4 <LSM6DSM_ACC_GYRO_W_TiltEvOnInt1+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;
 800b4ce:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b4d0:	b003      	add	sp, #12
 800b4d2:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT1_TILT_MASK;
 800b4d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b4d8:	f023 0302 	bic.w	r3, r3, #2
  value |= newValue;
 800b4dc:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b4de:	f10d 0207 	add.w	r2, sp, #7
 800b4e2:	4628      	mov	r0, r5
 800b4e4:	2301      	movs	r3, #1
 800b4e6:	215e      	movs	r1, #94	; 0x5e
  value |= newValue;
 800b4e8:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b4ec:	f002 ffba 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b4f0:	fab0 f080 	clz	r0, r0
 800b4f4:	0940      	lsrs	r0, r0, #5
}
 800b4f6:	b003      	add	sp, #12
 800b4f8:	bd30      	pop	{r4, r5, pc}
 800b4fa:	bf00      	nop

0800b4fc <LSM6DSM_ACC_GYRO_W_6DEvOnInt1>:
* Input          : LSM6DSM_ACC_GYRO_INT1_6D_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_6DEvOnInt1(void *handle, LSM6DSM_ACC_GYRO_INT1_6D_t newValue)
{
 800b4fc:	b530      	push	{r4, r5, lr}
 800b4fe:	b083      	sub	sp, #12
 800b500:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b502:	f10d 0207 	add.w	r2, sp, #7
 800b506:	2301      	movs	r3, #1
 800b508:	215e      	movs	r1, #94	; 0x5e
{
 800b50a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b50c:	f003 f898 	bl	800e640 <Sensor_IO_Read>
 800b510:	b110      	cbz	r0, 800b518 <LSM6DSM_ACC_GYRO_W_6DEvOnInt1+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;
 800b512:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b514:	b003      	add	sp, #12
 800b516:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT1_6D_MASK;
 800b518:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b51c:	f023 0304 	bic.w	r3, r3, #4
  value |= newValue;
 800b520:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b522:	f10d 0207 	add.w	r2, sp, #7
 800b526:	4628      	mov	r0, r5
 800b528:	2301      	movs	r3, #1
 800b52a:	215e      	movs	r1, #94	; 0x5e
  value |= newValue;
 800b52c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b530:	f002 ff98 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b534:	fab0 f080 	clz	r0, r0
 800b538:	0940      	lsrs	r0, r0, #5
}
 800b53a:	b003      	add	sp, #12
 800b53c:	bd30      	pop	{r4, r5, pc}
 800b53e:	bf00      	nop

0800b540 <LSM6DSM_ACC_GYRO_W_TapEvOnInt1>:
* Input          : LSM6DSM_ACC_GYRO_INT1_TAP_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_TapEvOnInt1(void *handle, LSM6DSM_ACC_GYRO_INT1_TAP_t newValue)
{
 800b540:	b530      	push	{r4, r5, lr}
 800b542:	b083      	sub	sp, #12
 800b544:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b546:	f10d 0207 	add.w	r2, sp, #7
 800b54a:	2301      	movs	r3, #1
 800b54c:	215e      	movs	r1, #94	; 0x5e
{
 800b54e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b550:	f003 f876 	bl	800e640 <Sensor_IO_Read>
 800b554:	b110      	cbz	r0, 800b55c <LSM6DSM_ACC_GYRO_W_TapEvOnInt1+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;
 800b556:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b558:	b003      	add	sp, #12
 800b55a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT1_TAP_MASK;
 800b55c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b560:	f023 0308 	bic.w	r3, r3, #8
  value |= newValue;
 800b564:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b566:	f10d 0207 	add.w	r2, sp, #7
 800b56a:	4628      	mov	r0, r5
 800b56c:	2301      	movs	r3, #1
 800b56e:	215e      	movs	r1, #94	; 0x5e
  value |= newValue;
 800b570:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b574:	f002 ff76 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b578:	fab0 f080 	clz	r0, r0
 800b57c:	0940      	lsrs	r0, r0, #5
}
 800b57e:	b003      	add	sp, #12
 800b580:	bd30      	pop	{r4, r5, pc}
 800b582:	bf00      	nop

0800b584 <LSM6DSM_ACC_GYRO_W_FFEvOnInt1>:
* Input          : LSM6DSM_ACC_GYRO_INT1_FF_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_FFEvOnInt1(void *handle, LSM6DSM_ACC_GYRO_INT1_FF_t newValue)
{
 800b584:	b530      	push	{r4, r5, lr}
 800b586:	b083      	sub	sp, #12
 800b588:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b58a:	f10d 0207 	add.w	r2, sp, #7
 800b58e:	2301      	movs	r3, #1
 800b590:	215e      	movs	r1, #94	; 0x5e
{
 800b592:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b594:	f003 f854 	bl	800e640 <Sensor_IO_Read>
 800b598:	b110      	cbz	r0, 800b5a0 <LSM6DSM_ACC_GYRO_W_FFEvOnInt1+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;
 800b59a:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b59c:	b003      	add	sp, #12
 800b59e:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT1_FF_MASK;
 800b5a0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b5a4:	f023 0310 	bic.w	r3, r3, #16
  value |= newValue;
 800b5a8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b5aa:	f10d 0207 	add.w	r2, sp, #7
 800b5ae:	4628      	mov	r0, r5
 800b5b0:	2301      	movs	r3, #1
 800b5b2:	215e      	movs	r1, #94	; 0x5e
  value |= newValue;
 800b5b4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b5b8:	f002 ff54 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b5bc:	fab0 f080 	clz	r0, r0
 800b5c0:	0940      	lsrs	r0, r0, #5
}
 800b5c2:	b003      	add	sp, #12
 800b5c4:	bd30      	pop	{r4, r5, pc}
 800b5c6:	bf00      	nop

0800b5c8 <LSM6DSM_ACC_GYRO_W_WUEvOnInt1>:
* Input          : LSM6DSM_ACC_GYRO_INT1_WU_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_WUEvOnInt1(void *handle, LSM6DSM_ACC_GYRO_INT1_WU_t newValue)
{
 800b5c8:	b530      	push	{r4, r5, lr}
 800b5ca:	b083      	sub	sp, #12
 800b5cc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b5ce:	f10d 0207 	add.w	r2, sp, #7
 800b5d2:	2301      	movs	r3, #1
 800b5d4:	215e      	movs	r1, #94	; 0x5e
{
 800b5d6:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b5d8:	f003 f832 	bl	800e640 <Sensor_IO_Read>
 800b5dc:	b110      	cbz	r0, 800b5e4 <LSM6DSM_ACC_GYRO_W_WUEvOnInt1+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;
 800b5de:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b5e0:	b003      	add	sp, #12
 800b5e2:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT1_WU_MASK;
 800b5e4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b5e8:	f023 0320 	bic.w	r3, r3, #32
  value |= newValue;
 800b5ec:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b5ee:	f10d 0207 	add.w	r2, sp, #7
 800b5f2:	4628      	mov	r0, r5
 800b5f4:	2301      	movs	r3, #1
 800b5f6:	215e      	movs	r1, #94	; 0x5e
  value |= newValue;
 800b5f8:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b5fc:	f002 ff32 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b600:	fab0 f080 	clz	r0, r0
 800b604:	0940      	lsrs	r0, r0, #5
}
 800b606:	b003      	add	sp, #12
 800b608:	bd30      	pop	{r4, r5, pc}
 800b60a:	bf00      	nop

0800b60c <LSM6DSM_ACC_GYRO_W_SingleTapOnInt1>:
* Input          : LSM6DSM_ACC_GYRO_INT1_SINGLE_TAP_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_SingleTapOnInt1(void *handle, LSM6DSM_ACC_GYRO_INT1_SINGLE_TAP_t newValue)
{
 800b60c:	b530      	push	{r4, r5, lr}
 800b60e:	b083      	sub	sp, #12
 800b610:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b612:	f10d 0207 	add.w	r2, sp, #7
 800b616:	2301      	movs	r3, #1
 800b618:	215e      	movs	r1, #94	; 0x5e
{
 800b61a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b61c:	f003 f810 	bl	800e640 <Sensor_IO_Read>
 800b620:	b110      	cbz	r0, 800b628 <LSM6DSM_ACC_GYRO_W_SingleTapOnInt1+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;
 800b622:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b624:	b003      	add	sp, #12
 800b626:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT1_SINGLE_TAP_MASK;
 800b628:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b62c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  value |= newValue;
 800b630:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b632:	f10d 0207 	add.w	r2, sp, #7
 800b636:	4628      	mov	r0, r5
 800b638:	2301      	movs	r3, #1
 800b63a:	215e      	movs	r1, #94	; 0x5e
  value |= newValue;
 800b63c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b640:	f002 ff10 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b644:	fab0 f080 	clz	r0, r0
 800b648:	0940      	lsrs	r0, r0, #5
}
 800b64a:	b003      	add	sp, #12
 800b64c:	bd30      	pop	{r4, r5, pc}
 800b64e:	bf00      	nop

0800b650 <LSM6DSM_ACC_GYRO_W_TiltEvOnInt2>:
* Input          : LSM6DSM_ACC_GYRO_INT2_TILT_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_TiltEvOnInt2(void *handle, LSM6DSM_ACC_GYRO_INT2_TILT_t newValue)
{
 800b650:	b530      	push	{r4, r5, lr}
 800b652:	b083      	sub	sp, #12
 800b654:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b656:	f10d 0207 	add.w	r2, sp, #7
 800b65a:	2301      	movs	r3, #1
 800b65c:	215f      	movs	r1, #95	; 0x5f
{
 800b65e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b660:	f002 ffee 	bl	800e640 <Sensor_IO_Read>
 800b664:	b110      	cbz	r0, 800b66c <LSM6DSM_ACC_GYRO_W_TiltEvOnInt2+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;
 800b666:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b668:	b003      	add	sp, #12
 800b66a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT2_TILT_MASK;
 800b66c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b670:	f023 0302 	bic.w	r3, r3, #2
  value |= newValue;
 800b674:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b676:	f10d 0207 	add.w	r2, sp, #7
 800b67a:	4628      	mov	r0, r5
 800b67c:	2301      	movs	r3, #1
 800b67e:	215f      	movs	r1, #95	; 0x5f
  value |= newValue;
 800b680:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b684:	f002 feee 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b688:	fab0 f080 	clz	r0, r0
 800b68c:	0940      	lsrs	r0, r0, #5
}
 800b68e:	b003      	add	sp, #12
 800b690:	bd30      	pop	{r4, r5, pc}
 800b692:	bf00      	nop

0800b694 <LSM6DSM_ACC_GYRO_W_6DEvOnInt2>:
* Input          : LSM6DSM_ACC_GYRO_INT2_6D_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_6DEvOnInt2(void *handle, LSM6DSM_ACC_GYRO_INT2_6D_t newValue)
{
 800b694:	b530      	push	{r4, r5, lr}
 800b696:	b083      	sub	sp, #12
 800b698:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b69a:	f10d 0207 	add.w	r2, sp, #7
 800b69e:	2301      	movs	r3, #1
 800b6a0:	215f      	movs	r1, #95	; 0x5f
{
 800b6a2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b6a4:	f002 ffcc 	bl	800e640 <Sensor_IO_Read>
 800b6a8:	b110      	cbz	r0, 800b6b0 <LSM6DSM_ACC_GYRO_W_6DEvOnInt2+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;
 800b6aa:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b6ac:	b003      	add	sp, #12
 800b6ae:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT2_6D_MASK;
 800b6b0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b6b4:	f023 0304 	bic.w	r3, r3, #4
  value |= newValue;
 800b6b8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b6ba:	f10d 0207 	add.w	r2, sp, #7
 800b6be:	4628      	mov	r0, r5
 800b6c0:	2301      	movs	r3, #1
 800b6c2:	215f      	movs	r1, #95	; 0x5f
  value |= newValue;
 800b6c4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b6c8:	f002 fecc 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b6cc:	fab0 f080 	clz	r0, r0
 800b6d0:	0940      	lsrs	r0, r0, #5
}
 800b6d2:	b003      	add	sp, #12
 800b6d4:	bd30      	pop	{r4, r5, pc}
 800b6d6:	bf00      	nop

0800b6d8 <LSM6DSM_ACC_GYRO_W_TapEvOnInt2>:
* Input          : LSM6DSM_ACC_GYRO_INT2_TAP_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_TapEvOnInt2(void *handle, LSM6DSM_ACC_GYRO_INT2_TAP_t newValue)
{
 800b6d8:	b530      	push	{r4, r5, lr}
 800b6da:	b083      	sub	sp, #12
 800b6dc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b6de:	f10d 0207 	add.w	r2, sp, #7
 800b6e2:	2301      	movs	r3, #1
 800b6e4:	215f      	movs	r1, #95	; 0x5f
{
 800b6e6:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b6e8:	f002 ffaa 	bl	800e640 <Sensor_IO_Read>
 800b6ec:	b110      	cbz	r0, 800b6f4 <LSM6DSM_ACC_GYRO_W_TapEvOnInt2+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;
 800b6ee:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b6f0:	b003      	add	sp, #12
 800b6f2:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT2_TAP_MASK;
 800b6f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b6f8:	f023 0308 	bic.w	r3, r3, #8
  value |= newValue;
 800b6fc:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b6fe:	f10d 0207 	add.w	r2, sp, #7
 800b702:	4628      	mov	r0, r5
 800b704:	2301      	movs	r3, #1
 800b706:	215f      	movs	r1, #95	; 0x5f
  value |= newValue;
 800b708:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b70c:	f002 feaa 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b710:	fab0 f080 	clz	r0, r0
 800b714:	0940      	lsrs	r0, r0, #5
}
 800b716:	b003      	add	sp, #12
 800b718:	bd30      	pop	{r4, r5, pc}
 800b71a:	bf00      	nop

0800b71c <LSM6DSM_ACC_GYRO_W_FFEvOnInt2>:
* Input          : LSM6DSM_ACC_GYRO_INT2_FF_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_FFEvOnInt2(void *handle, LSM6DSM_ACC_GYRO_INT2_FF_t newValue)
{
 800b71c:	b530      	push	{r4, r5, lr}
 800b71e:	b083      	sub	sp, #12
 800b720:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b722:	f10d 0207 	add.w	r2, sp, #7
 800b726:	2301      	movs	r3, #1
 800b728:	215f      	movs	r1, #95	; 0x5f
{
 800b72a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b72c:	f002 ff88 	bl	800e640 <Sensor_IO_Read>
 800b730:	b110      	cbz	r0, 800b738 <LSM6DSM_ACC_GYRO_W_FFEvOnInt2+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;
 800b732:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b734:	b003      	add	sp, #12
 800b736:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT2_FF_MASK;
 800b738:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b73c:	f023 0310 	bic.w	r3, r3, #16
  value |= newValue;
 800b740:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b742:	f10d 0207 	add.w	r2, sp, #7
 800b746:	4628      	mov	r0, r5
 800b748:	2301      	movs	r3, #1
 800b74a:	215f      	movs	r1, #95	; 0x5f
  value |= newValue;
 800b74c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b750:	f002 fe88 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b754:	fab0 f080 	clz	r0, r0
 800b758:	0940      	lsrs	r0, r0, #5
}
 800b75a:	b003      	add	sp, #12
 800b75c:	bd30      	pop	{r4, r5, pc}
 800b75e:	bf00      	nop

0800b760 <LSM6DSM_ACC_GYRO_W_WUEvOnInt2>:
* Input          : LSM6DSM_ACC_GYRO_INT2_WU_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_WUEvOnInt2(void *handle, LSM6DSM_ACC_GYRO_INT2_WU_t newValue)
{
 800b760:	b530      	push	{r4, r5, lr}
 800b762:	b083      	sub	sp, #12
 800b764:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b766:	f10d 0207 	add.w	r2, sp, #7
 800b76a:	2301      	movs	r3, #1
 800b76c:	215f      	movs	r1, #95	; 0x5f
{
 800b76e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b770:	f002 ff66 	bl	800e640 <Sensor_IO_Read>
 800b774:	b110      	cbz	r0, 800b77c <LSM6DSM_ACC_GYRO_W_WUEvOnInt2+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;
 800b776:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b778:	b003      	add	sp, #12
 800b77a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT2_WU_MASK;
 800b77c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b780:	f023 0320 	bic.w	r3, r3, #32
  value |= newValue;
 800b784:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b786:	f10d 0207 	add.w	r2, sp, #7
 800b78a:	4628      	mov	r0, r5
 800b78c:	2301      	movs	r3, #1
 800b78e:	215f      	movs	r1, #95	; 0x5f
  value |= newValue;
 800b790:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b794:	f002 fe66 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b798:	fab0 f080 	clz	r0, r0
 800b79c:	0940      	lsrs	r0, r0, #5
}
 800b79e:	b003      	add	sp, #12
 800b7a0:	bd30      	pop	{r4, r5, pc}
 800b7a2:	bf00      	nop

0800b7a4 <LSM6DSM_ACC_GYRO_W_SingleTapOnInt2>:
* Input          : LSM6DSM_ACC_GYRO_INT2_SINGLE_TAP_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_SingleTapOnInt2(void *handle, LSM6DSM_ACC_GYRO_INT2_SINGLE_TAP_t newValue)
{
 800b7a4:	b530      	push	{r4, r5, lr}
 800b7a6:	b083      	sub	sp, #12
 800b7a8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b7aa:	f10d 0207 	add.w	r2, sp, #7
 800b7ae:	2301      	movs	r3, #1
 800b7b0:	215f      	movs	r1, #95	; 0x5f
{
 800b7b2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b7b4:	f002 ff44 	bl	800e640 <Sensor_IO_Read>
 800b7b8:	b110      	cbz	r0, 800b7c0 <LSM6DSM_ACC_GYRO_W_SingleTapOnInt2+0x1c>
  u8_t value;

  if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;
 800b7ba:	2000      	movs	r0, #0

  if( !LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800b7bc:	b003      	add	sp, #12
 800b7be:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSM_ACC_GYRO_INT2_SINGLE_TAP_MASK;
 800b7c0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b7c4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  value |= newValue;
 800b7c8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b7ca:	f10d 0207 	add.w	r2, sp, #7
 800b7ce:	4628      	mov	r0, r5
 800b7d0:	2301      	movs	r3, #1
 800b7d2:	215f      	movs	r1, #95	; 0x5f
  value |= newValue;
 800b7d4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b7d8:	f002 fe44 	bl	800e464 <Sensor_IO_Write>
    return MEMS_ERROR;
 800b7dc:	fab0 f080 	clz	r0, r0
 800b7e0:	0940      	lsrs	r0, r0, #5
}
 800b7e2:	b003      	add	sp, #12
 800b7e4:	bd30      	pop	{r4, r5, pc}
 800b7e6:	bf00      	nop

0800b7e8 <LSM6DSM_ACC_GYRO_Get_GetFIFOData>:
* Input          : pointer to [u8_t]
* Output         : GetFIFOData buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_Get_GetFIFOData(void *handle, u8_t *buff)
{
 800b7e8:	b538      	push	{r3, r4, r5, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b7ea:	460a      	mov	r2, r1
{
 800b7ec:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b7ee:	2301      	movs	r3, #1
 800b7f0:	213e      	movs	r1, #62	; 0x3e
{
 800b7f2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b7f4:	f002 ff24 	bl	800e640 <Sensor_IO_Read>
 800b7f8:	b948      	cbnz	r0, 800b80e <LSM6DSM_ACC_GYRO_Get_GetFIFOData+0x26>
 800b7fa:	1c62      	adds	r2, r4, #1
 800b7fc:	4628      	mov	r0, r5
 800b7fe:	2301      	movs	r3, #1
 800b800:	213f      	movs	r1, #63	; 0x3f
 800b802:	f002 ff1d 	bl	800e640 <Sensor_IO_Read>
  for (i = 0; i < 1; i++ )
  {
    for (j = 0; j < numberOfByteForDimension; j++ )
    {
      if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_FIFO_DATA_OUT_L + k, &buff[k], 1))
        return MEMS_ERROR;
 800b806:	fab0 f080 	clz	r0, r0
 800b80a:	0940      	lsrs	r0, r0, #5
      k++;
    }
  }

  return MEMS_SUCCESS;
}
 800b80c:	bd38      	pop	{r3, r4, r5, pc}
        return MEMS_ERROR;
 800b80e:	2000      	movs	r0, #0
}
 800b810:	bd38      	pop	{r3, r4, r5, pc}
 800b812:	bf00      	nop

0800b814 <LSM6DSM_ACC_GYRO_Get_GetStepCounter>:
* Input          : pointer to [u8_t]
* Output         : GetStepCounter buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSM_ACC_GYRO_Get_GetStepCounter(void *handle, u8_t *buff)
{
 800b814:	b538      	push	{r3, r4, r5, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b816:	460a      	mov	r2, r1
{
 800b818:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b81a:	2301      	movs	r3, #1
 800b81c:	214b      	movs	r1, #75	; 0x4b
{
 800b81e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b820:	f002 ff0e 	bl	800e640 <Sensor_IO_Read>
 800b824:	b948      	cbnz	r0, 800b83a <LSM6DSM_ACC_GYRO_Get_GetStepCounter+0x26>
 800b826:	1c62      	adds	r2, r4, #1
 800b828:	4628      	mov	r0, r5
 800b82a:	2301      	movs	r3, #1
 800b82c:	214c      	movs	r1, #76	; 0x4c
 800b82e:	f002 ff07 	bl	800e640 <Sensor_IO_Read>
  for (i = 0; i < 1; i++ )
  {
    for (j = 0; j < numberOfByteForDimension; j++ )
    {
      if( !LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_STEP_COUNTER_L + k, &buff[k], 1))
        return MEMS_ERROR;
 800b832:	fab0 f080 	clz	r0, r0
 800b836:	0940      	lsrs	r0, r0, #5
      k++;
    }
  }

  return MEMS_SUCCESS;
}
 800b838:	bd38      	pop	{r3, r4, r5, pc}
        return MEMS_ERROR;
 800b83a:	2000      	movs	r0, #0
}
 800b83c:	bd38      	pop	{r3, r4, r5, pc}
 800b83e:	bf00      	nop

0800b840 <LSM6DSM_ACC_GYRO_W_PedoThreshold>:
* Input          : pointer to [u8_t]
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSM_ACC_GYRO_W_PedoThreshold(void *handle, u8_t newValue)
{
 800b840:	b570      	push	{r4, r5, r6, lr}
 800b842:	4605      	mov	r5, r0
 800b844:	b082      	sub	sp, #8
 800b846:	460e      	mov	r6, r1
  u8_t value;

  /* Open Embedded Function Register page*/
  LSM6DSM_ACC_GYRO_W_EmbeddedAccess(handle, LSM6DSM_ACC_GYRO_EMBEDDED_ACCESS_ENABLED);
 800b848:	2180      	movs	r1, #128	; 0x80
 800b84a:	f7fe ffed 	bl	800a828 <LSM6DSM_ACC_GYRO_W_EmbeddedAccess>
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800b84e:	f10d 0207 	add.w	r2, sp, #7
 800b852:	4628      	mov	r0, r5
 800b854:	2301      	movs	r3, #1
 800b856:	210f      	movs	r1, #15
 800b858:	f002 fef2 	bl	800e640 <Sensor_IO_Read>

  /* read current value */
  LSM6DSM_ACC_GYRO_ReadReg(handle, LSM6DSM_ACC_GYRO_CONFIG_PEDO_THS_MIN, &value, 1);

  value &= ~0x1F;
 800b85c:	f89d 4007 	ldrb.w	r4, [sp, #7]
  value |= (newValue & 0x1F);
 800b860:	f006 061f 	and.w	r6, r6, #31
  value &= ~0x1F;
 800b864:	f024 041f 	bic.w	r4, r4, #31
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b868:	f10d 0207 	add.w	r2, sp, #7
 800b86c:	2301      	movs	r3, #1
  value |= (newValue & 0x1F);
 800b86e:	4334      	orrs	r4, r6
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b870:	4628      	mov	r0, r5
 800b872:	210f      	movs	r1, #15
  value |= (newValue & 0x1F);
 800b874:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800b878:	f002 fdf4 	bl	800e464 <Sensor_IO_Write>

  /* write new value */
  LSM6DSM_ACC_GYRO_WriteReg(handle, LSM6DSM_ACC_GYRO_CONFIG_PEDO_THS_MIN, &value, 1);

  /* Close Embedded Function Register page*/
  LSM6DSM_ACC_GYRO_W_EmbeddedAccess(handle, LSM6DSM_ACC_GYRO_EMBEDDED_ACCESS_DISABLED);
 800b87c:	4628      	mov	r0, r5
 800b87e:	2100      	movs	r1, #0
 800b880:	f7fe ffd2 	bl	800a828 <LSM6DSM_ACC_GYRO_W_EmbeddedAccess>

  return MEMS_SUCCESS;
}
 800b884:	2001      	movs	r0, #1
 800b886:	b002      	add	sp, #8
 800b888:	bd70      	pop	{r4, r5, r6, pc}
 800b88a:	bf00      	nop

0800b88c <LSM6DSM_FIFO_Set_Watermark_Level>:
 * @param watermark FIFO watermark level
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LSM6DSM_FIFO_Set_Watermark_Level( DrvContextTypeDef *handle, uint16_t watermark )
{
 800b88c:	b508      	push	{r3, lr}

  if ( LSM6DSM_ACC_GYRO_W_FIFO_Watermark( handle, watermark ) == MEMS_ERROR )
 800b88e:	f7fe ffed 	bl	800a86c <LSM6DSM_ACC_GYRO_W_FIFO_Watermark>
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 800b892:	fab0 f080 	clz	r0, r0
 800b896:	0940      	lsrs	r0, r0, #5
 800b898:	bd08      	pop	{r3, pc}
 800b89a:	bf00      	nop

0800b89c <LSM6DSM_X_Get_Sensitivity>:
{
 800b89c:	b510      	push	{r4, lr}
 800b89e:	b082      	sub	sp, #8
 800b8a0:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_FS_XL( (void *)handle, &fullScale ) == MEMS_ERROR )
 800b8a2:	f10d 0107 	add.w	r1, sp, #7
 800b8a6:	f7fe feaf 	bl	800a608 <LSM6DSM_ACC_GYRO_R_FS_XL>
 800b8aa:	b160      	cbz	r0, 800b8c6 <LSM6DSM_X_Get_Sensitivity+0x2a>
  switch( fullScale )
 800b8ac:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b8b0:	2b0c      	cmp	r3, #12
 800b8b2:	d81f      	bhi.n	800b8f4 <LSM6DSM_X_Get_Sensitivity+0x58>
 800b8b4:	e8df f003 	tbb	[pc, r3]
 800b8b8:	1e1e1e0f 	.word	0x1e1e1e0f
 800b8bc:	1e1e1e14 	.word	0x1e1e1e14
 800b8c0:	1e1e1e19 	.word	0x1e1e1e19
 800b8c4:	0a          	.byte	0x0a
 800b8c5:	00          	.byte	0x00
    return COMPONENT_ERROR;
 800b8c6:	2001      	movs	r0, #1
}
 800b8c8:	b002      	add	sp, #8
 800b8ca:	bd10      	pop	{r4, pc}
      *sensitivity = ( float )LSM6DSM_ACC_SENSITIVITY_FOR_FS_8G;
 800b8cc:	4b0c      	ldr	r3, [pc, #48]	; (800b900 <LSM6DSM_X_Get_Sensitivity+0x64>)
 800b8ce:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800b8d0:	2000      	movs	r0, #0
}
 800b8d2:	b002      	add	sp, #8
 800b8d4:	bd10      	pop	{r4, pc}
      *sensitivity = ( float )LSM6DSM_ACC_SENSITIVITY_FOR_FS_2G;
 800b8d6:	4b0b      	ldr	r3, [pc, #44]	; (800b904 <LSM6DSM_X_Get_Sensitivity+0x68>)
 800b8d8:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800b8da:	2000      	movs	r0, #0
}
 800b8dc:	b002      	add	sp, #8
 800b8de:	bd10      	pop	{r4, pc}
      *sensitivity = ( float )LSM6DSM_ACC_SENSITIVITY_FOR_FS_16G;
 800b8e0:	4b09      	ldr	r3, [pc, #36]	; (800b908 <LSM6DSM_X_Get_Sensitivity+0x6c>)
 800b8e2:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800b8e4:	2000      	movs	r0, #0
}
 800b8e6:	b002      	add	sp, #8
 800b8e8:	bd10      	pop	{r4, pc}
      *sensitivity = ( float )LSM6DSM_ACC_SENSITIVITY_FOR_FS_4G;
 800b8ea:	4b08      	ldr	r3, [pc, #32]	; (800b90c <LSM6DSM_X_Get_Sensitivity+0x70>)
 800b8ec:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800b8ee:	2000      	movs	r0, #0
}
 800b8f0:	b002      	add	sp, #8
 800b8f2:	bd10      	pop	{r4, pc}
      *sensitivity = -1.0f;
 800b8f4:	4b06      	ldr	r3, [pc, #24]	; (800b910 <LSM6DSM_X_Get_Sensitivity+0x74>)
 800b8f6:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 800b8f8:	2001      	movs	r0, #1
}
 800b8fa:	b002      	add	sp, #8
 800b8fc:	bd10      	pop	{r4, pc}
 800b8fe:	bf00      	nop
 800b900:	3e79db23 	.word	0x3e79db23
 800b904:	3d79db23 	.word	0x3d79db23
 800b908:	3ef9db23 	.word	0x3ef9db23
 800b90c:	3df9db23 	.word	0x3df9db23
 800b910:	bf800000 	.word	0xbf800000

0800b914 <LSM6DSM_X_Get_FS>:
{
 800b914:	b510      	push	{r4, lr}
 800b916:	b082      	sub	sp, #8
 800b918:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_FS_XL( (void *)handle, &fs_low_level ) == MEMS_ERROR )
 800b91a:	f10d 0107 	add.w	r1, sp, #7
 800b91e:	f7fe fe73 	bl	800a608 <LSM6DSM_ACC_GYRO_R_FS_XL>
 800b922:	b160      	cbz	r0, 800b93e <LSM6DSM_X_Get_FS+0x2a>
  switch( fs_low_level )
 800b924:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b928:	2b0c      	cmp	r3, #12
 800b92a:	d823      	bhi.n	800b974 <LSM6DSM_X_Get_FS+0x60>
 800b92c:	e8df f003 	tbb	[pc, r3]
 800b930:	22222210 	.word	0x22222210
 800b934:	22222216 	.word	0x22222216
 800b938:	2222221c 	.word	0x2222221c
 800b93c:	0a          	.byte	0x0a
 800b93d:	00          	.byte	0x00
    return COMPONENT_ERROR;
 800b93e:	2001      	movs	r0, #1
}
 800b940:	b002      	add	sp, #8
 800b942:	bd10      	pop	{r4, pc}
      *fullScale =  8.0f;
 800b944:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
  return COMPONENT_OK;
 800b948:	2000      	movs	r0, #0
      *fullScale =  8.0f;
 800b94a:	6023      	str	r3, [r4, #0]
}
 800b94c:	b002      	add	sp, #8
 800b94e:	bd10      	pop	{r4, pc}
      *fullScale =  2.0f;
 800b950:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  return COMPONENT_OK;
 800b954:	2000      	movs	r0, #0
      *fullScale =  2.0f;
 800b956:	6023      	str	r3, [r4, #0]
}
 800b958:	b002      	add	sp, #8
 800b95a:	bd10      	pop	{r4, pc}
      *fullScale = 16.0f;
 800b95c:	f04f 4383 	mov.w	r3, #1098907648	; 0x41800000
  return COMPONENT_OK;
 800b960:	2000      	movs	r0, #0
      *fullScale = 16.0f;
 800b962:	6023      	str	r3, [r4, #0]
}
 800b964:	b002      	add	sp, #8
 800b966:	bd10      	pop	{r4, pc}
      *fullScale =  4.0f;
 800b968:	f04f 4381 	mov.w	r3, #1082130432	; 0x40800000
  return COMPONENT_OK;
 800b96c:	2000      	movs	r0, #0
      *fullScale =  4.0f;
 800b96e:	6023      	str	r3, [r4, #0]
}
 800b970:	b002      	add	sp, #8
 800b972:	bd10      	pop	{r4, pc}
      *fullScale = -1.0f;
 800b974:	4b02      	ldr	r3, [pc, #8]	; (800b980 <LSM6DSM_X_Get_FS+0x6c>)
 800b976:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 800b978:	2001      	movs	r0, #1
}
 800b97a:	b002      	add	sp, #8
 800b97c:	bd10      	pop	{r4, pc}
 800b97e:	bf00      	nop
 800b980:	bf800000 	.word	0xbf800000

0800b984 <LSM6DSM_FIFO_Get_Num_Of_Samples>:
{
 800b984:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_R_FIFONumOfEntries( handle, nSamples ) == MEMS_ERROR )
 800b986:	f7ff fa97 	bl	800aeb8 <LSM6DSM_ACC_GYRO_R_FIFONumOfEntries>
}
 800b98a:	fab0 f080 	clz	r0, r0
 800b98e:	0940      	lsrs	r0, r0, #5
 800b990:	bd08      	pop	{r3, pc}
 800b992:	bf00      	nop

0800b994 <LSM6DSM_FIFO_Get_Data>:
{
 800b994:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_Get_GetFIFOData( handle, aData ) == MEMS_ERROR )
 800b996:	f7ff ff27 	bl	800b7e8 <LSM6DSM_ACC_GYRO_Get_GetFIFOData>
}
 800b99a:	fab0 f080 	clz	r0, r0
 800b99e:	0940      	lsrs	r0, r0, #5
 800b9a0:	bd08      	pop	{r3, pc}
 800b9a2:	bf00      	nop

0800b9a4 <LSM6DSM_FIFO_X_Get_Axis>:
{
 800b9a4:	b570      	push	{r4, r5, r6, lr}
 800b9a6:	b082      	sub	sp, #8
  float sensitivity = 0;
 800b9a8:	2300      	movs	r3, #0
{
 800b9aa:	460d      	mov	r5, r1
  if ( LSM6DSM_ACC_GYRO_Get_GetFIFOData( handle, aData ) == MEMS_ERROR )
 800b9ac:	4669      	mov	r1, sp
  float sensitivity = 0;
 800b9ae:	9301      	str	r3, [sp, #4]
{
 800b9b0:	4604      	mov	r4, r0
  if ( LSM6DSM_ACC_GYRO_Get_GetFIFOData( handle, aData ) == MEMS_ERROR )
 800b9b2:	f7ff ff19 	bl	800b7e8 <LSM6DSM_ACC_GYRO_Get_GetFIFOData>
 800b9b6:	b910      	cbnz	r0, 800b9be <LSM6DSM_FIFO_X_Get_Axis+0x1a>
    return COMPONENT_ERROR;
 800b9b8:	2001      	movs	r0, #1
}
 800b9ba:	b002      	add	sp, #8
 800b9bc:	bd70      	pop	{r4, r5, r6, pc}
  if ( LSM6DSM_X_Get_Sensitivity( handle, &sensitivity ) == COMPONENT_ERROR )
 800b9be:	4620      	mov	r0, r4
 800b9c0:	a901      	add	r1, sp, #4
  rawData = ( aData[1] << 8 ) | aData[0];
 800b9c2:	f89d 6001 	ldrb.w	r6, [sp, #1]
 800b9c6:	f89d 4000 	ldrb.w	r4, [sp]
  if ( LSM6DSM_X_Get_Sensitivity( handle, &sensitivity ) == COMPONENT_ERROR )
 800b9ca:	f7ff ff67 	bl	800b89c <LSM6DSM_X_Get_Sensitivity>
 800b9ce:	2801      	cmp	r0, #1
 800b9d0:	d0f2      	beq.n	800b9b8 <LSM6DSM_FIFO_X_Get_Axis+0x14>
  rawData = ( aData[1] << 8 ) | aData[0];
 800b9d2:	ea44 2406 	orr.w	r4, r4, r6, lsl #8
  *acceleration = ( int32_t )( rawData * sensitivity );
 800b9d6:	b224      	sxth	r4, r4
 800b9d8:	ee07 4a90 	vmov	s15, r4
 800b9dc:	ed9d 7a01 	vldr	s14, [sp, #4]
 800b9e0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  return COMPONENT_OK;
 800b9e4:	2000      	movs	r0, #0
  *acceleration = ( int32_t )( rawData * sensitivity );
 800b9e6:	ee67 7a87 	vmul.f32	s15, s15, s14
 800b9ea:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800b9ee:	edc5 7a00 	vstr	s15, [r5]
}
 800b9f2:	b002      	add	sp, #8
 800b9f4:	bd70      	pop	{r4, r5, r6, pc}
 800b9f6:	bf00      	nop

0800b9f8 <LSM6DSM_FIFO_Get_Pattern>:
{
 800b9f8:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_R_FIFOPattern( handle, pattern ) == MEMS_ERROR )
 800b9fa:	f7ff fab1 	bl	800af60 <LSM6DSM_ACC_GYRO_R_FIFOPattern>
}
 800b9fe:	fab0 f080 	clz	r0, r0
 800ba02:	0940      	lsrs	r0, r0, #5
 800ba04:	bd08      	pop	{r3, pc}
 800ba06:	bf00      	nop

0800ba08 <LSM6DSM_FIFO_Get_Overrun_Status>:
{
 800ba08:	b510      	push	{r4, lr}
 800ba0a:	b082      	sub	sp, #8
 800ba0c:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_OVERRUN( handle, &status_raw ) == MEMS_ERROR )
 800ba0e:	f10d 0107 	add.w	r1, sp, #7
 800ba12:	f7ff fa95 	bl	800af40 <LSM6DSM_ACC_GYRO_R_OVERRUN>
 800ba16:	b120      	cbz	r0, 800ba22 <LSM6DSM_FIFO_Get_Overrun_Status+0x1a>
  switch( status_raw )
 800ba18:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800ba1c:	b148      	cbz	r0, 800ba32 <LSM6DSM_FIFO_Get_Overrun_Status+0x2a>
 800ba1e:	2840      	cmp	r0, #64	; 0x40
 800ba20:	d002      	beq.n	800ba28 <LSM6DSM_FIFO_Get_Overrun_Status+0x20>
      return COMPONENT_ERROR;
 800ba22:	2001      	movs	r0, #1
}
 800ba24:	b002      	add	sp, #8
 800ba26:	bd10      	pop	{r4, pc}
      *status = 1;
 800ba28:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800ba2a:	2000      	movs	r0, #0
      *status = 1;
 800ba2c:	7023      	strb	r3, [r4, #0]
}
 800ba2e:	b002      	add	sp, #8
 800ba30:	bd10      	pop	{r4, pc}
      *status = 0;
 800ba32:	7020      	strb	r0, [r4, #0]
}
 800ba34:	b002      	add	sp, #8
 800ba36:	bd10      	pop	{r4, pc}

0800ba38 <LSM6DSM_FIFO_Get_Empty_Status>:
{
 800ba38:	b510      	push	{r4, lr}
 800ba3a:	b082      	sub	sp, #8
 800ba3c:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_FIFOEmpty( handle, &status_raw ) == MEMS_ERROR )
 800ba3e:	f10d 0107 	add.w	r1, sp, #7
 800ba42:	f7ff fa5d 	bl	800af00 <LSM6DSM_ACC_GYRO_R_FIFOEmpty>
 800ba46:	b120      	cbz	r0, 800ba52 <LSM6DSM_FIFO_Get_Empty_Status+0x1a>
  switch( status_raw )
 800ba48:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800ba4c:	b148      	cbz	r0, 800ba62 <LSM6DSM_FIFO_Get_Empty_Status+0x2a>
 800ba4e:	2810      	cmp	r0, #16
 800ba50:	d002      	beq.n	800ba58 <LSM6DSM_FIFO_Get_Empty_Status+0x20>
      return COMPONENT_ERROR;
 800ba52:	2001      	movs	r0, #1
}
 800ba54:	b002      	add	sp, #8
 800ba56:	bd10      	pop	{r4, pc}
      *status = 1;
 800ba58:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800ba5a:	2000      	movs	r0, #0
      *status = 1;
 800ba5c:	7023      	strb	r3, [r4, #0]
}
 800ba5e:	b002      	add	sp, #8
 800ba60:	bd10      	pop	{r4, pc}
      *status = 0;
 800ba62:	7020      	strb	r0, [r4, #0]
}
 800ba64:	b002      	add	sp, #8
 800ba66:	bd10      	pop	{r4, pc}

0800ba68 <LSM6DSM_FIFO_Get_Full_Status>:
{
 800ba68:	b510      	push	{r4, lr}
 800ba6a:	b082      	sub	sp, #8
 800ba6c:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_FIFOFull( handle, &status_raw ) == MEMS_ERROR )
 800ba6e:	f10d 0107 	add.w	r1, sp, #7
 800ba72:	f7ff fa55 	bl	800af20 <LSM6DSM_ACC_GYRO_R_FIFOFull>
 800ba76:	b120      	cbz	r0, 800ba82 <LSM6DSM_FIFO_Get_Full_Status+0x1a>
  switch( status_raw )
 800ba78:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800ba7c:	b148      	cbz	r0, 800ba92 <LSM6DSM_FIFO_Get_Full_Status+0x2a>
 800ba7e:	2820      	cmp	r0, #32
 800ba80:	d002      	beq.n	800ba88 <LSM6DSM_FIFO_Get_Full_Status+0x20>
      return COMPONENT_ERROR;
 800ba82:	2001      	movs	r0, #1
}
 800ba84:	b002      	add	sp, #8
 800ba86:	bd10      	pop	{r4, pc}
      *status = 1;
 800ba88:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800ba8a:	2000      	movs	r0, #0
      *status = 1;
 800ba8c:	7023      	strb	r3, [r4, #0]
}
 800ba8e:	b002      	add	sp, #8
 800ba90:	bd10      	pop	{r4, pc}
      *status = 0;
 800ba92:	7020      	strb	r0, [r4, #0]
}
 800ba94:	b002      	add	sp, #8
 800ba96:	bd10      	pop	{r4, pc}

0800ba98 <LSM6DSM_FIFO_Set_ODR_Value>:
            : ( odr <=   25.0f ) ? LSM6DSM_ACC_GYRO_ODR_FIFO_25Hz
 800ba98:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 800ba9c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800baa0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 800baa4:	b508      	push	{r3, lr}
            : ( odr <=   25.0f ) ? LSM6DSM_ACC_GYRO_ODR_FIFO_25Hz
 800baa6:	d90d      	bls.n	800bac4 <LSM6DSM_FIFO_Set_ODR_Value+0x2c>
 800baa8:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
 800baac:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bab0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bab4:	d80d      	bhi.n	800bad2 <LSM6DSM_FIFO_Set_ODR_Value+0x3a>
 800bab6:	2110      	movs	r1, #16
  if ( LSM6DSM_ACC_GYRO_W_ODR_FIFO( handle, new_odr ) == MEMS_ERROR )
 800bab8:	f7fe ff96 	bl	800a9e8 <LSM6DSM_ACC_GYRO_W_ODR_FIFO>
}
 800babc:	fab0 f080 	clz	r0, r0
 800bac0:	0940      	lsrs	r0, r0, #5
 800bac2:	bd08      	pop	{r3, pc}
            : ( odr <=   25.0f ) ? LSM6DSM_ACC_GYRO_ODR_FIFO_25Hz
 800bac4:	2108      	movs	r1, #8
  if ( LSM6DSM_ACC_GYRO_W_ODR_FIFO( handle, new_odr ) == MEMS_ERROR )
 800bac6:	f7fe ff8f 	bl	800a9e8 <LSM6DSM_ACC_GYRO_W_ODR_FIFO>
}
 800baca:	fab0 f080 	clz	r0, r0
 800bace:	0940      	lsrs	r0, r0, #5
 800bad0:	bd08      	pop	{r3, pc}
            : ( odr <=   25.0f ) ? LSM6DSM_ACC_GYRO_ODR_FIFO_25Hz
 800bad2:	eddf 7a22 	vldr	s15, [pc, #136]	; 800bb5c <LSM6DSM_FIFO_Set_ODR_Value+0xc4>
 800bad6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bada:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bade:	d92c      	bls.n	800bb3a <LSM6DSM_FIFO_Set_ODR_Value+0xa2>
 800bae0:	eddf 7a1f 	vldr	s15, [pc, #124]	; 800bb60 <LSM6DSM_FIFO_Set_ODR_Value+0xc8>
 800bae4:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bae8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800baec:	d92c      	bls.n	800bb48 <LSM6DSM_FIFO_Set_ODR_Value+0xb0>
 800baee:	eddf 7a1d 	vldr	s15, [pc, #116]	; 800bb64 <LSM6DSM_FIFO_Set_ODR_Value+0xcc>
 800baf2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800baf6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bafa:	d927      	bls.n	800bb4c <LSM6DSM_FIFO_Set_ODR_Value+0xb4>
 800bafc:	eddf 7a1a 	vldr	s15, [pc, #104]	; 800bb68 <LSM6DSM_FIFO_Set_ODR_Value+0xd0>
 800bb00:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bb04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bb08:	d922      	bls.n	800bb50 <LSM6DSM_FIFO_Set_ODR_Value+0xb8>
 800bb0a:	eddf 7a18 	vldr	s15, [pc, #96]	; 800bb6c <LSM6DSM_FIFO_Set_ODR_Value+0xd4>
 800bb0e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bb12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bb16:	d91d      	bls.n	800bb54 <LSM6DSM_FIFO_Set_ODR_Value+0xbc>
 800bb18:	eddf 7a15 	vldr	s15, [pc, #84]	; 800bb70 <LSM6DSM_FIFO_Set_ODR_Value+0xd8>
 800bb1c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bb20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bb24:	d918      	bls.n	800bb58 <LSM6DSM_FIFO_Set_ODR_Value+0xc0>
 800bb26:	eddf 7a13 	vldr	s15, [pc, #76]	; 800bb74 <LSM6DSM_FIFO_Set_ODR_Value+0xdc>
 800bb2a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bb2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bb32:	bf94      	ite	ls
 800bb34:	2148      	movls	r1, #72	; 0x48
 800bb36:	2150      	movhi	r1, #80	; 0x50
 800bb38:	e7c5      	b.n	800bac6 <LSM6DSM_FIFO_Set_ODR_Value+0x2e>
 800bb3a:	2118      	movs	r1, #24
  if ( LSM6DSM_ACC_GYRO_W_ODR_FIFO( handle, new_odr ) == MEMS_ERROR )
 800bb3c:	f7fe ff54 	bl	800a9e8 <LSM6DSM_ACC_GYRO_W_ODR_FIFO>
}
 800bb40:	fab0 f080 	clz	r0, r0
 800bb44:	0940      	lsrs	r0, r0, #5
 800bb46:	bd08      	pop	{r3, pc}
            : ( odr <=   25.0f ) ? LSM6DSM_ACC_GYRO_ODR_FIFO_25Hz
 800bb48:	2120      	movs	r1, #32
 800bb4a:	e7bc      	b.n	800bac6 <LSM6DSM_FIFO_Set_ODR_Value+0x2e>
 800bb4c:	2128      	movs	r1, #40	; 0x28
 800bb4e:	e7ba      	b.n	800bac6 <LSM6DSM_FIFO_Set_ODR_Value+0x2e>
 800bb50:	2130      	movs	r1, #48	; 0x30
 800bb52:	e7b8      	b.n	800bac6 <LSM6DSM_FIFO_Set_ODR_Value+0x2e>
 800bb54:	2138      	movs	r1, #56	; 0x38
 800bb56:	e7b6      	b.n	800bac6 <LSM6DSM_FIFO_Set_ODR_Value+0x2e>
 800bb58:	2140      	movs	r1, #64	; 0x40
 800bb5a:	e7b4      	b.n	800bac6 <LSM6DSM_FIFO_Set_ODR_Value+0x2e>
 800bb5c:	42480000 	.word	0x42480000
 800bb60:	42c80000 	.word	0x42c80000
 800bb64:	43480000 	.word	0x43480000
 800bb68:	43c80000 	.word	0x43c80000
 800bb6c:	44480000 	.word	0x44480000
 800bb70:	44c80000 	.word	0x44c80000
 800bb74:	454e4000 	.word	0x454e4000

0800bb78 <LSM6DSM_X_Read_Reg>:
{
 800bb78:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 800bb7a:	2301      	movs	r3, #1
 800bb7c:	f7fe fce6 	bl	800a54c <LSM6DSM_ACC_GYRO_ReadReg>
}
 800bb80:	fab0 f080 	clz	r0, r0
 800bb84:	0940      	lsrs	r0, r0, #5
 800bb86:	bd08      	pop	{r3, pc}

0800bb88 <LSM6DSM_G_Read_Reg>:
 800bb88:	f7ff bff6 	b.w	800bb78 <LSM6DSM_X_Read_Reg>

0800bb8c <LSM6DSM_X_Get_Event_Status>:
{
 800bb8c:	b530      	push	{r4, r5, lr}
  uint8_t Wake_Up_Src = 0, Tap_Src = 0, D6D_Src = 0, Func_Src = 0, Md1_Cfg = 0, Md2_Cfg = 0, Int1_Ctrl = 0, Int2_Ctrl = 0;
 800bb8e:	2400      	movs	r4, #0
{
 800bb90:	b083      	sub	sp, #12
  memset((void *)status, 0x0, sizeof(ACCELERO_Event_Status_t));
 800bb92:	600c      	str	r4, [r1, #0]
{
 800bb94:	460d      	mov	r5, r1
  if ( LSM6DSM_ACC_GYRO_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 800bb96:	2301      	movs	r3, #1
 800bb98:	466a      	mov	r2, sp
 800bb9a:	211b      	movs	r1, #27
  uint8_t Wake_Up_Src = 0, Tap_Src = 0, D6D_Src = 0, Func_Src = 0, Md1_Cfg = 0, Md2_Cfg = 0, Int1_Ctrl = 0, Int2_Ctrl = 0;
 800bb9c:	f88d 4000 	strb.w	r4, [sp]
 800bba0:	f88d 4001 	strb.w	r4, [sp, #1]
 800bba4:	f88d 4002 	strb.w	r4, [sp, #2]
 800bba8:	f88d 4003 	strb.w	r4, [sp, #3]
 800bbac:	f88d 4004 	strb.w	r4, [sp, #4]
 800bbb0:	f88d 4005 	strb.w	r4, [sp, #5]
 800bbb4:	f88d 4006 	strb.w	r4, [sp, #6]
 800bbb8:	f88d 4007 	strb.w	r4, [sp, #7]
{
 800bbbc:	4604      	mov	r4, r0
  if ( LSM6DSM_ACC_GYRO_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 800bbbe:	f7fe fcc5 	bl	800a54c <LSM6DSM_ACC_GYRO_ReadReg>
 800bbc2:	b910      	cbnz	r0, 800bbca <LSM6DSM_X_Get_Event_Status+0x3e>
    return COMPONENT_ERROR;
 800bbc4:	2001      	movs	r0, #1
}
 800bbc6:	b003      	add	sp, #12
 800bbc8:	bd30      	pop	{r4, r5, pc}
  if ( LSM6DSM_ACC_GYRO_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 800bbca:	2301      	movs	r3, #1
 800bbcc:	eb0d 0203 	add.w	r2, sp, r3
 800bbd0:	211c      	movs	r1, #28
 800bbd2:	4620      	mov	r0, r4
 800bbd4:	f7fe fcba 	bl	800a54c <LSM6DSM_ACC_GYRO_ReadReg>
 800bbd8:	2800      	cmp	r0, #0
 800bbda:	d0f3      	beq.n	800bbc4 <LSM6DSM_X_Get_Event_Status+0x38>
 800bbdc:	2301      	movs	r3, #1
 800bbde:	f10d 0202 	add.w	r2, sp, #2
 800bbe2:	211d      	movs	r1, #29
 800bbe4:	4620      	mov	r0, r4
 800bbe6:	f7fe fcb1 	bl	800a54c <LSM6DSM_ACC_GYRO_ReadReg>
 800bbea:	2800      	cmp	r0, #0
 800bbec:	d0ea      	beq.n	800bbc4 <LSM6DSM_X_Get_Event_Status+0x38>
 800bbee:	2301      	movs	r3, #1
 800bbf0:	f10d 0203 	add.w	r2, sp, #3
 800bbf4:	2153      	movs	r1, #83	; 0x53
 800bbf6:	4620      	mov	r0, r4
 800bbf8:	f7fe fca8 	bl	800a54c <LSM6DSM_ACC_GYRO_ReadReg>
 800bbfc:	2800      	cmp	r0, #0
 800bbfe:	d0e1      	beq.n	800bbc4 <LSM6DSM_X_Get_Event_Status+0x38>
 800bc00:	2301      	movs	r3, #1
 800bc02:	aa01      	add	r2, sp, #4
 800bc04:	215e      	movs	r1, #94	; 0x5e
 800bc06:	4620      	mov	r0, r4
 800bc08:	f7fe fca0 	bl	800a54c <LSM6DSM_ACC_GYRO_ReadReg>
 800bc0c:	2800      	cmp	r0, #0
 800bc0e:	d0d9      	beq.n	800bbc4 <LSM6DSM_X_Get_Event_Status+0x38>
 800bc10:	2301      	movs	r3, #1
 800bc12:	f10d 0205 	add.w	r2, sp, #5
 800bc16:	215f      	movs	r1, #95	; 0x5f
 800bc18:	4620      	mov	r0, r4
 800bc1a:	f7fe fc97 	bl	800a54c <LSM6DSM_ACC_GYRO_ReadReg>
 800bc1e:	2800      	cmp	r0, #0
 800bc20:	d0d0      	beq.n	800bbc4 <LSM6DSM_X_Get_Event_Status+0x38>
 800bc22:	2301      	movs	r3, #1
 800bc24:	f10d 0206 	add.w	r2, sp, #6
 800bc28:	210d      	movs	r1, #13
 800bc2a:	4620      	mov	r0, r4
 800bc2c:	f7fe fc8e 	bl	800a54c <LSM6DSM_ACC_GYRO_ReadReg>
 800bc30:	2800      	cmp	r0, #0
 800bc32:	d0c7      	beq.n	800bbc4 <LSM6DSM_X_Get_Event_Status+0x38>
 800bc34:	4620      	mov	r0, r4
 800bc36:	2301      	movs	r3, #1
 800bc38:	f10d 0207 	add.w	r2, sp, #7
 800bc3c:	210e      	movs	r1, #14
 800bc3e:	f7fe fc85 	bl	800a54c <LSM6DSM_ACC_GYRO_ReadReg>
 800bc42:	2800      	cmp	r0, #0
 800bc44:	d0be      	beq.n	800bbc4 <LSM6DSM_X_Get_Event_Status+0x38>
  if((Md1_Cfg & LSM6DSM_ACC_GYRO_INT1_FF_MASK) || (Md2_Cfg & LSM6DSM_ACC_GYRO_INT2_FF_MASK))
 800bc46:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800bc4a:	06dc      	lsls	r4, r3, #27
 800bc4c:	d403      	bmi.n	800bc56 <LSM6DSM_X_Get_Event_Status+0xca>
 800bc4e:	f89d 2005 	ldrb.w	r2, [sp, #5]
 800bc52:	06d0      	lsls	r0, r2, #27
 800bc54:	d507      	bpl.n	800bc66 <LSM6DSM_X_Get_Event_Status+0xda>
    if((Wake_Up_Src & LSM6DSM_ACC_GYRO_FF_EV_STATUS_MASK))
 800bc56:	f89d 2000 	ldrb.w	r2, [sp]
 800bc5a:	0691      	lsls	r1, r2, #26
 800bc5c:	d503      	bpl.n	800bc66 <LSM6DSM_X_Get_Event_Status+0xda>
      status->FreeFallStatus = 1;  
 800bc5e:	782a      	ldrb	r2, [r5, #0]
 800bc60:	f042 0201 	orr.w	r2, r2, #1
 800bc64:	702a      	strb	r2, [r5, #0]
  if((Md1_Cfg & LSM6DSM_ACC_GYRO_INT1_WU_MASK) || (Md2_Cfg & LSM6DSM_ACC_GYRO_INT2_WU_MASK))
 800bc66:	069a      	lsls	r2, r3, #26
 800bc68:	d403      	bmi.n	800bc72 <LSM6DSM_X_Get_Event_Status+0xe6>
 800bc6a:	f89d 2005 	ldrb.w	r2, [sp, #5]
 800bc6e:	0694      	lsls	r4, r2, #26
 800bc70:	d507      	bpl.n	800bc82 <LSM6DSM_X_Get_Event_Status+0xf6>
    if((Wake_Up_Src & LSM6DSM_ACC_GYRO_WU_EV_STATUS_MASK))
 800bc72:	f89d 2000 	ldrb.w	r2, [sp]
 800bc76:	0710      	lsls	r0, r2, #28
 800bc78:	d503      	bpl.n	800bc82 <LSM6DSM_X_Get_Event_Status+0xf6>
      status->WakeUpStatus = 1;  
 800bc7a:	782a      	ldrb	r2, [r5, #0]
 800bc7c:	f042 0208 	orr.w	r2, r2, #8
 800bc80:	702a      	strb	r2, [r5, #0]
  if((Md1_Cfg & LSM6DSM_ACC_GYRO_INT1_SINGLE_TAP_MASK) || (Md2_Cfg & LSM6DSM_ACC_GYRO_INT2_SINGLE_TAP_MASK))
 800bc82:	0659      	lsls	r1, r3, #25
 800bc84:	d403      	bmi.n	800bc8e <LSM6DSM_X_Get_Event_Status+0x102>
 800bc86:	f89d 2005 	ldrb.w	r2, [sp, #5]
 800bc8a:	0652      	lsls	r2, r2, #25
 800bc8c:	d507      	bpl.n	800bc9e <LSM6DSM_X_Get_Event_Status+0x112>
    if((Tap_Src & LSM6DSM_ACC_GYRO_SINGLE_TAP_EV_STATUS_MASK))
 800bc8e:	f89d 2001 	ldrb.w	r2, [sp, #1]
 800bc92:	0694      	lsls	r4, r2, #26
 800bc94:	d503      	bpl.n	800bc9e <LSM6DSM_X_Get_Event_Status+0x112>
      status->TapStatus = 1;  
 800bc96:	782a      	ldrb	r2, [r5, #0]
 800bc98:	f042 0202 	orr.w	r2, r2, #2
 800bc9c:	702a      	strb	r2, [r5, #0]
  if((Md1_Cfg & LSM6DSM_ACC_GYRO_INT1_TAP_MASK) || (Md2_Cfg & LSM6DSM_ACC_GYRO_INT2_TAP_MASK))
 800bc9e:	0718      	lsls	r0, r3, #28
 800bca0:	d403      	bmi.n	800bcaa <LSM6DSM_X_Get_Event_Status+0x11e>
 800bca2:	f89d 2005 	ldrb.w	r2, [sp, #5]
 800bca6:	0711      	lsls	r1, r2, #28
 800bca8:	d507      	bpl.n	800bcba <LSM6DSM_X_Get_Event_Status+0x12e>
    if((Tap_Src & LSM6DSM_ACC_GYRO_DOUBLE_TAP_EV_STATUS_MASK))
 800bcaa:	f89d 2001 	ldrb.w	r2, [sp, #1]
 800bcae:	06d2      	lsls	r2, r2, #27
 800bcb0:	d503      	bpl.n	800bcba <LSM6DSM_X_Get_Event_Status+0x12e>
      status->DoubleTapStatus = 1;  
 800bcb2:	782a      	ldrb	r2, [r5, #0]
 800bcb4:	f042 0204 	orr.w	r2, r2, #4
 800bcb8:	702a      	strb	r2, [r5, #0]
  if((Md1_Cfg & LSM6DSM_ACC_GYRO_INT1_6D_MASK) || (Md2_Cfg & LSM6DSM_ACC_GYRO_INT2_6D_MASK))
 800bcba:	075c      	lsls	r4, r3, #29
 800bcbc:	d403      	bmi.n	800bcc6 <LSM6DSM_X_Get_Event_Status+0x13a>
 800bcbe:	f89d 2005 	ldrb.w	r2, [sp, #5]
 800bcc2:	0750      	lsls	r0, r2, #29
 800bcc4:	d507      	bpl.n	800bcd6 <LSM6DSM_X_Get_Event_Status+0x14a>
    if((D6D_Src & LSM6DSM_ACC_GYRO_D6D_EV_STATUS_MASK))
 800bcc6:	f89d 2002 	ldrb.w	r2, [sp, #2]
 800bcca:	0651      	lsls	r1, r2, #25
 800bccc:	d503      	bpl.n	800bcd6 <LSM6DSM_X_Get_Event_Status+0x14a>
      status->D6DOrientationStatus = 1;  
 800bcce:	782a      	ldrb	r2, [r5, #0]
 800bcd0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800bcd4:	702a      	strb	r2, [r5, #0]
  if((Int1_Ctrl & LSM6DSM_ACC_GYRO_INT1_PEDO_MASK) || (Int2_Ctrl & LSM6DSM_ACC_GYRO_INT2_STEP_DELTA_MASK))
 800bcd6:	f99d 2006 	ldrsb.w	r2, [sp, #6]
 800bcda:	2a00      	cmp	r2, #0
 800bcdc:	db15      	blt.n	800bd0a <LSM6DSM_X_Get_Event_Status+0x17e>
 800bcde:	f99d 2007 	ldrsb.w	r2, [sp, #7]
 800bce2:	2a00      	cmp	r2, #0
 800bce4:	db11      	blt.n	800bd0a <LSM6DSM_X_Get_Event_Status+0x17e>
  if((Md1_Cfg & LSM6DSM_ACC_GYRO_INT1_TILT_MASK) || (Md2_Cfg & LSM6DSM_ACC_GYRO_INT2_TILT_MASK))
 800bce6:	079b      	lsls	r3, r3, #30
 800bce8:	d404      	bmi.n	800bcf4 <LSM6DSM_X_Get_Event_Status+0x168>
 800bcea:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800bcee:	f013 0302 	ands.w	r3, r3, #2
 800bcf2:	d008      	beq.n	800bd06 <LSM6DSM_X_Get_Event_Status+0x17a>
    if((Func_Src & LSM6DSM_ACC_GYRO_TILT_EV_STATUS_MASK))
 800bcf4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800bcf8:	f013 0320 	ands.w	r3, r3, #32
 800bcfc:	d00e      	beq.n	800bd1c <LSM6DSM_X_Get_Event_Status+0x190>
      status->TiltStatus = 1;  
 800bcfe:	782b      	ldrb	r3, [r5, #0]
 800bd00:	f043 0320 	orr.w	r3, r3, #32
 800bd04:	702b      	strb	r3, [r5, #0]
  return COMPONENT_OK;
 800bd06:	2000      	movs	r0, #0
 800bd08:	e75d      	b.n	800bbc6 <LSM6DSM_X_Get_Event_Status+0x3a>
    if((Func_Src & LSM6DSM_ACC_GYRO_PEDO_EV_STATUS_MASK))
 800bd0a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800bd0e:	06d2      	lsls	r2, r2, #27
 800bd10:	d5e9      	bpl.n	800bce6 <LSM6DSM_X_Get_Event_Status+0x15a>
      status->StepStatus = 1;  
 800bd12:	782a      	ldrb	r2, [r5, #0]
 800bd14:	f042 0210 	orr.w	r2, r2, #16
 800bd18:	702a      	strb	r2, [r5, #0]
 800bd1a:	e7e4      	b.n	800bce6 <LSM6DSM_X_Get_Event_Status+0x15a>
  return COMPONENT_OK;
 800bd1c:	4618      	mov	r0, r3
 800bd1e:	e752      	b.n	800bbc6 <LSM6DSM_X_Get_Event_Status+0x3a>

0800bd20 <LSM6DSM_X_Get_6D_Orientation_ZH>:
{
 800bd20:	b510      	push	{r4, lr}
 800bd22:	b082      	sub	sp, #8
 800bd24:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_DSD_ZH( (void *)handle, &zh_raw ) == MEMS_ERROR )
 800bd26:	f10d 0107 	add.w	r1, sp, #7
 800bd2a:	f7ff f885 	bl	800ae38 <LSM6DSM_ACC_GYRO_R_DSD_ZH>
 800bd2e:	b120      	cbz	r0, 800bd3a <LSM6DSM_X_Get_6D_Orientation_ZH+0x1a>
  switch( zh_raw )
 800bd30:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800bd34:	b148      	cbz	r0, 800bd4a <LSM6DSM_X_Get_6D_Orientation_ZH+0x2a>
 800bd36:	2820      	cmp	r0, #32
 800bd38:	d002      	beq.n	800bd40 <LSM6DSM_X_Get_6D_Orientation_ZH+0x20>
      return COMPONENT_ERROR;
 800bd3a:	2001      	movs	r0, #1
}
 800bd3c:	b002      	add	sp, #8
 800bd3e:	bd10      	pop	{r4, pc}
      *zh = 1;
 800bd40:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800bd42:	2000      	movs	r0, #0
      *zh = 1;
 800bd44:	7023      	strb	r3, [r4, #0]
}
 800bd46:	b002      	add	sp, #8
 800bd48:	bd10      	pop	{r4, pc}
      *zh = 0;
 800bd4a:	7020      	strb	r0, [r4, #0]
}
 800bd4c:	b002      	add	sp, #8
 800bd4e:	bd10      	pop	{r4, pc}

0800bd50 <LSM6DSM_X_Get_6D_Orientation_ZL>:
{
 800bd50:	b510      	push	{r4, lr}
 800bd52:	b082      	sub	sp, #8
 800bd54:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_DSD_ZL( (void *)handle, &zl_raw ) == MEMS_ERROR )
 800bd56:	f10d 0107 	add.w	r1, sp, #7
 800bd5a:	f7ff f85d 	bl	800ae18 <LSM6DSM_ACC_GYRO_R_DSD_ZL>
 800bd5e:	b120      	cbz	r0, 800bd6a <LSM6DSM_X_Get_6D_Orientation_ZL+0x1a>
  switch( zl_raw )
 800bd60:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800bd64:	b148      	cbz	r0, 800bd7a <LSM6DSM_X_Get_6D_Orientation_ZL+0x2a>
 800bd66:	2810      	cmp	r0, #16
 800bd68:	d002      	beq.n	800bd70 <LSM6DSM_X_Get_6D_Orientation_ZL+0x20>
      return COMPONENT_ERROR;
 800bd6a:	2001      	movs	r0, #1
}
 800bd6c:	b002      	add	sp, #8
 800bd6e:	bd10      	pop	{r4, pc}
      *zl = 1;
 800bd70:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800bd72:	2000      	movs	r0, #0
      *zl = 1;
 800bd74:	7023      	strb	r3, [r4, #0]
}
 800bd76:	b002      	add	sp, #8
 800bd78:	bd10      	pop	{r4, pc}
      *zl = 0;
 800bd7a:	7020      	strb	r0, [r4, #0]
}
 800bd7c:	b002      	add	sp, #8
 800bd7e:	bd10      	pop	{r4, pc}

0800bd80 <LSM6DSM_X_Get_6D_Orientation_YH>:
{
 800bd80:	b510      	push	{r4, lr}
 800bd82:	b082      	sub	sp, #8
 800bd84:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_DSD_YH( (void *)handle, &yh_raw ) == MEMS_ERROR )
 800bd86:	f10d 0107 	add.w	r1, sp, #7
 800bd8a:	f7ff f835 	bl	800adf8 <LSM6DSM_ACC_GYRO_R_DSD_YH>
 800bd8e:	b120      	cbz	r0, 800bd9a <LSM6DSM_X_Get_6D_Orientation_YH+0x1a>
  switch( yh_raw )
 800bd90:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800bd94:	b148      	cbz	r0, 800bdaa <LSM6DSM_X_Get_6D_Orientation_YH+0x2a>
 800bd96:	2808      	cmp	r0, #8
 800bd98:	d002      	beq.n	800bda0 <LSM6DSM_X_Get_6D_Orientation_YH+0x20>
      return COMPONENT_ERROR;
 800bd9a:	2001      	movs	r0, #1
}
 800bd9c:	b002      	add	sp, #8
 800bd9e:	bd10      	pop	{r4, pc}
      *yh = 1;
 800bda0:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800bda2:	2000      	movs	r0, #0
      *yh = 1;
 800bda4:	7023      	strb	r3, [r4, #0]
}
 800bda6:	b002      	add	sp, #8
 800bda8:	bd10      	pop	{r4, pc}
      *yh = 0;
 800bdaa:	7020      	strb	r0, [r4, #0]
}
 800bdac:	b002      	add	sp, #8
 800bdae:	bd10      	pop	{r4, pc}

0800bdb0 <LSM6DSM_X_Get_6D_Orientation_YL>:
{
 800bdb0:	b510      	push	{r4, lr}
 800bdb2:	b082      	sub	sp, #8
 800bdb4:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_DSD_YL( (void *)handle, &yl_raw ) == MEMS_ERROR )
 800bdb6:	f10d 0107 	add.w	r1, sp, #7
 800bdba:	f7ff f80d 	bl	800add8 <LSM6DSM_ACC_GYRO_R_DSD_YL>
 800bdbe:	b120      	cbz	r0, 800bdca <LSM6DSM_X_Get_6D_Orientation_YL+0x1a>
  switch( yl_raw )
 800bdc0:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800bdc4:	b148      	cbz	r0, 800bdda <LSM6DSM_X_Get_6D_Orientation_YL+0x2a>
 800bdc6:	2804      	cmp	r0, #4
 800bdc8:	d002      	beq.n	800bdd0 <LSM6DSM_X_Get_6D_Orientation_YL+0x20>
      return COMPONENT_ERROR;
 800bdca:	2001      	movs	r0, #1
}
 800bdcc:	b002      	add	sp, #8
 800bdce:	bd10      	pop	{r4, pc}
      *yl = 1;
 800bdd0:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800bdd2:	2000      	movs	r0, #0
      *yl = 1;
 800bdd4:	7023      	strb	r3, [r4, #0]
}
 800bdd6:	b002      	add	sp, #8
 800bdd8:	bd10      	pop	{r4, pc}
      *yl = 0;
 800bdda:	7020      	strb	r0, [r4, #0]
}
 800bddc:	b002      	add	sp, #8
 800bdde:	bd10      	pop	{r4, pc}

0800bde0 <LSM6DSM_X_Get_6D_Orientation_XH>:
{
 800bde0:	b510      	push	{r4, lr}
 800bde2:	b082      	sub	sp, #8
 800bde4:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_DSD_XH( (void *)handle, &xh_raw ) == MEMS_ERROR )
 800bde6:	f10d 0107 	add.w	r1, sp, #7
 800bdea:	f7fe ffe5 	bl	800adb8 <LSM6DSM_ACC_GYRO_R_DSD_XH>
 800bdee:	b120      	cbz	r0, 800bdfa <LSM6DSM_X_Get_6D_Orientation_XH+0x1a>
  switch( xh_raw )
 800bdf0:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800bdf4:	b148      	cbz	r0, 800be0a <LSM6DSM_X_Get_6D_Orientation_XH+0x2a>
 800bdf6:	2802      	cmp	r0, #2
 800bdf8:	d002      	beq.n	800be00 <LSM6DSM_X_Get_6D_Orientation_XH+0x20>
      return COMPONENT_ERROR;
 800bdfa:	2001      	movs	r0, #1
}
 800bdfc:	b002      	add	sp, #8
 800bdfe:	bd10      	pop	{r4, pc}
      *xh = 1;
 800be00:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800be02:	2000      	movs	r0, #0
      *xh = 1;
 800be04:	7023      	strb	r3, [r4, #0]
}
 800be06:	b002      	add	sp, #8
 800be08:	bd10      	pop	{r4, pc}
      *xh = 0;
 800be0a:	7020      	strb	r0, [r4, #0]
}
 800be0c:	b002      	add	sp, #8
 800be0e:	bd10      	pop	{r4, pc}

0800be10 <LSM6DSM_X_Get_6D_Orientation_XL>:
{
 800be10:	b510      	push	{r4, lr}
 800be12:	b082      	sub	sp, #8
 800be14:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_DSD_XL( (void *)handle, &xl_raw ) == MEMS_ERROR )
 800be16:	f10d 0107 	add.w	r1, sp, #7
 800be1a:	f7fe ffbd 	bl	800ad98 <LSM6DSM_ACC_GYRO_R_DSD_XL>
 800be1e:	b120      	cbz	r0, 800be2a <LSM6DSM_X_Get_6D_Orientation_XL+0x1a>
  switch( xl_raw )
 800be20:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800be24:	b140      	cbz	r0, 800be38 <LSM6DSM_X_Get_6D_Orientation_XL+0x28>
 800be26:	2801      	cmp	r0, #1
 800be28:	d002      	beq.n	800be30 <LSM6DSM_X_Get_6D_Orientation_XL+0x20>
      return COMPONENT_ERROR;
 800be2a:	2001      	movs	r0, #1
}
 800be2c:	b002      	add	sp, #8
 800be2e:	bd10      	pop	{r4, pc}
      *xl = 1;
 800be30:	7020      	strb	r0, [r4, #0]
  return COMPONENT_OK;
 800be32:	2000      	movs	r0, #0
}
 800be34:	b002      	add	sp, #8
 800be36:	bd10      	pop	{r4, pc}
      *xl = 0;
 800be38:	7020      	strb	r0, [r4, #0]
}
 800be3a:	b002      	add	sp, #8
 800be3c:	bd10      	pop	{r4, pc}
 800be3e:	bf00      	nop

0800be40 <LSM6DSM_X_Get_6D_Orientation_Status>:
{
 800be40:	b510      	push	{r4, lr}
 800be42:	b082      	sub	sp, #8
 800be44:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_D6D_EV_STATUS( (void *)handle, &status_raw ) == MEMS_ERROR )
 800be46:	f10d 0107 	add.w	r1, sp, #7
 800be4a:	f7ff f805 	bl	800ae58 <LSM6DSM_ACC_GYRO_R_D6D_EV_STATUS>
 800be4e:	b120      	cbz	r0, 800be5a <LSM6DSM_X_Get_6D_Orientation_Status+0x1a>
  switch( status_raw )
 800be50:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800be54:	b148      	cbz	r0, 800be6a <LSM6DSM_X_Get_6D_Orientation_Status+0x2a>
 800be56:	2840      	cmp	r0, #64	; 0x40
 800be58:	d002      	beq.n	800be60 <LSM6DSM_X_Get_6D_Orientation_Status+0x20>
      return COMPONENT_ERROR;
 800be5a:	2001      	movs	r0, #1
}
 800be5c:	b002      	add	sp, #8
 800be5e:	bd10      	pop	{r4, pc}
      *status = 1;
 800be60:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800be62:	2000      	movs	r0, #0
      *status = 1;
 800be64:	7023      	strb	r3, [r4, #0]
}
 800be66:	b002      	add	sp, #8
 800be68:	bd10      	pop	{r4, pc}
      *status = 0;
 800be6a:	7020      	strb	r0, [r4, #0]
}
 800be6c:	b002      	add	sp, #8
 800be6e:	bd10      	pop	{r4, pc}

0800be70 <LSM6DSM_X_Set_FS_Value>:
           : ( fullScale <= 4.0f ) ? LSM6DSM_ACC_GYRO_FS_XL_4g
 800be70:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 800be74:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800be78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 800be7c:	b508      	push	{r3, lr}
           : ( fullScale <= 4.0f ) ? LSM6DSM_ACC_GYRO_FS_XL_4g
 800be7e:	d90d      	bls.n	800be9c <LSM6DSM_X_Set_FS_Value+0x2c>
 800be80:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
 800be84:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800be88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800be8c:	d80d      	bhi.n	800beaa <LSM6DSM_X_Set_FS_Value+0x3a>
 800be8e:	2108      	movs	r1, #8
  if ( LSM6DSM_ACC_GYRO_W_FS_XL( (void *)handle, new_fs ) == MEMS_ERROR )
 800be90:	f7fe fb98 	bl	800a5c4 <LSM6DSM_ACC_GYRO_W_FS_XL>
}
 800be94:	fab0 f080 	clz	r0, r0
 800be98:	0940      	lsrs	r0, r0, #5
 800be9a:	bd08      	pop	{r3, pc}
           : ( fullScale <= 4.0f ) ? LSM6DSM_ACC_GYRO_FS_XL_4g
 800be9c:	2100      	movs	r1, #0
  if ( LSM6DSM_ACC_GYRO_W_FS_XL( (void *)handle, new_fs ) == MEMS_ERROR )
 800be9e:	f7fe fb91 	bl	800a5c4 <LSM6DSM_ACC_GYRO_W_FS_XL>
}
 800bea2:	fab0 f080 	clz	r0, r0
 800bea6:	0940      	lsrs	r0, r0, #5
 800bea8:	bd08      	pop	{r3, pc}
           : ( fullScale <= 4.0f ) ? LSM6DSM_ACC_GYRO_FS_XL_4g
 800beaa:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 800beae:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800beb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800beb6:	bf94      	ite	ls
 800beb8:	210c      	movls	r1, #12
 800beba:	2104      	movhi	r1, #4
  if ( LSM6DSM_ACC_GYRO_W_FS_XL( (void *)handle, new_fs ) == MEMS_ERROR )
 800bebc:	f7fe fb82 	bl	800a5c4 <LSM6DSM_ACC_GYRO_W_FS_XL>
}
 800bec0:	fab0 f080 	clz	r0, r0
 800bec4:	0940      	lsrs	r0, r0, #5
 800bec6:	bd08      	pop	{r3, pc}

0800bec8 <LSM6DSM_X_Set_FS>:
  switch( fullScale )
 800bec8:	2902      	cmp	r1, #2
 800beca:	d00c      	beq.n	800bee6 <LSM6DSM_X_Set_FS+0x1e>
 800becc:	2904      	cmp	r1, #4
 800bece:	d002      	beq.n	800bed6 <LSM6DSM_X_Set_FS+0xe>
 800bed0:	b111      	cbz	r1, 800bed8 <LSM6DSM_X_Set_FS+0x10>
      return COMPONENT_ERROR;
 800bed2:	2001      	movs	r0, #1
}
 800bed4:	4770      	bx	lr
      new_fs = LSM6DSM_ACC_GYRO_FS_XL_8g;
 800bed6:	210c      	movs	r1, #12
{
 800bed8:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_FS_XL( (void *)handle, new_fs ) == MEMS_ERROR )
 800beda:	f7fe fb73 	bl	800a5c4 <LSM6DSM_ACC_GYRO_W_FS_XL>
      return COMPONENT_ERROR;
 800bede:	fab0 f080 	clz	r0, r0
 800bee2:	0940      	lsrs	r0, r0, #5
}
 800bee4:	bd08      	pop	{r3, pc}
      new_fs = LSM6DSM_ACC_GYRO_FS_XL_4g;
 800bee6:	2108      	movs	r1, #8
{
 800bee8:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_FS_XL( (void *)handle, new_fs ) == MEMS_ERROR )
 800beea:	f7fe fb6b 	bl	800a5c4 <LSM6DSM_ACC_GYRO_W_FS_XL>
      return COMPONENT_ERROR;
 800beee:	fab0 f080 	clz	r0, r0
 800bef2:	0940      	lsrs	r0, r0, #5
}
 800bef4:	bd08      	pop	{r3, pc}
 800bef6:	bf00      	nop

0800bef8 <LSM6DSM_X_Set_ODR_Value_When_Enabled>:
            : ( odr <=   26.0f ) ? LSM6DSM_ACC_GYRO_ODR_XL_26Hz
 800bef8:	eef2 7a0a 	vmov.f32	s15, #42	; 0x41500000  13.0
 800befc:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bf00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 800bf04:	b508      	push	{r3, lr}
            : ( odr <=   26.0f ) ? LSM6DSM_ACC_GYRO_ODR_XL_26Hz
 800bf06:	d90d      	bls.n	800bf24 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0x2c>
 800bf08:	eef3 7a0a 	vmov.f32	s15, #58	; 0x41d00000  26.0
 800bf0c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bf10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bf14:	d80d      	bhi.n	800bf32 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0x3a>
 800bf16:	2120      	movs	r1, #32
  if ( LSM6DSM_ACC_GYRO_W_ODR_XL( (void *)handle, new_odr ) == MEMS_ERROR )
 800bf18:	f7fe fba2 	bl	800a660 <LSM6DSM_ACC_GYRO_W_ODR_XL>
}
 800bf1c:	fab0 f080 	clz	r0, r0
 800bf20:	0940      	lsrs	r0, r0, #5
 800bf22:	bd08      	pop	{r3, pc}
            : ( odr <=   26.0f ) ? LSM6DSM_ACC_GYRO_ODR_XL_26Hz
 800bf24:	2110      	movs	r1, #16
  if ( LSM6DSM_ACC_GYRO_W_ODR_XL( (void *)handle, new_odr ) == MEMS_ERROR )
 800bf26:	f7fe fb9b 	bl	800a660 <LSM6DSM_ACC_GYRO_W_ODR_XL>
}
 800bf2a:	fab0 f080 	clz	r0, r0
 800bf2e:	0940      	lsrs	r0, r0, #5
 800bf30:	bd08      	pop	{r3, pc}
            : ( odr <=   26.0f ) ? LSM6DSM_ACC_GYRO_ODR_XL_26Hz
 800bf32:	eddf 7a22 	vldr	s15, [pc, #136]	; 800bfbc <LSM6DSM_X_Set_ODR_Value_When_Enabled+0xc4>
 800bf36:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bf3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bf3e:	d92c      	bls.n	800bf9a <LSM6DSM_X_Set_ODR_Value_When_Enabled+0xa2>
 800bf40:	eddf 7a1f 	vldr	s15, [pc, #124]	; 800bfc0 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0xc8>
 800bf44:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bf48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bf4c:	d92c      	bls.n	800bfa8 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0xb0>
 800bf4e:	eddf 7a1d 	vldr	s15, [pc, #116]	; 800bfc4 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0xcc>
 800bf52:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bf56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bf5a:	d927      	bls.n	800bfac <LSM6DSM_X_Set_ODR_Value_When_Enabled+0xb4>
 800bf5c:	eddf 7a1a 	vldr	s15, [pc, #104]	; 800bfc8 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0xd0>
 800bf60:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bf64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bf68:	d922      	bls.n	800bfb0 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0xb8>
 800bf6a:	eddf 7a18 	vldr	s15, [pc, #96]	; 800bfcc <LSM6DSM_X_Set_ODR_Value_When_Enabled+0xd4>
 800bf6e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bf72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bf76:	d91d      	bls.n	800bfb4 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0xbc>
 800bf78:	eddf 7a15 	vldr	s15, [pc, #84]	; 800bfd0 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0xd8>
 800bf7c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bf80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bf84:	d918      	bls.n	800bfb8 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0xc0>
 800bf86:	eddf 7a13 	vldr	s15, [pc, #76]	; 800bfd4 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0xdc>
 800bf8a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bf8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bf92:	bf94      	ite	ls
 800bf94:	2190      	movls	r1, #144	; 0x90
 800bf96:	21a0      	movhi	r1, #160	; 0xa0
 800bf98:	e7c5      	b.n	800bf26 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0x2e>
 800bf9a:	2130      	movs	r1, #48	; 0x30
  if ( LSM6DSM_ACC_GYRO_W_ODR_XL( (void *)handle, new_odr ) == MEMS_ERROR )
 800bf9c:	f7fe fb60 	bl	800a660 <LSM6DSM_ACC_GYRO_W_ODR_XL>
}
 800bfa0:	fab0 f080 	clz	r0, r0
 800bfa4:	0940      	lsrs	r0, r0, #5
 800bfa6:	bd08      	pop	{r3, pc}
            : ( odr <=   26.0f ) ? LSM6DSM_ACC_GYRO_ODR_XL_26Hz
 800bfa8:	2140      	movs	r1, #64	; 0x40
 800bfaa:	e7bc      	b.n	800bf26 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0x2e>
 800bfac:	2150      	movs	r1, #80	; 0x50
 800bfae:	e7ba      	b.n	800bf26 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0x2e>
 800bfb0:	2160      	movs	r1, #96	; 0x60
 800bfb2:	e7b8      	b.n	800bf26 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0x2e>
 800bfb4:	2170      	movs	r1, #112	; 0x70
 800bfb6:	e7b6      	b.n	800bf26 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0x2e>
 800bfb8:	2180      	movs	r1, #128	; 0x80
 800bfba:	e7b4      	b.n	800bf26 <LSM6DSM_X_Set_ODR_Value_When_Enabled+0x2e>
 800bfbc:	42500000 	.word	0x42500000
 800bfc0:	42d00000 	.word	0x42d00000
 800bfc4:	43500000 	.word	0x43500000
 800bfc8:	43d00000 	.word	0x43d00000
 800bfcc:	44504000 	.word	0x44504000
 800bfd0:	44cf8000 	.word	0x44cf8000
 800bfd4:	45502000 	.word	0x45502000

0800bfd8 <LSM6DSM_X_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 800bfd8:	7982      	ldrb	r2, [r0, #6]
 800bfda:	2a01      	cmp	r2, #1
 800bfdc:	d00d      	beq.n	800bffa <LSM6DSM_X_Sensor_Enable+0x22>
  LSM6DSM_X_Data_t *pComponentData = ( LSM6DSM_X_Data_t * )pData->pComponentData;
 800bfde:	6883      	ldr	r3, [r0, #8]
  if ( LSM6DSM_X_Set_ODR_Value_When_Enabled( handle, pComponentData->Previous_ODR ) == COMPONENT_ERROR )
 800bfe0:	681b      	ldr	r3, [r3, #0]
{
 800bfe2:	b510      	push	{r4, lr}
  if ( LSM6DSM_X_Set_ODR_Value_When_Enabled( handle, pComponentData->Previous_ODR ) == COMPONENT_ERROR )
 800bfe4:	ed93 0a01 	vldr	s0, [r3, #4]
 800bfe8:	4604      	mov	r4, r0
 800bfea:	f7ff ff85 	bl	800bef8 <LSM6DSM_X_Set_ODR_Value_When_Enabled>
 800bfee:	2801      	cmp	r0, #1
 800bff0:	d002      	beq.n	800bff8 <LSM6DSM_X_Sensor_Enable+0x20>
  handle->isEnabled = 1;
 800bff2:	2301      	movs	r3, #1
 800bff4:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 800bff6:	2000      	movs	r0, #0
}
 800bff8:	bd10      	pop	{r4, pc}
    return COMPONENT_OK;
 800bffa:	2000      	movs	r0, #0
}
 800bffc:	4770      	bx	lr
 800bffe:	bf00      	nop

0800c000 <LSM6DSM_X_Set_Tap_Duration_Time>:
{
 800c000:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_DUR( (void *)handle, time ) == MEMS_ERROR )
 800c002:	f7ff f929 	bl	800b258 <LSM6DSM_ACC_GYRO_W_DUR>
}
 800c006:	fab0 f080 	clz	r0, r0
 800c00a:	0940      	lsrs	r0, r0, #5
 800c00c:	bd08      	pop	{r3, pc}
 800c00e:	bf00      	nop

0800c010 <LSM6DSM_X_Set_Tap_Quiet_Time>:
{
 800c010:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_QUIET_Duration( (void *)handle, time ) == MEMS_ERROR )
 800c012:	f7ff f8fd 	bl	800b210 <LSM6DSM_ACC_GYRO_W_QUIET_Duration>
}
 800c016:	fab0 f080 	clz	r0, r0
 800c01a:	0940      	lsrs	r0, r0, #5
 800c01c:	bd08      	pop	{r3, pc}
 800c01e:	bf00      	nop

0800c020 <LSM6DSM_X_Set_Tap_Shock_Time>:
{
 800c020:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_SHOCK_Duration( (void *)handle, time ) == MEMS_ERROR )
 800c022:	f7ff f8d1 	bl	800b1c8 <LSM6DSM_ACC_GYRO_W_SHOCK_Duration>
}
 800c026:	fab0 f080 	clz	r0, r0
 800c02a:	0940      	lsrs	r0, r0, #5
 800c02c:	bd08      	pop	{r3, pc}
 800c02e:	bf00      	nop

0800c030 <LSM6DSM_X_Set_Tap_Threshold>:
{
 800c030:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_TAP_THS( (void *)handle, thr ) == MEMS_ERROR )
 800c032:	f7ff f883 	bl	800b13c <LSM6DSM_ACC_GYRO_W_TAP_THS>
}
 800c036:	fab0 f080 	clz	r0, r0
 800c03a:	0940      	lsrs	r0, r0, #5
 800c03c:	bd08      	pop	{r3, pc}
 800c03e:	bf00      	nop

0800c040 <LSM6DSM_X_Get_Double_Tap_Detection_Status>:
{
 800c040:	b510      	push	{r4, lr}
 800c042:	b082      	sub	sp, #8
 800c044:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_DOUBLE_TAP_EV_STATUS( (void *)handle, &tap_status ) == MEMS_ERROR )
 800c046:	f10d 0107 	add.w	r1, sp, #7
 800c04a:	f7fe fe85 	bl	800ad58 <LSM6DSM_ACC_GYRO_R_DOUBLE_TAP_EV_STATUS>
 800c04e:	b120      	cbz	r0, 800c05a <LSM6DSM_X_Get_Double_Tap_Detection_Status+0x1a>
  switch( tap_status )
 800c050:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800c054:	b148      	cbz	r0, 800c06a <LSM6DSM_X_Get_Double_Tap_Detection_Status+0x2a>
 800c056:	2810      	cmp	r0, #16
 800c058:	d002      	beq.n	800c060 <LSM6DSM_X_Get_Double_Tap_Detection_Status+0x20>
      return COMPONENT_ERROR;
 800c05a:	2001      	movs	r0, #1
}
 800c05c:	b002      	add	sp, #8
 800c05e:	bd10      	pop	{r4, pc}
      *status = 1;
 800c060:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800c062:	2000      	movs	r0, #0
      *status = 1;
 800c064:	7023      	strb	r3, [r4, #0]
}
 800c066:	b002      	add	sp, #8
 800c068:	bd10      	pop	{r4, pc}
      *status = 0;
 800c06a:	7020      	strb	r0, [r4, #0]
}
 800c06c:	b002      	add	sp, #8
 800c06e:	bd10      	pop	{r4, pc}

0800c070 <LSM6DSM_X_Get_Single_Tap_Detection_Status>:
{
 800c070:	b510      	push	{r4, lr}
 800c072:	b082      	sub	sp, #8
 800c074:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_SINGLE_TAP_EV_STATUS( (void *)handle, &tap_status ) == MEMS_ERROR )
 800c076:	f10d 0107 	add.w	r1, sp, #7
 800c07a:	f7fe fe7d 	bl	800ad78 <LSM6DSM_ACC_GYRO_R_SINGLE_TAP_EV_STATUS>
 800c07e:	b120      	cbz	r0, 800c08a <LSM6DSM_X_Get_Single_Tap_Detection_Status+0x1a>
  switch( tap_status )
 800c080:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800c084:	b148      	cbz	r0, 800c09a <LSM6DSM_X_Get_Single_Tap_Detection_Status+0x2a>
 800c086:	2820      	cmp	r0, #32
 800c088:	d002      	beq.n	800c090 <LSM6DSM_X_Get_Single_Tap_Detection_Status+0x20>
      return COMPONENT_ERROR;
 800c08a:	2001      	movs	r0, #1
}
 800c08c:	b002      	add	sp, #8
 800c08e:	bd10      	pop	{r4, pc}
      *status = 1;
 800c090:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800c092:	2000      	movs	r0, #0
      *status = 1;
 800c094:	7023      	strb	r3, [r4, #0]
}
 800c096:	b002      	add	sp, #8
 800c098:	bd10      	pop	{r4, pc}
      *status = 0;
 800c09a:	7020      	strb	r0, [r4, #0]
}
 800c09c:	b002      	add	sp, #8
 800c09e:	bd10      	pop	{r4, pc}

0800c0a0 <LSM6DSM_X_Set_Wake_Up_Threshold>:
{
 800c0a0:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_WK_THS( (void *)handle, thr ) == MEMS_ERROR )
 800c0a2:	f7ff f8fb 	bl	800b29c <LSM6DSM_ACC_GYRO_W_WK_THS>
}
 800c0a6:	fab0 f080 	clz	r0, r0
 800c0aa:	0940      	lsrs	r0, r0, #5
 800c0ac:	bd08      	pop	{r3, pc}
 800c0ae:	bf00      	nop

0800c0b0 <LSM6DSM_X_Get_Wake_Up_Detection_Status>:
{
 800c0b0:	b510      	push	{r4, lr}
 800c0b2:	b082      	sub	sp, #8
 800c0b4:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_WU_EV_STATUS( (void *)handle, &wake_up_status ) == MEMS_ERROR )
 800c0b6:	f10d 0107 	add.w	r1, sp, #7
 800c0ba:	f7fe fe2d 	bl	800ad18 <LSM6DSM_ACC_GYRO_R_WU_EV_STATUS>
 800c0be:	b120      	cbz	r0, 800c0ca <LSM6DSM_X_Get_Wake_Up_Detection_Status+0x1a>
  switch( wake_up_status )
 800c0c0:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800c0c4:	b148      	cbz	r0, 800c0da <LSM6DSM_X_Get_Wake_Up_Detection_Status+0x2a>
 800c0c6:	2808      	cmp	r0, #8
 800c0c8:	d002      	beq.n	800c0d0 <LSM6DSM_X_Get_Wake_Up_Detection_Status+0x20>
      return COMPONENT_ERROR;
 800c0ca:	2001      	movs	r0, #1
}
 800c0cc:	b002      	add	sp, #8
 800c0ce:	bd10      	pop	{r4, pc}
      *status = 1;
 800c0d0:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800c0d2:	2000      	movs	r0, #0
      *status = 1;
 800c0d4:	7023      	strb	r3, [r4, #0]
}
 800c0d6:	b002      	add	sp, #8
 800c0d8:	bd10      	pop	{r4, pc}
      *status = 0;
 800c0da:	7020      	strb	r0, [r4, #0]
}
 800c0dc:	b002      	add	sp, #8
 800c0de:	bd10      	pop	{r4, pc}

0800c0e0 <LSM6DSM_X_Get_Tilt_Detection_Status>:
{
 800c0e0:	b510      	push	{r4, lr}
 800c0e2:	b082      	sub	sp, #8
 800c0e4:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_TILT_EV_STATUS( (void *)handle, &tilt_status ) == MEMS_ERROR )
 800c0e6:	f10d 0107 	add.w	r1, sp, #7
 800c0ea:	f7fe ff6d 	bl	800afc8 <LSM6DSM_ACC_GYRO_R_TILT_EV_STATUS>
 800c0ee:	b120      	cbz	r0, 800c0fa <LSM6DSM_X_Get_Tilt_Detection_Status+0x1a>
  switch( tilt_status )
 800c0f0:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800c0f4:	b148      	cbz	r0, 800c10a <LSM6DSM_X_Get_Tilt_Detection_Status+0x2a>
 800c0f6:	2820      	cmp	r0, #32
 800c0f8:	d002      	beq.n	800c100 <LSM6DSM_X_Get_Tilt_Detection_Status+0x20>
      return COMPONENT_ERROR;
 800c0fa:	2001      	movs	r0, #1
}
 800c0fc:	b002      	add	sp, #8
 800c0fe:	bd10      	pop	{r4, pc}
      *status = 1;
 800c100:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800c102:	2000      	movs	r0, #0
      *status = 1;
 800c104:	7023      	strb	r3, [r4, #0]
}
 800c106:	b002      	add	sp, #8
 800c108:	bd10      	pop	{r4, pc}
      *status = 0;
 800c10a:	7020      	strb	r0, [r4, #0]
}
 800c10c:	b002      	add	sp, #8
 800c10e:	bd10      	pop	{r4, pc}

0800c110 <LSM6DSM_X_Set_Pedometer_Threshold>:
{
 800c110:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_PedoThreshold( (void *)handle, thr ) == MEMS_ERROR )
 800c112:	f7ff fb95 	bl	800b840 <LSM6DSM_ACC_GYRO_W_PedoThreshold>
}
 800c116:	fab0 f080 	clz	r0, r0
 800c11a:	0940      	lsrs	r0, r0, #5
 800c11c:	bd08      	pop	{r3, pc}
 800c11e:	bf00      	nop

0800c120 <LSM6DSM_X_Disable_Step_Counter_Reset>:
{
 800c120:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_PedoStepReset( (void *)handle, LSM6DSM_ACC_GYRO_PEDO_RST_STEP_DISABLED ) == MEMS_ERROR )
 800c122:	2100      	movs	r1, #0
 800c124:	f7fe fd70 	bl	800ac08 <LSM6DSM_ACC_GYRO_W_PedoStepReset>
}
 800c128:	fab0 f080 	clz	r0, r0
 800c12c:	0940      	lsrs	r0, r0, #5
 800c12e:	bd08      	pop	{r3, pc}

0800c130 <LSM6DSM_X_Enable_Step_Counter_Reset>:
{
 800c130:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_PedoStepReset( (void *)handle, LSM6DSM_ACC_GYRO_PEDO_RST_STEP_ENABLED ) == MEMS_ERROR )
 800c132:	2102      	movs	r1, #2
 800c134:	f7fe fd68 	bl	800ac08 <LSM6DSM_ACC_GYRO_W_PedoStepReset>
}
 800c138:	fab0 f080 	clz	r0, r0
 800c13c:	0940      	lsrs	r0, r0, #5
 800c13e:	bd08      	pop	{r3, pc}

0800c140 <LSM6DSM_X_Get_Step_Count>:
{
 800c140:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_Get_GetStepCounter( (void *)handle, ( uint8_t* )step_count ) == MEMS_ERROR )
 800c142:	f7ff fb67 	bl	800b814 <LSM6DSM_ACC_GYRO_Get_GetStepCounter>
}
 800c146:	fab0 f080 	clz	r0, r0
 800c14a:	0940      	lsrs	r0, r0, #5
 800c14c:	bd08      	pop	{r3, pc}
 800c14e:	bf00      	nop

0800c150 <LSM6DSM_X_Get_Pedometer_Status>:
{
 800c150:	b510      	push	{r4, lr}
 800c152:	b082      	sub	sp, #8
 800c154:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_PEDO_EV_STATUS( (void *)handle, &pedometer_status ) == MEMS_ERROR )
 800c156:	f10d 0107 	add.w	r1, sp, #7
 800c15a:	f7fe ff25 	bl	800afa8 <LSM6DSM_ACC_GYRO_R_PEDO_EV_STATUS>
 800c15e:	b120      	cbz	r0, 800c16a <LSM6DSM_X_Get_Pedometer_Status+0x1a>
  switch( pedometer_status )
 800c160:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800c164:	b148      	cbz	r0, 800c17a <LSM6DSM_X_Get_Pedometer_Status+0x2a>
 800c166:	2810      	cmp	r0, #16
 800c168:	d002      	beq.n	800c170 <LSM6DSM_X_Get_Pedometer_Status+0x20>
      return COMPONENT_ERROR;
 800c16a:	2001      	movs	r0, #1
}
 800c16c:	b002      	add	sp, #8
 800c16e:	bd10      	pop	{r4, pc}
      *status = 1;
 800c170:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800c172:	2000      	movs	r0, #0
      *status = 1;
 800c174:	7023      	strb	r3, [r4, #0]
}
 800c176:	b002      	add	sp, #8
 800c178:	bd10      	pop	{r4, pc}
      *status = 0;
 800c17a:	7020      	strb	r0, [r4, #0]
}
 800c17c:	b002      	add	sp, #8
 800c17e:	bd10      	pop	{r4, pc}

0800c180 <LSM6DSM_X_Set_Free_Fall_Threshold>:
{
 800c180:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_FF_THS( (void *)handle, (LSM6DSM_ACC_GYRO_FF_THS_t)thr ) == MEMS_ERROR )
 800c182:	f7ff f93b 	bl	800b3fc <LSM6DSM_ACC_GYRO_W_FF_THS>
}
 800c186:	fab0 f080 	clz	r0, r0
 800c18a:	0940      	lsrs	r0, r0, #5
 800c18c:	bd08      	pop	{r3, pc}
 800c18e:	bf00      	nop

0800c190 <LSM6DSM_X_Get_Free_Fall_Detection_Status>:
{
 800c190:	b510      	push	{r4, lr}
 800c192:	b082      	sub	sp, #8
 800c194:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_FF_EV_STATUS( (void *)handle, &free_fall_status ) == MEMS_ERROR )
 800c196:	f10d 0107 	add.w	r1, sp, #7
 800c19a:	f7fe fdcd 	bl	800ad38 <LSM6DSM_ACC_GYRO_R_FF_EV_STATUS>
 800c19e:	b120      	cbz	r0, 800c1aa <LSM6DSM_X_Get_Free_Fall_Detection_Status+0x1a>
  switch( free_fall_status )
 800c1a0:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800c1a4:	b148      	cbz	r0, 800c1ba <LSM6DSM_X_Get_Free_Fall_Detection_Status+0x2a>
 800c1a6:	2820      	cmp	r0, #32
 800c1a8:	d002      	beq.n	800c1b0 <LSM6DSM_X_Get_Free_Fall_Detection_Status+0x20>
      return COMPONENT_ERROR;
 800c1aa:	2001      	movs	r0, #1
}
 800c1ac:	b002      	add	sp, #8
 800c1ae:	bd10      	pop	{r4, pc}
      *status = 1;
 800c1b0:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800c1b2:	2000      	movs	r0, #0
      *status = 1;
 800c1b4:	7023      	strb	r3, [r4, #0]
}
 800c1b6:	b002      	add	sp, #8
 800c1b8:	bd10      	pop	{r4, pc}
      *status = 0;
 800c1ba:	7020      	strb	r0, [r4, #0]
}
 800c1bc:	b002      	add	sp, #8
 800c1be:	bd10      	pop	{r4, pc}

0800c1c0 <LSM6DSM_G_Get_FS>:
{
 800c1c0:	b530      	push	{r4, r5, lr}
 800c1c2:	b083      	sub	sp, #12
 800c1c4:	460d      	mov	r5, r1
  if ( LSM6DSM_ACC_GYRO_R_FS_125( (void *)handle, &fs_125 ) == MEMS_ERROR )
 800c1c6:	f10d 0107 	add.w	r1, sp, #7
{
 800c1ca:	4604      	mov	r4, r0
  if ( LSM6DSM_ACC_GYRO_R_FS_125( (void *)handle, &fs_125 ) == MEMS_ERROR )
 800c1cc:	f7fe fb1c 	bl	800a808 <LSM6DSM_ACC_GYRO_R_FS_125>
 800c1d0:	b910      	cbnz	r0, 800c1d8 <LSM6DSM_G_Get_FS+0x18>
        return COMPONENT_ERROR;
 800c1d2:	2001      	movs	r0, #1
}
 800c1d4:	b003      	add	sp, #12
 800c1d6:	bd30      	pop	{r4, r5, pc}
  if ( LSM6DSM_ACC_GYRO_R_FS_G( (void *)handle, &fs_low_level ) == MEMS_ERROR )
 800c1d8:	4620      	mov	r0, r4
 800c1da:	f10d 0106 	add.w	r1, sp, #6
 800c1de:	f7fe fa93 	bl	800a708 <LSM6DSM_ACC_GYRO_R_FS_G>
 800c1e2:	2800      	cmp	r0, #0
 800c1e4:	d0f5      	beq.n	800c1d2 <LSM6DSM_G_Get_FS+0x12>
  if ( fs_125 == LSM6DSM_ACC_GYRO_FS_125_ENABLED )
 800c1e6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800c1ea:	2b02      	cmp	r3, #2
 800c1ec:	d00c      	beq.n	800c208 <LSM6DSM_G_Get_FS+0x48>
    switch( fs_low_level )
 800c1ee:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800c1f2:	2b0c      	cmp	r3, #12
 800c1f4:	d81c      	bhi.n	800c230 <LSM6DSM_G_Get_FS+0x70>
 800c1f6:	e8df f003 	tbb	[pc, r3]
 800c1fa:	1b17      	.short	0x1b17
 800c1fc:	1b131b1b 	.word	0x1b131b1b
 800c200:	1b0f1b1b 	.word	0x1b0f1b1b
 800c204:	1b1b      	.short	0x1b1b
 800c206:	0b          	.byte	0x0b
 800c207:	00          	.byte	0x00
    *fullScale = 125.0f;
 800c208:	4b0b      	ldr	r3, [pc, #44]	; (800c238 <LSM6DSM_G_Get_FS+0x78>)
 800c20a:	602b      	str	r3, [r5, #0]
  return COMPONENT_OK;
 800c20c:	2000      	movs	r0, #0
 800c20e:	e7e1      	b.n	800c1d4 <LSM6DSM_G_Get_FS+0x14>
        *fullScale = 2000.0f;
 800c210:	4b0a      	ldr	r3, [pc, #40]	; (800c23c <LSM6DSM_G_Get_FS+0x7c>)
 800c212:	602b      	str	r3, [r5, #0]
  return COMPONENT_OK;
 800c214:	2000      	movs	r0, #0
        break;
 800c216:	e7dd      	b.n	800c1d4 <LSM6DSM_G_Get_FS+0x14>
        *fullScale = 1000.0f;
 800c218:	4b09      	ldr	r3, [pc, #36]	; (800c240 <LSM6DSM_G_Get_FS+0x80>)
 800c21a:	602b      	str	r3, [r5, #0]
  return COMPONENT_OK;
 800c21c:	2000      	movs	r0, #0
        break;
 800c21e:	e7d9      	b.n	800c1d4 <LSM6DSM_G_Get_FS+0x14>
        *fullScale =  500.0f;
 800c220:	4b08      	ldr	r3, [pc, #32]	; (800c244 <LSM6DSM_G_Get_FS+0x84>)
 800c222:	602b      	str	r3, [r5, #0]
  return COMPONENT_OK;
 800c224:	2000      	movs	r0, #0
        break;
 800c226:	e7d5      	b.n	800c1d4 <LSM6DSM_G_Get_FS+0x14>
        *fullScale =  245.0f;
 800c228:	4b07      	ldr	r3, [pc, #28]	; (800c248 <LSM6DSM_G_Get_FS+0x88>)
 800c22a:	602b      	str	r3, [r5, #0]
  return COMPONENT_OK;
 800c22c:	2000      	movs	r0, #0
        break;
 800c22e:	e7d1      	b.n	800c1d4 <LSM6DSM_G_Get_FS+0x14>
        *fullScale =   -1.0f;
 800c230:	4b06      	ldr	r3, [pc, #24]	; (800c24c <LSM6DSM_G_Get_FS+0x8c>)
 800c232:	602b      	str	r3, [r5, #0]
 800c234:	e7cd      	b.n	800c1d2 <LSM6DSM_G_Get_FS+0x12>
 800c236:	bf00      	nop
 800c238:	42fa0000 	.word	0x42fa0000
 800c23c:	44fa0000 	.word	0x44fa0000
 800c240:	447a0000 	.word	0x447a0000
 800c244:	43fa0000 	.word	0x43fa0000
 800c248:	43750000 	.word	0x43750000
 800c24c:	bf800000 	.word	0xbf800000

0800c250 <LSM6DSM_X_Get_DRDY_Status>:
{
 800c250:	b510      	push	{r4, lr}
 800c252:	b082      	sub	sp, #8
 800c254:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_XLDA( (void *)handle, &status_raw ) == MEMS_ERROR )
 800c256:	f10d 0107 	add.w	r1, sp, #7
 800c25a:	f7fe fe0d 	bl	800ae78 <LSM6DSM_ACC_GYRO_R_XLDA>
 800c25e:	b120      	cbz	r0, 800c26a <LSM6DSM_X_Get_DRDY_Status+0x1a>
  switch( status_raw )
 800c260:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800c264:	b140      	cbz	r0, 800c278 <LSM6DSM_X_Get_DRDY_Status+0x28>
 800c266:	2801      	cmp	r0, #1
 800c268:	d002      	beq.n	800c270 <LSM6DSM_X_Get_DRDY_Status+0x20>
      return COMPONENT_ERROR;
 800c26a:	2001      	movs	r0, #1
}
 800c26c:	b002      	add	sp, #8
 800c26e:	bd10      	pop	{r4, pc}
      *status = 1;
 800c270:	7020      	strb	r0, [r4, #0]
  return COMPONENT_OK;
 800c272:	2000      	movs	r0, #0
}
 800c274:	b002      	add	sp, #8
 800c276:	bd10      	pop	{r4, pc}
      *status = 0;
 800c278:	7020      	strb	r0, [r4, #0]
}
 800c27a:	b002      	add	sp, #8
 800c27c:	bd10      	pop	{r4, pc}
 800c27e:	bf00      	nop

0800c280 <LSM6DSM_X_Write_Reg>:
{
 800c280:	b510      	push	{r4, lr}
 800c282:	b082      	sub	sp, #8
 800c284:	ac02      	add	r4, sp, #8
  if ( LSM6DSM_ACC_GYRO_WriteReg( (void *)handle, reg, &data, 1 ) == MEMS_ERROR )
 800c286:	2301      	movs	r3, #1
 800c288:	f804 2d01 	strb.w	r2, [r4, #-1]!
 800c28c:	4622      	mov	r2, r4
 800c28e:	f7fe f965 	bl	800a55c <LSM6DSM_ACC_GYRO_WriteReg>
}
 800c292:	fab0 f080 	clz	r0, r0
 800c296:	0940      	lsrs	r0, r0, #5
 800c298:	b002      	add	sp, #8
 800c29a:	bd10      	pop	{r4, pc}

0800c29c <LSM6DSM_G_Write_Reg>:
 800c29c:	f7ff bff0 	b.w	800c280 <LSM6DSM_X_Write_Reg>

0800c2a0 <LSM6DSM_X_Get_ODR>:
{
 800c2a0:	b510      	push	{r4, lr}
 800c2a2:	b082      	sub	sp, #8
 800c2a4:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_ODR_XL( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 800c2a6:	f10d 0107 	add.w	r1, sp, #7
 800c2aa:	f7fe f9fb 	bl	800a6a4 <LSM6DSM_ACC_GYRO_R_ODR_XL>
 800c2ae:	b178      	cbz	r0, 800c2d0 <LSM6DSM_X_Get_ODR+0x30>
  switch( odr_low_level )
 800c2b0:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800c2b4:	2850      	cmp	r0, #80	; 0x50
 800c2b6:	d028      	beq.n	800c30a <LSM6DSM_X_Get_ODR+0x6a>
 800c2b8:	d80d      	bhi.n	800c2d6 <LSM6DSM_X_Get_ODR+0x36>
 800c2ba:	2820      	cmp	r0, #32
 800c2bc:	d035      	beq.n	800c32a <LSM6DSM_X_Get_ODR+0x8a>
 800c2be:	d91d      	bls.n	800c2fc <LSM6DSM_X_Get_ODR+0x5c>
 800c2c0:	2830      	cmp	r0, #48	; 0x30
 800c2c2:	d03a      	beq.n	800c33a <LSM6DSM_X_Get_ODR+0x9a>
 800c2c4:	2840      	cmp	r0, #64	; 0x40
 800c2c6:	d124      	bne.n	800c312 <LSM6DSM_X_Get_ODR+0x72>
      *odr =   104.0f;
 800c2c8:	4b1f      	ldr	r3, [pc, #124]	; (800c348 <LSM6DSM_X_Get_ODR+0xa8>)
 800c2ca:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c2cc:	2000      	movs	r0, #0
      break;
 800c2ce:	e000      	b.n	800c2d2 <LSM6DSM_X_Get_ODR+0x32>
    return COMPONENT_ERROR;
 800c2d0:	2001      	movs	r0, #1
}
 800c2d2:	b002      	add	sp, #8
 800c2d4:	bd10      	pop	{r4, pc}
  switch( odr_low_level )
 800c2d6:	2880      	cmp	r0, #128	; 0x80
 800c2d8:	d023      	beq.n	800c322 <LSM6DSM_X_Get_ODR+0x82>
 800c2da:	d907      	bls.n	800c2ec <LSM6DSM_X_Get_ODR+0x4c>
 800c2dc:	2890      	cmp	r0, #144	; 0x90
 800c2de:	d028      	beq.n	800c332 <LSM6DSM_X_Get_ODR+0x92>
 800c2e0:	28a0      	cmp	r0, #160	; 0xa0
 800c2e2:	d116      	bne.n	800c312 <LSM6DSM_X_Get_ODR+0x72>
      *odr =  6660.0f;
 800c2e4:	4b19      	ldr	r3, [pc, #100]	; (800c34c <LSM6DSM_X_Get_ODR+0xac>)
 800c2e6:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c2e8:	2000      	movs	r0, #0
      break;
 800c2ea:	e7f2      	b.n	800c2d2 <LSM6DSM_X_Get_ODR+0x32>
  switch( odr_low_level )
 800c2ec:	2860      	cmp	r0, #96	; 0x60
 800c2ee:	d014      	beq.n	800c31a <LSM6DSM_X_Get_ODR+0x7a>
 800c2f0:	2870      	cmp	r0, #112	; 0x70
 800c2f2:	d10e      	bne.n	800c312 <LSM6DSM_X_Get_ODR+0x72>
      *odr =   833.0f;
 800c2f4:	4b16      	ldr	r3, [pc, #88]	; (800c350 <LSM6DSM_X_Get_ODR+0xb0>)
 800c2f6:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c2f8:	2000      	movs	r0, #0
      break;
 800c2fa:	e7ea      	b.n	800c2d2 <LSM6DSM_X_Get_ODR+0x32>
  switch( odr_low_level )
 800c2fc:	b308      	cbz	r0, 800c342 <LSM6DSM_X_Get_ODR+0xa2>
 800c2fe:	2810      	cmp	r0, #16
 800c300:	d107      	bne.n	800c312 <LSM6DSM_X_Get_ODR+0x72>
      *odr =    13.0f;
 800c302:	4b14      	ldr	r3, [pc, #80]	; (800c354 <LSM6DSM_X_Get_ODR+0xb4>)
 800c304:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c306:	2000      	movs	r0, #0
      break;
 800c308:	e7e3      	b.n	800c2d2 <LSM6DSM_X_Get_ODR+0x32>
      *odr =   208.0f;
 800c30a:	4b13      	ldr	r3, [pc, #76]	; (800c358 <LSM6DSM_X_Get_ODR+0xb8>)
 800c30c:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c30e:	2000      	movs	r0, #0
      break;
 800c310:	e7df      	b.n	800c2d2 <LSM6DSM_X_Get_ODR+0x32>
      *odr =    -1.0f;
 800c312:	4b12      	ldr	r3, [pc, #72]	; (800c35c <LSM6DSM_X_Get_ODR+0xbc>)
 800c314:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 800c316:	2001      	movs	r0, #1
 800c318:	e7db      	b.n	800c2d2 <LSM6DSM_X_Get_ODR+0x32>
      *odr =   416.0f;
 800c31a:	4b11      	ldr	r3, [pc, #68]	; (800c360 <LSM6DSM_X_Get_ODR+0xc0>)
 800c31c:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c31e:	2000      	movs	r0, #0
      break;
 800c320:	e7d7      	b.n	800c2d2 <LSM6DSM_X_Get_ODR+0x32>
      *odr =  1660.0f;
 800c322:	4b10      	ldr	r3, [pc, #64]	; (800c364 <LSM6DSM_X_Get_ODR+0xc4>)
 800c324:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c326:	2000      	movs	r0, #0
      break;
 800c328:	e7d3      	b.n	800c2d2 <LSM6DSM_X_Get_ODR+0x32>
      *odr =    26.0f;
 800c32a:	4b0f      	ldr	r3, [pc, #60]	; (800c368 <LSM6DSM_X_Get_ODR+0xc8>)
 800c32c:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c32e:	2000      	movs	r0, #0
      break;
 800c330:	e7cf      	b.n	800c2d2 <LSM6DSM_X_Get_ODR+0x32>
      *odr =  3330.0f;
 800c332:	4b0e      	ldr	r3, [pc, #56]	; (800c36c <LSM6DSM_X_Get_ODR+0xcc>)
 800c334:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c336:	2000      	movs	r0, #0
      break;
 800c338:	e7cb      	b.n	800c2d2 <LSM6DSM_X_Get_ODR+0x32>
      *odr =    52.0f;
 800c33a:	4b0d      	ldr	r3, [pc, #52]	; (800c370 <LSM6DSM_X_Get_ODR+0xd0>)
 800c33c:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c33e:	2000      	movs	r0, #0
      break;
 800c340:	e7c7      	b.n	800c2d2 <LSM6DSM_X_Get_ODR+0x32>
      *odr =     0.0f;
 800c342:	2300      	movs	r3, #0
 800c344:	6023      	str	r3, [r4, #0]
      break;
 800c346:	e7c4      	b.n	800c2d2 <LSM6DSM_X_Get_ODR+0x32>
 800c348:	42d00000 	.word	0x42d00000
 800c34c:	45d02000 	.word	0x45d02000
 800c350:	44504000 	.word	0x44504000
 800c354:	41500000 	.word	0x41500000
 800c358:	43500000 	.word	0x43500000
 800c35c:	bf800000 	.word	0xbf800000
 800c360:	43d00000 	.word	0x43d00000
 800c364:	44cf8000 	.word	0x44cf8000
 800c368:	41d00000 	.word	0x41d00000
 800c36c:	45502000 	.word	0x45502000
 800c370:	42500000 	.word	0x42500000

0800c374 <LSM6DSM_X_Get_Axes_Raw>:
{
 800c374:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c376:	b083      	sub	sp, #12
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 800c378:	2400      	movs	r4, #0
{
 800c37a:	460d      	mov	r5, r1
  if ( LSM6DSM_ACC_GYRO_GetRawAccData( (void *)handle, ( uint8_t* )regValue ) == MEMS_ERROR )
 800c37c:	4669      	mov	r1, sp
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 800c37e:	f8ad 4004 	strh.w	r4, [sp, #4]
 800c382:	9400      	str	r4, [sp, #0]
  if ( LSM6DSM_ACC_GYRO_GetRawAccData( (void *)handle, ( uint8_t* )regValue ) == MEMS_ERROR )
 800c384:	f7fe f950 	bl	800a628 <LSM6DSM_ACC_GYRO_GetRawAccData>
 800c388:	b1b8      	cbz	r0, 800c3ba <LSM6DSM_X_Get_Axes_Raw+0x46>
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 800c38a:	f89d 0005 	ldrb.w	r0, [sp, #5]
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 800c38e:	f89d 7001 	ldrb.w	r7, [sp, #1]
 800c392:	f89d 1000 	ldrb.w	r1, [sp]
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 800c396:	f89d 6003 	ldrb.w	r6, [sp, #3]
 800c39a:	f89d 2002 	ldrb.w	r2, [sp, #2]
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 800c39e:	f89d 3004 	ldrb.w	r3, [sp, #4]
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 800c3a2:	eb01 2107 	add.w	r1, r1, r7, lsl #8
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 800c3a6:	eb03 2300 	add.w	r3, r3, r0, lsl #8
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 800c3aa:	eb02 2206 	add.w	r2, r2, r6, lsl #8
  return COMPONENT_OK;
 800c3ae:	4620      	mov	r0, r4
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 800c3b0:	8029      	strh	r1, [r5, #0]
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 800c3b2:	806a      	strh	r2, [r5, #2]
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 800c3b4:	80ab      	strh	r3, [r5, #4]
}
 800c3b6:	b003      	add	sp, #12
 800c3b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return COMPONENT_ERROR;
 800c3ba:	2001      	movs	r0, #1
}
 800c3bc:	b003      	add	sp, #12
 800c3be:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800c3c0 <LSM6DSM_X_Get_AxesRaw>:
{
 800c3c0:	b510      	push	{r4, lr}
 800c3c2:	b082      	sub	sp, #8
 800c3c4:	460c      	mov	r4, r1
  if ( LSM6DSM_X_Get_Axes_Raw( handle, dataRaw ) == COMPONENT_ERROR )
 800c3c6:	4669      	mov	r1, sp
 800c3c8:	f7ff ffd4 	bl	800c374 <LSM6DSM_X_Get_Axes_Raw>
 800c3cc:	2801      	cmp	r0, #1
 800c3ce:	d009      	beq.n	800c3e4 <LSM6DSM_X_Get_AxesRaw+0x24>
  value->AXIS_X = dataRaw[0];
 800c3d0:	f8bd 1000 	ldrh.w	r1, [sp]
  value->AXIS_Y = dataRaw[1];
 800c3d4:	f8bd 2002 	ldrh.w	r2, [sp, #2]
  value->AXIS_Z = dataRaw[2];
 800c3d8:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  value->AXIS_X = dataRaw[0];
 800c3dc:	8021      	strh	r1, [r4, #0]
  value->AXIS_Y = dataRaw[1];
 800c3de:	8062      	strh	r2, [r4, #2]
  value->AXIS_Z = dataRaw[2];
 800c3e0:	80a3      	strh	r3, [r4, #4]
  return COMPONENT_OK;
 800c3e2:	2000      	movs	r0, #0
}
 800c3e4:	b002      	add	sp, #8
 800c3e6:	bd10      	pop	{r4, pc}

0800c3e8 <LSM6DSM_X_Get_Axes>:
{
 800c3e8:	b530      	push	{r4, r5, lr}
 800c3ea:	b085      	sub	sp, #20
  float sensitivity = 0;
 800c3ec:	2300      	movs	r3, #0
{
 800c3ee:	460c      	mov	r4, r1
  if ( LSM6DSM_X_Get_Axes_Raw( handle, dataRaw ) == COMPONENT_ERROR )
 800c3f0:	a902      	add	r1, sp, #8
  float sensitivity = 0;
 800c3f2:	9301      	str	r3, [sp, #4]
{
 800c3f4:	4605      	mov	r5, r0
  if ( LSM6DSM_X_Get_Axes_Raw( handle, dataRaw ) == COMPONENT_ERROR )
 800c3f6:	f7ff ffbd 	bl	800c374 <LSM6DSM_X_Get_Axes_Raw>
 800c3fa:	2801      	cmp	r0, #1
 800c3fc:	d02e      	beq.n	800c45c <LSM6DSM_X_Get_Axes+0x74>
  if ( LSM6DSM_X_Get_Sensitivity( handle, &sensitivity ) == COMPONENT_ERROR )
 800c3fe:	4628      	mov	r0, r5
 800c400:	a901      	add	r1, sp, #4
 800c402:	f7ff fa4b 	bl	800b89c <LSM6DSM_X_Get_Sensitivity>
 800c406:	2801      	cmp	r0, #1
 800c408:	d028      	beq.n	800c45c <LSM6DSM_X_Get_Axes+0x74>
  acceleration->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 800c40a:	f9bd 3008 	ldrsh.w	r3, [sp, #8]
 800c40e:	ed9d 6a01 	vldr	s12, [sp, #4]
 800c412:	ee06 3a90 	vmov	s13, r3
  acceleration->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 800c416:	f9bd 300a 	ldrsh.w	r3, [sp, #10]
 800c41a:	ee07 3a10 	vmov	s14, r3
  acceleration->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 800c41e:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
 800c422:	ee07 3a90 	vmov	s15, r3
  acceleration->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 800c426:	eef8 6ae6 	vcvt.f32.s32	s13, s13
  acceleration->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 800c42a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  acceleration->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 800c42e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  acceleration->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 800c432:	ee66 6a86 	vmul.f32	s13, s13, s12
  acceleration->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 800c436:	ee27 7a06 	vmul.f32	s14, s14, s12
  acceleration->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 800c43a:	ee67 7a86 	vmul.f32	s15, s15, s12
  acceleration->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 800c43e:	eefd 6ae6 	vcvt.s32.f32	s13, s13
  acceleration->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 800c442:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  acceleration->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 800c446:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  return COMPONENT_OK;
 800c44a:	2000      	movs	r0, #0
  acceleration->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 800c44c:	edc4 6a00 	vstr	s13, [r4]
  acceleration->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 800c450:	ed84 7a01 	vstr	s14, [r4, #4]
  acceleration->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 800c454:	edc4 7a02 	vstr	s15, [r4, #8]
}
 800c458:	b005      	add	sp, #20
 800c45a:	bd30      	pop	{r4, r5, pc}
    return COMPONENT_ERROR;
 800c45c:	2001      	movs	r0, #1
}
 800c45e:	b005      	add	sp, #20
 800c460:	bd30      	pop	{r4, r5, pc}
 800c462:	bf00      	nop

0800c464 <LSM6DSM_Check_WhoAmI>:
{
 800c464:	b510      	push	{r4, lr}
 800c466:	b082      	sub	sp, #8
  uint8_t who_am_i = 0x00;
 800c468:	a902      	add	r1, sp, #8
 800c46a:	2300      	movs	r3, #0
 800c46c:	f801 3d01 	strb.w	r3, [r1, #-1]!
{
 800c470:	4604      	mov	r4, r0
  if ( LSM6DSM_ACC_GYRO_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 800c472:	f7fe f87b 	bl	800a56c <LSM6DSM_ACC_GYRO_R_WHO_AM_I>
 800c476:	b138      	cbz	r0, 800c488 <LSM6DSM_Check_WhoAmI+0x24>
  if ( who_am_i != handle->who_am_i )
 800c478:	7820      	ldrb	r0, [r4, #0]
 800c47a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    return COMPONENT_ERROR;
 800c47e:	1ac0      	subs	r0, r0, r3
 800c480:	bf18      	it	ne
 800c482:	2001      	movne	r0, #1
}
 800c484:	b002      	add	sp, #8
 800c486:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 800c488:	2001      	movs	r0, #1
}
 800c48a:	b002      	add	sp, #8
 800c48c:	bd10      	pop	{r4, pc}
 800c48e:	bf00      	nop

0800c490 <LSM6DSM_X_Check_WhoAmI>:
  return LSM6DSM_Check_WhoAmI(handle);
 800c490:	f7ff bfe8 	b.w	800c464 <LSM6DSM_Check_WhoAmI>

0800c494 <LSM6DSM_X_Get_WhoAmI>:
{
 800c494:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 800c496:	f7fe f869 	bl	800a56c <LSM6DSM_ACC_GYRO_R_WHO_AM_I>
}
 800c49a:	fab0 f080 	clz	r0, r0
 800c49e:	0940      	lsrs	r0, r0, #5
 800c4a0:	bd08      	pop	{r3, pc}
 800c4a2:	bf00      	nop

0800c4a4 <LSM6DSM_G_Get_WhoAmI>:
 800c4a4:	f7ff bff6 	b.w	800c494 <LSM6DSM_X_Get_WhoAmI>

0800c4a8 <LSM6DSM_X_Init>:
  LSM6DSM_X_Data_t *pComponentData = ( LSM6DSM_X_Data_t * )pData->pComponentData;
 800c4a8:	6883      	ldr	r3, [r0, #8]
{
 800c4aa:	b570      	push	{r4, r5, r6, lr}
  LSM6DSM_X_Data_t *pComponentData = ( LSM6DSM_X_Data_t * )pData->pComponentData;
 800c4ac:	681d      	ldr	r5, [r3, #0]
{
 800c4ae:	4604      	mov	r4, r0
  LSM6DSM_Combo_Data_t *comboData = pComponentData->comboData;
 800c4b0:	682e      	ldr	r6, [r5, #0]
  if ( LSM6DSM_Check_WhoAmI( handle ) == COMPONENT_ERROR )
 800c4b2:	f7ff ffd7 	bl	800c464 <LSM6DSM_Check_WhoAmI>
 800c4b6:	2801      	cmp	r0, #1
 800c4b8:	d004      	beq.n	800c4c4 <LSM6DSM_X_Init+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_IF_Addr_Incr( (void *)handle, LSM6DSM_ACC_GYRO_IF_INC_ENABLED ) == MEMS_ERROR )
 800c4ba:	2104      	movs	r1, #4
 800c4bc:	4620      	mov	r0, r4
 800c4be:	f7fe fb1b 	bl	800aaf8 <LSM6DSM_ACC_GYRO_W_IF_Addr_Incr>
 800c4c2:	b908      	cbnz	r0, 800c4c8 <LSM6DSM_X_Init+0x20>
    return COMPONENT_ERROR;
 800c4c4:	2001      	movs	r0, #1
}
 800c4c6:	bd70      	pop	{r4, r5, r6, pc}
  if ( LSM6DSM_ACC_GYRO_W_BDU( (void *)handle, LSM6DSM_ACC_GYRO_BDU_BLOCK_UPDATE ) == MEMS_ERROR )
 800c4c8:	2140      	movs	r1, #64	; 0x40
 800c4ca:	4620      	mov	r0, r4
 800c4cc:	f7fe f858 	bl	800a580 <LSM6DSM_ACC_GYRO_W_BDU>
 800c4d0:	2800      	cmp	r0, #0
 800c4d2:	d0f7      	beq.n	800c4c4 <LSM6DSM_X_Init+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_FIFO_MODE( (void *)handle, LSM6DSM_ACC_GYRO_FIFO_MODE_BYPASS ) == MEMS_ERROR )
 800c4d4:	2100      	movs	r1, #0
 800c4d6:	4620      	mov	r0, r4
 800c4d8:	f7fe fa64 	bl	800a9a4 <LSM6DSM_ACC_GYRO_W_FIFO_MODE>
 800c4dc:	2800      	cmp	r0, #0
 800c4de:	d0f1      	beq.n	800c4c4 <LSM6DSM_X_Init+0x1c>
  pComponentData->Previous_ODR = 104.0f;
 800c4e0:	4b09      	ldr	r3, [pc, #36]	; (800c508 <LSM6DSM_X_Init+0x60>)
 800c4e2:	606b      	str	r3, [r5, #4]
  if ( LSM6DSM_ACC_GYRO_W_ODR_XL( (void *)handle, LSM6DSM_ACC_GYRO_ODR_XL_POWER_DOWN ) == MEMS_ERROR )
 800c4e4:	2100      	movs	r1, #0
 800c4e6:	4620      	mov	r0, r4
 800c4e8:	f7fe f8ba 	bl	800a660 <LSM6DSM_ACC_GYRO_W_ODR_XL>
 800c4ec:	2800      	cmp	r0, #0
 800c4ee:	d0e9      	beq.n	800c4c4 <LSM6DSM_X_Init+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_FS_XL( (void *)handle, new_fs ) == MEMS_ERROR )
 800c4f0:	2100      	movs	r1, #0
 800c4f2:	4620      	mov	r0, r4
 800c4f4:	f7fe f866 	bl	800a5c4 <LSM6DSM_ACC_GYRO_W_FS_XL>
 800c4f8:	2800      	cmp	r0, #0
 800c4fa:	d0e3      	beq.n	800c4c4 <LSM6DSM_X_Init+0x1c>
  comboData->isAccInitialized = 1;
 800c4fc:	2301      	movs	r3, #1
 800c4fe:	7033      	strb	r3, [r6, #0]
  handle->isInitialized = 1;
 800c500:	7163      	strb	r3, [r4, #5]
  return COMPONENT_OK;
 800c502:	2000      	movs	r0, #0
}
 800c504:	bd70      	pop	{r4, r5, r6, pc}
 800c506:	bf00      	nop
 800c508:	42d00000 	.word	0x42d00000

0800c50c <LSM6DSM_G_Get_DRDY_Status>:
{
 800c50c:	b510      	push	{r4, lr}
 800c50e:	b082      	sub	sp, #8
 800c510:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_GDA( (void *)handle, &status_raw ) == MEMS_ERROR )
 800c512:	f10d 0107 	add.w	r1, sp, #7
 800c516:	f7fe fcbf 	bl	800ae98 <LSM6DSM_ACC_GYRO_R_GDA>
 800c51a:	b120      	cbz	r0, 800c526 <LSM6DSM_G_Get_DRDY_Status+0x1a>
  switch( status_raw )
 800c51c:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800c520:	b148      	cbz	r0, 800c536 <LSM6DSM_G_Get_DRDY_Status+0x2a>
 800c522:	2802      	cmp	r0, #2
 800c524:	d002      	beq.n	800c52c <LSM6DSM_G_Get_DRDY_Status+0x20>
      return COMPONENT_ERROR;
 800c526:	2001      	movs	r0, #1
}
 800c528:	b002      	add	sp, #8
 800c52a:	bd10      	pop	{r4, pc}
      *status = 1;
 800c52c:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800c52e:	2000      	movs	r0, #0
      *status = 1;
 800c530:	7023      	strb	r3, [r4, #0]
}
 800c532:	b002      	add	sp, #8
 800c534:	bd10      	pop	{r4, pc}
      *status = 0;
 800c536:	7020      	strb	r0, [r4, #0]
}
 800c538:	b002      	add	sp, #8
 800c53a:	bd10      	pop	{r4, pc}

0800c53c <LSM6DSM_G_Set_FS>:
  switch( fullScale )
 800c53c:	2902      	cmp	r1, #2
 800c53e:	d00c      	beq.n	800c55a <LSM6DSM_G_Set_FS+0x1e>
 800c540:	2904      	cmp	r1, #4
 800c542:	d002      	beq.n	800c54a <LSM6DSM_G_Set_FS+0xe>
 800c544:	b111      	cbz	r1, 800c54c <LSM6DSM_G_Set_FS+0x10>
      return COMPONENT_ERROR;
 800c546:	2001      	movs	r0, #1
}
 800c548:	4770      	bx	lr
      new_fs = LSM6DSM_ACC_GYRO_FS_G_2000dps;
 800c54a:	210c      	movs	r1, #12
{
 800c54c:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_FS_G( (void *)handle, new_fs ) == MEMS_ERROR )
 800c54e:	f7fe f8b9 	bl	800a6c4 <LSM6DSM_ACC_GYRO_W_FS_G>
      return COMPONENT_ERROR;
 800c552:	fab0 f080 	clz	r0, r0
 800c556:	0940      	lsrs	r0, r0, #5
}
 800c558:	bd08      	pop	{r3, pc}
      new_fs = LSM6DSM_ACC_GYRO_FS_G_500dps;
 800c55a:	2104      	movs	r1, #4
{
 800c55c:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_FS_G( (void *)handle, new_fs ) == MEMS_ERROR )
 800c55e:	f7fe f8b1 	bl	800a6c4 <LSM6DSM_ACC_GYRO_W_FS_G>
      return COMPONENT_ERROR;
 800c562:	fab0 f080 	clz	r0, r0
 800c566:	0940      	lsrs	r0, r0, #5
}
 800c568:	bd08      	pop	{r3, pc}
 800c56a:	bf00      	nop

0800c56c <LSM6DSM_G_Set_ODR_Value_When_Enabled>:
            : ( odr <=  26.0f )  ? LSM6DSM_ACC_GYRO_ODR_G_26Hz
 800c56c:	eef2 7a0a 	vmov.f32	s15, #42	; 0x41500000  13.0
 800c570:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c574:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 800c578:	b508      	push	{r3, lr}
            : ( odr <=  26.0f )  ? LSM6DSM_ACC_GYRO_ODR_G_26Hz
 800c57a:	d90d      	bls.n	800c598 <LSM6DSM_G_Set_ODR_Value_When_Enabled+0x2c>
 800c57c:	eef3 7a0a 	vmov.f32	s15, #58	; 0x41d00000  26.0
 800c580:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c584:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c588:	d80d      	bhi.n	800c5a6 <LSM6DSM_G_Set_ODR_Value_When_Enabled+0x3a>
 800c58a:	2120      	movs	r1, #32
  if ( LSM6DSM_ACC_GYRO_W_ODR_G( (void *)handle, new_odr ) == MEMS_ERROR )
 800c58c:	f7fe f8e8 	bl	800a760 <LSM6DSM_ACC_GYRO_W_ODR_G>
}
 800c590:	fab0 f080 	clz	r0, r0
 800c594:	0940      	lsrs	r0, r0, #5
 800c596:	bd08      	pop	{r3, pc}
            : ( odr <=  26.0f )  ? LSM6DSM_ACC_GYRO_ODR_G_26Hz
 800c598:	2110      	movs	r1, #16
  if ( LSM6DSM_ACC_GYRO_W_ODR_G( (void *)handle, new_odr ) == MEMS_ERROR )
 800c59a:	f7fe f8e1 	bl	800a760 <LSM6DSM_ACC_GYRO_W_ODR_G>
}
 800c59e:	fab0 f080 	clz	r0, r0
 800c5a2:	0940      	lsrs	r0, r0, #5
 800c5a4:	bd08      	pop	{r3, pc}
            : ( odr <=  26.0f )  ? LSM6DSM_ACC_GYRO_ODR_G_26Hz
 800c5a6:	eddf 7a22 	vldr	s15, [pc, #136]	; 800c630 <LSM6DSM_G_Set_ODR_Value_When_Enabled+0xc4>
 800c5aa:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c5ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c5b2:	d92c      	bls.n	800c60e <LSM6DSM_G_Set_ODR_Value_When_Enabled+0xa2>
 800c5b4:	eddf 7a1f 	vldr	s15, [pc, #124]	; 800c634 <LSM6DSM_G_Set_ODR_Value_When_Enabled+0xc8>
 800c5b8:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c5bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c5c0:	d92c      	bls.n	800c61c <LSM6DSM_G_Set_ODR_Value_When_Enabled+0xb0>
 800c5c2:	eddf 7a1d 	vldr	s15, [pc, #116]	; 800c638 <LSM6DSM_G_Set_ODR_Value_When_Enabled+0xcc>
 800c5c6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c5ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c5ce:	d927      	bls.n	800c620 <LSM6DSM_G_Set_ODR_Value_When_Enabled+0xb4>
 800c5d0:	eddf 7a1a 	vldr	s15, [pc, #104]	; 800c63c <LSM6DSM_G_Set_ODR_Value_When_Enabled+0xd0>
 800c5d4:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c5d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c5dc:	d922      	bls.n	800c624 <LSM6DSM_G_Set_ODR_Value_When_Enabled+0xb8>
 800c5de:	eddf 7a18 	vldr	s15, [pc, #96]	; 800c640 <LSM6DSM_G_Set_ODR_Value_When_Enabled+0xd4>
 800c5e2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c5e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c5ea:	d91d      	bls.n	800c628 <LSM6DSM_G_Set_ODR_Value_When_Enabled+0xbc>
 800c5ec:	eddf 7a15 	vldr	s15, [pc, #84]	; 800c644 <LSM6DSM_G_Set_ODR_Value_When_Enabled+0xd8>
 800c5f0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c5f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c5f8:	d918      	bls.n	800c62c <LSM6DSM_G_Set_ODR_Value_When_Enabled+0xc0>
 800c5fa:	eddf 7a13 	vldr	s15, [pc, #76]	; 800c648 <LSM6DSM_G_Set_ODR_Value_When_Enabled+0xdc>
 800c5fe:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c602:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c606:	bf94      	ite	ls
 800c608:	2190      	movls	r1, #144	; 0x90
 800c60a:	21a0      	movhi	r1, #160	; 0xa0
 800c60c:	e7c5      	b.n	800c59a <LSM6DSM_G_Set_ODR_Value_When_Enabled+0x2e>
 800c60e:	2130      	movs	r1, #48	; 0x30
  if ( LSM6DSM_ACC_GYRO_W_ODR_G( (void *)handle, new_odr ) == MEMS_ERROR )
 800c610:	f7fe f8a6 	bl	800a760 <LSM6DSM_ACC_GYRO_W_ODR_G>
}
 800c614:	fab0 f080 	clz	r0, r0
 800c618:	0940      	lsrs	r0, r0, #5
 800c61a:	bd08      	pop	{r3, pc}
            : ( odr <=  26.0f )  ? LSM6DSM_ACC_GYRO_ODR_G_26Hz
 800c61c:	2140      	movs	r1, #64	; 0x40
 800c61e:	e7bc      	b.n	800c59a <LSM6DSM_G_Set_ODR_Value_When_Enabled+0x2e>
 800c620:	2150      	movs	r1, #80	; 0x50
 800c622:	e7ba      	b.n	800c59a <LSM6DSM_G_Set_ODR_Value_When_Enabled+0x2e>
 800c624:	2160      	movs	r1, #96	; 0x60
 800c626:	e7b8      	b.n	800c59a <LSM6DSM_G_Set_ODR_Value_When_Enabled+0x2e>
 800c628:	2170      	movs	r1, #112	; 0x70
 800c62a:	e7b6      	b.n	800c59a <LSM6DSM_G_Set_ODR_Value_When_Enabled+0x2e>
 800c62c:	2180      	movs	r1, #128	; 0x80
 800c62e:	e7b4      	b.n	800c59a <LSM6DSM_G_Set_ODR_Value_When_Enabled+0x2e>
 800c630:	42500000 	.word	0x42500000
 800c634:	42d00000 	.word	0x42d00000
 800c638:	43500000 	.word	0x43500000
 800c63c:	43d00000 	.word	0x43d00000
 800c640:	44504000 	.word	0x44504000
 800c644:	44cf8000 	.word	0x44cf8000
 800c648:	45502000 	.word	0x45502000

0800c64c <LSM6DSM_G_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 800c64c:	7982      	ldrb	r2, [r0, #6]
 800c64e:	2a01      	cmp	r2, #1
 800c650:	d00d      	beq.n	800c66e <LSM6DSM_G_Sensor_Enable+0x22>
  LSM6DSM_G_Data_t *pComponentData = ( LSM6DSM_G_Data_t * )pData->pComponentData;
 800c652:	6883      	ldr	r3, [r0, #8]
  if ( LSM6DSM_G_Set_ODR_Value_When_Enabled( handle, pComponentData->Previous_ODR ) == COMPONENT_ERROR )
 800c654:	681b      	ldr	r3, [r3, #0]
{
 800c656:	b510      	push	{r4, lr}
  if ( LSM6DSM_G_Set_ODR_Value_When_Enabled( handle, pComponentData->Previous_ODR ) == COMPONENT_ERROR )
 800c658:	ed93 0a01 	vldr	s0, [r3, #4]
 800c65c:	4604      	mov	r4, r0
 800c65e:	f7ff ff85 	bl	800c56c <LSM6DSM_G_Set_ODR_Value_When_Enabled>
 800c662:	2801      	cmp	r0, #1
 800c664:	d002      	beq.n	800c66c <LSM6DSM_G_Sensor_Enable+0x20>
  handle->isEnabled = 1;
 800c666:	2301      	movs	r3, #1
 800c668:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 800c66a:	2000      	movs	r0, #0
}
 800c66c:	bd10      	pop	{r4, pc}
    return COMPONENT_OK;
 800c66e:	2000      	movs	r0, #0
}
 800c670:	4770      	bx	lr
 800c672:	bf00      	nop

0800c674 <LSM6DSM_G_Init>:
  LSM6DSM_G_Data_t *pComponentData = ( LSM6DSM_G_Data_t * )pData->pComponentData;
 800c674:	6883      	ldr	r3, [r0, #8]
{
 800c676:	b570      	push	{r4, r5, r6, lr}
  LSM6DSM_G_Data_t *pComponentData = ( LSM6DSM_G_Data_t * )pData->pComponentData;
 800c678:	681d      	ldr	r5, [r3, #0]
{
 800c67a:	4604      	mov	r4, r0
  LSM6DSM_Combo_Data_t *comboData = pComponentData->comboData;
 800c67c:	682e      	ldr	r6, [r5, #0]
  if ( LSM6DSM_Check_WhoAmI( handle ) == COMPONENT_ERROR )
 800c67e:	f7ff fef1 	bl	800c464 <LSM6DSM_Check_WhoAmI>
 800c682:	2801      	cmp	r0, #1
 800c684:	d004      	beq.n	800c690 <LSM6DSM_G_Init+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_IF_Addr_Incr( (void *)handle, LSM6DSM_ACC_GYRO_IF_INC_ENABLED ) == MEMS_ERROR )
 800c686:	2104      	movs	r1, #4
 800c688:	4620      	mov	r0, r4
 800c68a:	f7fe fa35 	bl	800aaf8 <LSM6DSM_ACC_GYRO_W_IF_Addr_Incr>
 800c68e:	b908      	cbnz	r0, 800c694 <LSM6DSM_G_Init+0x20>
    return COMPONENT_ERROR;
 800c690:	2001      	movs	r0, #1
}
 800c692:	bd70      	pop	{r4, r5, r6, pc}
  if ( LSM6DSM_ACC_GYRO_W_BDU( (void *)handle, LSM6DSM_ACC_GYRO_BDU_BLOCK_UPDATE ) == MEMS_ERROR )
 800c694:	2140      	movs	r1, #64	; 0x40
 800c696:	4620      	mov	r0, r4
 800c698:	f7fd ff72 	bl	800a580 <LSM6DSM_ACC_GYRO_W_BDU>
 800c69c:	2800      	cmp	r0, #0
 800c69e:	d0f7      	beq.n	800c690 <LSM6DSM_G_Init+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_FIFO_MODE( (void *)handle, LSM6DSM_ACC_GYRO_FIFO_MODE_BYPASS ) == MEMS_ERROR )
 800c6a0:	2100      	movs	r1, #0
 800c6a2:	4620      	mov	r0, r4
 800c6a4:	f7fe f97e 	bl	800a9a4 <LSM6DSM_ACC_GYRO_W_FIFO_MODE>
 800c6a8:	2800      	cmp	r0, #0
 800c6aa:	d0f1      	beq.n	800c690 <LSM6DSM_G_Init+0x1c>
  pComponentData->Previous_ODR = 104.0f;
 800c6ac:	4b09      	ldr	r3, [pc, #36]	; (800c6d4 <LSM6DSM_G_Init+0x60>)
 800c6ae:	606b      	str	r3, [r5, #4]
  if ( LSM6DSM_ACC_GYRO_W_ODR_G( (void *)handle, LSM6DSM_ACC_GYRO_ODR_G_POWER_DOWN ) == MEMS_ERROR )
 800c6b0:	2100      	movs	r1, #0
 800c6b2:	4620      	mov	r0, r4
 800c6b4:	f7fe f854 	bl	800a760 <LSM6DSM_ACC_GYRO_W_ODR_G>
 800c6b8:	2800      	cmp	r0, #0
 800c6ba:	d0e9      	beq.n	800c690 <LSM6DSM_G_Init+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_FS_G( (void *)handle, new_fs ) == MEMS_ERROR )
 800c6bc:	210c      	movs	r1, #12
 800c6be:	4620      	mov	r0, r4
 800c6c0:	f7fe f800 	bl	800a6c4 <LSM6DSM_ACC_GYRO_W_FS_G>
 800c6c4:	2800      	cmp	r0, #0
 800c6c6:	d0e3      	beq.n	800c690 <LSM6DSM_G_Init+0x1c>
  comboData->isGyroInitialized = 1;
 800c6c8:	2301      	movs	r3, #1
 800c6ca:	7073      	strb	r3, [r6, #1]
  handle->isInitialized = 1;
 800c6cc:	7163      	strb	r3, [r4, #5]
  return COMPONENT_OK;
 800c6ce:	2000      	movs	r0, #0
}
 800c6d0:	bd70      	pop	{r4, r5, r6, pc}
 800c6d2:	bf00      	nop
 800c6d4:	42d00000 	.word	0x42d00000

0800c6d8 <LSM6DSM_G_Get_ODR>:
{
 800c6d8:	b510      	push	{r4, lr}
 800c6da:	b082      	sub	sp, #8
 800c6dc:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_ODR_G( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 800c6de:	f10d 0107 	add.w	r1, sp, #7
 800c6e2:	f7fe f85f 	bl	800a7a4 <LSM6DSM_ACC_GYRO_R_ODR_G>
 800c6e6:	b178      	cbz	r0, 800c708 <LSM6DSM_G_Get_ODR+0x30>
  switch( odr_low_level )
 800c6e8:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800c6ec:	2850      	cmp	r0, #80	; 0x50
 800c6ee:	d028      	beq.n	800c742 <LSM6DSM_G_Get_ODR+0x6a>
 800c6f0:	d80d      	bhi.n	800c70e <LSM6DSM_G_Get_ODR+0x36>
 800c6f2:	2820      	cmp	r0, #32
 800c6f4:	d035      	beq.n	800c762 <LSM6DSM_G_Get_ODR+0x8a>
 800c6f6:	d91d      	bls.n	800c734 <LSM6DSM_G_Get_ODR+0x5c>
 800c6f8:	2830      	cmp	r0, #48	; 0x30
 800c6fa:	d03a      	beq.n	800c772 <LSM6DSM_G_Get_ODR+0x9a>
 800c6fc:	2840      	cmp	r0, #64	; 0x40
 800c6fe:	d124      	bne.n	800c74a <LSM6DSM_G_Get_ODR+0x72>
      *odr =  104.0f;
 800c700:	4b1f      	ldr	r3, [pc, #124]	; (800c780 <LSM6DSM_G_Get_ODR+0xa8>)
 800c702:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c704:	2000      	movs	r0, #0
      break;
 800c706:	e000      	b.n	800c70a <LSM6DSM_G_Get_ODR+0x32>
    return COMPONENT_ERROR;
 800c708:	2001      	movs	r0, #1
}
 800c70a:	b002      	add	sp, #8
 800c70c:	bd10      	pop	{r4, pc}
  switch( odr_low_level )
 800c70e:	2880      	cmp	r0, #128	; 0x80
 800c710:	d023      	beq.n	800c75a <LSM6DSM_G_Get_ODR+0x82>
 800c712:	d907      	bls.n	800c724 <LSM6DSM_G_Get_ODR+0x4c>
 800c714:	2890      	cmp	r0, #144	; 0x90
 800c716:	d028      	beq.n	800c76a <LSM6DSM_G_Get_ODR+0x92>
 800c718:	28a0      	cmp	r0, #160	; 0xa0
 800c71a:	d116      	bne.n	800c74a <LSM6DSM_G_Get_ODR+0x72>
      *odr = 6660.0f;
 800c71c:	4b19      	ldr	r3, [pc, #100]	; (800c784 <LSM6DSM_G_Get_ODR+0xac>)
 800c71e:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c720:	2000      	movs	r0, #0
      break;
 800c722:	e7f2      	b.n	800c70a <LSM6DSM_G_Get_ODR+0x32>
  switch( odr_low_level )
 800c724:	2860      	cmp	r0, #96	; 0x60
 800c726:	d014      	beq.n	800c752 <LSM6DSM_G_Get_ODR+0x7a>
 800c728:	2870      	cmp	r0, #112	; 0x70
 800c72a:	d10e      	bne.n	800c74a <LSM6DSM_G_Get_ODR+0x72>
      *odr =  833.0f;
 800c72c:	4b16      	ldr	r3, [pc, #88]	; (800c788 <LSM6DSM_G_Get_ODR+0xb0>)
 800c72e:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c730:	2000      	movs	r0, #0
      break;
 800c732:	e7ea      	b.n	800c70a <LSM6DSM_G_Get_ODR+0x32>
  switch( odr_low_level )
 800c734:	b308      	cbz	r0, 800c77a <LSM6DSM_G_Get_ODR+0xa2>
 800c736:	2810      	cmp	r0, #16
 800c738:	d107      	bne.n	800c74a <LSM6DSM_G_Get_ODR+0x72>
      *odr =   13.0f;
 800c73a:	4b14      	ldr	r3, [pc, #80]	; (800c78c <LSM6DSM_G_Get_ODR+0xb4>)
 800c73c:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c73e:	2000      	movs	r0, #0
      break;
 800c740:	e7e3      	b.n	800c70a <LSM6DSM_G_Get_ODR+0x32>
      *odr =  208.0f;
 800c742:	4b13      	ldr	r3, [pc, #76]	; (800c790 <LSM6DSM_G_Get_ODR+0xb8>)
 800c744:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c746:	2000      	movs	r0, #0
      break;
 800c748:	e7df      	b.n	800c70a <LSM6DSM_G_Get_ODR+0x32>
      *odr =   -1.0f;
 800c74a:	4b12      	ldr	r3, [pc, #72]	; (800c794 <LSM6DSM_G_Get_ODR+0xbc>)
 800c74c:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 800c74e:	2001      	movs	r0, #1
 800c750:	e7db      	b.n	800c70a <LSM6DSM_G_Get_ODR+0x32>
      *odr =  416.0f;
 800c752:	4b11      	ldr	r3, [pc, #68]	; (800c798 <LSM6DSM_G_Get_ODR+0xc0>)
 800c754:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c756:	2000      	movs	r0, #0
      break;
 800c758:	e7d7      	b.n	800c70a <LSM6DSM_G_Get_ODR+0x32>
      *odr = 1660.0f;
 800c75a:	4b10      	ldr	r3, [pc, #64]	; (800c79c <LSM6DSM_G_Get_ODR+0xc4>)
 800c75c:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c75e:	2000      	movs	r0, #0
      break;
 800c760:	e7d3      	b.n	800c70a <LSM6DSM_G_Get_ODR+0x32>
      *odr =   26.0f;
 800c762:	4b0f      	ldr	r3, [pc, #60]	; (800c7a0 <LSM6DSM_G_Get_ODR+0xc8>)
 800c764:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c766:	2000      	movs	r0, #0
      break;
 800c768:	e7cf      	b.n	800c70a <LSM6DSM_G_Get_ODR+0x32>
      *odr = 3330.0f;
 800c76a:	4b0e      	ldr	r3, [pc, #56]	; (800c7a4 <LSM6DSM_G_Get_ODR+0xcc>)
 800c76c:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c76e:	2000      	movs	r0, #0
      break;
 800c770:	e7cb      	b.n	800c70a <LSM6DSM_G_Get_ODR+0x32>
      *odr =   52.0f;
 800c772:	4b0d      	ldr	r3, [pc, #52]	; (800c7a8 <LSM6DSM_G_Get_ODR+0xd0>)
 800c774:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800c776:	2000      	movs	r0, #0
      break;
 800c778:	e7c7      	b.n	800c70a <LSM6DSM_G_Get_ODR+0x32>
      *odr =    0.0f;
 800c77a:	2300      	movs	r3, #0
 800c77c:	6023      	str	r3, [r4, #0]
      break;
 800c77e:	e7c4      	b.n	800c70a <LSM6DSM_G_Get_ODR+0x32>
 800c780:	42d00000 	.word	0x42d00000
 800c784:	45d02000 	.word	0x45d02000
 800c788:	44504000 	.word	0x44504000
 800c78c:	41500000 	.word	0x41500000
 800c790:	43500000 	.word	0x43500000
 800c794:	bf800000 	.word	0xbf800000
 800c798:	43d00000 	.word	0x43d00000
 800c79c:	44cf8000 	.word	0x44cf8000
 800c7a0:	41d00000 	.word	0x41d00000
 800c7a4:	45502000 	.word	0x45502000
 800c7a8:	42500000 	.word	0x42500000

0800c7ac <LSM6DSM_G_Get_Axes_Raw>:
{
 800c7ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c7ae:	b083      	sub	sp, #12
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 800c7b0:	2400      	movs	r4, #0
{
 800c7b2:	460d      	mov	r5, r1
  if ( LSM6DSM_ACC_GYRO_GetRawGyroData( (void *)handle, ( uint8_t* )regValue ) == MEMS_ERROR )
 800c7b4:	4669      	mov	r1, sp
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 800c7b6:	f8ad 4004 	strh.w	r4, [sp, #4]
 800c7ba:	9400      	str	r4, [sp, #0]
  if ( LSM6DSM_ACC_GYRO_GetRawGyroData( (void *)handle, ( uint8_t* )regValue ) == MEMS_ERROR )
 800c7bc:	f7fd ffb4 	bl	800a728 <LSM6DSM_ACC_GYRO_GetRawGyroData>
 800c7c0:	b1b8      	cbz	r0, 800c7f2 <LSM6DSM_G_Get_Axes_Raw+0x46>
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 800c7c2:	f89d 0005 	ldrb.w	r0, [sp, #5]
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 800c7c6:	f89d 7001 	ldrb.w	r7, [sp, #1]
 800c7ca:	f89d 1000 	ldrb.w	r1, [sp]
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 800c7ce:	f89d 6003 	ldrb.w	r6, [sp, #3]
 800c7d2:	f89d 2002 	ldrb.w	r2, [sp, #2]
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 800c7d6:	f89d 3004 	ldrb.w	r3, [sp, #4]
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 800c7da:	eb01 2107 	add.w	r1, r1, r7, lsl #8
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 800c7de:	eb03 2300 	add.w	r3, r3, r0, lsl #8
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 800c7e2:	eb02 2206 	add.w	r2, r2, r6, lsl #8
  return COMPONENT_OK;
 800c7e6:	4620      	mov	r0, r4
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 800c7e8:	8029      	strh	r1, [r5, #0]
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 800c7ea:	806a      	strh	r2, [r5, #2]
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 800c7ec:	80ab      	strh	r3, [r5, #4]
}
 800c7ee:	b003      	add	sp, #12
 800c7f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return COMPONENT_ERROR;
 800c7f2:	2001      	movs	r0, #1
}
 800c7f4:	b003      	add	sp, #12
 800c7f6:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800c7f8 <LSM6DSM_G_Get_AxesRaw>:
{
 800c7f8:	b510      	push	{r4, lr}
 800c7fa:	b082      	sub	sp, #8
 800c7fc:	460c      	mov	r4, r1
  if ( LSM6DSM_G_Get_Axes_Raw( handle, dataRaw ) == COMPONENT_ERROR )
 800c7fe:	4669      	mov	r1, sp
 800c800:	f7ff ffd4 	bl	800c7ac <LSM6DSM_G_Get_Axes_Raw>
 800c804:	2801      	cmp	r0, #1
 800c806:	d009      	beq.n	800c81c <LSM6DSM_G_Get_AxesRaw+0x24>
  value->AXIS_X = dataRaw[0];
 800c808:	f8bd 1000 	ldrh.w	r1, [sp]
  value->AXIS_Y = dataRaw[1];
 800c80c:	f8bd 2002 	ldrh.w	r2, [sp, #2]
  value->AXIS_Z = dataRaw[2];
 800c810:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  value->AXIS_X = dataRaw[0];
 800c814:	8021      	strh	r1, [r4, #0]
  value->AXIS_Y = dataRaw[1];
 800c816:	8062      	strh	r2, [r4, #2]
  value->AXIS_Z = dataRaw[2];
 800c818:	80a3      	strh	r3, [r4, #4]
  return COMPONENT_OK;
 800c81a:	2000      	movs	r0, #0
}
 800c81c:	b002      	add	sp, #8
 800c81e:	bd10      	pop	{r4, pc}

0800c820 <LSM6DSM_X_Set_SelfTest>:
*/
static DrvStatusTypeDef LSM6DSM_X_Set_SelfTest( DrvContextTypeDef *handle, uint8_t status )
{

  /* Verify that the passed parameter contains one of the valid values. */
  switch ( ( LSM6DSM_ACC_GYRO_ST_XL_t )status )
 800c820:	2903      	cmp	r1, #3
 800c822:	d901      	bls.n	800c828 <LSM6DSM_X_Set_SelfTest+0x8>
    case LSM6DSM_ACC_GYRO_ST_XL_POS_SIGN_TEST:
    case LSM6DSM_ACC_GYRO_ST_XL_NEG_SIGN_TEST:
    case LSM6DSM_ACC_GYRO_ST_XL_NA:
      break;
    default:
      return COMPONENT_ERROR;
 800c824:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 800c826:	4770      	bx	lr
{
 800c828:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_SelfTest_XL( handle, ( LSM6DSM_ACC_GYRO_ST_XL_t )status ) == MEMS_ERROR )
 800c82a:	f7fe f9a9 	bl	800ab80 <LSM6DSM_ACC_GYRO_W_SelfTest_XL>
      return COMPONENT_ERROR;
 800c82e:	fab0 f080 	clz	r0, r0
 800c832:	0940      	lsrs	r0, r0, #5
}
 800c834:	bd08      	pop	{r3, pc}
 800c836:	bf00      	nop

0800c838 <LSM6DSM_X_Set_Interrupt_Latch>:
  switch ( ( LSM6DSM_ACC_GYRO_LIR_t )status )
 800c838:	2901      	cmp	r1, #1
 800c83a:	d901      	bls.n	800c840 <LSM6DSM_X_Set_Interrupt_Latch+0x8>
      return COMPONENT_ERROR;
 800c83c:	2001      	movs	r0, #1
}
 800c83e:	4770      	bx	lr
{
 800c840:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_LIR( handle, ( LSM6DSM_ACC_GYRO_LIR_t )status ) == MEMS_ERROR )
 800c842:	f7fe fbd1 	bl	800afe8 <LSM6DSM_ACC_GYRO_W_LIR>
      return COMPONENT_ERROR;
 800c846:	fab0 f080 	clz	r0, r0
 800c84a:	0940      	lsrs	r0, r0, #5
}
 800c84c:	bd08      	pop	{r3, pc}
 800c84e:	bf00      	nop

0800c850 <LSM6DSM_G_Set_Interrupt_Latch>:
 800c850:	f7ff bff2 	b.w	800c838 <LSM6DSM_X_Set_Interrupt_Latch>

0800c854 <LSM6DSM_FIFO_Set_Stop_On_Fth>:
  switch ( ( LSM6DSM_ACC_GYRO_STOP_ON_FTH_t )status )
 800c854:	b119      	cbz	r1, 800c85e <LSM6DSM_FIFO_Set_Stop_On_Fth+0xa>
 800c856:	2980      	cmp	r1, #128	; 0x80
 800c858:	d001      	beq.n	800c85e <LSM6DSM_FIFO_Set_Stop_On_Fth+0xa>
      return COMPONENT_ERROR;
 800c85a:	2001      	movs	r0, #1
}
 800c85c:	4770      	bx	lr
{
 800c85e:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_STOP_ON_FTH( handle, ( LSM6DSM_ACC_GYRO_STOP_ON_FTH_t )status ) == MEMS_ERROR )
 800c860:	f7fe f87e 	bl	800a960 <LSM6DSM_ACC_GYRO_W_STOP_ON_FTH>
      return COMPONENT_ERROR;
 800c864:	fab0 f080 	clz	r0, r0
 800c868:	0940      	lsrs	r0, r0, #5
}
 800c86a:	bd08      	pop	{r3, pc}

0800c86c <LSM6DSM_FIFO_Set_INT1_FIFO_Full>:
  switch ( ( LSM6DSM_ACC_GYRO_INT1_FULL_FLAG_t )status )
 800c86c:	b119      	cbz	r1, 800c876 <LSM6DSM_FIFO_Set_INT1_FIFO_Full+0xa>
 800c86e:	2920      	cmp	r1, #32
 800c870:	d001      	beq.n	800c876 <LSM6DSM_FIFO_Set_INT1_FIFO_Full+0xa>
      return COMPONENT_ERROR;
 800c872:	2001      	movs	r0, #1
}
 800c874:	4770      	bx	lr
{
 800c876:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_FULL_FLAG_on_INT1( handle, ( LSM6DSM_ACC_GYRO_INT1_FULL_FLAG_t )status ) == MEMS_ERROR )
 800c878:	f7fe f8d8 	bl	800aa2c <LSM6DSM_ACC_GYRO_W_FULL_FLAG_on_INT1>
      return COMPONENT_ERROR;
 800c87c:	fab0 f080 	clz	r0, r0
 800c880:	0940      	lsrs	r0, r0, #5
}
 800c882:	bd08      	pop	{r3, pc}

0800c884 <LSM6DSM_FIFO_Set_Mode>:
{
 800c884:	2906      	cmp	r1, #6
 800c886:	d808      	bhi.n	800c89a <LSM6DSM_FIFO_Set_Mode+0x16>
 800c888:	b508      	push	{r3, lr}
 800c88a:	2301      	movs	r3, #1
 800c88c:	fa03 f201 	lsl.w	r2, r3, r1
 800c890:	f012 0f5b 	tst.w	r2, #91	; 0x5b
 800c894:	d103      	bne.n	800c89e <LSM6DSM_FIFO_Set_Mode+0x1a>
      return COMPONENT_ERROR;
 800c896:	4618      	mov	r0, r3
}
 800c898:	bd08      	pop	{r3, pc}
      return COMPONENT_ERROR;
 800c89a:	2001      	movs	r0, #1
}
 800c89c:	4770      	bx	lr
  if ( LSM6DSM_ACC_GYRO_W_FIFO_MODE( handle, ( LSM6DSM_ACC_GYRO_FIFO_MODE_t )mode ) == MEMS_ERROR )
 800c89e:	f7fe f881 	bl	800a9a4 <LSM6DSM_ACC_GYRO_W_FIFO_MODE>
      return COMPONENT_ERROR;
 800c8a2:	fab0 f080 	clz	r0, r0
 800c8a6:	0940      	lsrs	r0, r0, #5
}
 800c8a8:	bd08      	pop	{r3, pc}
 800c8aa:	bf00      	nop

0800c8ac <LSM6DSM_FIFO_X_Set_Decimation>:
  switch ( ( LSM6DSM_ACC_GYRO_DEC_FIFO_XL_t )decimation )
 800c8ac:	2907      	cmp	r1, #7
 800c8ae:	d901      	bls.n	800c8b4 <LSM6DSM_FIFO_X_Set_Decimation+0x8>
      return COMPONENT_ERROR;
 800c8b0:	2001      	movs	r0, #1
}
 800c8b2:	4770      	bx	lr
{
 800c8b4:	b508      	push	{r3, lr}
  if ( LSM6DSM_ACC_GYRO_W_DEC_FIFO_XL( handle, ( LSM6DSM_ACC_GYRO_DEC_FIFO_XL_t )decimation ) == MEMS_ERROR )
 800c8b6:	f7fe f80f 	bl	800a8d8 <LSM6DSM_ACC_GYRO_W_DEC_FIFO_XL>
      return COMPONENT_ERROR;
 800c8ba:	fab0 f080 	clz	r0, r0
 800c8be:	0940      	lsrs	r0, r0, #5
}
 800c8c0:	bd08      	pop	{r3, pc}
 800c8c2:	bf00      	nop

0800c8c4 <LSM6DSM_X_Disable_6D_Orientation>:
{
 800c8c4:	b510      	push	{r4, lr}
  if ( LSM6DSM_ACC_GYRO_W_6DEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_6D_DISABLED ) == MEMS_ERROR )
 800c8c6:	2100      	movs	r1, #0
{
 800c8c8:	4604      	mov	r4, r0
  if ( LSM6DSM_ACC_GYRO_W_6DEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_6D_DISABLED ) == MEMS_ERROR )
 800c8ca:	f7fe fe17 	bl	800b4fc <LSM6DSM_ACC_GYRO_W_6DEvOnInt1>
 800c8ce:	b908      	cbnz	r0, 800c8d4 <LSM6DSM_X_Disable_6D_Orientation+0x10>
    return COMPONENT_ERROR;
 800c8d0:	2001      	movs	r0, #1
}
 800c8d2:	bd10      	pop	{r4, pc}
  if ( LSM6DSM_ACC_GYRO_W_6DEvOnInt2( (void *)handle, LSM6DSM_ACC_GYRO_INT2_6D_DISABLED ) == MEMS_ERROR )
 800c8d4:	2100      	movs	r1, #0
 800c8d6:	4620      	mov	r0, r4
 800c8d8:	f7fe fedc 	bl	800b694 <LSM6DSM_ACC_GYRO_W_6DEvOnInt2>
 800c8dc:	2800      	cmp	r0, #0
 800c8de:	d0f7      	beq.n	800c8d0 <LSM6DSM_X_Disable_6D_Orientation+0xc>
  if ( LSM6DSM_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSM_ACC_GYRO_BASIC_INT_DISABLED ) == MEMS_ERROR )
 800c8e0:	2100      	movs	r1, #0
 800c8e2:	4620      	mov	r0, r4
 800c8e4:	f7fe fc08 	bl	800b0f8 <LSM6DSM_ACC_GYRO_W_BASIC_INT>
 800c8e8:	2800      	cmp	r0, #0
 800c8ea:	d0f1      	beq.n	800c8d0 <LSM6DSM_X_Disable_6D_Orientation+0xc>
  if ( LSM6DSM_ACC_GYRO_W_SIXD_THS( (void *)handle, LSM6DSM_ACC_GYRO_SIXD_THS_80_degree ) == MEMS_ERROR )
 800c8ec:	4620      	mov	r0, r4
 800c8ee:	2100      	movs	r1, #0
 800c8f0:	f7fe fc48 	bl	800b184 <LSM6DSM_ACC_GYRO_W_SIXD_THS>
    return COMPONENT_ERROR;
 800c8f4:	fab0 f080 	clz	r0, r0
 800c8f8:	0940      	lsrs	r0, r0, #5
}
 800c8fa:	bd10      	pop	{r4, pc}

0800c8fc <LSM6DSM_X_Set_ODR_Value>:
{
 800c8fc:	b508      	push	{r3, lr}
  if(handle->isEnabled == 1)
 800c8fe:	7982      	ldrb	r2, [r0, #6]
 800c900:	2a01      	cmp	r2, #1
 800c902:	d048      	beq.n	800c996 <LSM6DSM_X_Set_ODR_Value+0x9a>
                                 : ( odr <=   26.0f ) ? 26.0f
 800c904:	eef2 7a0a 	vmov.f32	s15, #42	; 0x41500000  13.0
  LSM6DSM_X_Data_t *pComponentData = ( LSM6DSM_X_Data_t * )pData->pComponentData;
 800c908:	6883      	ldr	r3, [r0, #8]
                                 : ( odr <=   26.0f ) ? 26.0f
 800c90a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c90e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  LSM6DSM_X_Data_t *pComponentData = ( LSM6DSM_X_Data_t * )pData->pComponentData;
 800c912:	681b      	ldr	r3, [r3, #0]
                                 : ( odr <=   26.0f ) ? 26.0f
 800c914:	d93b      	bls.n	800c98e <LSM6DSM_X_Set_ODR_Value+0x92>
                                 : ( odr <=   52.0f ) ? 52.0f
 800c916:	eef3 7a0a 	vmov.f32	s15, #58	; 0x41d00000  26.0
 800c91a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c91e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c922:	d934      	bls.n	800c98e <LSM6DSM_X_Set_ODR_Value+0x92>
                                 : ( odr <=  104.0f ) ? 104.0f
 800c924:	eddf 7a20 	vldr	s15, [pc, #128]	; 800c9a8 <LSM6DSM_X_Set_ODR_Value+0xac>
 800c928:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c92c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c930:	d92d      	bls.n	800c98e <LSM6DSM_X_Set_ODR_Value+0x92>
                                 : ( odr <=  208.0f ) ? 208.0f
 800c932:	eddf 7a1e 	vldr	s15, [pc, #120]	; 800c9ac <LSM6DSM_X_Set_ODR_Value+0xb0>
 800c936:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c93a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c93e:	d926      	bls.n	800c98e <LSM6DSM_X_Set_ODR_Value+0x92>
                                 : ( odr <=  416.0f ) ? 416.0f
 800c940:	eddf 7a1b 	vldr	s15, [pc, #108]	; 800c9b0 <LSM6DSM_X_Set_ODR_Value+0xb4>
 800c944:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c948:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c94c:	d91f      	bls.n	800c98e <LSM6DSM_X_Set_ODR_Value+0x92>
                                 : ( odr <=  833.0f ) ? 833.0f
 800c94e:	eddf 7a19 	vldr	s15, [pc, #100]	; 800c9b4 <LSM6DSM_X_Set_ODR_Value+0xb8>
 800c952:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c956:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c95a:	d918      	bls.n	800c98e <LSM6DSM_X_Set_ODR_Value+0x92>
                                 : ( odr <= 1660.0f ) ? 1660.0f
 800c95c:	eddf 7a16 	vldr	s15, [pc, #88]	; 800c9b8 <LSM6DSM_X_Set_ODR_Value+0xbc>
 800c960:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c964:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c968:	d911      	bls.n	800c98e <LSM6DSM_X_Set_ODR_Value+0x92>
                                 : ( odr <= 3330.0f ) ? 3330.0f
 800c96a:	eddf 7a14 	vldr	s15, [pc, #80]	; 800c9bc <LSM6DSM_X_Set_ODR_Value+0xc0>
 800c96e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c972:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c976:	d90a      	bls.n	800c98e <LSM6DSM_X_Set_ODR_Value+0x92>
                                 :                      6660.0f;
 800c978:	eddf 7a11 	vldr	s15, [pc, #68]	; 800c9c0 <LSM6DSM_X_Set_ODR_Value+0xc4>
 800c97c:	eddf 6a11 	vldr	s13, [pc, #68]	; 800c9c4 <LSM6DSM_X_Set_ODR_Value+0xc8>
 800c980:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800c984:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c988:	bf88      	it	hi
 800c98a:	eef0 7a66 	vmovhi.f32	s15, s13
  pComponentData->Previous_ODR = ( odr <=   13.0f ) ? 13.0f
 800c98e:	edc3 7a01 	vstr	s15, [r3, #4]
  return COMPONENT_OK;
 800c992:	2000      	movs	r0, #0
}
 800c994:	bd08      	pop	{r3, pc}
    if(LSM6DSM_X_Set_ODR_Value_When_Enabled(handle, odr) == COMPONENT_ERROR)
 800c996:	f7ff faaf 	bl	800bef8 <LSM6DSM_X_Set_ODR_Value_When_Enabled>
  return COMPONENT_OK;
 800c99a:	f1a0 0001 	sub.w	r0, r0, #1
 800c99e:	fab0 f080 	clz	r0, r0
 800c9a2:	0940      	lsrs	r0, r0, #5
}
 800c9a4:	bd08      	pop	{r3, pc}
 800c9a6:	bf00      	nop
 800c9a8:	42500000 	.word	0x42500000
 800c9ac:	42d00000 	.word	0x42d00000
 800c9b0:	43500000 	.word	0x43500000
 800c9b4:	43d00000 	.word	0x43d00000
 800c9b8:	44504000 	.word	0x44504000
 800c9bc:	44cf8000 	.word	0x44cf8000
 800c9c0:	45502000 	.word	0x45502000
 800c9c4:	45d02000 	.word	0x45d02000

0800c9c8 <LSM6DSM_X_Enable_6D_Orientation>:
{
 800c9c8:	b538      	push	{r3, r4, r5, lr}
  if(LSM6DSM_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 800c9ca:	ed9f 0a17 	vldr	s0, [pc, #92]	; 800ca28 <LSM6DSM_X_Enable_6D_Orientation+0x60>
{
 800c9ce:	460d      	mov	r5, r1
 800c9d0:	4604      	mov	r4, r0
  if(LSM6DSM_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 800c9d2:	f7ff ff93 	bl	800c8fc <LSM6DSM_X_Set_ODR_Value>
 800c9d6:	2801      	cmp	r0, #1
 800c9d8:	d004      	beq.n	800c9e4 <LSM6DSM_X_Enable_6D_Orientation+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_FS_XL( (void *)handle, LSM6DSM_ACC_GYRO_FS_XL_2g ) == MEMS_ERROR )
 800c9da:	2100      	movs	r1, #0
 800c9dc:	4620      	mov	r0, r4
 800c9de:	f7fd fdf1 	bl	800a5c4 <LSM6DSM_ACC_GYRO_W_FS_XL>
 800c9e2:	b908      	cbnz	r0, 800c9e8 <LSM6DSM_X_Enable_6D_Orientation+0x20>
    return COMPONENT_ERROR;
 800c9e4:	2001      	movs	r0, #1
}
 800c9e6:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSM_ACC_GYRO_W_SIXD_THS( (void *)handle, LSM6DSM_ACC_GYRO_SIXD_THS_60_degree ) == MEMS_ERROR )
 800c9e8:	2140      	movs	r1, #64	; 0x40
 800c9ea:	4620      	mov	r0, r4
 800c9ec:	f7fe fbca 	bl	800b184 <LSM6DSM_ACC_GYRO_W_SIXD_THS>
 800c9f0:	2800      	cmp	r0, #0
 800c9f2:	d0f7      	beq.n	800c9e4 <LSM6DSM_X_Enable_6D_Orientation+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSM_ACC_GYRO_BASIC_INT_ENABLED ) == MEMS_ERROR )
 800c9f4:	2180      	movs	r1, #128	; 0x80
 800c9f6:	4620      	mov	r0, r4
 800c9f8:	f7fe fb7e 	bl	800b0f8 <LSM6DSM_ACC_GYRO_W_BASIC_INT>
 800c9fc:	2800      	cmp	r0, #0
 800c9fe:	d0f1      	beq.n	800c9e4 <LSM6DSM_X_Enable_6D_Orientation+0x1c>
  switch (int_pin)
 800ca00:	b14d      	cbz	r5, 800ca16 <LSM6DSM_X_Enable_6D_Orientation+0x4e>
 800ca02:	2d01      	cmp	r5, #1
 800ca04:	d1ee      	bne.n	800c9e4 <LSM6DSM_X_Enable_6D_Orientation+0x1c>
    if ( LSM6DSM_ACC_GYRO_W_6DEvOnInt2( (void *)handle, LSM6DSM_ACC_GYRO_INT2_6D_ENABLED ) == MEMS_ERROR )
 800ca06:	4620      	mov	r0, r4
 800ca08:	2104      	movs	r1, #4
 800ca0a:	f7fe fe43 	bl	800b694 <LSM6DSM_ACC_GYRO_W_6DEvOnInt2>
    return COMPONENT_ERROR;
 800ca0e:	fab0 f080 	clz	r0, r0
 800ca12:	0940      	lsrs	r0, r0, #5
}
 800ca14:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSM_ACC_GYRO_W_6DEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_6D_ENABLED ) == MEMS_ERROR )
 800ca16:	4620      	mov	r0, r4
 800ca18:	2104      	movs	r1, #4
 800ca1a:	f7fe fd6f 	bl	800b4fc <LSM6DSM_ACC_GYRO_W_6DEvOnInt1>
    return COMPONENT_ERROR;
 800ca1e:	fab0 f080 	clz	r0, r0
 800ca22:	0940      	lsrs	r0, r0, #5
}
 800ca24:	bd38      	pop	{r3, r4, r5, pc}
 800ca26:	bf00      	nop
 800ca28:	43d00000 	.word	0x43d00000

0800ca2c <LSM6DSM_X_Set_ODR>:
{
 800ca2c:	b508      	push	{r3, lr}
  if(handle->isEnabled == 1)
 800ca2e:	7983      	ldrb	r3, [r0, #6]
 800ca30:	2b01      	cmp	r3, #1
 800ca32:	d00c      	beq.n	800ca4e <LSM6DSM_X_Set_ODR+0x22>
  LSM6DSM_X_Data_t *pComponentData = ( LSM6DSM_X_Data_t * )pData->pComponentData;
 800ca34:	6883      	ldr	r3, [r0, #8]
 800ca36:	681b      	ldr	r3, [r3, #0]
  switch( odr )
 800ca38:	2904      	cmp	r1, #4
 800ca3a:	d828      	bhi.n	800ca8e <LSM6DSM_X_Set_ODR+0x62>
 800ca3c:	e8df f001 	tbb	[pc, r1]
 800ca40:	16120303 	.word	0x16120303
 800ca44:	0e          	.byte	0x0e
 800ca45:	00          	.byte	0x00
      pComponentData->Previous_ODR = 13.0f;
 800ca46:	4a13      	ldr	r2, [pc, #76]	; (800ca94 <LSM6DSM_X_Set_ODR+0x68>)
 800ca48:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 800ca4a:	2000      	movs	r0, #0
}
 800ca4c:	bd08      	pop	{r3, pc}
  switch( odr )
 800ca4e:	2904      	cmp	r1, #4
 800ca50:	d81d      	bhi.n	800ca8e <LSM6DSM_X_Set_ODR+0x62>
 800ca52:	e8df f001 	tbb	[pc, r1]
 800ca56:	0f0f      	.short	0x0f0f
 800ca58:	1a18      	.short	0x1a18
 800ca5a:	16          	.byte	0x16
 800ca5b:	00          	.byte	0x00
      pComponentData->Previous_ODR = 104.0f;
 800ca5c:	4a0e      	ldr	r2, [pc, #56]	; (800ca98 <LSM6DSM_X_Set_ODR+0x6c>)
 800ca5e:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 800ca60:	2000      	movs	r0, #0
}
 800ca62:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 26.0f;
 800ca64:	4a0d      	ldr	r2, [pc, #52]	; (800ca9c <LSM6DSM_X_Set_ODR+0x70>)
 800ca66:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 800ca68:	2000      	movs	r0, #0
}
 800ca6a:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 52.0f;
 800ca6c:	4a0c      	ldr	r2, [pc, #48]	; (800caa0 <LSM6DSM_X_Set_ODR+0x74>)
 800ca6e:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 800ca70:	2000      	movs	r0, #0
}
 800ca72:	bd08      	pop	{r3, pc}
      new_odr = LSM6DSM_ACC_GYRO_ODR_XL_13Hz;
 800ca74:	2110      	movs	r1, #16
  if ( LSM6DSM_ACC_GYRO_W_ODR_XL( (void *)handle, new_odr ) == MEMS_ERROR )
 800ca76:	f7fd fdf3 	bl	800a660 <LSM6DSM_ACC_GYRO_W_ODR_XL>
  return COMPONENT_OK;
 800ca7a:	fab0 f080 	clz	r0, r0
 800ca7e:	0940      	lsrs	r0, r0, #5
}
 800ca80:	bd08      	pop	{r3, pc}
      new_odr = LSM6DSM_ACC_GYRO_ODR_XL_104Hz;
 800ca82:	2140      	movs	r1, #64	; 0x40
 800ca84:	e7f7      	b.n	800ca76 <LSM6DSM_X_Set_ODR+0x4a>
      new_odr = LSM6DSM_ACC_GYRO_ODR_XL_26Hz;
 800ca86:	2120      	movs	r1, #32
 800ca88:	e7f5      	b.n	800ca76 <LSM6DSM_X_Set_ODR+0x4a>
      new_odr = LSM6DSM_ACC_GYRO_ODR_XL_52Hz;
 800ca8a:	2130      	movs	r1, #48	; 0x30
 800ca8c:	e7f3      	b.n	800ca76 <LSM6DSM_X_Set_ODR+0x4a>
      return COMPONENT_ERROR;
 800ca8e:	2001      	movs	r0, #1
}
 800ca90:	bd08      	pop	{r3, pc}
 800ca92:	bf00      	nop
 800ca94:	41500000 	.word	0x41500000
 800ca98:	42d00000 	.word	0x42d00000
 800ca9c:	41d00000 	.word	0x41d00000
 800caa0:	42500000 	.word	0x42500000

0800caa4 <LSM6DSM_X_Disable_Double_Tap_Detection>:
{
 800caa4:	b510      	push	{r4, lr}
  if ( LSM6DSM_ACC_GYRO_W_TapEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_TAP_DISABLED ) == MEMS_ERROR )
 800caa6:	2100      	movs	r1, #0
{
 800caa8:	4604      	mov	r4, r0
  if ( LSM6DSM_ACC_GYRO_W_TapEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_TAP_DISABLED ) == MEMS_ERROR )
 800caaa:	f7fe fd49 	bl	800b540 <LSM6DSM_ACC_GYRO_W_TapEvOnInt1>
 800caae:	b908      	cbnz	r0, 800cab4 <LSM6DSM_X_Disable_Double_Tap_Detection+0x10>
    return COMPONENT_ERROR;
 800cab0:	2001      	movs	r0, #1
}
 800cab2:	bd10      	pop	{r4, pc}
  if ( LSM6DSM_ACC_GYRO_W_TapEvOnInt2( (void *)handle, LSM6DSM_ACC_GYRO_INT2_TAP_DISABLED ) == MEMS_ERROR )
 800cab4:	2100      	movs	r1, #0
 800cab6:	4620      	mov	r0, r4
 800cab8:	f7fe fe0e 	bl	800b6d8 <LSM6DSM_ACC_GYRO_W_TapEvOnInt2>
 800cabc:	2800      	cmp	r0, #0
 800cabe:	d0f7      	beq.n	800cab0 <LSM6DSM_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSM_ACC_GYRO_BASIC_INT_DISABLED ) == MEMS_ERROR )
 800cac0:	2100      	movs	r1, #0
 800cac2:	4620      	mov	r0, r4
 800cac4:	f7fe fb18 	bl	800b0f8 <LSM6DSM_ACC_GYRO_W_BASIC_INT>
 800cac8:	2800      	cmp	r0, #0
 800caca:	d0f1      	beq.n	800cab0 <LSM6DSM_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_TAP_THS( (void *)handle, thr ) == MEMS_ERROR )
 800cacc:	2100      	movs	r1, #0
 800cace:	4620      	mov	r0, r4
 800cad0:	f7fe fb34 	bl	800b13c <LSM6DSM_ACC_GYRO_W_TAP_THS>
 800cad4:	2800      	cmp	r0, #0
 800cad6:	d0eb      	beq.n	800cab0 <LSM6DSM_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_SHOCK_Duration( (void *)handle, time ) == MEMS_ERROR )
 800cad8:	2100      	movs	r1, #0
 800cada:	4620      	mov	r0, r4
 800cadc:	f7fe fb74 	bl	800b1c8 <LSM6DSM_ACC_GYRO_W_SHOCK_Duration>
 800cae0:	2800      	cmp	r0, #0
 800cae2:	d0e5      	beq.n	800cab0 <LSM6DSM_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_QUIET_Duration( (void *)handle, time ) == MEMS_ERROR )
 800cae4:	2100      	movs	r1, #0
 800cae6:	4620      	mov	r0, r4
 800cae8:	f7fe fb92 	bl	800b210 <LSM6DSM_ACC_GYRO_W_QUIET_Duration>
 800caec:	2800      	cmp	r0, #0
 800caee:	d0df      	beq.n	800cab0 <LSM6DSM_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_DUR( (void *)handle, time ) == MEMS_ERROR )
 800caf0:	2100      	movs	r1, #0
 800caf2:	4620      	mov	r0, r4
 800caf4:	f7fe fbb0 	bl	800b258 <LSM6DSM_ACC_GYRO_W_DUR>
 800caf8:	2800      	cmp	r0, #0
 800cafa:	d0d9      	beq.n	800cab0 <LSM6DSM_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_SINGLE_DOUBLE_TAP_EV( (void *)handle,
 800cafc:	2100      	movs	r1, #0
 800cafe:	4620      	mov	r0, r4
 800cb00:	f7fe fbf0 	bl	800b2e4 <LSM6DSM_ACC_GYRO_W_SINGLE_DOUBLE_TAP_EV>
 800cb04:	2800      	cmp	r0, #0
 800cb06:	d0d3      	beq.n	800cab0 <LSM6DSM_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_TAP_Z_EN( (void *)handle, LSM6DSM_ACC_GYRO_TAP_Z_EN_DISABLED ) == MEMS_ERROR )
 800cb08:	2100      	movs	r1, #0
 800cb0a:	4620      	mov	r0, r4
 800cb0c:	f7fe fa8e 	bl	800b02c <LSM6DSM_ACC_GYRO_W_TAP_Z_EN>
 800cb10:	2800      	cmp	r0, #0
 800cb12:	d0cd      	beq.n	800cab0 <LSM6DSM_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_TAP_Y_EN( (void *)handle, LSM6DSM_ACC_GYRO_TAP_Y_EN_DISABLED ) == MEMS_ERROR )
 800cb14:	2100      	movs	r1, #0
 800cb16:	4620      	mov	r0, r4
 800cb18:	f7fe faaa 	bl	800b070 <LSM6DSM_ACC_GYRO_W_TAP_Y_EN>
 800cb1c:	2800      	cmp	r0, #0
 800cb1e:	d0c7      	beq.n	800cab0 <LSM6DSM_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_TAP_X_EN( (void *)handle, LSM6DSM_ACC_GYRO_TAP_X_EN_DISABLED ) == MEMS_ERROR )
 800cb20:	4620      	mov	r0, r4
 800cb22:	2100      	movs	r1, #0
 800cb24:	f7fe fac6 	bl	800b0b4 <LSM6DSM_ACC_GYRO_W_TAP_X_EN>
    return COMPONENT_ERROR;
 800cb28:	fab0 f080 	clz	r0, r0
 800cb2c:	0940      	lsrs	r0, r0, #5
}
 800cb2e:	bd10      	pop	{r4, pc}

0800cb30 <LSM6DSM_X_Enable_Double_Tap_Detection>:
{
 800cb30:	b538      	push	{r3, r4, r5, lr}
  if(LSM6DSM_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 800cb32:	ed9f 0a2c 	vldr	s0, [pc, #176]	; 800cbe4 <LSM6DSM_X_Enable_Double_Tap_Detection+0xb4>
{
 800cb36:	460d      	mov	r5, r1
 800cb38:	4604      	mov	r4, r0
  if(LSM6DSM_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 800cb3a:	f7ff fedf 	bl	800c8fc <LSM6DSM_X_Set_ODR_Value>
 800cb3e:	2801      	cmp	r0, #1
 800cb40:	d004      	beq.n	800cb4c <LSM6DSM_X_Enable_Double_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_FS_XL( (void *)handle, LSM6DSM_ACC_GYRO_FS_XL_2g ) == MEMS_ERROR )
 800cb42:	2100      	movs	r1, #0
 800cb44:	4620      	mov	r0, r4
 800cb46:	f7fd fd3d 	bl	800a5c4 <LSM6DSM_ACC_GYRO_W_FS_XL>
 800cb4a:	b908      	cbnz	r0, 800cb50 <LSM6DSM_X_Enable_Double_Tap_Detection+0x20>
    return COMPONENT_ERROR;
 800cb4c:	2001      	movs	r0, #1
}
 800cb4e:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSM_ACC_GYRO_W_TAP_X_EN( (void *)handle, LSM6DSM_ACC_GYRO_TAP_X_EN_ENABLED ) == MEMS_ERROR )
 800cb50:	2108      	movs	r1, #8
 800cb52:	4620      	mov	r0, r4
 800cb54:	f7fe faae 	bl	800b0b4 <LSM6DSM_ACC_GYRO_W_TAP_X_EN>
 800cb58:	2800      	cmp	r0, #0
 800cb5a:	d0f7      	beq.n	800cb4c <LSM6DSM_X_Enable_Double_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_TAP_Y_EN( (void *)handle, LSM6DSM_ACC_GYRO_TAP_Y_EN_ENABLED ) == MEMS_ERROR )
 800cb5c:	2104      	movs	r1, #4
 800cb5e:	4620      	mov	r0, r4
 800cb60:	f7fe fa86 	bl	800b070 <LSM6DSM_ACC_GYRO_W_TAP_Y_EN>
 800cb64:	2800      	cmp	r0, #0
 800cb66:	d0f1      	beq.n	800cb4c <LSM6DSM_X_Enable_Double_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_TAP_Z_EN( (void *)handle, LSM6DSM_ACC_GYRO_TAP_Z_EN_ENABLED ) == MEMS_ERROR )
 800cb68:	2102      	movs	r1, #2
 800cb6a:	4620      	mov	r0, r4
 800cb6c:	f7fe fa5e 	bl	800b02c <LSM6DSM_ACC_GYRO_W_TAP_Z_EN>
 800cb70:	2800      	cmp	r0, #0
 800cb72:	d0eb      	beq.n	800cb4c <LSM6DSM_X_Enable_Double_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_TAP_THS( (void *)handle, thr ) == MEMS_ERROR )
 800cb74:	2108      	movs	r1, #8
 800cb76:	4620      	mov	r0, r4
 800cb78:	f7fe fae0 	bl	800b13c <LSM6DSM_ACC_GYRO_W_TAP_THS>
 800cb7c:	2800      	cmp	r0, #0
 800cb7e:	d0e5      	beq.n	800cb4c <LSM6DSM_X_Enable_Double_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_SHOCK_Duration( (void *)handle, time ) == MEMS_ERROR )
 800cb80:	2103      	movs	r1, #3
 800cb82:	4620      	mov	r0, r4
 800cb84:	f7fe fb20 	bl	800b1c8 <LSM6DSM_ACC_GYRO_W_SHOCK_Duration>
 800cb88:	2800      	cmp	r0, #0
 800cb8a:	d0df      	beq.n	800cb4c <LSM6DSM_X_Enable_Double_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_QUIET_Duration( (void *)handle, time ) == MEMS_ERROR )
 800cb8c:	2103      	movs	r1, #3
 800cb8e:	4620      	mov	r0, r4
 800cb90:	f7fe fb3e 	bl	800b210 <LSM6DSM_ACC_GYRO_W_QUIET_Duration>
 800cb94:	2800      	cmp	r0, #0
 800cb96:	d0d9      	beq.n	800cb4c <LSM6DSM_X_Enable_Double_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_DUR( (void *)handle, time ) == MEMS_ERROR )
 800cb98:	2108      	movs	r1, #8
 800cb9a:	4620      	mov	r0, r4
 800cb9c:	f7fe fb5c 	bl	800b258 <LSM6DSM_ACC_GYRO_W_DUR>
 800cba0:	2800      	cmp	r0, #0
 800cba2:	d0d3      	beq.n	800cb4c <LSM6DSM_X_Enable_Double_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_SINGLE_DOUBLE_TAP_EV( (void *)handle,
 800cba4:	2180      	movs	r1, #128	; 0x80
 800cba6:	4620      	mov	r0, r4
 800cba8:	f7fe fb9c 	bl	800b2e4 <LSM6DSM_ACC_GYRO_W_SINGLE_DOUBLE_TAP_EV>
 800cbac:	2800      	cmp	r0, #0
 800cbae:	d0cd      	beq.n	800cb4c <LSM6DSM_X_Enable_Double_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSM_ACC_GYRO_BASIC_INT_ENABLED ) == MEMS_ERROR )
 800cbb0:	2180      	movs	r1, #128	; 0x80
 800cbb2:	4620      	mov	r0, r4
 800cbb4:	f7fe faa0 	bl	800b0f8 <LSM6DSM_ACC_GYRO_W_BASIC_INT>
 800cbb8:	2800      	cmp	r0, #0
 800cbba:	d0c7      	beq.n	800cb4c <LSM6DSM_X_Enable_Double_Tap_Detection+0x1c>
  switch (int_pin)
 800cbbc:	b14d      	cbz	r5, 800cbd2 <LSM6DSM_X_Enable_Double_Tap_Detection+0xa2>
 800cbbe:	2d01      	cmp	r5, #1
 800cbc0:	d1c4      	bne.n	800cb4c <LSM6DSM_X_Enable_Double_Tap_Detection+0x1c>
    if ( LSM6DSM_ACC_GYRO_W_TapEvOnInt2( (void *)handle, LSM6DSM_ACC_GYRO_INT2_TAP_ENABLED ) == MEMS_ERROR )
 800cbc2:	4620      	mov	r0, r4
 800cbc4:	2108      	movs	r1, #8
 800cbc6:	f7fe fd87 	bl	800b6d8 <LSM6DSM_ACC_GYRO_W_TapEvOnInt2>
    return COMPONENT_ERROR;
 800cbca:	fab0 f080 	clz	r0, r0
 800cbce:	0940      	lsrs	r0, r0, #5
}
 800cbd0:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSM_ACC_GYRO_W_TapEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_TAP_ENABLED ) == MEMS_ERROR )
 800cbd2:	4620      	mov	r0, r4
 800cbd4:	2108      	movs	r1, #8
 800cbd6:	f7fe fcb3 	bl	800b540 <LSM6DSM_ACC_GYRO_W_TapEvOnInt1>
    return COMPONENT_ERROR;
 800cbda:	fab0 f080 	clz	r0, r0
 800cbde:	0940      	lsrs	r0, r0, #5
}
 800cbe0:	bd38      	pop	{r3, r4, r5, pc}
 800cbe2:	bf00      	nop
 800cbe4:	43d00000 	.word	0x43d00000

0800cbe8 <LSM6DSM_X_Disable_Single_Tap_Detection>:
{
 800cbe8:	b510      	push	{r4, lr}
  if ( LSM6DSM_ACC_GYRO_W_SingleTapOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_SINGLE_TAP_DISABLED ) == MEMS_ERROR )
 800cbea:	2100      	movs	r1, #0
{
 800cbec:	4604      	mov	r4, r0
  if ( LSM6DSM_ACC_GYRO_W_SingleTapOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_SINGLE_TAP_DISABLED ) == MEMS_ERROR )
 800cbee:	f7fe fd0d 	bl	800b60c <LSM6DSM_ACC_GYRO_W_SingleTapOnInt1>
 800cbf2:	b908      	cbnz	r0, 800cbf8 <LSM6DSM_X_Disable_Single_Tap_Detection+0x10>
    return COMPONENT_ERROR;
 800cbf4:	2001      	movs	r0, #1
}
 800cbf6:	bd10      	pop	{r4, pc}
  if ( LSM6DSM_ACC_GYRO_W_SingleTapOnInt2( (void *)handle, LSM6DSM_ACC_GYRO_INT2_SINGLE_TAP_DISABLED ) == MEMS_ERROR )
 800cbf8:	2100      	movs	r1, #0
 800cbfa:	4620      	mov	r0, r4
 800cbfc:	f7fe fdd2 	bl	800b7a4 <LSM6DSM_ACC_GYRO_W_SingleTapOnInt2>
 800cc00:	2800      	cmp	r0, #0
 800cc02:	d0f7      	beq.n	800cbf4 <LSM6DSM_X_Disable_Single_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSM_ACC_GYRO_BASIC_INT_DISABLED ) == MEMS_ERROR )
 800cc04:	2100      	movs	r1, #0
 800cc06:	4620      	mov	r0, r4
 800cc08:	f7fe fa76 	bl	800b0f8 <LSM6DSM_ACC_GYRO_W_BASIC_INT>
 800cc0c:	2800      	cmp	r0, #0
 800cc0e:	d0f1      	beq.n	800cbf4 <LSM6DSM_X_Disable_Single_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_TAP_THS( (void *)handle, thr ) == MEMS_ERROR )
 800cc10:	2100      	movs	r1, #0
 800cc12:	4620      	mov	r0, r4
 800cc14:	f7fe fa92 	bl	800b13c <LSM6DSM_ACC_GYRO_W_TAP_THS>
 800cc18:	2800      	cmp	r0, #0
 800cc1a:	d0eb      	beq.n	800cbf4 <LSM6DSM_X_Disable_Single_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_SHOCK_Duration( (void *)handle, time ) == MEMS_ERROR )
 800cc1c:	2100      	movs	r1, #0
 800cc1e:	4620      	mov	r0, r4
 800cc20:	f7fe fad2 	bl	800b1c8 <LSM6DSM_ACC_GYRO_W_SHOCK_Duration>
 800cc24:	2800      	cmp	r0, #0
 800cc26:	d0e5      	beq.n	800cbf4 <LSM6DSM_X_Disable_Single_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_QUIET_Duration( (void *)handle, time ) == MEMS_ERROR )
 800cc28:	2100      	movs	r1, #0
 800cc2a:	4620      	mov	r0, r4
 800cc2c:	f7fe faf0 	bl	800b210 <LSM6DSM_ACC_GYRO_W_QUIET_Duration>
 800cc30:	2800      	cmp	r0, #0
 800cc32:	d0df      	beq.n	800cbf4 <LSM6DSM_X_Disable_Single_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_TAP_Z_EN( (void *)handle, LSM6DSM_ACC_GYRO_TAP_Z_EN_DISABLED ) == MEMS_ERROR )
 800cc34:	2100      	movs	r1, #0
 800cc36:	4620      	mov	r0, r4
 800cc38:	f7fe f9f8 	bl	800b02c <LSM6DSM_ACC_GYRO_W_TAP_Z_EN>
 800cc3c:	2800      	cmp	r0, #0
 800cc3e:	d0d9      	beq.n	800cbf4 <LSM6DSM_X_Disable_Single_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_TAP_Y_EN( (void *)handle, LSM6DSM_ACC_GYRO_TAP_Y_EN_DISABLED ) == MEMS_ERROR )
 800cc40:	2100      	movs	r1, #0
 800cc42:	4620      	mov	r0, r4
 800cc44:	f7fe fa14 	bl	800b070 <LSM6DSM_ACC_GYRO_W_TAP_Y_EN>
 800cc48:	2800      	cmp	r0, #0
 800cc4a:	d0d3      	beq.n	800cbf4 <LSM6DSM_X_Disable_Single_Tap_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_TAP_X_EN( (void *)handle, LSM6DSM_ACC_GYRO_TAP_X_EN_DISABLED ) == MEMS_ERROR )
 800cc4c:	4620      	mov	r0, r4
 800cc4e:	2100      	movs	r1, #0
 800cc50:	f7fe fa30 	bl	800b0b4 <LSM6DSM_ACC_GYRO_W_TAP_X_EN>
    return COMPONENT_ERROR;
 800cc54:	fab0 f080 	clz	r0, r0
 800cc58:	0940      	lsrs	r0, r0, #5
}
 800cc5a:	bd10      	pop	{r4, pc}

0800cc5c <LSM6DSM_X_Enable_Single_Tap_Detection>:
{
 800cc5c:	b538      	push	{r3, r4, r5, lr}
  if(LSM6DSM_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 800cc5e:	ed9f 0a26 	vldr	s0, [pc, #152]	; 800ccf8 <LSM6DSM_X_Enable_Single_Tap_Detection+0x9c>
{
 800cc62:	460d      	mov	r5, r1
 800cc64:	4604      	mov	r4, r0
  if(LSM6DSM_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 800cc66:	f7ff fe49 	bl	800c8fc <LSM6DSM_X_Set_ODR_Value>
 800cc6a:	2801      	cmp	r0, #1
 800cc6c:	d004      	beq.n	800cc78 <LSM6DSM_X_Enable_Single_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_FS_XL( (void *)handle, LSM6DSM_ACC_GYRO_FS_XL_2g ) == MEMS_ERROR )
 800cc6e:	2100      	movs	r1, #0
 800cc70:	4620      	mov	r0, r4
 800cc72:	f7fd fca7 	bl	800a5c4 <LSM6DSM_ACC_GYRO_W_FS_XL>
 800cc76:	b908      	cbnz	r0, 800cc7c <LSM6DSM_X_Enable_Single_Tap_Detection+0x20>
    return COMPONENT_ERROR;
 800cc78:	2001      	movs	r0, #1
}
 800cc7a:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSM_ACC_GYRO_W_TAP_X_EN( (void *)handle, LSM6DSM_ACC_GYRO_TAP_X_EN_ENABLED ) == MEMS_ERROR )
 800cc7c:	2108      	movs	r1, #8
 800cc7e:	4620      	mov	r0, r4
 800cc80:	f7fe fa18 	bl	800b0b4 <LSM6DSM_ACC_GYRO_W_TAP_X_EN>
 800cc84:	2800      	cmp	r0, #0
 800cc86:	d0f7      	beq.n	800cc78 <LSM6DSM_X_Enable_Single_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_TAP_Y_EN( (void *)handle, LSM6DSM_ACC_GYRO_TAP_Y_EN_ENABLED ) == MEMS_ERROR )
 800cc88:	2104      	movs	r1, #4
 800cc8a:	4620      	mov	r0, r4
 800cc8c:	f7fe f9f0 	bl	800b070 <LSM6DSM_ACC_GYRO_W_TAP_Y_EN>
 800cc90:	2800      	cmp	r0, #0
 800cc92:	d0f1      	beq.n	800cc78 <LSM6DSM_X_Enable_Single_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_TAP_Z_EN( (void *)handle, LSM6DSM_ACC_GYRO_TAP_Z_EN_ENABLED ) == MEMS_ERROR )
 800cc94:	2102      	movs	r1, #2
 800cc96:	4620      	mov	r0, r4
 800cc98:	f7fe f9c8 	bl	800b02c <LSM6DSM_ACC_GYRO_W_TAP_Z_EN>
 800cc9c:	2800      	cmp	r0, #0
 800cc9e:	d0eb      	beq.n	800cc78 <LSM6DSM_X_Enable_Single_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_TAP_THS( (void *)handle, thr ) == MEMS_ERROR )
 800cca0:	2108      	movs	r1, #8
 800cca2:	4620      	mov	r0, r4
 800cca4:	f7fe fa4a 	bl	800b13c <LSM6DSM_ACC_GYRO_W_TAP_THS>
 800cca8:	2800      	cmp	r0, #0
 800ccaa:	d0e5      	beq.n	800cc78 <LSM6DSM_X_Enable_Single_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_SHOCK_Duration( (void *)handle, time ) == MEMS_ERROR )
 800ccac:	2102      	movs	r1, #2
 800ccae:	4620      	mov	r0, r4
 800ccb0:	f7fe fa8a 	bl	800b1c8 <LSM6DSM_ACC_GYRO_W_SHOCK_Duration>
 800ccb4:	2800      	cmp	r0, #0
 800ccb6:	d0df      	beq.n	800cc78 <LSM6DSM_X_Enable_Single_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_QUIET_Duration( (void *)handle, time ) == MEMS_ERROR )
 800ccb8:	2101      	movs	r1, #1
 800ccba:	4620      	mov	r0, r4
 800ccbc:	f7fe faa8 	bl	800b210 <LSM6DSM_ACC_GYRO_W_QUIET_Duration>
 800ccc0:	2800      	cmp	r0, #0
 800ccc2:	d0d9      	beq.n	800cc78 <LSM6DSM_X_Enable_Single_Tap_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSM_ACC_GYRO_BASIC_INT_ENABLED ) == MEMS_ERROR )
 800ccc4:	2180      	movs	r1, #128	; 0x80
 800ccc6:	4620      	mov	r0, r4
 800ccc8:	f7fe fa16 	bl	800b0f8 <LSM6DSM_ACC_GYRO_W_BASIC_INT>
 800cccc:	2800      	cmp	r0, #0
 800ccce:	d0d3      	beq.n	800cc78 <LSM6DSM_X_Enable_Single_Tap_Detection+0x1c>
  switch (int_pin)
 800ccd0:	b14d      	cbz	r5, 800cce6 <LSM6DSM_X_Enable_Single_Tap_Detection+0x8a>
 800ccd2:	2d01      	cmp	r5, #1
 800ccd4:	d1d0      	bne.n	800cc78 <LSM6DSM_X_Enable_Single_Tap_Detection+0x1c>
    if ( LSM6DSM_ACC_GYRO_W_SingleTapOnInt2( (void *)handle, LSM6DSM_ACC_GYRO_INT2_SINGLE_TAP_ENABLED ) == MEMS_ERROR )
 800ccd6:	4620      	mov	r0, r4
 800ccd8:	2140      	movs	r1, #64	; 0x40
 800ccda:	f7fe fd63 	bl	800b7a4 <LSM6DSM_ACC_GYRO_W_SingleTapOnInt2>
    return COMPONENT_ERROR;
 800ccde:	fab0 f080 	clz	r0, r0
 800cce2:	0940      	lsrs	r0, r0, #5
}
 800cce4:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSM_ACC_GYRO_W_SingleTapOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_SINGLE_TAP_ENABLED ) == MEMS_ERROR )
 800cce6:	4620      	mov	r0, r4
 800cce8:	2140      	movs	r1, #64	; 0x40
 800ccea:	f7fe fc8f 	bl	800b60c <LSM6DSM_ACC_GYRO_W_SingleTapOnInt1>
    return COMPONENT_ERROR;
 800ccee:	fab0 f080 	clz	r0, r0
 800ccf2:	0940      	lsrs	r0, r0, #5
}
 800ccf4:	bd38      	pop	{r3, r4, r5, pc}
 800ccf6:	bf00      	nop
 800ccf8:	43d00000 	.word	0x43d00000

0800ccfc <LSM6DSM_X_Disable_Wake_Up_Detection>:
{
 800ccfc:	b510      	push	{r4, lr}
  if ( LSM6DSM_ACC_GYRO_W_WUEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_WU_DISABLED ) == MEMS_ERROR )
 800ccfe:	2100      	movs	r1, #0
{
 800cd00:	4604      	mov	r4, r0
  if ( LSM6DSM_ACC_GYRO_W_WUEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_WU_DISABLED ) == MEMS_ERROR )
 800cd02:	f7fe fc61 	bl	800b5c8 <LSM6DSM_ACC_GYRO_W_WUEvOnInt1>
 800cd06:	b908      	cbnz	r0, 800cd0c <LSM6DSM_X_Disable_Wake_Up_Detection+0x10>
    return COMPONENT_ERROR;
 800cd08:	2001      	movs	r0, #1
}
 800cd0a:	bd10      	pop	{r4, pc}
  if ( LSM6DSM_ACC_GYRO_W_WUEvOnInt2( (void *)handle, LSM6DSM_ACC_GYRO_INT2_WU_DISABLED ) == MEMS_ERROR )
 800cd0c:	2100      	movs	r1, #0
 800cd0e:	4620      	mov	r0, r4
 800cd10:	f7fe fd26 	bl	800b760 <LSM6DSM_ACC_GYRO_W_WUEvOnInt2>
 800cd14:	2800      	cmp	r0, #0
 800cd16:	d0f7      	beq.n	800cd08 <LSM6DSM_X_Disable_Wake_Up_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSM_ACC_GYRO_BASIC_INT_DISABLED ) == MEMS_ERROR )
 800cd18:	2100      	movs	r1, #0
 800cd1a:	4620      	mov	r0, r4
 800cd1c:	f7fe f9ec 	bl	800b0f8 <LSM6DSM_ACC_GYRO_W_BASIC_INT>
 800cd20:	2800      	cmp	r0, #0
 800cd22:	d0f1      	beq.n	800cd08 <LSM6DSM_X_Disable_Wake_Up_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_WAKE_DUR( (void *)handle, 0x00 ) == MEMS_ERROR )
 800cd24:	2100      	movs	r1, #0
 800cd26:	4620      	mov	r0, r4
 800cd28:	f7fe fb44 	bl	800b3b4 <LSM6DSM_ACC_GYRO_W_WAKE_DUR>
 800cd2c:	2800      	cmp	r0, #0
 800cd2e:	d0eb      	beq.n	800cd08 <LSM6DSM_X_Disable_Wake_Up_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_WK_THS( (void *)handle, 0x00 ) == MEMS_ERROR )
 800cd30:	4620      	mov	r0, r4
 800cd32:	2100      	movs	r1, #0
 800cd34:	f7fe fab2 	bl	800b29c <LSM6DSM_ACC_GYRO_W_WK_THS>
    return COMPONENT_ERROR;
 800cd38:	fab0 f080 	clz	r0, r0
 800cd3c:	0940      	lsrs	r0, r0, #5
}
 800cd3e:	bd10      	pop	{r4, pc}

0800cd40 <LSM6DSM_X_Enable_Wake_Up_Detection>:
{
 800cd40:	b538      	push	{r3, r4, r5, lr}
  if(LSM6DSM_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 800cd42:	ed9f 0a1a 	vldr	s0, [pc, #104]	; 800cdac <LSM6DSM_X_Enable_Wake_Up_Detection+0x6c>
{
 800cd46:	460d      	mov	r5, r1
 800cd48:	4604      	mov	r4, r0
  if(LSM6DSM_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 800cd4a:	f7ff fdd7 	bl	800c8fc <LSM6DSM_X_Set_ODR_Value>
 800cd4e:	2801      	cmp	r0, #1
 800cd50:	d004      	beq.n	800cd5c <LSM6DSM_X_Enable_Wake_Up_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_FS_XL( (void *)handle, LSM6DSM_ACC_GYRO_FS_XL_2g ) == MEMS_ERROR )
 800cd52:	2100      	movs	r1, #0
 800cd54:	4620      	mov	r0, r4
 800cd56:	f7fd fc35 	bl	800a5c4 <LSM6DSM_ACC_GYRO_W_FS_XL>
 800cd5a:	b908      	cbnz	r0, 800cd60 <LSM6DSM_X_Enable_Wake_Up_Detection+0x20>
    return COMPONENT_ERROR;
 800cd5c:	2001      	movs	r0, #1
}
 800cd5e:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSM_ACC_GYRO_W_WAKE_DUR( (void *)handle, 0x00 ) == MEMS_ERROR )
 800cd60:	2100      	movs	r1, #0
 800cd62:	4620      	mov	r0, r4
 800cd64:	f7fe fb26 	bl	800b3b4 <LSM6DSM_ACC_GYRO_W_WAKE_DUR>
 800cd68:	2800      	cmp	r0, #0
 800cd6a:	d0f7      	beq.n	800cd5c <LSM6DSM_X_Enable_Wake_Up_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_WK_THS( (void *)handle, 0x02 ) == MEMS_ERROR )
 800cd6c:	2102      	movs	r1, #2
 800cd6e:	4620      	mov	r0, r4
 800cd70:	f7fe fa94 	bl	800b29c <LSM6DSM_ACC_GYRO_W_WK_THS>
 800cd74:	2800      	cmp	r0, #0
 800cd76:	d0f1      	beq.n	800cd5c <LSM6DSM_X_Enable_Wake_Up_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSM_ACC_GYRO_BASIC_INT_ENABLED ) == MEMS_ERROR )
 800cd78:	2180      	movs	r1, #128	; 0x80
 800cd7a:	4620      	mov	r0, r4
 800cd7c:	f7fe f9bc 	bl	800b0f8 <LSM6DSM_ACC_GYRO_W_BASIC_INT>
 800cd80:	2800      	cmp	r0, #0
 800cd82:	d0eb      	beq.n	800cd5c <LSM6DSM_X_Enable_Wake_Up_Detection+0x1c>
  switch (int_pin)
 800cd84:	b14d      	cbz	r5, 800cd9a <LSM6DSM_X_Enable_Wake_Up_Detection+0x5a>
 800cd86:	2d01      	cmp	r5, #1
 800cd88:	d1e8      	bne.n	800cd5c <LSM6DSM_X_Enable_Wake_Up_Detection+0x1c>
    if ( LSM6DSM_ACC_GYRO_W_WUEvOnInt2( (void *)handle, LSM6DSM_ACC_GYRO_INT2_WU_ENABLED ) == MEMS_ERROR )
 800cd8a:	4620      	mov	r0, r4
 800cd8c:	2120      	movs	r1, #32
 800cd8e:	f7fe fce7 	bl	800b760 <LSM6DSM_ACC_GYRO_W_WUEvOnInt2>
    return COMPONENT_ERROR;
 800cd92:	fab0 f080 	clz	r0, r0
 800cd96:	0940      	lsrs	r0, r0, #5
}
 800cd98:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSM_ACC_GYRO_W_WUEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_WU_ENABLED ) == MEMS_ERROR )
 800cd9a:	4620      	mov	r0, r4
 800cd9c:	2120      	movs	r1, #32
 800cd9e:	f7fe fc13 	bl	800b5c8 <LSM6DSM_ACC_GYRO_W_WUEvOnInt1>
    return COMPONENT_ERROR;
 800cda2:	fab0 f080 	clz	r0, r0
 800cda6:	0940      	lsrs	r0, r0, #5
}
 800cda8:	bd38      	pop	{r3, r4, r5, pc}
 800cdaa:	bf00      	nop
 800cdac:	43d00000 	.word	0x43d00000

0800cdb0 <LSM6DSM_X_Disable_Tilt_Detection>:
{
 800cdb0:	b510      	push	{r4, lr}
  if ( LSM6DSM_ACC_GYRO_W_TiltEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_TILT_DISABLED ) == MEMS_ERROR )
 800cdb2:	2100      	movs	r1, #0
{
 800cdb4:	4604      	mov	r4, r0
  if ( LSM6DSM_ACC_GYRO_W_TiltEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_TILT_DISABLED ) == MEMS_ERROR )
 800cdb6:	f7fe fb7f 	bl	800b4b8 <LSM6DSM_ACC_GYRO_W_TiltEvOnInt1>
 800cdba:	b908      	cbnz	r0, 800cdc0 <LSM6DSM_X_Disable_Tilt_Detection+0x10>
    return COMPONENT_ERROR;
 800cdbc:	2001      	movs	r0, #1
}
 800cdbe:	bd10      	pop	{r4, pc}
  if ( LSM6DSM_ACC_GYRO_W_TiltEvOnInt2( (void *)handle, LSM6DSM_ACC_GYRO_INT2_TILT_DISABLED ) == MEMS_ERROR )
 800cdc0:	2100      	movs	r1, #0
 800cdc2:	4620      	mov	r0, r4
 800cdc4:	f7fe fc44 	bl	800b650 <LSM6DSM_ACC_GYRO_W_TiltEvOnInt2>
 800cdc8:	2800      	cmp	r0, #0
 800cdca:	d0f7      	beq.n	800cdbc <LSM6DSM_X_Disable_Tilt_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_TILT( (void *)handle, LSM6DSM_ACC_GYRO_TILT_DISABLED ) == MEMS_ERROR )
 800cdcc:	2100      	movs	r1, #0
 800cdce:	4620      	mov	r0, r4
 800cdd0:	f7fd ff3c 	bl	800ac4c <LSM6DSM_ACC_GYRO_W_TILT>
 800cdd4:	2800      	cmp	r0, #0
 800cdd6:	d0f1      	beq.n	800cdbc <LSM6DSM_X_Disable_Tilt_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_FUNC_EN( (void *)handle, LSM6DSM_ACC_GYRO_FUNC_EN_DISABLED ) == MEMS_ERROR )
 800cdd8:	4620      	mov	r0, r4
 800cdda:	2100      	movs	r1, #0
 800cddc:	f7fd ff7a 	bl	800acd4 <LSM6DSM_ACC_GYRO_W_FUNC_EN>
    return COMPONENT_ERROR;
 800cde0:	fab0 f080 	clz	r0, r0
 800cde4:	0940      	lsrs	r0, r0, #5
}
 800cde6:	bd10      	pop	{r4, pc}

0800cde8 <LSM6DSM_X_Enable_Tilt_Detection>:
{
 800cde8:	b538      	push	{r3, r4, r5, lr}
  if(LSM6DSM_X_Set_ODR_Value(handle, 26.0f) == COMPONENT_ERROR)
 800cdea:	eeb3 0a0a 	vmov.f32	s0, #58	; 0x41d00000  26.0
{
 800cdee:	460d      	mov	r5, r1
 800cdf0:	4604      	mov	r4, r0
  if(LSM6DSM_X_Set_ODR_Value(handle, 26.0f) == COMPONENT_ERROR)
 800cdf2:	f7ff fd83 	bl	800c8fc <LSM6DSM_X_Set_ODR_Value>
 800cdf6:	2801      	cmp	r0, #1
 800cdf8:	d004      	beq.n	800ce04 <LSM6DSM_X_Enable_Tilt_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_FS_XL( (void *)handle, LSM6DSM_ACC_GYRO_FS_XL_2g ) == MEMS_ERROR )
 800cdfa:	2100      	movs	r1, #0
 800cdfc:	4620      	mov	r0, r4
 800cdfe:	f7fd fbe1 	bl	800a5c4 <LSM6DSM_ACC_GYRO_W_FS_XL>
 800ce02:	b908      	cbnz	r0, 800ce08 <LSM6DSM_X_Enable_Tilt_Detection+0x20>
    return COMPONENT_ERROR;
 800ce04:	2001      	movs	r0, #1
}
 800ce06:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSM_ACC_GYRO_W_FUNC_EN( (void *)handle, LSM6DSM_ACC_GYRO_FUNC_EN_ENABLED ) == MEMS_ERROR )
 800ce08:	2104      	movs	r1, #4
 800ce0a:	4620      	mov	r0, r4
 800ce0c:	f7fd ff62 	bl	800acd4 <LSM6DSM_ACC_GYRO_W_FUNC_EN>
 800ce10:	2800      	cmp	r0, #0
 800ce12:	d0f7      	beq.n	800ce04 <LSM6DSM_X_Enable_Tilt_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_TILT( (void *)handle, LSM6DSM_ACC_GYRO_TILT_ENABLED ) == MEMS_ERROR )
 800ce14:	2108      	movs	r1, #8
 800ce16:	4620      	mov	r0, r4
 800ce18:	f7fd ff18 	bl	800ac4c <LSM6DSM_ACC_GYRO_W_TILT>
 800ce1c:	2800      	cmp	r0, #0
 800ce1e:	d0f1      	beq.n	800ce04 <LSM6DSM_X_Enable_Tilt_Detection+0x1c>
  switch (int_pin)
 800ce20:	b14d      	cbz	r5, 800ce36 <LSM6DSM_X_Enable_Tilt_Detection+0x4e>
 800ce22:	2d01      	cmp	r5, #1
 800ce24:	d1ee      	bne.n	800ce04 <LSM6DSM_X_Enable_Tilt_Detection+0x1c>
    if ( LSM6DSM_ACC_GYRO_W_TiltEvOnInt2( (void *)handle, LSM6DSM_ACC_GYRO_INT2_TILT_ENABLED ) == MEMS_ERROR )
 800ce26:	4620      	mov	r0, r4
 800ce28:	2102      	movs	r1, #2
 800ce2a:	f7fe fc11 	bl	800b650 <LSM6DSM_ACC_GYRO_W_TiltEvOnInt2>
    return COMPONENT_ERROR;
 800ce2e:	fab0 f080 	clz	r0, r0
 800ce32:	0940      	lsrs	r0, r0, #5
}
 800ce34:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSM_ACC_GYRO_W_TiltEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_TILT_ENABLED ) == MEMS_ERROR )
 800ce36:	4620      	mov	r0, r4
 800ce38:	2102      	movs	r1, #2
 800ce3a:	f7fe fb3d 	bl	800b4b8 <LSM6DSM_ACC_GYRO_W_TiltEvOnInt1>
    return COMPONENT_ERROR;
 800ce3e:	fab0 f080 	clz	r0, r0
 800ce42:	0940      	lsrs	r0, r0, #5
}
 800ce44:	bd38      	pop	{r3, r4, r5, pc}
 800ce46:	bf00      	nop

0800ce48 <LSM6DSM_X_Disable_Pedometer>:
{
 800ce48:	b510      	push	{r4, lr}
  if ( LSM6DSM_ACC_GYRO_W_STEP_DET_on_INT1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_PEDO_DISABLED ) == MEMS_ERROR )
 800ce4a:	2100      	movs	r1, #0
{
 800ce4c:	4604      	mov	r4, r0
  if ( LSM6DSM_ACC_GYRO_W_STEP_DET_on_INT1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_PEDO_DISABLED ) == MEMS_ERROR )
 800ce4e:	f7fd fe0f 	bl	800aa70 <LSM6DSM_ACC_GYRO_W_STEP_DET_on_INT1>
 800ce52:	b908      	cbnz	r0, 800ce58 <LSM6DSM_X_Disable_Pedometer+0x10>
    return COMPONENT_ERROR;
 800ce54:	2001      	movs	r0, #1
}
 800ce56:	bd10      	pop	{r4, pc}
  if ( LSM6DSM_ACC_GYRO_W_STEP_DELTA_on_INT2( (void *)handle, LSM6DSM_ACC_GYRO_INT2_STEP_DELTA_DISABLED ) == MEMS_ERROR )
 800ce58:	2100      	movs	r1, #0
 800ce5a:	4620      	mov	r0, r4
 800ce5c:	f7fd fe2a 	bl	800aab4 <LSM6DSM_ACC_GYRO_W_STEP_DELTA_on_INT2>
 800ce60:	2800      	cmp	r0, #0
 800ce62:	d0f7      	beq.n	800ce54 <LSM6DSM_X_Disable_Pedometer+0xc>
  if ( LSM6DSM_ACC_GYRO_W_PEDO( (void *)handle, LSM6DSM_ACC_GYRO_PEDO_DISABLED ) == MEMS_ERROR )
 800ce64:	2100      	movs	r1, #0
 800ce66:	4620      	mov	r0, r4
 800ce68:	f7fd ff12 	bl	800ac90 <LSM6DSM_ACC_GYRO_W_PEDO>
 800ce6c:	2800      	cmp	r0, #0
 800ce6e:	d0f1      	beq.n	800ce54 <LSM6DSM_X_Disable_Pedometer+0xc>
  if ( LSM6DSM_ACC_GYRO_W_FUNC_EN( (void *)handle, LSM6DSM_ACC_GYRO_FUNC_EN_DISABLED ) == MEMS_ERROR )
 800ce70:	2100      	movs	r1, #0
 800ce72:	4620      	mov	r0, r4
 800ce74:	f7fd ff2e 	bl	800acd4 <LSM6DSM_ACC_GYRO_W_FUNC_EN>
 800ce78:	2800      	cmp	r0, #0
 800ce7a:	d0eb      	beq.n	800ce54 <LSM6DSM_X_Disable_Pedometer+0xc>
  if ( LSM6DSM_ACC_GYRO_W_PedoThreshold( (void *)handle, thr ) == MEMS_ERROR )
 800ce7c:	4620      	mov	r0, r4
 800ce7e:	2100      	movs	r1, #0
 800ce80:	f7fe fcde 	bl	800b840 <LSM6DSM_ACC_GYRO_W_PedoThreshold>
    return COMPONENT_ERROR;
 800ce84:	fab0 f080 	clz	r0, r0
 800ce88:	0940      	lsrs	r0, r0, #5
}
 800ce8a:	bd10      	pop	{r4, pc}

0800ce8c <LSM6DSM_X_Enable_Pedometer>:
{
 800ce8c:	b538      	push	{r3, r4, r5, lr}
  if(LSM6DSM_X_Set_ODR_Value(handle, 26.0f) == COMPONENT_ERROR)
 800ce8e:	eeb3 0a0a 	vmov.f32	s0, #58	; 0x41d00000  26.0
{
 800ce92:	460d      	mov	r5, r1
 800ce94:	4604      	mov	r4, r0
  if(LSM6DSM_X_Set_ODR_Value(handle, 26.0f) == COMPONENT_ERROR)
 800ce96:	f7ff fd31 	bl	800c8fc <LSM6DSM_X_Set_ODR_Value>
 800ce9a:	2801      	cmp	r0, #1
 800ce9c:	d004      	beq.n	800cea8 <LSM6DSM_X_Enable_Pedometer+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_FS_XL( (void *)handle, LSM6DSM_ACC_GYRO_FS_XL_2g ) == MEMS_ERROR )
 800ce9e:	2100      	movs	r1, #0
 800cea0:	4620      	mov	r0, r4
 800cea2:	f7fd fb8f 	bl	800a5c4 <LSM6DSM_ACC_GYRO_W_FS_XL>
 800cea6:	b908      	cbnz	r0, 800ceac <LSM6DSM_X_Enable_Pedometer+0x20>
    return COMPONENT_ERROR;
 800cea8:	2001      	movs	r0, #1
}
 800ceaa:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSM_ACC_GYRO_W_PedoThreshold( (void *)handle, thr ) == MEMS_ERROR )
 800ceac:	2117      	movs	r1, #23
 800ceae:	4620      	mov	r0, r4
 800ceb0:	f7fe fcc6 	bl	800b840 <LSM6DSM_ACC_GYRO_W_PedoThreshold>
 800ceb4:	2800      	cmp	r0, #0
 800ceb6:	d0f7      	beq.n	800cea8 <LSM6DSM_X_Enable_Pedometer+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_FUNC_EN( (void *)handle, LSM6DSM_ACC_GYRO_FUNC_EN_ENABLED ) == MEMS_ERROR )
 800ceb8:	2104      	movs	r1, #4
 800ceba:	4620      	mov	r0, r4
 800cebc:	f7fd ff0a 	bl	800acd4 <LSM6DSM_ACC_GYRO_W_FUNC_EN>
 800cec0:	2800      	cmp	r0, #0
 800cec2:	d0f1      	beq.n	800cea8 <LSM6DSM_X_Enable_Pedometer+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_PEDO( (void *)handle, LSM6DSM_ACC_GYRO_PEDO_ENABLED ) == MEMS_ERROR )
 800cec4:	2110      	movs	r1, #16
 800cec6:	4620      	mov	r0, r4
 800cec8:	f7fd fee2 	bl	800ac90 <LSM6DSM_ACC_GYRO_W_PEDO>
 800cecc:	2800      	cmp	r0, #0
 800cece:	d0eb      	beq.n	800cea8 <LSM6DSM_X_Enable_Pedometer+0x1c>
  switch (int_pin)
 800ced0:	b14d      	cbz	r5, 800cee6 <LSM6DSM_X_Enable_Pedometer+0x5a>
 800ced2:	2d01      	cmp	r5, #1
 800ced4:	d1e8      	bne.n	800cea8 <LSM6DSM_X_Enable_Pedometer+0x1c>
    if ( LSM6DSM_ACC_GYRO_W_STEP_DELTA_on_INT2( (void *)handle, LSM6DSM_ACC_GYRO_INT2_STEP_DELTA_ENABLED ) == MEMS_ERROR )
 800ced6:	4620      	mov	r0, r4
 800ced8:	2180      	movs	r1, #128	; 0x80
 800ceda:	f7fd fdeb 	bl	800aab4 <LSM6DSM_ACC_GYRO_W_STEP_DELTA_on_INT2>
    return COMPONENT_ERROR;
 800cede:	fab0 f080 	clz	r0, r0
 800cee2:	0940      	lsrs	r0, r0, #5
}
 800cee4:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSM_ACC_GYRO_W_STEP_DET_on_INT1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_PEDO_ENABLED ) == MEMS_ERROR )
 800cee6:	4620      	mov	r0, r4
 800cee8:	2180      	movs	r1, #128	; 0x80
 800ceea:	f7fd fdc1 	bl	800aa70 <LSM6DSM_ACC_GYRO_W_STEP_DET_on_INT1>
    return COMPONENT_ERROR;
 800ceee:	fab0 f080 	clz	r0, r0
 800cef2:	0940      	lsrs	r0, r0, #5
}
 800cef4:	bd38      	pop	{r3, r4, r5, pc}
 800cef6:	bf00      	nop

0800cef8 <LSM6DSM_X_Disable_Free_Fall_Detection>:
{
 800cef8:	b510      	push	{r4, lr}
  if ( LSM6DSM_ACC_GYRO_W_FFEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_FF_DISABLED ) == MEMS_ERROR )
 800cefa:	2100      	movs	r1, #0
{
 800cefc:	4604      	mov	r4, r0
  if ( LSM6DSM_ACC_GYRO_W_FFEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_FF_DISABLED ) == MEMS_ERROR )
 800cefe:	f7fe fb41 	bl	800b584 <LSM6DSM_ACC_GYRO_W_FFEvOnInt1>
 800cf02:	b908      	cbnz	r0, 800cf08 <LSM6DSM_X_Disable_Free_Fall_Detection+0x10>
    return COMPONENT_ERROR;
 800cf04:	2001      	movs	r0, #1
}
 800cf06:	bd10      	pop	{r4, pc}
  if ( LSM6DSM_ACC_GYRO_W_FFEvOnInt2( (void *)handle, LSM6DSM_ACC_GYRO_INT2_FF_DISABLED ) == MEMS_ERROR )
 800cf08:	2100      	movs	r1, #0
 800cf0a:	4620      	mov	r0, r4
 800cf0c:	f7fe fc06 	bl	800b71c <LSM6DSM_ACC_GYRO_W_FFEvOnInt2>
 800cf10:	2800      	cmp	r0, #0
 800cf12:	d0f7      	beq.n	800cf04 <LSM6DSM_X_Disable_Free_Fall_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSM_ACC_GYRO_BASIC_INT_DISABLED ) == MEMS_ERROR )
 800cf14:	2100      	movs	r1, #0
 800cf16:	4620      	mov	r0, r4
 800cf18:	f7fe f8ee 	bl	800b0f8 <LSM6DSM_ACC_GYRO_W_BASIC_INT>
 800cf1c:	2800      	cmp	r0, #0
 800cf1e:	d0f1      	beq.n	800cf04 <LSM6DSM_X_Disable_Free_Fall_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_FF_Duration( (void *)handle, 0x00 ) == MEMS_ERROR )
 800cf20:	2100      	movs	r1, #0
 800cf22:	4620      	mov	r0, r4
 800cf24:	f7fe fa8c 	bl	800b440 <LSM6DSM_ACC_GYRO_W_FF_Duration>
 800cf28:	2800      	cmp	r0, #0
 800cf2a:	d0eb      	beq.n	800cf04 <LSM6DSM_X_Disable_Free_Fall_Detection+0xc>
  if ( LSM6DSM_ACC_GYRO_W_FF_THS( (void *)handle, LSM6DSM_ACC_GYRO_FF_THS_156mg ) == MEMS_ERROR )
 800cf2c:	4620      	mov	r0, r4
 800cf2e:	2100      	movs	r1, #0
 800cf30:	f7fe fa64 	bl	800b3fc <LSM6DSM_ACC_GYRO_W_FF_THS>
    return COMPONENT_ERROR;
 800cf34:	fab0 f080 	clz	r0, r0
 800cf38:	0940      	lsrs	r0, r0, #5
}
 800cf3a:	bd10      	pop	{r4, pc}

0800cf3c <LSM6DSM_X_Enable_Free_Fall_Detection>:
{
 800cf3c:	b538      	push	{r3, r4, r5, lr}
  if(LSM6DSM_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 800cf3e:	ed9f 0a23 	vldr	s0, [pc, #140]	; 800cfcc <LSM6DSM_X_Enable_Free_Fall_Detection+0x90>
{
 800cf42:	460d      	mov	r5, r1
 800cf44:	4604      	mov	r4, r0
  if(LSM6DSM_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 800cf46:	f7ff fcd9 	bl	800c8fc <LSM6DSM_X_Set_ODR_Value>
 800cf4a:	2801      	cmp	r0, #1
 800cf4c:	d004      	beq.n	800cf58 <LSM6DSM_X_Enable_Free_Fall_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_FS_XL( (void *)handle, LSM6DSM_ACC_GYRO_FS_XL_2g ) == MEMS_ERROR )
 800cf4e:	2100      	movs	r1, #0
 800cf50:	4620      	mov	r0, r4
 800cf52:	f7fd fb37 	bl	800a5c4 <LSM6DSM_ACC_GYRO_W_FS_XL>
 800cf56:	b908      	cbnz	r0, 800cf5c <LSM6DSM_X_Enable_Free_Fall_Detection+0x20>
    return COMPONENT_ERROR;
 800cf58:	2001      	movs	r0, #1
}
 800cf5a:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSM_ACC_GYRO_W_FF_Duration( (void *)handle, 0x06 ) == MEMS_ERROR )
 800cf5c:	2106      	movs	r1, #6
 800cf5e:	4620      	mov	r0, r4
 800cf60:	f7fe fa6e 	bl	800b440 <LSM6DSM_ACC_GYRO_W_FF_Duration>
 800cf64:	2800      	cmp	r0, #0
 800cf66:	d0f7      	beq.n	800cf58 <LSM6DSM_X_Enable_Free_Fall_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_WAKE_DUR( (void *)handle, 0x00 ) == MEMS_ERROR )
 800cf68:	2100      	movs	r1, #0
 800cf6a:	4620      	mov	r0, r4
 800cf6c:	f7fe fa22 	bl	800b3b4 <LSM6DSM_ACC_GYRO_W_WAKE_DUR>
 800cf70:	2800      	cmp	r0, #0
 800cf72:	d0f1      	beq.n	800cf58 <LSM6DSM_X_Enable_Free_Fall_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_TIMER_HR( (void *)handle, LSM6DSM_ACC_GYRO_TIMER_HR_6_4ms ) == MEMS_ERROR )
 800cf74:	2100      	movs	r1, #0
 800cf76:	4620      	mov	r0, r4
 800cf78:	f7fe f9fa 	bl	800b370 <LSM6DSM_ACC_GYRO_W_TIMER_HR>
 800cf7c:	2800      	cmp	r0, #0
 800cf7e:	d0eb      	beq.n	800cf58 <LSM6DSM_X_Enable_Free_Fall_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_SLEEP_DUR( (void *)handle, 0x00 ) == MEMS_ERROR )
 800cf80:	2100      	movs	r1, #0
 800cf82:	4620      	mov	r0, r4
 800cf84:	f7fe f9d0 	bl	800b328 <LSM6DSM_ACC_GYRO_W_SLEEP_DUR>
 800cf88:	2800      	cmp	r0, #0
 800cf8a:	d0e5      	beq.n	800cf58 <LSM6DSM_X_Enable_Free_Fall_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_FF_THS( (void *) handle, LSM6DSM_ACC_GYRO_FF_THS_312mg ) == MEMS_ERROR )
 800cf8c:	2103      	movs	r1, #3
 800cf8e:	4620      	mov	r0, r4
 800cf90:	f7fe fa34 	bl	800b3fc <LSM6DSM_ACC_GYRO_W_FF_THS>
 800cf94:	2800      	cmp	r0, #0
 800cf96:	d0df      	beq.n	800cf58 <LSM6DSM_X_Enable_Free_Fall_Detection+0x1c>
  if ( LSM6DSM_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSM_ACC_GYRO_BASIC_INT_ENABLED ) == MEMS_ERROR )
 800cf98:	2180      	movs	r1, #128	; 0x80
 800cf9a:	4620      	mov	r0, r4
 800cf9c:	f7fe f8ac 	bl	800b0f8 <LSM6DSM_ACC_GYRO_W_BASIC_INT>
 800cfa0:	2800      	cmp	r0, #0
 800cfa2:	d0d9      	beq.n	800cf58 <LSM6DSM_X_Enable_Free_Fall_Detection+0x1c>
  switch (int_pin)
 800cfa4:	b14d      	cbz	r5, 800cfba <LSM6DSM_X_Enable_Free_Fall_Detection+0x7e>
 800cfa6:	2d01      	cmp	r5, #1
 800cfa8:	d1d6      	bne.n	800cf58 <LSM6DSM_X_Enable_Free_Fall_Detection+0x1c>
    if ( LSM6DSM_ACC_GYRO_W_FFEvOnInt2( (void *)handle, LSM6DSM_ACC_GYRO_INT2_FF_ENABLED ) == MEMS_ERROR )
 800cfaa:	4620      	mov	r0, r4
 800cfac:	2110      	movs	r1, #16
 800cfae:	f7fe fbb5 	bl	800b71c <LSM6DSM_ACC_GYRO_W_FFEvOnInt2>
    return COMPONENT_ERROR;
 800cfb2:	fab0 f080 	clz	r0, r0
 800cfb6:	0940      	lsrs	r0, r0, #5
}
 800cfb8:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSM_ACC_GYRO_W_FFEvOnInt1( (void *)handle, LSM6DSM_ACC_GYRO_INT1_FF_ENABLED ) == MEMS_ERROR )
 800cfba:	4620      	mov	r0, r4
 800cfbc:	2110      	movs	r1, #16
 800cfbe:	f7fe fae1 	bl	800b584 <LSM6DSM_ACC_GYRO_W_FFEvOnInt1>
    return COMPONENT_ERROR;
 800cfc2:	fab0 f080 	clz	r0, r0
 800cfc6:	0940      	lsrs	r0, r0, #5
}
 800cfc8:	bd38      	pop	{r3, r4, r5, pc}
 800cfca:	bf00      	nop
 800cfcc:	43d00000 	.word	0x43d00000

0800cfd0 <LSM6DSM_G_Set_SelfTest>:
 * @param status self-test enable/disable
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LSM6DSM_G_Set_SelfTest( DrvContextTypeDef *handle, uint8_t status )
{
 800cfd0:	290c      	cmp	r1, #12
 800cfd2:	d809      	bhi.n	800cfe8 <LSM6DSM_G_Set_SelfTest+0x18>
 800cfd4:	2301      	movs	r3, #1
 800cfd6:	b510      	push	{r4, lr}
 800cfd8:	fa03 f201 	lsl.w	r2, r3, r1
 800cfdc:	f241 1411 	movw	r4, #4369	; 0x1111
 800cfe0:	4222      	tst	r2, r4
 800cfe2:	d103      	bne.n	800cfec <LSM6DSM_G_Set_SelfTest+0x1c>
    case LSM6DSM_ACC_GYRO_ST_G_POS_SIGN_TEST:
    case LSM6DSM_ACC_GYRO_ST_G_NA:
    case LSM6DSM_ACC_GYRO_ST_G_NEG_SIGN_TEST:
      break;
    default:
      return COMPONENT_ERROR;
 800cfe4:	4618      	mov	r0, r3
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 800cfe6:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 800cfe8:	2001      	movs	r0, #1
}
 800cfea:	4770      	bx	lr
  if ( LSM6DSM_ACC_GYRO_W_SelfTest_G( handle, ( LSM6DSM_ACC_GYRO_ST_G_t )status ) == MEMS_ERROR )
 800cfec:	f7fd fdea 	bl	800abc4 <LSM6DSM_ACC_GYRO_W_SelfTest_G>
      return COMPONENT_ERROR;
 800cff0:	fab0 f080 	clz	r0, r0
 800cff4:	0940      	lsrs	r0, r0, #5
}
 800cff6:	bd10      	pop	{r4, pc}

0800cff8 <LSM6DSM_G_Get_Sensitivity>:
{
 800cff8:	b530      	push	{r4, r5, lr}
 800cffa:	b083      	sub	sp, #12
 800cffc:	460c      	mov	r4, r1
  if ( LSM6DSM_ACC_GYRO_R_FS_125( (void *)handle, &fullScale125 ) == MEMS_ERROR )
 800cffe:	f10d 0106 	add.w	r1, sp, #6
{
 800d002:	4605      	mov	r5, r0
  if ( LSM6DSM_ACC_GYRO_R_FS_125( (void *)handle, &fullScale125 ) == MEMS_ERROR )
 800d004:	f7fd fc00 	bl	800a808 <LSM6DSM_ACC_GYRO_R_FS_125>
 800d008:	b1b0      	cbz	r0, 800d038 <LSM6DSM_G_Get_Sensitivity+0x40>
  if ( fullScale125 == LSM6DSM_ACC_GYRO_FS_125_ENABLED )
 800d00a:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800d00e:	2b02      	cmp	r3, #2
 800d010:	d015      	beq.n	800d03e <LSM6DSM_G_Get_Sensitivity+0x46>
    if ( LSM6DSM_ACC_GYRO_R_FS_G( (void *)handle, &fullScale ) == MEMS_ERROR )
 800d012:	4628      	mov	r0, r5
 800d014:	f10d 0107 	add.w	r1, sp, #7
 800d018:	f7fd fb76 	bl	800a708 <LSM6DSM_ACC_GYRO_R_FS_G>
 800d01c:	b160      	cbz	r0, 800d038 <LSM6DSM_G_Get_Sensitivity+0x40>
    switch( fullScale )
 800d01e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800d022:	2b0c      	cmp	r3, #12
 800d024:	d820      	bhi.n	800d068 <LSM6DSM_G_Get_Sensitivity+0x70>
 800d026:	e8df f003 	tbb	[pc, r3]
 800d02a:	1f1b      	.short	0x1f1b
 800d02c:	1f171f1f 	.word	0x1f171f1f
 800d030:	1f131f1f 	.word	0x1f131f1f
 800d034:	1f1f      	.short	0x1f1f
 800d036:	0f          	.byte	0x0f
 800d037:	00          	.byte	0x00
    return COMPONENT_ERROR;
 800d038:	2001      	movs	r0, #1
}
 800d03a:	b003      	add	sp, #12
 800d03c:	bd30      	pop	{r4, r5, pc}
    *sensitivity = ( float )LSM6DSM_GYRO_SENSITIVITY_FOR_FS_125DPS;
 800d03e:	4b0c      	ldr	r3, [pc, #48]	; (800d070 <LSM6DSM_G_Get_Sensitivity+0x78>)
 800d040:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800d042:	2000      	movs	r0, #0
}
 800d044:	b003      	add	sp, #12
 800d046:	bd30      	pop	{r4, r5, pc}
        *sensitivity = ( float )LSM6DSM_GYRO_SENSITIVITY_FOR_FS_2000DPS;
 800d048:	4b0a      	ldr	r3, [pc, #40]	; (800d074 <LSM6DSM_G_Get_Sensitivity+0x7c>)
 800d04a:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800d04c:	2000      	movs	r0, #0
 800d04e:	e7f4      	b.n	800d03a <LSM6DSM_G_Get_Sensitivity+0x42>
        *sensitivity = ( float )LSM6DSM_GYRO_SENSITIVITY_FOR_FS_1000DPS;
 800d050:	4b09      	ldr	r3, [pc, #36]	; (800d078 <LSM6DSM_G_Get_Sensitivity+0x80>)
 800d052:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800d054:	2000      	movs	r0, #0
 800d056:	e7f0      	b.n	800d03a <LSM6DSM_G_Get_Sensitivity+0x42>
        *sensitivity = ( float )LSM6DSM_GYRO_SENSITIVITY_FOR_FS_500DPS;
 800d058:	4b08      	ldr	r3, [pc, #32]	; (800d07c <LSM6DSM_G_Get_Sensitivity+0x84>)
 800d05a:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800d05c:	2000      	movs	r0, #0
 800d05e:	e7ec      	b.n	800d03a <LSM6DSM_G_Get_Sensitivity+0x42>
        *sensitivity = ( float )LSM6DSM_GYRO_SENSITIVITY_FOR_FS_245DPS;
 800d060:	4b07      	ldr	r3, [pc, #28]	; (800d080 <LSM6DSM_G_Get_Sensitivity+0x88>)
 800d062:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800d064:	2000      	movs	r0, #0
 800d066:	e7e8      	b.n	800d03a <LSM6DSM_G_Get_Sensitivity+0x42>
        *sensitivity = -1.0f;
 800d068:	4b06      	ldr	r3, [pc, #24]	; (800d084 <LSM6DSM_G_Get_Sensitivity+0x8c>)
 800d06a:	6023      	str	r3, [r4, #0]
        return COMPONENT_ERROR;
 800d06c:	2001      	movs	r0, #1
 800d06e:	e7e4      	b.n	800d03a <LSM6DSM_G_Get_Sensitivity+0x42>
 800d070:	408c0000 	.word	0x408c0000
 800d074:	428c0000 	.word	0x428c0000
 800d078:	420c0000 	.word	0x420c0000
 800d07c:	418c0000 	.word	0x418c0000
 800d080:	410c0000 	.word	0x410c0000
 800d084:	bf800000 	.word	0xbf800000

0800d088 <LSM6DSM_FIFO_G_Get_Axis>:
{
 800d088:	b570      	push	{r4, r5, r6, lr}
 800d08a:	b082      	sub	sp, #8
  float sensitivity = 0;
 800d08c:	2300      	movs	r3, #0
{
 800d08e:	460d      	mov	r5, r1
  if ( LSM6DSM_ACC_GYRO_Get_GetFIFOData( handle, aData ) == MEMS_ERROR )
 800d090:	4669      	mov	r1, sp
  float sensitivity = 0;
 800d092:	9301      	str	r3, [sp, #4]
{
 800d094:	4604      	mov	r4, r0
  if ( LSM6DSM_ACC_GYRO_Get_GetFIFOData( handle, aData ) == MEMS_ERROR )
 800d096:	f7fe fba7 	bl	800b7e8 <LSM6DSM_ACC_GYRO_Get_GetFIFOData>
 800d09a:	b910      	cbnz	r0, 800d0a2 <LSM6DSM_FIFO_G_Get_Axis+0x1a>
    return COMPONENT_ERROR;
 800d09c:	2001      	movs	r0, #1
}
 800d09e:	b002      	add	sp, #8
 800d0a0:	bd70      	pop	{r4, r5, r6, pc}
  if ( LSM6DSM_G_Get_Sensitivity( handle, &sensitivity ) == COMPONENT_ERROR )
 800d0a2:	4620      	mov	r0, r4
 800d0a4:	a901      	add	r1, sp, #4
  rawData = ( aData[1] << 8 ) | aData[0];
 800d0a6:	f89d 6001 	ldrb.w	r6, [sp, #1]
 800d0aa:	f89d 4000 	ldrb.w	r4, [sp]
  if ( LSM6DSM_G_Get_Sensitivity( handle, &sensitivity ) == COMPONENT_ERROR )
 800d0ae:	f7ff ffa3 	bl	800cff8 <LSM6DSM_G_Get_Sensitivity>
 800d0b2:	2801      	cmp	r0, #1
 800d0b4:	d0f2      	beq.n	800d09c <LSM6DSM_FIFO_G_Get_Axis+0x14>
  rawData = ( aData[1] << 8 ) | aData[0];
 800d0b6:	ea44 2406 	orr.w	r4, r4, r6, lsl #8
  *angular_velocity = ( int32_t )( rawData * sensitivity );
 800d0ba:	b224      	sxth	r4, r4
 800d0bc:	ee07 4a90 	vmov	s15, r4
 800d0c0:	ed9d 7a01 	vldr	s14, [sp, #4]
 800d0c4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  return COMPONENT_OK;
 800d0c8:	2000      	movs	r0, #0
  *angular_velocity = ( int32_t )( rawData * sensitivity );
 800d0ca:	ee67 7a87 	vmul.f32	s15, s15, s14
 800d0ce:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800d0d2:	edc5 7a00 	vstr	s15, [r5]
}
 800d0d6:	b002      	add	sp, #8
 800d0d8:	bd70      	pop	{r4, r5, r6, pc}
 800d0da:	bf00      	nop

0800d0dc <LSM6DSM_G_Get_Axes>:
{
 800d0dc:	b530      	push	{r4, r5, lr}
 800d0de:	b085      	sub	sp, #20
  float   sensitivity = 0;
 800d0e0:	2300      	movs	r3, #0
{
 800d0e2:	460c      	mov	r4, r1
  if ( LSM6DSM_G_Get_Axes_Raw( handle, dataRaw ) == COMPONENT_ERROR )
 800d0e4:	a902      	add	r1, sp, #8
  float   sensitivity = 0;
 800d0e6:	9301      	str	r3, [sp, #4]
{
 800d0e8:	4605      	mov	r5, r0
  if ( LSM6DSM_G_Get_Axes_Raw( handle, dataRaw ) == COMPONENT_ERROR )
 800d0ea:	f7ff fb5f 	bl	800c7ac <LSM6DSM_G_Get_Axes_Raw>
 800d0ee:	2801      	cmp	r0, #1
 800d0f0:	d02e      	beq.n	800d150 <LSM6DSM_G_Get_Axes+0x74>
  if ( LSM6DSM_G_Get_Sensitivity( handle, &sensitivity ) == COMPONENT_ERROR )
 800d0f2:	4628      	mov	r0, r5
 800d0f4:	a901      	add	r1, sp, #4
 800d0f6:	f7ff ff7f 	bl	800cff8 <LSM6DSM_G_Get_Sensitivity>
 800d0fa:	2801      	cmp	r0, #1
 800d0fc:	d028      	beq.n	800d150 <LSM6DSM_G_Get_Axes+0x74>
  angular_velocity->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 800d0fe:	f9bd 3008 	ldrsh.w	r3, [sp, #8]
 800d102:	ed9d 6a01 	vldr	s12, [sp, #4]
 800d106:	ee06 3a90 	vmov	s13, r3
  angular_velocity->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 800d10a:	f9bd 300a 	ldrsh.w	r3, [sp, #10]
 800d10e:	ee07 3a10 	vmov	s14, r3
  angular_velocity->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 800d112:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
 800d116:	ee07 3a90 	vmov	s15, r3
  angular_velocity->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 800d11a:	eef8 6ae6 	vcvt.f32.s32	s13, s13
  angular_velocity->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 800d11e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  angular_velocity->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 800d122:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  angular_velocity->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 800d126:	ee66 6a86 	vmul.f32	s13, s13, s12
  angular_velocity->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 800d12a:	ee27 7a06 	vmul.f32	s14, s14, s12
  angular_velocity->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 800d12e:	ee67 7a86 	vmul.f32	s15, s15, s12
  angular_velocity->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 800d132:	eefd 6ae6 	vcvt.s32.f32	s13, s13
  angular_velocity->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 800d136:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  angular_velocity->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 800d13a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  return COMPONENT_OK;
 800d13e:	2000      	movs	r0, #0
  angular_velocity->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 800d140:	edc4 6a00 	vstr	s13, [r4]
  angular_velocity->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 800d144:	ed84 7a01 	vstr	s14, [r4, #4]
  angular_velocity->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 800d148:	edc4 7a02 	vstr	s15, [r4, #8]
}
 800d14c:	b005      	add	sp, #20
 800d14e:	bd30      	pop	{r4, r5, pc}
    return COMPONENT_ERROR;
 800d150:	2001      	movs	r0, #1
}
 800d152:	b005      	add	sp, #20
 800d154:	bd30      	pop	{r4, r5, pc}
 800d156:	bf00      	nop

0800d158 <LSM6DSM_FIFO_G_Set_Decimation>:
{
 800d158:	b508      	push	{r3, lr}
  switch ( ( LSM6DSM_ACC_GYRO_DEC_FIFO_G_t )decimation )
 800d15a:	2938      	cmp	r1, #56	; 0x38
 800d15c:	d81e      	bhi.n	800d19c <LSM6DSM_FIFO_G_Set_Decimation+0x44>
 800d15e:	e8df f001 	tbb	[pc, r1]
 800d162:	1d1f      	.short	0x1d1f
 800d164:	1d1d1d1d 	.word	0x1d1d1d1d
 800d168:	1d1f1d1d 	.word	0x1d1f1d1d
 800d16c:	1d1d1d1d 	.word	0x1d1d1d1d
 800d170:	1d1f1d1d 	.word	0x1d1f1d1d
 800d174:	1d1d1d1d 	.word	0x1d1d1d1d
 800d178:	1d1f1d1d 	.word	0x1d1f1d1d
 800d17c:	1d1d1d1d 	.word	0x1d1d1d1d
 800d180:	1d1f1d1d 	.word	0x1d1f1d1d
 800d184:	1d1d1d1d 	.word	0x1d1d1d1d
 800d188:	1d1f1d1d 	.word	0x1d1f1d1d
 800d18c:	1d1d1d1d 	.word	0x1d1d1d1d
 800d190:	1d1f1d1d 	.word	0x1d1f1d1d
 800d194:	1d1d1d1d 	.word	0x1d1d1d1d
 800d198:	1d1d      	.short	0x1d1d
 800d19a:	1f          	.byte	0x1f
 800d19b:	00          	.byte	0x00
      return COMPONENT_ERROR;
 800d19c:	2001      	movs	r0, #1
}
 800d19e:	bd08      	pop	{r3, pc}
  if ( LSM6DSM_ACC_GYRO_W_DEC_FIFO_G( handle, ( LSM6DSM_ACC_GYRO_DEC_FIFO_G_t )decimation ) == MEMS_ERROR )
 800d1a0:	f7fd fbbc 	bl	800a91c <LSM6DSM_ACC_GYRO_W_DEC_FIFO_G>
      return COMPONENT_ERROR;
 800d1a4:	fab0 f080 	clz	r0, r0
 800d1a8:	0940      	lsrs	r0, r0, #5
}
 800d1aa:	bd08      	pop	{r3, pc}

0800d1ac <LSM6DSM_X_Sensor_Disable>:
  if ( handle->isEnabled == 0 )
 800d1ac:	7983      	ldrb	r3, [r0, #6]
 800d1ae:	b90b      	cbnz	r3, 800d1b4 <LSM6DSM_X_Sensor_Disable+0x8>
    return COMPONENT_OK;
 800d1b0:	4618      	mov	r0, r3
}
 800d1b2:	4770      	bx	lr
  LSM6DSM_X_Data_t *pComponentData = ( LSM6DSM_X_Data_t * )pData->pComponentData;
 800d1b4:	6883      	ldr	r3, [r0, #8]
  if ( LSM6DSM_X_Get_ODR( handle, &( pComponentData->Previous_ODR ) ) == COMPONENT_ERROR )
 800d1b6:	6819      	ldr	r1, [r3, #0]
{
 800d1b8:	b510      	push	{r4, lr}
  if ( LSM6DSM_X_Get_ODR( handle, &( pComponentData->Previous_ODR ) ) == COMPONENT_ERROR )
 800d1ba:	3104      	adds	r1, #4
 800d1bc:	4604      	mov	r4, r0
 800d1be:	f7ff f86f 	bl	800c2a0 <LSM6DSM_X_Get_ODR>
 800d1c2:	2801      	cmp	r0, #1
 800d1c4:	d008      	beq.n	800d1d8 <LSM6DSM_X_Sensor_Disable+0x2c>
  if ( LSM6DSM_ACC_GYRO_W_ODR_XL( (void *)handle, LSM6DSM_ACC_GYRO_ODR_XL_POWER_DOWN ) == MEMS_ERROR )
 800d1c6:	2100      	movs	r1, #0
 800d1c8:	4620      	mov	r0, r4
 800d1ca:	f7fd fa49 	bl	800a660 <LSM6DSM_ACC_GYRO_W_ODR_XL>
 800d1ce:	b118      	cbz	r0, 800d1d8 <LSM6DSM_X_Sensor_Disable+0x2c>
  handle->isEnabled = 0;
 800d1d0:	2300      	movs	r3, #0
 800d1d2:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 800d1d4:	4618      	mov	r0, r3
}
 800d1d6:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 800d1d8:	2001      	movs	r0, #1
}
 800d1da:	bd10      	pop	{r4, pc}

0800d1dc <LSM6DSM_X_DeInit>:
  LSM6DSM_X_Data_t *pComponentData = ( LSM6DSM_X_Data_t * )pData->pComponentData;
 800d1dc:	6883      	ldr	r3, [r0, #8]
{
 800d1de:	b570      	push	{r4, r5, r6, lr}
  LSM6DSM_X_Data_t *pComponentData = ( LSM6DSM_X_Data_t * )pData->pComponentData;
 800d1e0:	681d      	ldr	r5, [r3, #0]
{
 800d1e2:	4604      	mov	r4, r0
  LSM6DSM_Combo_Data_t *comboData = pComponentData->comboData;
 800d1e4:	682e      	ldr	r6, [r5, #0]
  if ( LSM6DSM_Check_WhoAmI( handle ) == COMPONENT_ERROR )
 800d1e6:	f7ff f93d 	bl	800c464 <LSM6DSM_Check_WhoAmI>
 800d1ea:	2801      	cmp	r0, #1
 800d1ec:	d02e      	beq.n	800d24c <LSM6DSM_X_DeInit+0x70>
  if( LSM6DSM_X_Disable_Free_Fall_Detection( handle ) == COMPONENT_ERROR )
 800d1ee:	4620      	mov	r0, r4
 800d1f0:	f7ff fe82 	bl	800cef8 <LSM6DSM_X_Disable_Free_Fall_Detection>
 800d1f4:	2801      	cmp	r0, #1
 800d1f6:	d029      	beq.n	800d24c <LSM6DSM_X_DeInit+0x70>
  if( LSM6DSM_X_Disable_6D_Orientation( handle ) == COMPONENT_ERROR )
 800d1f8:	4620      	mov	r0, r4
 800d1fa:	f7ff fb63 	bl	800c8c4 <LSM6DSM_X_Disable_6D_Orientation>
 800d1fe:	2801      	cmp	r0, #1
 800d200:	d024      	beq.n	800d24c <LSM6DSM_X_DeInit+0x70>
  if( LSM6DSM_X_Disable_Pedometer( handle ) == COMPONENT_ERROR )
 800d202:	4620      	mov	r0, r4
 800d204:	f7ff fe20 	bl	800ce48 <LSM6DSM_X_Disable_Pedometer>
 800d208:	2801      	cmp	r0, #1
 800d20a:	d01f      	beq.n	800d24c <LSM6DSM_X_DeInit+0x70>
  if( LSM6DSM_X_Disable_Single_Tap_Detection( handle ) == COMPONENT_ERROR )
 800d20c:	4620      	mov	r0, r4
 800d20e:	f7ff fceb 	bl	800cbe8 <LSM6DSM_X_Disable_Single_Tap_Detection>
 800d212:	2801      	cmp	r0, #1
 800d214:	d01a      	beq.n	800d24c <LSM6DSM_X_DeInit+0x70>
  if( LSM6DSM_X_Disable_Double_Tap_Detection( handle ) == COMPONENT_ERROR )
 800d216:	4620      	mov	r0, r4
 800d218:	f7ff fc44 	bl	800caa4 <LSM6DSM_X_Disable_Double_Tap_Detection>
 800d21c:	2801      	cmp	r0, #1
 800d21e:	d015      	beq.n	800d24c <LSM6DSM_X_DeInit+0x70>
  if( LSM6DSM_X_Disable_Tilt_Detection( handle ) == COMPONENT_ERROR )
 800d220:	4620      	mov	r0, r4
 800d222:	f7ff fdc5 	bl	800cdb0 <LSM6DSM_X_Disable_Tilt_Detection>
 800d226:	2801      	cmp	r0, #1
 800d228:	d010      	beq.n	800d24c <LSM6DSM_X_DeInit+0x70>
  if( LSM6DSM_X_Disable_Wake_Up_Detection( handle ) == COMPONENT_ERROR )
 800d22a:	4620      	mov	r0, r4
 800d22c:	f7ff fd66 	bl	800ccfc <LSM6DSM_X_Disable_Wake_Up_Detection>
 800d230:	2801      	cmp	r0, #1
 800d232:	d00b      	beq.n	800d24c <LSM6DSM_X_DeInit+0x70>
  if( LSM6DSM_X_Sensor_Disable( handle ) == COMPONENT_ERROR )
 800d234:	4620      	mov	r0, r4
 800d236:	f7ff ffb9 	bl	800d1ac <LSM6DSM_X_Sensor_Disable>
 800d23a:	2801      	cmp	r0, #1
 800d23c:	d006      	beq.n	800d24c <LSM6DSM_X_DeInit+0x70>
  comboData->isAccInitialized = 0;
 800d23e:	2300      	movs	r3, #0
  pComponentData->Previous_ODR = 0.0f;
 800d240:	2200      	movs	r2, #0
 800d242:	606a      	str	r2, [r5, #4]
  comboData->isAccInitialized = 0;
 800d244:	7033      	strb	r3, [r6, #0]
  handle->isInitialized = 0;
 800d246:	7163      	strb	r3, [r4, #5]
  return COMPONENT_OK;
 800d248:	4618      	mov	r0, r3
}
 800d24a:	bd70      	pop	{r4, r5, r6, pc}
    return COMPONENT_ERROR;
 800d24c:	2001      	movs	r0, #1
}
 800d24e:	bd70      	pop	{r4, r5, r6, pc}

0800d250 <LSM6DSM_G_Set_FS_Value>:
  if ( fullScale <= 125.0f )
 800d250:	eddf 7a1f 	vldr	s15, [pc, #124]	; 800d2d0 <LSM6DSM_G_Set_FS_Value+0x80>
 800d254:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d258:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 800d25c:	b538      	push	{r3, r4, r5, lr}
  if ( fullScale <= 125.0f )
 800d25e:	d925      	bls.n	800d2ac <LSM6DSM_G_Set_FS_Value+0x5c>
             : ( fullScale <=  500.0f ) ? LSM6DSM_ACC_GYRO_FS_G_500dps
 800d260:	eddf 7a1c 	vldr	s15, [pc, #112]	; 800d2d4 <LSM6DSM_G_Set_FS_Value+0x84>
 800d264:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d268:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d26c:	4604      	mov	r4, r0
 800d26e:	d807      	bhi.n	800d280 <LSM6DSM_G_Set_FS_Value+0x30>
 800d270:	2500      	movs	r5, #0
    if ( LSM6DSM_ACC_GYRO_W_FS_125( (void *)handle, LSM6DSM_ACC_GYRO_FS_125_DISABLED ) == MEMS_ERROR )
 800d272:	2100      	movs	r1, #0
 800d274:	4620      	mov	r0, r4
 800d276:	f7fd faa5 	bl	800a7c4 <LSM6DSM_ACC_GYRO_W_FS_125>
 800d27a:	b978      	cbnz	r0, 800d29c <LSM6DSM_G_Set_FS_Value+0x4c>
      return COMPONENT_ERROR;
 800d27c:	2001      	movs	r0, #1
}
 800d27e:	bd38      	pop	{r3, r4, r5, pc}
             : ( fullScale <=  500.0f ) ? LSM6DSM_ACC_GYRO_FS_G_500dps
 800d280:	eddf 7a15 	vldr	s15, [pc, #84]	; 800d2d8 <LSM6DSM_G_Set_FS_Value+0x88>
 800d284:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d288:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d28c:	d815      	bhi.n	800d2ba <LSM6DSM_G_Set_FS_Value+0x6a>
    if ( LSM6DSM_ACC_GYRO_W_FS_125( (void *)handle, LSM6DSM_ACC_GYRO_FS_125_DISABLED ) == MEMS_ERROR )
 800d28e:	2100      	movs	r1, #0
 800d290:	4620      	mov	r0, r4
             : ( fullScale <=  500.0f ) ? LSM6DSM_ACC_GYRO_FS_G_500dps
 800d292:	2504      	movs	r5, #4
    if ( LSM6DSM_ACC_GYRO_W_FS_125( (void *)handle, LSM6DSM_ACC_GYRO_FS_125_DISABLED ) == MEMS_ERROR )
 800d294:	f7fd fa96 	bl	800a7c4 <LSM6DSM_ACC_GYRO_W_FS_125>
 800d298:	2800      	cmp	r0, #0
 800d29a:	d0ef      	beq.n	800d27c <LSM6DSM_G_Set_FS_Value+0x2c>
    if ( LSM6DSM_ACC_GYRO_W_FS_G( (void *)handle, new_fs ) == MEMS_ERROR )
 800d29c:	4629      	mov	r1, r5
 800d29e:	4620      	mov	r0, r4
 800d2a0:	f7fd fa10 	bl	800a6c4 <LSM6DSM_ACC_GYRO_W_FS_G>
  return COMPONENT_OK;
 800d2a4:	fab0 f080 	clz	r0, r0
 800d2a8:	0940      	lsrs	r0, r0, #5
}
 800d2aa:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSM_ACC_GYRO_W_FS_125( (void *)handle, LSM6DSM_ACC_GYRO_FS_125_ENABLED ) == MEMS_ERROR )
 800d2ac:	2102      	movs	r1, #2
 800d2ae:	f7fd fa89 	bl	800a7c4 <LSM6DSM_ACC_GYRO_W_FS_125>
  return COMPONENT_OK;
 800d2b2:	fab0 f080 	clz	r0, r0
 800d2b6:	0940      	lsrs	r0, r0, #5
}
 800d2b8:	bd38      	pop	{r3, r4, r5, pc}
             : ( fullScale <=  500.0f ) ? LSM6DSM_ACC_GYRO_FS_G_500dps
 800d2ba:	eddf 7a08 	vldr	s15, [pc, #32]	; 800d2dc <LSM6DSM_G_Set_FS_Value+0x8c>
 800d2be:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d2c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d2c6:	bf94      	ite	ls
 800d2c8:	2508      	movls	r5, #8
 800d2ca:	250c      	movhi	r5, #12
 800d2cc:	e7d1      	b.n	800d272 <LSM6DSM_G_Set_FS_Value+0x22>
 800d2ce:	bf00      	nop
 800d2d0:	42fa0000 	.word	0x42fa0000
 800d2d4:	43750000 	.word	0x43750000
 800d2d8:	43fa0000 	.word	0x43fa0000
 800d2dc:	447a0000 	.word	0x447a0000

0800d2e0 <LSM6DSM_G_Set_ODR_Value>:
{
 800d2e0:	b508      	push	{r3, lr}
  if(handle->isEnabled == 1)
 800d2e2:	7982      	ldrb	r2, [r0, #6]
 800d2e4:	2a01      	cmp	r2, #1
 800d2e6:	d048      	beq.n	800d37a <LSM6DSM_G_Set_ODR_Value+0x9a>
                                 : ( odr <=  26.0f )  ? 26.0f
 800d2e8:	eef2 7a0a 	vmov.f32	s15, #42	; 0x41500000  13.0
  LSM6DSM_G_Data_t *pComponentData = ( LSM6DSM_G_Data_t * )pData->pComponentData;
 800d2ec:	6883      	ldr	r3, [r0, #8]
                                 : ( odr <=  26.0f )  ? 26.0f
 800d2ee:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d2f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  LSM6DSM_G_Data_t *pComponentData = ( LSM6DSM_G_Data_t * )pData->pComponentData;
 800d2f6:	681b      	ldr	r3, [r3, #0]
                                 : ( odr <=  26.0f )  ? 26.0f
 800d2f8:	d93b      	bls.n	800d372 <LSM6DSM_G_Set_ODR_Value+0x92>
                                 : ( odr <=  52.0f )  ? 52.0f
 800d2fa:	eef3 7a0a 	vmov.f32	s15, #58	; 0x41d00000  26.0
 800d2fe:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d302:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d306:	d934      	bls.n	800d372 <LSM6DSM_G_Set_ODR_Value+0x92>
                                 : ( odr <= 104.0f )  ? 104.0f
 800d308:	eddf 7a20 	vldr	s15, [pc, #128]	; 800d38c <LSM6DSM_G_Set_ODR_Value+0xac>
 800d30c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d310:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d314:	d92d      	bls.n	800d372 <LSM6DSM_G_Set_ODR_Value+0x92>
                                 : ( odr <= 208.0f )  ? 208.0f
 800d316:	eddf 7a1e 	vldr	s15, [pc, #120]	; 800d390 <LSM6DSM_G_Set_ODR_Value+0xb0>
 800d31a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d31e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d322:	d926      	bls.n	800d372 <LSM6DSM_G_Set_ODR_Value+0x92>
                                 : ( odr <= 416.0f )  ? 416.0f
 800d324:	eddf 7a1b 	vldr	s15, [pc, #108]	; 800d394 <LSM6DSM_G_Set_ODR_Value+0xb4>
 800d328:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d32c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d330:	d91f      	bls.n	800d372 <LSM6DSM_G_Set_ODR_Value+0x92>
                                 : ( odr <= 833.0f )  ? 833.0f
 800d332:	eddf 7a19 	vldr	s15, [pc, #100]	; 800d398 <LSM6DSM_G_Set_ODR_Value+0xb8>
 800d336:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d33a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d33e:	d918      	bls.n	800d372 <LSM6DSM_G_Set_ODR_Value+0x92>
                                 : ( odr <= 1660.0f ) ? 1660.0f
 800d340:	eddf 7a16 	vldr	s15, [pc, #88]	; 800d39c <LSM6DSM_G_Set_ODR_Value+0xbc>
 800d344:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d348:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d34c:	d911      	bls.n	800d372 <LSM6DSM_G_Set_ODR_Value+0x92>
                                 : ( odr <= 3330.0f ) ? 3330.0f
 800d34e:	eddf 7a14 	vldr	s15, [pc, #80]	; 800d3a0 <LSM6DSM_G_Set_ODR_Value+0xc0>
 800d352:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d356:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d35a:	d90a      	bls.n	800d372 <LSM6DSM_G_Set_ODR_Value+0x92>
                                 :                      6660.0f;
 800d35c:	eddf 7a11 	vldr	s15, [pc, #68]	; 800d3a4 <LSM6DSM_G_Set_ODR_Value+0xc4>
 800d360:	eddf 6a11 	vldr	s13, [pc, #68]	; 800d3a8 <LSM6DSM_G_Set_ODR_Value+0xc8>
 800d364:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d368:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d36c:	bf88      	it	hi
 800d36e:	eef0 7a66 	vmovhi.f32	s15, s13
  pComponentData->Previous_ODR = ( odr <=  13.0f )  ? 13.0f
 800d372:	edc3 7a01 	vstr	s15, [r3, #4]
  return COMPONENT_OK;
 800d376:	2000      	movs	r0, #0
}
 800d378:	bd08      	pop	{r3, pc}
    if(LSM6DSM_G_Set_ODR_Value_When_Enabled(handle, odr) == COMPONENT_ERROR)
 800d37a:	f7ff f8f7 	bl	800c56c <LSM6DSM_G_Set_ODR_Value_When_Enabled>
  return COMPONENT_OK;
 800d37e:	f1a0 0001 	sub.w	r0, r0, #1
 800d382:	fab0 f080 	clz	r0, r0
 800d386:	0940      	lsrs	r0, r0, #5
}
 800d388:	bd08      	pop	{r3, pc}
 800d38a:	bf00      	nop
 800d38c:	42500000 	.word	0x42500000
 800d390:	42d00000 	.word	0x42d00000
 800d394:	43500000 	.word	0x43500000
 800d398:	43d00000 	.word	0x43d00000
 800d39c:	44504000 	.word	0x44504000
 800d3a0:	44cf8000 	.word	0x44cf8000
 800d3a4:	45502000 	.word	0x45502000
 800d3a8:	45d02000 	.word	0x45d02000

0800d3ac <LSM6DSM_G_Set_ODR>:
{
 800d3ac:	b508      	push	{r3, lr}
  if(handle->isEnabled == 1)
 800d3ae:	7983      	ldrb	r3, [r0, #6]
 800d3b0:	2b01      	cmp	r3, #1
 800d3b2:	d00c      	beq.n	800d3ce <LSM6DSM_G_Set_ODR+0x22>
  LSM6DSM_G_Data_t *pComponentData = ( LSM6DSM_G_Data_t * )pData->pComponentData;
 800d3b4:	6883      	ldr	r3, [r0, #8]
 800d3b6:	681b      	ldr	r3, [r3, #0]
  switch( odr )
 800d3b8:	2904      	cmp	r1, #4
 800d3ba:	d828      	bhi.n	800d40e <LSM6DSM_G_Set_ODR+0x62>
 800d3bc:	e8df f001 	tbb	[pc, r1]
 800d3c0:	16120303 	.word	0x16120303
 800d3c4:	0e          	.byte	0x0e
 800d3c5:	00          	.byte	0x00
      pComponentData->Previous_ODR = 13.0f;
 800d3c6:	4a13      	ldr	r2, [pc, #76]	; (800d414 <LSM6DSM_G_Set_ODR+0x68>)
 800d3c8:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 800d3ca:	2000      	movs	r0, #0
}
 800d3cc:	bd08      	pop	{r3, pc}
  switch( odr )
 800d3ce:	2904      	cmp	r1, #4
 800d3d0:	d81d      	bhi.n	800d40e <LSM6DSM_G_Set_ODR+0x62>
 800d3d2:	e8df f001 	tbb	[pc, r1]
 800d3d6:	0f0f      	.short	0x0f0f
 800d3d8:	1a18      	.short	0x1a18
 800d3da:	16          	.byte	0x16
 800d3db:	00          	.byte	0x00
      pComponentData->Previous_ODR = 104.0f;
 800d3dc:	4a0e      	ldr	r2, [pc, #56]	; (800d418 <LSM6DSM_G_Set_ODR+0x6c>)
 800d3de:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 800d3e0:	2000      	movs	r0, #0
}
 800d3e2:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 26.0f;
 800d3e4:	4a0d      	ldr	r2, [pc, #52]	; (800d41c <LSM6DSM_G_Set_ODR+0x70>)
 800d3e6:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 800d3e8:	2000      	movs	r0, #0
}
 800d3ea:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 52.0f;
 800d3ec:	4a0c      	ldr	r2, [pc, #48]	; (800d420 <LSM6DSM_G_Set_ODR+0x74>)
 800d3ee:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 800d3f0:	2000      	movs	r0, #0
}
 800d3f2:	bd08      	pop	{r3, pc}
      new_odr = LSM6DSM_ACC_GYRO_ODR_G_13Hz;
 800d3f4:	2110      	movs	r1, #16
  if ( LSM6DSM_ACC_GYRO_W_ODR_G( (void *)handle, new_odr ) == MEMS_ERROR )
 800d3f6:	f7fd f9b3 	bl	800a760 <LSM6DSM_ACC_GYRO_W_ODR_G>
  return COMPONENT_OK;
 800d3fa:	fab0 f080 	clz	r0, r0
 800d3fe:	0940      	lsrs	r0, r0, #5
}
 800d400:	bd08      	pop	{r3, pc}
      new_odr = LSM6DSM_ACC_GYRO_ODR_G_104Hz;
 800d402:	2140      	movs	r1, #64	; 0x40
 800d404:	e7f7      	b.n	800d3f6 <LSM6DSM_G_Set_ODR+0x4a>
      new_odr = LSM6DSM_ACC_GYRO_ODR_G_26Hz;
 800d406:	2120      	movs	r1, #32
 800d408:	e7f5      	b.n	800d3f6 <LSM6DSM_G_Set_ODR+0x4a>
      new_odr = LSM6DSM_ACC_GYRO_ODR_G_52Hz;
 800d40a:	2130      	movs	r1, #48	; 0x30
 800d40c:	e7f3      	b.n	800d3f6 <LSM6DSM_G_Set_ODR+0x4a>
      return COMPONENT_ERROR;
 800d40e:	2001      	movs	r0, #1
}
 800d410:	bd08      	pop	{r3, pc}
 800d412:	bf00      	nop
 800d414:	41500000 	.word	0x41500000
 800d418:	42d00000 	.word	0x42d00000
 800d41c:	41d00000 	.word	0x41d00000
 800d420:	42500000 	.word	0x42500000

0800d424 <LSM6DSM_G_Sensor_Disable>:
  if ( handle->isEnabled == 0 )
 800d424:	7983      	ldrb	r3, [r0, #6]
 800d426:	b90b      	cbnz	r3, 800d42c <LSM6DSM_G_Sensor_Disable+0x8>
    return COMPONENT_OK;
 800d428:	4618      	mov	r0, r3
}
 800d42a:	4770      	bx	lr
  LSM6DSM_G_Data_t *pComponentData = ( LSM6DSM_G_Data_t * )pData->pComponentData;
 800d42c:	6883      	ldr	r3, [r0, #8]
  if ( LSM6DSM_G_Get_ODR( handle, &( pComponentData->Previous_ODR ) ) == COMPONENT_ERROR )
 800d42e:	6819      	ldr	r1, [r3, #0]
{
 800d430:	b510      	push	{r4, lr}
  if ( LSM6DSM_G_Get_ODR( handle, &( pComponentData->Previous_ODR ) ) == COMPONENT_ERROR )
 800d432:	3104      	adds	r1, #4
 800d434:	4604      	mov	r4, r0
 800d436:	f7ff f94f 	bl	800c6d8 <LSM6DSM_G_Get_ODR>
 800d43a:	2801      	cmp	r0, #1
 800d43c:	d008      	beq.n	800d450 <LSM6DSM_G_Sensor_Disable+0x2c>
  if ( LSM6DSM_ACC_GYRO_W_ODR_G( (void *)handle, LSM6DSM_ACC_GYRO_ODR_G_POWER_DOWN ) == MEMS_ERROR )
 800d43e:	2100      	movs	r1, #0
 800d440:	4620      	mov	r0, r4
 800d442:	f7fd f98d 	bl	800a760 <LSM6DSM_ACC_GYRO_W_ODR_G>
 800d446:	b118      	cbz	r0, 800d450 <LSM6DSM_G_Sensor_Disable+0x2c>
  handle->isEnabled = 0;
 800d448:	2300      	movs	r3, #0
 800d44a:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 800d44c:	4618      	mov	r0, r3
}
 800d44e:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 800d450:	2001      	movs	r0, #1
}
 800d452:	bd10      	pop	{r4, pc}

0800d454 <LSM6DSM_G_DeInit>:
  LSM6DSM_G_Data_t *pComponentData = ( LSM6DSM_G_Data_t * )pData->pComponentData;
 800d454:	6883      	ldr	r3, [r0, #8]
{
 800d456:	b570      	push	{r4, r5, r6, lr}
  LSM6DSM_G_Data_t *pComponentData = ( LSM6DSM_G_Data_t * )pData->pComponentData;
 800d458:	681d      	ldr	r5, [r3, #0]
{
 800d45a:	4604      	mov	r4, r0
  LSM6DSM_Combo_Data_t *comboData = pComponentData->comboData;
 800d45c:	682e      	ldr	r6, [r5, #0]
  if ( LSM6DSM_Check_WhoAmI( handle ) == COMPONENT_ERROR )
 800d45e:	f7ff f801 	bl	800c464 <LSM6DSM_Check_WhoAmI>
 800d462:	2801      	cmp	r0, #1
 800d464:	d00b      	beq.n	800d47e <LSM6DSM_G_DeInit+0x2a>
  if ( LSM6DSM_G_Sensor_Disable( handle ) == COMPONENT_ERROR )
 800d466:	4620      	mov	r0, r4
 800d468:	f7ff ffdc 	bl	800d424 <LSM6DSM_G_Sensor_Disable>
 800d46c:	2801      	cmp	r0, #1
 800d46e:	d006      	beq.n	800d47e <LSM6DSM_G_DeInit+0x2a>
  comboData->isGyroInitialized = 0;
 800d470:	2300      	movs	r3, #0
  pComponentData->Previous_ODR = 0.0f;
 800d472:	2200      	movs	r2, #0
 800d474:	606a      	str	r2, [r5, #4]
  comboData->isGyroInitialized = 0;
 800d476:	7073      	strb	r3, [r6, #1]
  handle->isInitialized = 0;
 800d478:	7163      	strb	r3, [r4, #5]
  return COMPONENT_OK;
 800d47a:	4618      	mov	r0, r3
}
 800d47c:	bd70      	pop	{r4, r5, r6, pc}
    return COMPONENT_ERROR;
 800d47e:	2001      	movs	r0, #1
}
 800d480:	bd70      	pop	{r4, r5, r6, pc}
 800d482:	bf00      	nop

0800d484 <LSM6DSM_G_Check_WhoAmI>:
 800d484:	f7fe bfee 	b.w	800c464 <LSM6DSM_Check_WhoAmI>

0800d488 <STC3115_DeInit>:
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef STC3115_DeInit( DrvContextTypeDef *handle )
{
  handle->isInitialized = 0;
 800d488:	2300      	movs	r3, #0
 800d48a:	7143      	strb	r3, [r0, #5]

  return COMPONENT_OK;
}
 800d48c:	4618      	mov	r0, r3
 800d48e:	4770      	bx	lr

0800d490 <STC3115_GetSOC>:
 * @param None
 * @retval Battery State of Charge value
 */
static DrvStatusTypeDef STC3115_GetSOC( DrvContextTypeDef* handle, uint32_t* SOC)
{
  *SOC = ((( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.SOC + 5) / 10;
 800d490:	6883      	ldr	r3, [r0, #8]
 800d492:	4a06      	ldr	r2, [pc, #24]	; (800d4ac <STC3115_GetSOC+0x1c>)
 800d494:	681b      	ldr	r3, [r3, #0]
 800d496:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d498:	3305      	adds	r3, #5
 800d49a:	fb82 0203 	smull	r0, r2, r2, r3
 800d49e:	17db      	asrs	r3, r3, #31
 800d4a0:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 800d4a4:	600b      	str	r3, [r1, #0]
  return COMPONENT_OK;
}
 800d4a6:	2000      	movs	r0, #0
 800d4a8:	4770      	bx	lr
 800d4aa:	bf00      	nop
 800d4ac:	66666667 	.word	0x66666667

0800d4b0 <STC3115_GetOCV>:
 * @param None
 * @retval Open circuit Voltage value
 */
static DrvStatusTypeDef STC3115_GetOCV(DrvContextTypeDef* handle, uint32_t* OCV)
{
  *OCV = (( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.OCV;
 800d4b0:	6883      	ldr	r3, [r0, #8]
 800d4b2:	681b      	ldr	r3, [r3, #0]
 800d4b4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800d4b6:	600b      	str	r3, [r1, #0]
  return COMPONENT_OK;
}
 800d4b8:	2000      	movs	r0, #0
 800d4ba:	4770      	bx	lr

0800d4bc <STC3115_GetCurrent>:
 * @param None
 * @retval Current value
 */
static DrvStatusTypeDef STC3115_GetCurrent(DrvContextTypeDef* handle, int32_t* Current)
{
  *Current = (( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.Current;
 800d4bc:	6883      	ldr	r3, [r0, #8]
 800d4be:	681b      	ldr	r3, [r3, #0]
 800d4c0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d4c2:	600b      	str	r3, [r1, #0]
  return COMPONENT_OK;
}
 800d4c4:	2000      	movs	r0, #0
 800d4c6:	4770      	bx	lr

0800d4c8 <STC3115_GetTemperature>:
 * @param None
 * @retval Temperature value
 */
static DrvStatusTypeDef STC3115_GetTemperature(DrvContextTypeDef* handle, int32_t* Temperature)
{
  *Temperature = (( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.Temperature;
 800d4c8:	6883      	ldr	r3, [r0, #8]
 800d4ca:	681b      	ldr	r3, [r3, #0]
 800d4cc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d4ce:	600b      	str	r3, [r1, #0]
  return COMPONENT_OK;
}
 800d4d0:	2000      	movs	r0, #0
 800d4d2:	4770      	bx	lr

0800d4d4 <STC3115_GetVoltage>:
 * @param None
 * @retval Battery voltage value
 */
static DrvStatusTypeDef STC3115_GetVoltage(DrvContextTypeDef* handle, uint32_t* Voltage)
{
  *Voltage = (( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.Voltage;
 800d4d4:	6883      	ldr	r3, [r0, #8]
 800d4d6:	681b      	ldr	r3, [r3, #0]
 800d4d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d4da:	600b      	str	r3, [r1, #0]
  return COMPONENT_OK;
}
 800d4dc:	2000      	movs	r0, #0
 800d4de:	4770      	bx	lr

0800d4e0 <STC3115_GetChargeValue>:
 * @param None
 * @retval battery charge value
 */
static DrvStatusTypeDef STC3115_GetChargeValue(DrvContextTypeDef* handle, uint32_t* ChargeValue)
{
  *ChargeValue = (( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.ChargeValue;
 800d4e0:	6883      	ldr	r3, [r0, #8]
 800d4e2:	681b      	ldr	r3, [r3, #0]
 800d4e4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d4e6:	600b      	str	r3, [r1, #0]
  return COMPONENT_OK;
}
 800d4e8:	2000      	movs	r0, #0
 800d4ea:	4770      	bx	lr

0800d4ec <STC3115_GetPresence>:
 * @param None
 * @retval 0 if battery is not present, 1 if present
 */
static DrvStatusTypeDef STC3115_GetPresence(DrvContextTypeDef* handle, uint32_t* Presence)
{
  *Presence = (( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.Presence;
 800d4ec:	6883      	ldr	r3, [r0, #8]
 800d4ee:	681b      	ldr	r3, [r3, #0]
 800d4f0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800d4f2:	600b      	str	r3, [r1, #0]
  return COMPONENT_OK;
}
 800d4f4:	2000      	movs	r0, #0
 800d4f6:	4770      	bx	lr

0800d4f8 <STC3115_GetAlarmStatus>:
 * @param None
 * @retval STC3115 Alarm bits status
 */
static DrvStatusTypeDef STC3115_GetAlarmStatus(DrvContextTypeDef* handle, uint32_t* status)
{
  *status = ((( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.status >> 13) & 0x3;
 800d4f8:	6883      	ldr	r3, [r0, #8]
 800d4fa:	681b      	ldr	r3, [r3, #0]
 800d4fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d4fe:	f3c3 3341 	ubfx	r3, r3, #13, #2
 800d502:	600b      	str	r3, [r1, #0]
  return COMPONENT_OK;
}
 800d504:	2000      	movs	r0, #0
 800d506:	4770      	bx	lr

0800d508 <STC3115_GetRemTime>:
 * @param None
 * @retval RemTime value
 */
static DrvStatusTypeDef STC3115_GetRemTime(DrvContextTypeDef* handle, int32_t* RemTime)
{
  *RemTime = (( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.RemTime;
 800d508:	6883      	ldr	r3, [r0, #8]
 800d50a:	681b      	ldr	r3, [r3, #0]
 800d50c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800d50e:	600b      	str	r3, [r1, #0]
  return COMPONENT_OK;
}
 800d510:	2000      	movs	r0, #0
 800d512:	4770      	bx	lr

0800d514 <STC3115_Get_WhoAmI>:
{
 800d514:	b508      	push	{r3, lr}
 * @param  value pointer to integer where to store data
 * @retval Error code: 0 ok, -1 error
 */
static int STC3115_Read(DrvContextTypeDef* handle, uint8_t RegAddress, uint8_t *data, uint16_t NumByteToRead)
{
  if (Sensor_IO_Read(handle, RegAddress, data, NumByteToRead))
 800d516:	460a      	mov	r2, r1
 800d518:	2301      	movs	r3, #1
 800d51a:	2118      	movs	r1, #24
 800d51c:	f001 f890 	bl	800e640 <Sensor_IO_Read>
}
 800d520:	3000      	adds	r0, #0
 800d522:	bf18      	it	ne
 800d524:	2001      	movne	r0, #1
 800d526:	bd08      	pop	{r3, pc}

0800d528 <STC3115_Status>:
{
 800d528:	b510      	push	{r4, lr}
 800d52a:	b082      	sub	sp, #8
  if (Sensor_IO_Read(handle, RegAddress, data, NumByteToRead))
 800d52c:	2301      	movs	r3, #1
 800d52e:	f10d 0205 	add.w	r2, sp, #5
 800d532:	2118      	movs	r1, #24
{
 800d534:	4604      	mov	r4, r0
  if (Sensor_IO_Read(handle, RegAddress, data, NumByteToRead))
 800d536:	f001 f883 	bl	800e640 <Sensor_IO_Read>
 800d53a:	b990      	cbnz	r0, 800d562 <STC3115_Status+0x3a>
  if (data != STC3115_ID)
 800d53c:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800d540:	2b14      	cmp	r3, #20
 800d542:	d10e      	bne.n	800d562 <STC3115_Status+0x3a>
 */
static int STC3115_ReadWord(DrvContextTypeDef* handle, uint8_t RegAddress, int* value)
{
  uint16_t tmp;
  
  if (Sensor_IO_Read(handle, RegAddress, (uint8_t*)&tmp, 2))
 800d544:	4601      	mov	r1, r0
 800d546:	2302      	movs	r3, #2
 800d548:	4620      	mov	r0, r4
 800d54a:	f10d 0206 	add.w	r2, sp, #6
 800d54e:	f001 f877 	bl	800e640 <Sensor_IO_Read>
 800d552:	b930      	cbnz	r0, 800d562 <STC3115_Status+0x3a>
  {
    return -1;
  }
  else
  {
    *value = tmp & 0xffff;
 800d554:	f8bd 0006 	ldrh.w	r0, [sp, #6]
	value &= 0x7f7f;
 800d558:	f647 737f 	movw	r3, #32639	; 0x7f7f
 800d55c:	4018      	ands	r0, r3
}
 800d55e:	b002      	add	sp, #8
 800d560:	bd10      	pop	{r4, pc}
    return -1;
 800d562:	f04f 30ff 	mov.w	r0, #4294967295
}
 800d566:	b002      	add	sp, #8
 800d568:	bd10      	pop	{r4, pc}
 800d56a:	bf00      	nop

0800d56c <STC3115_SetParam>:
 * @brief Initialize the STC3115 parameters
 * @param ConfigData Pointer to STC3115 Configuration Data structure
 * @retval None
 */
static DrvStatusTypeDef STC3115_SetParam(DrvContextTypeDef* handle, STC3115_ConfigData_TypeDef *ConfigData)
{
 800d56c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d570:	b082      	sub	sp, #8
  uint8_t data;
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 800d572:	6883      	ldr	r3, [r0, #8]
  
  /* set GG_RUN=0 before changing algo parameters */
  data = STC3115_VMODE;
 800d574:	ac02      	add	r4, sp, #8
 800d576:	2701      	movs	r7, #1
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 800d578:	f8d3 8000 	ldr.w	r8, [r3]
  data = STC3115_VMODE;
 800d57c:	f804 7d03 	strb.w	r7, [r4, #-3]!
{
 800d580:	460e      	mov	r6, r1
 800d582:	4605      	mov	r5, r0
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d584:	4622      	mov	r2, r4
 800d586:	463b      	mov	r3, r7
 800d588:	2100      	movs	r1, #0
 800d58a:	f000 ff6b 	bl	800e464 <Sensor_IO_Write>
 800d58e:	2310      	movs	r3, #16
 800d590:	f106 0220 	add.w	r2, r6, #32
 800d594:	4628      	mov	r0, r5
 800d596:	2130      	movs	r1, #48	; 0x30
 800d598:	f000 ff64 	bl	800e464 <Sensor_IO_Write>
  
  /* init OCV curve */
  STC3115_Write(handle, STC3115_REG_OCVTAB, (unsigned char *) ConfigData->OCVOffset, OCVTAB_SIZE);
  
  /* set alm level if different from default */
  if (ConfigData->Alm_SOC != 0 )
 800d59c:	6873      	ldr	r3, [r6, #4]
 800d59e:	2b00      	cmp	r3, #0
 800d5a0:	d154      	bne.n	800d64c <STC3115_SetParam+0xe0>
  {
    data = ConfigData->Alm_SOC * 2;
    STC3115_Write(handle, STC3115_REG_ALARM_SOC, &data, 1);
  }
  if (ConfigData->Alm_Vbat != 0 )
 800d5a2:	68b3      	ldr	r3, [r6, #8]
 800d5a4:	2b00      	cmp	r3, #0
 800d5a6:	d141      	bne.n	800d62c <STC3115_SetParam+0xc0>
    data = ((long)(ConfigData->Alm_Vbat << 9) / VoltageFactor); /* LSB=8*2.2mV */
    STC3115_Write(handle, STC3115_REG_ALARM_VOLTAGE, &data, 1);
  }
  
  /* relaxation timer */
  if (ConfigData->Rsense != 0 )
 800d5a8:	69b1      	ldr	r1, [r6, #24]
 800d5aa:	bb71      	cbnz	r1, 800d60a <STC3115_SetParam+0x9e>
    data = ((long)(ConfigData->RelaxCurrent << 9) / (CurrentFactor / ConfigData->Rsense));  /* LSB=8*5.88uV */
    STC3115_Write(handle, STC3115_REG_CURRENT_THRES, &data, 1);
  }
  
  /* set parameters if different from default, only if a restart is done (battery change) */
  if (RAMData->reg.CC_cnf != 0 ) STC3115_WriteWord(handle, STC3115_REG_CC_CNF, RAMData->reg.CC_cnf);
 800d5ac:	f9b8 1060 	ldrsh.w	r1, [r8, #96]	; 0x60
 800d5b0:	bb11      	cbnz	r1, 800d5f8 <STC3115_SetParam+0x8c>
  if (RAMData->reg.VM_cnf != 0 ) STC3115_WriteWord(handle, STC3115_REG_VM_CNF, RAMData->reg.VM_cnf);
 800d5b2:	f9b8 1062 	ldrsh.w	r1, [r8, #98]	; 0x62
 800d5b6:	b139      	cbz	r1, 800d5c8 <STC3115_SetParam+0x5c>
  uint16_t tmp = value & 0xffff;
 800d5b8:	aa02      	add	r2, sp, #8
  if (Sensor_IO_Write(handle, RegAddress, (uint8_t*)&tmp, 2))
 800d5ba:	2302      	movs	r3, #2
  uint16_t tmp = value & 0xffff;
 800d5bc:	f822 1d02 	strh.w	r1, [r2, #-2]!
  if (Sensor_IO_Write(handle, RegAddress, (uint8_t*)&tmp, 2))
 800d5c0:	4628      	mov	r0, r5
 800d5c2:	2111      	movs	r1, #17
 800d5c4:	f000 ff4e 	bl	800e464 <Sensor_IO_Write>
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d5c8:	2301      	movs	r3, #1
 800d5ca:	4619      	mov	r1, r3
 800d5cc:	4622      	mov	r2, r4
  
  data = 0x03;
 800d5ce:	2703      	movs	r7, #3
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d5d0:	4628      	mov	r0, r5
  data = 0x03;
 800d5d2:	f88d 7005 	strb.w	r7, [sp, #5]
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d5d6:	f000 ff45 	bl	800e464 <Sensor_IO_Write>
  STC3115_Write(handle, STC3115_REG_CTRL, &data, 1); /*   clear PORDET, BATFAIL, free ALM pin, reset conv counter */
  
  data = STC3115_GG_RUN | (STC3115_VMODE * ConfigData->Vmode) | (STC3115_ALM_ENA * ALM_EN);
 800d5da:	6833      	ldr	r3, [r6, #0]
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d5dc:	4622      	mov	r2, r4
 800d5de:	4628      	mov	r0, r5
  data = STC3115_GG_RUN | (STC3115_VMODE * ConfigData->Vmode) | (STC3115_ALM_ENA * ALM_EN);
 800d5e0:	f043 0410 	orr.w	r4, r3, #16
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d5e4:	2100      	movs	r1, #0
 800d5e6:	2301      	movs	r3, #1
  data = STC3115_GG_RUN | (STC3115_VMODE * ConfigData->Vmode) | (STC3115_ALM_ENA * ALM_EN);
 800d5e8:	f88d 4005 	strb.w	r4, [sp, #5]
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d5ec:	f000 ff3a 	bl	800e464 <Sensor_IO_Write>
  STC3115_Write(handle, STC3115_REG_MODE, &data, 1);  /*   set GG_RUN=1, set mode, set alm enable */
  
  return COMPONENT_OK;
}
 800d5f0:	2000      	movs	r0, #0
 800d5f2:	b002      	add	sp, #8
 800d5f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  uint16_t tmp = value & 0xffff;
 800d5f8:	aa02      	add	r2, sp, #8
  if (Sensor_IO_Write(handle, RegAddress, (uint8_t*)&tmp, 2))
 800d5fa:	2302      	movs	r3, #2
  uint16_t tmp = value & 0xffff;
 800d5fc:	f822 1d02 	strh.w	r1, [r2, #-2]!
  if (Sensor_IO_Write(handle, RegAddress, (uint8_t*)&tmp, 2))
 800d600:	4628      	mov	r0, r5
 800d602:	210f      	movs	r1, #15
 800d604:	f000 ff2e 	bl	800e464 <Sensor_IO_Write>
 800d608:	e7d3      	b.n	800d5b2 <STC3115_SetParam+0x46>
    data = ((long)(ConfigData->RelaxCurrent << 9) / (CurrentFactor / ConfigData->Rsense));  /* LSB=8*5.88uV */
 800d60a:	69f0      	ldr	r0, [r6, #28]
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d60c:	2301      	movs	r3, #1
    data = ((long)(ConfigData->RelaxCurrent << 9) / (CurrentFactor / ConfigData->Rsense));  /* LSB=8*5.88uV */
 800d60e:	0240      	lsls	r0, r0, #9
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d610:	4622      	mov	r2, r4
    data = ((long)(ConfigData->RelaxCurrent << 9) / (CurrentFactor / ConfigData->Rsense));  /* LSB=8*5.88uV */
 800d612:	f645 6714 	movw	r7, #24084	; 0x5e14
 800d616:	fb97 f7f1 	sdiv	r7, r7, r1
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d61a:	2115      	movs	r1, #21
    data = ((long)(ConfigData->RelaxCurrent << 9) / (CurrentFactor / ConfigData->Rsense));  /* LSB=8*5.88uV */
 800d61c:	fb90 f7f7 	sdiv	r7, r0, r7
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d620:	4628      	mov	r0, r5
    data = ((long)(ConfigData->RelaxCurrent << 9) / (CurrentFactor / ConfigData->Rsense));  /* LSB=8*5.88uV */
 800d622:	f88d 7005 	strb.w	r7, [sp, #5]
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d626:	f000 ff1d 	bl	800e464 <Sensor_IO_Write>
 800d62a:	e7bf      	b.n	800d5ac <STC3115_SetParam+0x40>
    data = ((long)(ConfigData->Alm_Vbat << 9) / VoltageFactor); /* LSB=8*2.2mV */
 800d62c:	4f0d      	ldr	r7, [pc, #52]	; (800d664 <STC3115_SetParam+0xf8>)
 800d62e:	025b      	lsls	r3, r3, #9
 800d630:	fb87 2703 	smull	r2, r7, r7, r3
 800d634:	17db      	asrs	r3, r3, #31
 800d636:	ebc3 3727 	rsb	r7, r3, r7, asr #12
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d63a:	4622      	mov	r2, r4
 800d63c:	2301      	movs	r3, #1
 800d63e:	2114      	movs	r1, #20
 800d640:	4628      	mov	r0, r5
    data = ((long)(ConfigData->Alm_Vbat << 9) / VoltageFactor); /* LSB=8*2.2mV */
 800d642:	f88d 7005 	strb.w	r7, [sp, #5]
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d646:	f000 ff0d 	bl	800e464 <Sensor_IO_Write>
 800d64a:	e7ad      	b.n	800d5a8 <STC3115_SetParam+0x3c>
    data = ConfigData->Alm_SOC * 2;
 800d64c:	fa03 fc07 	lsl.w	ip, r3, r7
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d650:	4622      	mov	r2, r4
 800d652:	463b      	mov	r3, r7
 800d654:	2113      	movs	r1, #19
 800d656:	4628      	mov	r0, r5
    data = ConfigData->Alm_SOC * 2;
 800d658:	f88d c005 	strb.w	ip, [sp, #5]
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d65c:	f000 ff02 	bl	800e464 <Sensor_IO_Write>
 800d660:	e79f      	b.n	800d5a2 <STC3115_SetParam+0x36>
 800d662:	bf00      	nop
 800d664:	745dc089 	.word	0x745dc089

0800d668 <STC3115_Restore>:
{
 800d668:	b570      	push	{r4, r5, r6, lr}
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 800d66a:	6883      	ldr	r3, [r0, #8]
{
 800d66c:	b082      	sub	sp, #8
 800d66e:	4604      	mov	r4, r0
 800d670:	460e      	mov	r6, r1
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 800d672:	681d      	ldr	r5, [r3, #0]
  res = STC3115_Status(handle);
 800d674:	f7ff ff58 	bl	800d528 <STC3115_Status>
  if (res < 0) return(res);
 800d678:	2800      	cmp	r0, #0
 800d67a:	db08      	blt.n	800d68e <STC3115_Restore+0x26>
  STC3115_SetParam(handle, ConfigData);  /* set STC3115 parameters  */
 800d67c:	4631      	mov	r1, r6
 800d67e:	4620      	mov	r0, r4
 800d680:	f7ff ff74 	bl	800d56c <STC3115_SetParam>
  if (RAMData->reg.STC3115_Status == STC3115_RUNNING)
 800d684:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 800d688:	2b52      	cmp	r3, #82	; 0x52
 800d68a:	d002      	beq.n	800d692 <STC3115_Restore+0x2a>
  res = 0;
 800d68c:	2000      	movs	r0, #0
}
 800d68e:	b002      	add	sp, #8
 800d690:	bd70      	pop	{r4, r5, r6, pc}
    if (RAMData->reg.HRSOC != 0)
 800d692:	f9b5 005e 	ldrsh.w	r0, [r5, #94]	; 0x5e
 800d696:	2800      	cmp	r0, #0
 800d698:	d0f9      	beq.n	800d68e <STC3115_Restore+0x26>
  uint16_t tmp = value & 0xffff;
 800d69a:	aa02      	add	r2, sp, #8
  if (Sensor_IO_Write(handle, RegAddress, (uint8_t*)&tmp, 2))
 800d69c:	2302      	movs	r3, #2
  uint16_t tmp = value & 0xffff;
 800d69e:	f822 0d02 	strh.w	r0, [r2, #-2]!
  if (Sensor_IO_Write(handle, RegAddress, (uint8_t*)&tmp, 2))
 800d6a2:	4619      	mov	r1, r3
 800d6a4:	4620      	mov	r0, r4
 800d6a6:	f000 fedd 	bl	800e464 <Sensor_IO_Write>
 800d6aa:	3000      	adds	r0, #0
 800d6ac:	bf18      	it	ne
 800d6ae:	2001      	movne	r0, #1
 800d6b0:	4240      	negs	r0, r0
 800d6b2:	e7ec      	b.n	800d68e <STC3115_Restore+0x26>

0800d6b4 <STC3115_UpdateRamCRC.isra.0>:
static int STC3115_UpdateRamCRC( DrvContextTypeDef* handle )
 800d6b4:	b430      	push	{r4, r5}
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 800d6b6:	6805      	ldr	r5, [r0, #0]
  int crc = 0; /* initial value */
 800d6b8:	2000      	movs	r0, #0
 800d6ba:	f105 025b 	add.w	r2, r5, #91	; 0x5b
 800d6be:	f105 046a 	add.w	r4, r5, #106	; 0x6a
    crc ^= data[i];
 800d6c2:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 800d6c6:	2308      	movs	r3, #8
 800d6c8:	4048      	eors	r0, r1
      crc <<= 1;
 800d6ca:	0040      	lsls	r0, r0, #1
      if (crc & 0x100)  crc ^= 7;
 800d6cc:	05c1      	lsls	r1, r0, #23
 800d6ce:	bf48      	it	mi
 800d6d0:	f080 0007 	eormi.w	r0, r0, #7
    for (j = 0; j < 8; j++)
 800d6d4:	3b01      	subs	r3, #1
 800d6d6:	d1f8      	bne.n	800d6ca <STC3115_UpdateRamCRC.isra.0+0x16>
  for (i = 0; i < n; i++)
 800d6d8:	42a2      	cmp	r2, r4
 800d6da:	d1f2      	bne.n	800d6c2 <STC3115_UpdateRamCRC.isra.0+0xe>
  RAMData->db[RAM_SIZE - 1] = res; /* last byte holds the CRC */
 800d6dc:	f885 006b 	strb.w	r0, [r5, #107]	; 0x6b
}
 800d6e0:	b2c0      	uxtb	r0, r0
 800d6e2:	bc30      	pop	{r4, r5}
 800d6e4:	4770      	bx	lr
 800d6e6:	bf00      	nop

0800d6e8 <STC3115_Stop>:
{
 800d6e8:	b5f0      	push	{r4, r5, r6, r7, lr}
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 800d6ea:	6882      	ldr	r2, [r0, #8]
 800d6ec:	6815      	ldr	r5, [r2, #0]
  STC3115_ReadRamData(handle, RAMData->db);
 800d6ee:	f105 075c 	add.w	r7, r5, #92	; 0x5c
{
 800d6f2:	b083      	sub	sp, #12
 800d6f4:	4604      	mov	r4, r0
  if (Sensor_IO_Read(handle, STC3115_REG_RAM, RamData, RAM_SIZE))
 800d6f6:	463a      	mov	r2, r7
 800d6f8:	2120      	movs	r1, #32
 800d6fa:	2310      	movs	r3, #16
 800d6fc:	f000 ffa0 	bl	800e640 <Sensor_IO_Read>
  RAMData->reg.STC3115_Status = STC3115_POWERDN;
 800d700:	2344      	movs	r3, #68	; 0x44
  data = 0x01;
 800d702:	ae02      	add	r6, sp, #8
  RAMData->reg.STC3115_Status = STC3115_POWERDN;
 800d704:	f885 3065 	strb.w	r3, [r5, #101]	; 0x65
  STC3115_UpdateRamCRC(handle);
 800d708:	68a0      	ldr	r0, [r4, #8]
 800d70a:	f7ff ffd3 	bl	800d6b4 <STC3115_UpdateRamCRC.isra.0>
  data = 0x01;
 800d70e:	2501      	movs	r5, #1
  if (Sensor_IO_Write(handle, STC3115_REG_RAM, RamData, RAM_SIZE))
 800d710:	463a      	mov	r2, r7
 800d712:	4620      	mov	r0, r4
 800d714:	2310      	movs	r3, #16
 800d716:	2120      	movs	r1, #32
 800d718:	f000 fea4 	bl	800e464 <Sensor_IO_Write>
  data = 0x01;
 800d71c:	f806 5d01 	strb.w	r5, [r6, #-1]!
  data = 0x00;
 800d720:	2700      	movs	r7, #0
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d722:	462b      	mov	r3, r5
 800d724:	4632      	mov	r2, r6
 800d726:	4629      	mov	r1, r5
 800d728:	4620      	mov	r0, r4
 800d72a:	f000 fe9b 	bl	800e464 <Sensor_IO_Write>
 800d72e:	4632      	mov	r2, r6
 800d730:	462b      	mov	r3, r5
 800d732:	4620      	mov	r0, r4
 800d734:	4639      	mov	r1, r7
  data = 0x00;
 800d736:	f88d 7007 	strb.w	r7, [sp, #7]
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d73a:	f000 fe93 	bl	800e464 <Sensor_IO_Write>
}
 800d73e:	1bc0      	subs	r0, r0, r7
 800d740:	bf18      	it	ne
 800d742:	2001      	movne	r0, #1
 800d744:	b003      	add	sp, #12
 800d746:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800d748 <STC3115_Reset>:
{
 800d748:	b530      	push	{r4, r5, lr}
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 800d74a:	6883      	ldr	r3, [r0, #8]
 800d74c:	681a      	ldr	r2, [r3, #0]
  RAMData->reg.TstWord = 0;
 800d74e:	2100      	movs	r1, #0
 800d750:	f8a2 105c 	strh.w	r1, [r2, #92]	; 0x5c
  RAMData->reg.STC3115_Status = 0;
 800d754:	f882 1065 	strb.w	r1, [r2, #101]	; 0x65
{
 800d758:	b083      	sub	sp, #12
  if (Sensor_IO_Write(handle, STC3115_REG_RAM, RamData, RAM_SIZE))
 800d75a:	2310      	movs	r3, #16
 800d75c:	325c      	adds	r2, #92	; 0x5c
 800d75e:	2120      	movs	r1, #32
{
 800d760:	4605      	mov	r5, r0
  if (Sensor_IO_Write(handle, STC3115_REG_RAM, RamData, RAM_SIZE))
 800d762:	f000 fe7f 	bl	800e464 <Sensor_IO_Write>
 800d766:	b110      	cbz	r0, 800d76e <STC3115_Reset+0x26>
  if(res != OK) return COMPONENT_ERROR;
 800d768:	2001      	movs	r0, #1
}
 800d76a:	b003      	add	sp, #12
 800d76c:	bd30      	pop	{r4, r5, pc}
  uint8_t data = STC3115_PORDET;
 800d76e:	aa02      	add	r2, sp, #8
 800d770:	2310      	movs	r3, #16
 800d772:	f802 3d01 	strb.w	r3, [r2, #-1]!
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 800d776:	2301      	movs	r3, #1
 800d778:	4604      	mov	r4, r0
 800d77a:	4619      	mov	r1, r3
 800d77c:	4628      	mov	r0, r5
 800d77e:	f000 fe71 	bl	800e464 <Sensor_IO_Write>
 800d782:	4620      	mov	r0, r4
}
 800d784:	b003      	add	sp, #12
 800d786:	bd30      	pop	{r4, r5, pc}

0800d788 <STC3115_Task>:
{
 800d788:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  STC3115_ConfigData_TypeDef *ConfigData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->configData;
 800d78c:	6883      	ldr	r3, [r0, #8]
{
 800d78e:	b084      	sub	sp, #16
 800d790:	4605      	mov	r5, r0
 800d792:	460f      	mov	r7, r1
  STC3115_ConfigData_TypeDef *ConfigData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->configData;
 800d794:	681c      	ldr	r4, [r3, #0]
  res = STC3115_Status(handle);
 800d796:	f7ff fec7 	bl	800d528 <STC3115_Status>
  if (res < 0) return(COMPONENT_ERROR); /* return if I2C error or STC3115 not responding */
 800d79a:	2800      	cmp	r0, #0
 800d79c:	f2c0 80df 	blt.w	800d95e <STC3115_Task+0x1d6>
  STC3115_ReadRamData(handle, RAMData->db);
 800d7a0:	f104 065c 	add.w	r6, r4, #92	; 0x5c
  BatteryData->status = res;
 800d7a4:	6320      	str	r0, [r4, #48]	; 0x30
  if (Sensor_IO_Read(handle, STC3115_REG_RAM, RamData, RAM_SIZE))
 800d7a6:	4632      	mov	r2, r6
 800d7a8:	2310      	movs	r3, #16
 800d7aa:	2120      	movs	r1, #32
 800d7ac:	4628      	mov	r0, r5
 800d7ae:	f000 ff47 	bl	800e640 <Sensor_IO_Read>
  if ( (RAMData->reg.TstWord != RAM_TSTWORD) || (STC3115_CalcRamCRC8(RAMData->db, RAM_SIZE) != 0) )
 800d7b2:	f9b4 205c 	ldrsh.w	r2, [r4, #92]	; 0x5c
 800d7b6:	f245 33a9 	movw	r3, #21417	; 0x53a9
 800d7ba:	429a      	cmp	r2, r3
 800d7bc:	f000 80f7 	beq.w	800d9ae <STC3115_Task+0x226>
    STC3115_InitRamData(handle, ConfigData);
 800d7c0:	68a8      	ldr	r0, [r5, #8]
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 800d7c2:	f8d0 c000 	ldr.w	ip, [r0]
    RAMData->db[index] = 0;
 800d7c6:	2100      	movs	r1, #0
 800d7c8:	f10c 035b 	add.w	r3, ip, #91	; 0x5b
 800d7cc:	f10c 026b 	add.w	r2, ip, #107	; 0x6b
 800d7d0:	f803 1f01 	strb.w	r1, [r3, #1]!
  for (index = 0; index < RAM_SIZE; index++)
 800d7d4:	429a      	cmp	r2, r3
 800d7d6:	d1fb      	bne.n	800d7d0 <STC3115_Task+0x48>
  RAMData->reg.TstWord = RAM_TSTWORD; /* Fixed word to check RAM integrity */
 800d7d8:	f245 33a9 	movw	r3, #21417	; 0x53a9
  RAMData->reg.CC_cnf = ConfigData->CC_cnf;
 800d7dc:	68e2      	ldr	r2, [r4, #12]
  RAMData->reg.TstWord = RAM_TSTWORD; /* Fixed word to check RAM integrity */
 800d7de:	f8ac 305c 	strh.w	r3, [ip, #92]	; 0x5c
  RAMData->reg.VM_cnf = ConfigData->VM_cnf;
 800d7e2:	6923      	ldr	r3, [r4, #16]
 800d7e4:	f8ac 3062 	strh.w	r3, [ip, #98]	; 0x62
  RAMData->reg.CC_cnf = ConfigData->CC_cnf;
 800d7e8:	f8ac 2060 	strh.w	r2, [ip, #96]	; 0x60
  STC3115_UpdateRamCRC(handle);
 800d7ec:	f7ff ff62 	bl	800d6b4 <STC3115_UpdateRamCRC.isra.0>
    RAMData->reg.STC3115_Status = STC3115_INIT;
 800d7f0:	2349      	movs	r3, #73	; 0x49
 800d7f2:	f884 3065 	strb.w	r3, [r4, #101]	; 0x65
  if ((BatteryData->status & (STC3115_BATFAIL << 8)) != 0)
 800d7f6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800d7f8:	0519      	lsls	r1, r3, #20
 800d7fa:	f100 80ef 	bmi.w	800d9dc <STC3115_Task+0x254>
  if ((BatteryData->status & STC3115_GG_RUN) == 0)
 800d7fe:	06da      	lsls	r2, r3, #27
 800d800:	f140 80b1 	bpl.w	800d966 <STC3115_Task+0x1de>
 800d804:	46e8      	mov	r8, sp
  if (Sensor_IO_Read(handle, RegAddress, data, NumByteToRead))
 800d806:	230f      	movs	r3, #15
 800d808:	4642      	mov	r2, r8
 800d80a:	2100      	movs	r1, #0
 800d80c:	4628      	mov	r0, r5
 800d80e:	f000 ff17 	bl	800e640 <Sensor_IO_Read>
 800d812:	2800      	cmp	r0, #0
 800d814:	f040 80a3 	bne.w	800d95e <STC3115_Task+0x1d6>
  value = data[3];
 800d818:	f89d 3003 	ldrb.w	r3, [sp, #3]
  value = (value << 8) + data[2];
 800d81c:	f89d c002 	ldrb.w	ip, [sp, #2]
  if (RAMData->reg.STC3115_Status == STC3115_INIT)
 800d820:	f894 a065 	ldrb.w	sl, [r4, #101]	; 0x65
  value = (value << 8) + data[2];
 800d824:	eb0c 2c03 	add.w	ip, ip, r3, lsl #8
  BatteryData->SOC = (value * 10 + 256) / 512; /* result in 0.1% */
 800d828:	eb0c 008c 	add.w	r0, ip, ip, lsl #2
 800d82c:	0040      	lsls	r0, r0, #1
 800d82e:	f500 7080 	add.w	r0, r0, #256	; 0x100
 800d832:	1240      	asrs	r0, r0, #9
 800d834:	e9c4 c00d 	strd	ip, r0, [r4, #52]	; 0x34
  value = data[5];
 800d838:	f89d 3005 	ldrb.w	r3, [sp, #5]
  value = (value << 8) + data[4];
 800d83c:	f89d e004 	ldrb.w	lr, [sp, #4]
 800d840:	eb0e 2e03 	add.w	lr, lr, r3, lsl #8
  BatteryData->ConvCounter = value;
 800d844:	f8c4 e048 	str.w	lr, [r4, #72]	; 0x48
  value = data[7];
 800d848:	f89d 2007 	ldrb.w	r2, [sp, #7]
  value = (value << 8) + data[6];
 800d84c:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800d850:	eb03 2302 	add.w	r3, r3, r2, lsl #8
  value &= 0x3fff;   /* mask unused bits */
 800d854:	f3c3 030d 	ubfx	r3, r3, #0, #14
  if (value >= 0x2000) value = value - 0x4000; /* convert to signed value */
 800d858:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800d85c:	bfa8      	it	ge
 800d85e:	f5a3 4380 	subge.w	r3, r3, #16384	; 0x4000
  v = ( (long) value * factor ) >> 11;
 800d862:	f241 21d0 	movw	r1, #4816	; 0x12d0
 800d866:	fb01 f103 	mul.w	r1, r1, r3
 800d86a:	12c9      	asrs	r1, r1, #11
  v = (v+1)/2;
 800d86c:	3101      	adds	r1, #1
 800d86e:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
 800d872:	1049      	asrs	r1, r1, #1
  BatteryData->Current = STC3115_conv(value, 10*CurrentFactor / RSENSE); /* result in hundreds of uA */
 800d874:	6421      	str	r1, [r4, #64]	; 0x40
  value = data[9];
 800d876:	f89d 2009 	ldrb.w	r2, [sp, #9]
  value = (value << 8) + data[8];
 800d87a:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800d87e:	eb03 2302 	add.w	r3, r3, r2, lsl #8
  value &= 0x0fff; /* mask unused bits */
 800d882:	f3c3 030b 	ubfx	r3, r3, #0, #12
  if (value >= 0x0800) value -= 0x1000; /* convert to signed value */
 800d886:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800d88a:	bfa8      	it	ge
 800d88c:	f5a3 5380 	subge.w	r3, r3, #4096	; 0x1000
  v = ( (long) value * factor ) >> 11;
 800d890:	f242 3233 	movw	r2, #9011	; 0x2333
 800d894:	fb02 f203 	mul.w	r2, r2, r3
 800d898:	12d2      	asrs	r2, r2, #11
  v = (v+1)/2;
 800d89a:	3201      	adds	r2, #1
 800d89c:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
 800d8a0:	1052      	asrs	r2, r2, #1
  BatteryData->Voltage = value;  /* result in mV */
 800d8a2:	63e2      	str	r2, [r4, #60]	; 0x3c
  value = data[10];
 800d8a4:	f89d 300a 	ldrb.w	r3, [sp, #10]
  if (value >= 0x80) value -= 0x100; /* convert to signed value */
 800d8a8:	2b7f      	cmp	r3, #127	; 0x7f
 800d8aa:	bfc8      	it	gt
 800d8ac:	f5a3 7380 	subgt.w	r3, r3, #256	; 0x100
  BatteryData->Temperature = value * 10; /* result in 0.1C */
 800d8b0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800d8b4:	005b      	lsls	r3, r3, #1
 800d8b6:	6463      	str	r3, [r4, #68]	; 0x44
  value = data[14];
 800d8b8:	f89d 900e 	ldrb.w	r9, [sp, #14]
  value = (value << 8) + data[13];
 800d8bc:	f89d 300d 	ldrb.w	r3, [sp, #13]
 800d8c0:	eb03 2309 	add.w	r3, r3, r9, lsl #8
  value &= 0x3fff; /* mask unused bits */
 800d8c4:	f3c3 090d 	ubfx	r9, r3, #0, #14
  if (value >= 0x02000) value -= 0x4000; /* convert to signed value */
 800d8c8:	f5b9 5f00 	cmp.w	r9, #8192	; 0x2000
 800d8cc:	bfa8      	it	ge
 800d8ce:	f5a9 4980 	subge.w	r9, r9, #16384	; 0x4000
  v = ( (long) value * factor ) >> 11;
 800d8d2:	f242 3333 	movw	r3, #9011	; 0x2333
 800d8d6:	fb03 f309 	mul.w	r3, r3, r9
 800d8da:	12db      	asrs	r3, r3, #11
  v = (v+1)/2;
 800d8dc:	3301      	adds	r3, #1
 800d8de:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 800d8e2:	105b      	asrs	r3, r3, #1
  value = (value + 2) / 4; /* divide by 4 with rounding */
 800d8e4:	f113 0902 	adds.w	r9, r3, #2
 800d8e8:	bf48      	it	mi
 800d8ea:	f103 0905 	addmi.w	r9, r3, #5
 800d8ee:	ea4f 03a9 	mov.w	r3, r9, asr #2
  if (RAMData->reg.STC3115_Status == STC3115_INIT)
 800d8f2:	f1ba 0f49 	cmp.w	sl, #73	; 0x49
  BatteryData->OCV = value;  /* result in mV */
 800d8f6:	64e3      	str	r3, [r4, #76]	; 0x4c
  if (RAMData->reg.STC3115_Status == STC3115_INIT)
 800d8f8:	f000 8081 	beq.w	800d9fe <STC3115_Task+0x276>
  if (RAMData->reg.STC3115_Status != STC3115_RUNNING)   /* not running : data partially availalble*/
 800d8fc:	f1ba 0f52 	cmp.w	sl, #82	; 0x52
 800d900:	f000 8087 	beq.w	800da12 <STC3115_Task+0x28a>
    BatteryData->ChargeValue = ConfigData->Cnom * BatteryData->SOC / MAX_SOC;
 800d904:	6962      	ldr	r2, [r4, #20]
 800d906:	497b      	ldr	r1, [pc, #492]	; (800daf4 <STC3115_Task+0x36c>)
 800d908:	f8df e1f0 	ldr.w	lr, [pc, #496]	; 800dafc <STC3115_Task+0x374>
 800d90c:	fb02 f200 	mul.w	r2, r2, r0
 800d910:	1d43      	adds	r3, r0, #5
 800d912:	fb81 0102 	smull	r0, r1, r1, r2
 800d916:	17d2      	asrs	r2, r2, #31
 800d918:	ebc2 12a1 	rsb	r2, r2, r1, asr #6
 800d91c:	fbae 0303 	umull	r0, r3, lr, r3
    BatteryData->Temperature = 250;
 800d920:	21fa      	movs	r1, #250	; 0xfa
    BatteryData->Current = 0;
 800d922:	2000      	movs	r0, #0
    BatteryData->Temperature = 250;
 800d924:	e9c4 0110 	strd	r0, r1, [r4, #64]	; 0x40
    BatteryData->ChargeValue = ConfigData->Cnom * BatteryData->SOC / MAX_SOC;
 800d928:	6562      	str	r2, [r4, #84]	; 0x54
    BatteryData->RemTime = -1;
 800d92a:	f04f 32ff 	mov.w	r2, #4294967295
 800d92e:	f3c3 03c7 	ubfx	r3, r3, #3, #8
 800d932:	65a2      	str	r2, [r4, #88]	; 0x58
  RAMData->reg.HRSOC = BatteryData->HRSOC;
 800d934:	f8a4 c05e 	strh.w	ip, [r4, #94]	; 0x5e
  RAMData->reg.SOC = (BatteryData->SOC + 5) / 10;
 800d938:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
  STC3115_UpdateRamCRC(handle);
 800d93c:	68a8      	ldr	r0, [r5, #8]
 800d93e:	f7ff feb9 	bl	800d6b4 <STC3115_UpdateRamCRC.isra.0>
  if (Sensor_IO_Write(handle, STC3115_REG_RAM, RamData, RAM_SIZE))
 800d942:	2310      	movs	r3, #16
 800d944:	4632      	mov	r2, r6
 800d946:	4628      	mov	r0, r5
 800d948:	2120      	movs	r1, #32
 800d94a:	f000 fd8b 	bl	800e464 <Sensor_IO_Write>
  if (RAMData->reg.STC3115_Status == STC3115_RUNNING)
 800d94e:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
 800d952:	2b52      	cmp	r3, #82	; 0x52
 800d954:	d04b      	beq.n	800d9ee <STC3115_Task+0x266>
  return COMPONENT_OK;
 800d956:	2000      	movs	r0, #0
}
 800d958:	b004      	add	sp, #16
 800d95a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (res < 0) return(COMPONENT_ERROR); /* return if I2C error or STC3115 not responding */
 800d95e:	2001      	movs	r0, #1
}
 800d960:	b004      	add	sp, #16
 800d962:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if(RAMData->reg.STC3115_Status == STC3115_RUNNING)
 800d966:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
 800d96a:	2b52      	cmp	r3, #82	; 0x52
 800d96c:	f000 8082 	beq.w	800da74 <STC3115_Task+0x2ec>
  res = STC3115_Status(handle);
 800d970:	4628      	mov	r0, r5
 800d972:	f7ff fdd9 	bl	800d528 <STC3115_Status>
  if (res < 0) return(res);
 800d976:	2800      	cmp	r0, #0
 800d978:	46e8      	mov	r8, sp
 800d97a:	db14      	blt.n	800d9a6 <STC3115_Task+0x21e>
  if (Sensor_IO_Read(handle, RegAddress, (uint8_t*)&tmp, 2))
 800d97c:	4642      	mov	r2, r8
 800d97e:	2302      	movs	r3, #2
 800d980:	210d      	movs	r1, #13
 800d982:	4628      	mov	r0, r5
 800d984:	f000 fe5c 	bl	800e640 <Sensor_IO_Read>
 800d988:	b968      	cbnz	r0, 800d9a6 <STC3115_Task+0x21e>
  STC3115_SetParam(handle, ConfigData);  /* set STC3115 parameters  */
 800d98a:	4621      	mov	r1, r4
 800d98c:	4628      	mov	r0, r5
    *value = tmp & 0xffff;
 800d98e:	f8bd 9000 	ldrh.w	r9, [sp]
  STC3115_SetParam(handle, ConfigData);  /* set STC3115 parameters  */
 800d992:	f7ff fdeb 	bl	800d56c <STC3115_SetParam>
  if (Sensor_IO_Write(handle, RegAddress, (uint8_t*)&tmp, 2))
 800d996:	2302      	movs	r3, #2
 800d998:	4642      	mov	r2, r8
 800d99a:	210d      	movs	r1, #13
 800d99c:	4628      	mov	r0, r5
  uint16_t tmp = value & 0xffff;
 800d99e:	f8ad 9000 	strh.w	r9, [sp]
  if (Sensor_IO_Write(handle, RegAddress, (uint8_t*)&tmp, 2))
 800d9a2:	f000 fd5f 	bl	800e464 <Sensor_IO_Write>
    RAMData->reg.STC3115_Status = STC3115_INIT;
 800d9a6:	2349      	movs	r3, #73	; 0x49
 800d9a8:	f884 3065 	strb.w	r3, [r4, #101]	; 0x65
 800d9ac:	e72b      	b.n	800d806 <STC3115_Task+0x7e>
 800d9ae:	f104 015b 	add.w	r1, r4, #91	; 0x5b
 800d9b2:	f104 0c6b 	add.w	ip, r4, #107	; 0x6b
  int crc = 0; /* initial value */
 800d9b6:	2300      	movs	r3, #0
    crc ^= data[i];
 800d9b8:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 800d9bc:	2208      	movs	r2, #8
 800d9be:	4043      	eors	r3, r0
      crc <<= 1;
 800d9c0:	005b      	lsls	r3, r3, #1
      if (crc & 0x100)  crc ^= 7;
 800d9c2:	05d8      	lsls	r0, r3, #23
 800d9c4:	bf48      	it	mi
 800d9c6:	f083 0307 	eormi.w	r3, r3, #7
    for (j = 0; j < 8; j++)
 800d9ca:	3a01      	subs	r2, #1
 800d9cc:	d1f8      	bne.n	800d9c0 <STC3115_Task+0x238>
  for (i = 0; i < n; i++)
 800d9ce:	458c      	cmp	ip, r1
 800d9d0:	d1f2      	bne.n	800d9b8 <STC3115_Task+0x230>
  if ( (RAMData->reg.TstWord != RAM_TSTWORD) || (STC3115_CalcRamCRC8(RAMData->db, RAM_SIZE) != 0) )
 800d9d2:	f013 0fff 	tst.w	r3, #255	; 0xff
 800d9d6:	f43f af0e 	beq.w	800d7f6 <STC3115_Task+0x6e>
 800d9da:	e6f1      	b.n	800d7c0 <STC3115_Task+0x38>
    BatteryData->Presence = 0;
 800d9dc:	2300      	movs	r3, #0
    STC3115_Reset(handle);
 800d9de:	4628      	mov	r0, r5
    BatteryData->Presence = 0;
 800d9e0:	6523      	str	r3, [r4, #80]	; 0x50
    STC3115_Reset(handle);
 800d9e2:	f7ff feb1 	bl	800d748 <STC3115_Reset>
    return (COMPONENT_ERROR);
 800d9e6:	2001      	movs	r0, #1
}
 800d9e8:	b004      	add	sp, #16
 800d9ea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((BatteryData->status & (STC3115_GG_VM << 8)) == 0)
 800d9ee:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800d9f0:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
 800d9f4:	d044      	beq.n	800da80 <STC3115_Task+0x2f8>
      *vm_mode=VM_MODE; //return(1); // Voltage mode
 800d9f6:	2301      	movs	r3, #1
 800d9f8:	703b      	strb	r3, [r7, #0]
  return COMPONENT_OK;
 800d9fa:	2000      	movs	r0, #0
 800d9fc:	e7b0      	b.n	800d960 <STC3115_Task+0x1d8>
    if (BatteryData->ConvCounter > VCOUNT)
 800d9fe:	f1be 0f04 	cmp.w	lr, #4
 800da02:	f77f af7f 	ble.w	800d904 <STC3115_Task+0x17c>
      RAMData->reg.STC3115_Status = STC3115_RUNNING;
 800da06:	f04f 0c52 	mov.w	ip, #82	; 0x52
      BatteryData->Presence = 1;
 800da0a:	2301      	movs	r3, #1
      RAMData->reg.STC3115_Status = STC3115_RUNNING;
 800da0c:	f884 c065 	strb.w	ip, [r4, #101]	; 0x65
      BatteryData->Presence = 1;
 800da10:	6523      	str	r3, [r4, #80]	; 0x50
    if (BatteryData->Voltage < APP_CUTOFF_VOLTAGE)
 800da12:	f640 33b7 	movw	r3, #2999	; 0xbb7
 800da16:	429a      	cmp	r2, r3
 800da18:	dd35      	ble.n	800da86 <STC3115_Task+0x2fe>
    else if (BatteryData->Voltage < (APP_CUTOFF_VOLTAGE + 200))
 800da1a:	f5b2 6f48 	cmp.w	r2, #3200	; 0xc80
 800da1e:	da08      	bge.n	800da32 <STC3115_Task+0x2aa>
      BatteryData->SOC = BatteryData->SOC * (BatteryData->Voltage - APP_CUTOFF_VOLTAGE) / 200;
 800da20:	f6a2 32b8 	subw	r2, r2, #3000	; 0xbb8
 800da24:	4b34      	ldr	r3, [pc, #208]	; (800daf8 <STC3115_Task+0x370>)
 800da26:	fb00 f002 	mul.w	r0, r0, r2
 800da2a:	fba3 3000 	umull	r3, r0, r3, r0
 800da2e:	0980      	lsrs	r0, r0, #6
 800da30:	63a0      	str	r0, [r4, #56]	; 0x38
    BatteryData->ChargeValue = ConfigData->Cnom * BatteryData->SOC / MAX_SOC;
 800da32:	6963      	ldr	r3, [r4, #20]
 800da34:	4a2f      	ldr	r2, [pc, #188]	; (800daf4 <STC3115_Task+0x36c>)
 800da36:	fb03 f300 	mul.w	r3, r3, r0
 800da3a:	fb82 2c03 	smull	r2, ip, r2, r3
 800da3e:	17db      	asrs	r3, r3, #31
 800da40:	ebc3 13ac 	rsb	r3, r3, ip, asr #6
 800da44:	6563      	str	r3, [r4, #84]	; 0x54
    if ((BatteryData->status & STC3115_VMODE) == 0) /* mixed mode only*/
 800da46:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800da48:	07db      	lsls	r3, r3, #31
 800da4a:	d426      	bmi.n	800da9a <STC3115_Task+0x312>
        if(BatteryData->Current > APP_EOC_CURRENT && BatteryData->SOC > 990)
 800da4c:	290a      	cmp	r1, #10
 800da4e:	dd41      	ble.n	800dad4 <STC3115_Task+0x34c>
 800da50:	f240 32de 	movw	r2, #990	; 0x3de
 800da54:	4290      	cmp	r0, r2
 800da56:	dc31      	bgt.n	800dabc <STC3115_Task+0x334>
        BatteryData->RemTime = -1; /* means no estimated time available */
 800da58:	f04f 33ff 	mov.w	r3, #4294967295
 800da5c:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800da5e:	65a3      	str	r3, [r4, #88]	; 0x58
    if(BatteryData->SOC > 1000) BatteryData->SOC = MAX_SOC;
 800da60:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800da64:	dc12      	bgt.n	800da8c <STC3115_Task+0x304>
    if(BatteryData->SOC < 0) BatteryData->SOC = 0;
 800da66:	2800      	cmp	r0, #0
 800da68:	da1f      	bge.n	800daaa <STC3115_Task+0x322>
 800da6a:	2300      	movs	r3, #0
 800da6c:	f8d4 c034 	ldr.w	ip, [r4, #52]	; 0x34
 800da70:	63a3      	str	r3, [r4, #56]	; 0x38
 800da72:	e75f      	b.n	800d934 <STC3115_Task+0x1ac>
      STC3115_Restore(handle, ConfigData);  /* if RUNNING state, restore STC3115*/
 800da74:	4621      	mov	r1, r4
 800da76:	4628      	mov	r0, r5
 800da78:	f7ff fdf6 	bl	800d668 <STC3115_Restore>
 800da7c:	46e8      	mov	r8, sp
 800da7e:	e792      	b.n	800d9a6 <STC3115_Task+0x21e>
      *vm_mode=MIXED_MODE; //return(2); // Coulomb counter mode
 800da80:	703b      	strb	r3, [r7, #0]
  return COMPONENT_OK;
 800da82:	4618      	mov	r0, r3
 800da84:	e76c      	b.n	800d960 <STC3115_Task+0x1d8>
      BatteryData->SOC = 0;
 800da86:	2000      	movs	r0, #0
 800da88:	63a0      	str	r0, [r4, #56]	; 0x38
 800da8a:	e7d2      	b.n	800da32 <STC3115_Task+0x2aa>
    if(BatteryData->SOC > 1000) BatteryData->SOC = MAX_SOC;
 800da8c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800da90:	63a3      	str	r3, [r4, #56]	; 0x38
 800da92:	f8d4 c034 	ldr.w	ip, [r4, #52]	; 0x34
 800da96:	2364      	movs	r3, #100	; 0x64
 800da98:	e74c      	b.n	800d934 <STC3115_Task+0x1ac>
      BatteryData->Current = 0;
 800da9a:	2200      	movs	r2, #0
      BatteryData->RemTime = -1;
 800da9c:	f04f 33ff 	mov.w	r3, #4294967295
    if(BatteryData->SOC > 1000) BatteryData->SOC = MAX_SOC;
 800daa0:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
      BatteryData->Current = 0;
 800daa4:	6422      	str	r2, [r4, #64]	; 0x40
      BatteryData->RemTime = -1;
 800daa6:	65a3      	str	r3, [r4, #88]	; 0x58
    if(BatteryData->SOC > 1000) BatteryData->SOC = MAX_SOC;
 800daa8:	dcf0      	bgt.n	800da8c <STC3115_Task+0x304>
 800daaa:	4a14      	ldr	r2, [pc, #80]	; (800dafc <STC3115_Task+0x374>)
 800daac:	f8d4 c034 	ldr.w	ip, [r4, #52]	; 0x34
 800dab0:	1d43      	adds	r3, r0, #5
 800dab2:	fba2 2303 	umull	r2, r3, r2, r3
 800dab6:	f3c3 03c7 	ubfx	r3, r3, #3, #8
 800daba:	e73b      	b.n	800d934 <STC3115_Task+0x1ac>
  if (Sensor_IO_Write(handle, RegAddress, (uint8_t*)&tmp, 2))
 800dabc:	2302      	movs	r3, #2
          BatteryData->SOC = 990;
 800dabe:	63a2      	str	r2, [r4, #56]	; 0x38
  if (Sensor_IO_Write(handle, RegAddress, (uint8_t*)&tmp, 2))
 800dac0:	4619      	mov	r1, r3
  uint16_t tmp = value & 0xffff;
 800dac2:	f44f 4c46 	mov.w	ip, #50688	; 0xc600
  if (Sensor_IO_Write(handle, RegAddress, (uint8_t*)&tmp, 2))
 800dac6:	4642      	mov	r2, r8
 800dac8:	4628      	mov	r0, r5
  uint16_t tmp = value & 0xffff;
 800daca:	f8ad c000 	strh.w	ip, [sp]
  if (Sensor_IO_Write(handle, RegAddress, (uint8_t*)&tmp, 2))
 800dace:	f000 fcc9 	bl	800e464 <Sensor_IO_Write>
 800dad2:	6c21      	ldr	r1, [r4, #64]	; 0x40
      if(BatteryData->Current < 0)
 800dad4:	2900      	cmp	r1, #0
 800dad6:	dabf      	bge.n	800da58 <STC3115_Task+0x2d0>
        BatteryData->RemTime = (BatteryData->ChargeValue * CAPACITY * 6)/(-BatteryData->Current);
 800dad8:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800dada:	4b09      	ldr	r3, [pc, #36]	; (800db00 <STC3115_Task+0x378>)
 800dadc:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800dade:	fb03 f302 	mul.w	r3, r3, r2
 800dae2:	fb93 f1f1 	sdiv	r1, r3, r1
        if(BatteryData->RemTime  < 0)
 800dae6:	2900      	cmp	r1, #0
        BatteryData->RemTime = (BatteryData->ChargeValue * CAPACITY * 6)/(-BatteryData->Current);
 800dae8:	65a1      	str	r1, [r4, #88]	; 0x58
        if(BatteryData->RemTime  < 0)
 800daea:	dab9      	bge.n	800da60 <STC3115_Task+0x2d8>
          BatteryData->RemTime = -1; /* means no estimated time available */
 800daec:	f04f 33ff 	mov.w	r3, #4294967295
 800daf0:	65a3      	str	r3, [r4, #88]	; 0x58
 800daf2:	e7b5      	b.n	800da60 <STC3115_Task+0x2d8>
 800daf4:	10624dd3 	.word	0x10624dd3
 800daf8:	51eb851f 	.word	0x51eb851f
 800dafc:	cccccccd 	.word	0xcccccccd
 800db00:	fffffda8 	.word	0xfffffda8

0800db04 <STC3115_Init>:
{
 800db04:	b5f0      	push	{r4, r5, r6, r7, lr}
  int32_t OCVOffset[16] = OCV_OFFSET_TAB;
 800db06:	4e7b      	ldr	r6, [pc, #492]	; (800dcf4 <STC3115_Init+0x1f0>)
{
 800db08:	4604      	mov	r4, r0
  int32_t OCVOffset[16] = OCV_OFFSET_TAB;
 800db0a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
{
 800db0c:	b093      	sub	sp, #76	; 0x4c
  int32_t OCVOffset[16] = OCV_OFFSET_TAB;
 800db0e:	ad02      	add	r5, sp, #8
 800db10:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800db12:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800db14:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800db16:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800db18:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800db1a:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 800db1e:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  STC3115_ConfigData_TypeDef *ConfigData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->configData;
 800db22:	68a3      	ldr	r3, [r4, #8]
 800db24:	681d      	ldr	r5, [r3, #0]
  ConfigData->Vmode = VMODE;
 800db26:	2000      	movs	r0, #0
    ConfigData->Rsense = RSENSE;
 800db28:	2132      	movs	r1, #50	; 0x32
    ConfigData->VM_cnf = (CAPACITY * 200 * 50 + 24444) / 48889; // default value
 800db2a:	2314      	movs	r3, #20
  ConfigData->CC_cnf = (CAPACITY * ConfigData->Rsense * 250 + 6194) / 12389;
 800db2c:	2265      	movs	r2, #101	; 0x65
  ConfigData->Vmode = VMODE;
 800db2e:	6028      	str	r0, [r5, #0]
    ConfigData->Rsense = RSENSE;
 800db30:	61a9      	str	r1, [r5, #24]
    ConfigData->VM_cnf = (CAPACITY * 200 * 50 + 24444) / 48889; // default value
 800db32:	e9c5 2303 	strd	r2, r3, [r5, #12]
 800db36:	f105 011f 	add.w	r1, r5, #31
 800db3a:	ab02      	add	r3, sp, #8
 800db3c:	a812      	add	r0, sp, #72	; 0x48
      OCVOffset[loop] = -127;
 800db3e:	f06f 077e 	mvn.w	r7, #126	; 0x7e
      OCVOffset[loop] = 127;
 800db42:	267f      	movs	r6, #127	; 0x7f
 800db44:	e006      	b.n	800db54 <STC3115_Init+0x50>
 800db46:	601e      	str	r6, [r3, #0]
 800db48:	3304      	adds	r3, #4
 800db4a:	227f      	movs	r2, #127	; 0x7f
  for(loop = 0; loop < 16; loop++)
 800db4c:	4283      	cmp	r3, r0
    ConfigData->OCVOffset[loop] = OCVOffset[loop];
 800db4e:	f801 2f01 	strb.w	r2, [r1, #1]!
  for(loop = 0; loop < 16; loop++)
 800db52:	d00f      	beq.n	800db74 <STC3115_Init+0x70>
    if(OCVOffset[loop] > 127)
 800db54:	681a      	ldr	r2, [r3, #0]
 800db56:	2a7f      	cmp	r2, #127	; 0x7f
 800db58:	dcf5      	bgt.n	800db46 <STC3115_Init+0x42>
    if(OCVOffset[loop] < -127)
 800db5a:	f112 0f7f 	cmn.w	r2, #127	; 0x7f
      OCVOffset[loop] = -127;
 800db5e:	bfb8      	it	lt
 800db60:	601f      	strlt	r7, [r3, #0]
 800db62:	f103 0304 	add.w	r3, r3, #4
 800db66:	bfac      	ite	ge
 800db68:	b2d2      	uxtbge	r2, r2
 800db6a:	2281      	movlt	r2, #129	; 0x81
  for(loop = 0; loop < 16; loop++)
 800db6c:	4283      	cmp	r3, r0
    ConfigData->OCVOffset[loop] = OCVOffset[loop];
 800db6e:	f801 2f01 	strb.w	r2, [r1, #1]!
  for(loop = 0; loop < 16; loop++)
 800db72:	d1ef      	bne.n	800db54 <STC3115_Init+0x50>
  ConfigData->Cnom = CAPACITY;
 800db74:	2064      	movs	r0, #100	; 0x64
  ConfigData->RelaxCurrent = CAPACITY / 20;
 800db76:	2105      	movs	r1, #5
  ConfigData->Alm_SOC = ALM_SOC;
 800db78:	220a      	movs	r2, #10
  ConfigData->Alm_Vbat = ALM_VBAT;
 800db7a:	f640 3322 	movw	r3, #2850	; 0xb22
  ConfigData->Cnom = CAPACITY;
 800db7e:	6168      	str	r0, [r5, #20]
  ConfigData->RelaxCurrent = CAPACITY / 20;
 800db80:	61e9      	str	r1, [r5, #28]
  ConfigData->Alm_Vbat = ALM_VBAT;
 800db82:	e9c5 2301 	strd	r2, r3, [r5, #4]
  res = STC3115_Status(handle);
 800db86:	4620      	mov	r0, r4
 800db88:	f7ff fcce 	bl	800d528 <STC3115_Status>
  if(res < 0)
 800db8c:	2800      	cmp	r0, #0
 800db8e:	f2c0 80ad 	blt.w	800dcec <STC3115_Init+0x1e8>
  BatteryData->Presence = 1;
 800db92:	2701      	movs	r7, #1
  STC3115_ReadRamData(handle, RAMData->db);
 800db94:	f105 065c 	add.w	r6, r5, #92	; 0x5c
  if (Sensor_IO_Read(handle, STC3115_REG_RAM, RamData, RAM_SIZE))
 800db98:	4632      	mov	r2, r6
 800db9a:	2310      	movs	r3, #16
 800db9c:	2120      	movs	r1, #32
  BatteryData->Presence = 1;
 800db9e:	652f      	str	r7, [r5, #80]	; 0x50
  if (Sensor_IO_Read(handle, STC3115_REG_RAM, RamData, RAM_SIZE))
 800dba0:	4620      	mov	r0, r4
 800dba2:	f000 fd4d 	bl	800e640 <Sensor_IO_Read>
  if (Sensor_IO_Read(handle, RegAddress, data, NumByteToRead))
 800dba6:	463b      	mov	r3, r7
 800dba8:	f10d 0205 	add.w	r2, sp, #5
 800dbac:	2100      	movs	r1, #0
 800dbae:	4620      	mov	r0, r4
 800dbb0:	f000 fd46 	bl	800e640 <Sensor_IO_Read>
  res8 &= STC3115_GG_RUN;
 800dbb4:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800dbb8:	f003 0310 	and.w	r3, r3, #16
 800dbbc:	f88d 3005 	strb.w	r3, [sp, #5]
  if(res8 != 0)   /* GasGauge is running */
 800dbc0:	2b00      	cmp	r3, #0
 800dbc2:	d15d      	bne.n	800dc80 <STC3115_Init+0x17c>
  STC3115_Reset(handle);
 800dbc4:	4620      	mov	r0, r4
 800dbc6:	f7ff fdbf 	bl	800d748 <STC3115_Reset>
  STC3115_InitRamData(handle, ConfigData);
 800dbca:	68a0      	ldr	r0, [r4, #8]
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 800dbcc:	6807      	ldr	r7, [r0, #0]
    RAMData->db[index] = 0;
 800dbce:	2100      	movs	r1, #0
 800dbd0:	f107 035b 	add.w	r3, r7, #91	; 0x5b
 800dbd4:	f107 026b 	add.w	r2, r7, #107	; 0x6b
 800dbd8:	f803 1f01 	strb.w	r1, [r3, #1]!
  for (index = 0; index < RAM_SIZE; index++)
 800dbdc:	4293      	cmp	r3, r2
 800dbde:	d1fb      	bne.n	800dbd8 <STC3115_Init+0xd4>
  RAMData->reg.VM_cnf = ConfigData->VM_cnf;
 800dbe0:	e9d5 2303 	ldrd	r2, r3, [r5, #12]
  RAMData->reg.TstWord = RAM_TSTWORD; /* Fixed word to check RAM integrity */
 800dbe4:	f245 31a9 	movw	r1, #21417	; 0x53a9
 800dbe8:	f8a7 105c 	strh.w	r1, [r7, #92]	; 0x5c
  RAMData->reg.CC_cnf = ConfigData->CC_cnf;
 800dbec:	f8a7 2060 	strh.w	r2, [r7, #96]	; 0x60
  RAMData->reg.VM_cnf = ConfigData->VM_cnf;
 800dbf0:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
  STC3115_UpdateRamCRC(handle);
 800dbf4:	f7ff fd5e 	bl	800d6b4 <STC3115_UpdateRamCRC.isra.0>
  RAMData->reg.STC3115_Status = STC3115_INIT;
 800dbf8:	2349      	movs	r3, #73	; 0x49
 800dbfa:	f885 3065 	strb.w	r3, [r5, #101]	; 0x65
  STC3115_UpdateRamCRC(handle);
 800dbfe:	68a0      	ldr	r0, [r4, #8]
 800dc00:	f7ff fd58 	bl	800d6b4 <STC3115_UpdateRamCRC.isra.0>
  if (Sensor_IO_Write(handle, STC3115_REG_RAM, RamData, RAM_SIZE))
 800dc04:	4632      	mov	r2, r6
 800dc06:	2310      	movs	r3, #16
 800dc08:	2120      	movs	r1, #32
 800dc0a:	4620      	mov	r0, r4
 800dc0c:	f000 fc2a 	bl	800e464 <Sensor_IO_Write>
  STC3115_SetParam(handle, ConfigData);
 800dc10:	4629      	mov	r1, r5
 800dc12:	4620      	mov	r0, r4
 800dc14:	f7ff fcaa 	bl	800d56c <STC3115_SetParam>
  if (Sensor_IO_Read(handle, RegAddress, (uint8_t*)&tmp, 2))
 800dc18:	f10d 0206 	add.w	r2, sp, #6
 800dc1c:	2302      	movs	r3, #2
 800dc1e:	2104      	movs	r1, #4
 800dc20:	4620      	mov	r0, r4
 800dc22:	f000 fd0d 	bl	800e640 <Sensor_IO_Read>
 800dc26:	b938      	cbnz	r0, 800dc38 <STC3115_Init+0x134>
 800dc28:	e021      	b.n	800dc6e <STC3115_Init+0x16a>
      STC3115_SetParam(handle, ConfigData);
 800dc2a:	4629      	mov	r1, r5
 800dc2c:	4620      	mov	r0, r4
 800dc2e:	f7ff fc9d 	bl	800d56c <STC3115_SetParam>
      GG_Delay(200);
 800dc32:	20c8      	movs	r0, #200	; 0xc8
 800dc34:	f00d fa68 	bl	801b108 <HAL_Delay>
  if (Sensor_IO_Read(handle, RegAddress, data, NumByteToRead))
 800dc38:	2301      	movs	r3, #1
 800dc3a:	f10d 0205 	add.w	r2, sp, #5
 800dc3e:	2100      	movs	r1, #0
 800dc40:	4620      	mov	r0, r4
 800dc42:	f000 fcfd 	bl	800e640 <Sensor_IO_Read>
    res8 &= STC3115_GG_RUN;
 800dc46:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800dc4a:	f003 0310 	and.w	r3, r3, #16
 800dc4e:	f88d 3005 	strb.w	r3, [sp, #5]
    while(res8 == 0)
 800dc52:	2b00      	cmp	r3, #0
 800dc54:	d0e9      	beq.n	800dc2a <STC3115_Init+0x126>
    GG_Delay(200);
 800dc56:	20c8      	movs	r0, #200	; 0xc8
 800dc58:	f00d fa56 	bl	801b108 <HAL_Delay>
  if (Sensor_IO_Read(handle, RegAddress, (uint8_t*)&tmp, 2))
 800dc5c:	2302      	movs	r3, #2
 800dc5e:	f10d 0206 	add.w	r2, sp, #6
 800dc62:	2104      	movs	r1, #4
 800dc64:	4620      	mov	r0, r4
 800dc66:	f000 fceb 	bl	800e640 <Sensor_IO_Read>
 800dc6a:	2800      	cmp	r0, #0
 800dc6c:	d1e4      	bne.n	800dc38 <STC3115_Init+0x134>
    *value = tmp & 0xffff;
 800dc6e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
  while(vcount <= VCOUNT)
 800dc72:	2b04      	cmp	r3, #4
 800dc74:	d9e0      	bls.n	800dc38 <STC3115_Init+0x134>
  handle->isInitialized = 1;
 800dc76:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800dc78:	2000      	movs	r0, #0
  handle->isInitialized = 1;
 800dc7a:	7163      	strb	r3, [r4, #5]
}
 800dc7c:	b013      	add	sp, #76	; 0x4c
 800dc7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (Sensor_IO_Read(handle, RegAddress, data, NumByteToRead))
 800dc80:	463b      	mov	r3, r7
 800dc82:	4639      	mov	r1, r7
 800dc84:	f10d 0205 	add.w	r2, sp, #5
 800dc88:	4620      	mov	r0, r4
 800dc8a:	f000 fcd9 	bl	800e640 <Sensor_IO_Read>
    res8 &= (STC3115_BATFAIL | STC3115_PORDET);
 800dc8e:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800dc92:	f003 0318 	and.w	r3, r3, #24
 800dc96:	f88d 3005 	strb.w	r3, [sp, #5]
    if(res8 == 0)   /* no GG reset has occurred */
 800dc9a:	2b00      	cmp	r3, #0
 800dc9c:	d192      	bne.n	800dbc4 <STC3115_Init+0xc0>
      if((RAMData->reg.TstWord == RAM_TSTWORD) && (STC3115_CalcRamCRC8(RAMData->db, RAM_SIZE) == 0))  /* RAM data is consistent */
 800dc9e:	f9b5 105c 	ldrsh.w	r1, [r5, #92]	; 0x5c
 800dca2:	f245 32a9 	movw	r2, #21417	; 0x53a9
 800dca6:	4291      	cmp	r1, r2
 800dca8:	d18c      	bne.n	800dbc4 <STC3115_Init+0xc0>
 800dcaa:	f105 015b 	add.w	r1, r5, #91	; 0x5b
 800dcae:	f105 006b 	add.w	r0, r5, #107	; 0x6b
    crc ^= data[i];
 800dcb2:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 800dcb6:	4053      	eors	r3, r2
 800dcb8:	2208      	movs	r2, #8
      crc <<= 1;
 800dcba:	005b      	lsls	r3, r3, #1
      if (crc & 0x100)  crc ^= 7;
 800dcbc:	05df      	lsls	r7, r3, #23
 800dcbe:	bf48      	it	mi
 800dcc0:	f083 0307 	eormi.w	r3, r3, #7
    for (j = 0; j < 8; j++)
 800dcc4:	3a01      	subs	r2, #1
 800dcc6:	d1f8      	bne.n	800dcba <STC3115_Init+0x1b6>
  for (i = 0; i < n; i++)
 800dcc8:	4288      	cmp	r0, r1
 800dcca:	d1f2      	bne.n	800dcb2 <STC3115_Init+0x1ae>
      if((RAMData->reg.TstWord == RAM_TSTWORD) && (STC3115_CalcRamCRC8(RAMData->db, RAM_SIZE) == 0))  /* RAM data is consistent */
 800dccc:	f013 0fff 	tst.w	r3, #255	; 0xff
 800dcd0:	f47f af78 	bne.w	800dbc4 <STC3115_Init+0xc0>
        if(RAMData->reg.STC3115_Status == STC3115_RUNNING)   /* last saved RAM state was for a valid measurement */
 800dcd4:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 800dcd8:	2b52      	cmp	r3, #82	; 0x52
 800dcda:	f47f af73 	bne.w	800dbc4 <STC3115_Init+0xc0>
          res = STC3115_Restore(handle, ConfigData);
 800dcde:	4629      	mov	r1, r5
 800dce0:	4620      	mov	r0, r4
 800dce2:	f7ff fcc1 	bl	800d668 <STC3115_Restore>
          if(res < 0)
 800dce6:	2800      	cmp	r0, #0
 800dce8:	f6bf af6c 	bge.w	800dbc4 <STC3115_Init+0xc0>
    return COMPONENT_ERROR;
 800dcec:	2001      	movs	r0, #1
}
 800dcee:	b013      	add	sp, #76	; 0x4c
 800dcf0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800dcf2:	bf00      	nop
 800dcf4:	08022a6c 	.word	0x08022a6c

0800dcf8 <I2C_SENSORTILE_Init>:
 * @param  None
 * @retval 0 in case of success
 * @retval 1 in case of failure
 */
static uint8_t I2C_SENSORTILE_Init( void )
{
 800dcf8:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(HAL_I2C_GetState( &I2C_SENSORTILE_Handle) == HAL_I2C_STATE_RESET )
 800dcfa:	4c2e      	ldr	r4, [pc, #184]	; (800ddb4 <I2C_SENSORTILE_Init+0xbc>)
{
 800dcfc:	b0ab      	sub	sp, #172	; 0xac
  if(HAL_I2C_GetState( &I2C_SENSORTILE_Handle) == HAL_I2C_STATE_RESET )
 800dcfe:	4620      	mov	r0, r4
 800dd00:	f003 ffba 	bl	8011c78 <HAL_I2C_GetState>
 800dd04:	b138      	cbz	r0, 800dd16 <I2C_SENSORTILE_Init+0x1e>
    /* Init the I2C */
    I2C_SENSORTILE_MspInit();
    HAL_I2C_Init( &I2C_SENSORTILE_Handle );
  }
  
  if( HAL_I2C_GetState( &I2C_SENSORTILE_Handle) == HAL_I2C_STATE_READY )
 800dd06:	482b      	ldr	r0, [pc, #172]	; (800ddb4 <I2C_SENSORTILE_Init+0xbc>)
 800dd08:	f003 ffb6 	bl	8011c78 <HAL_I2C_GetState>
  }
  else
  {
    return 1;
  }
}
 800dd0c:	3820      	subs	r0, #32
 800dd0e:	bf18      	it	ne
 800dd10:	2001      	movne	r0, #1
 800dd12:	b02b      	add	sp, #172	; 0xac
 800dd14:	bdf0      	pop	{r4, r5, r6, r7, pc}
    I2C_SENSORTILE_Handle.Init.Timing = I2C_SENSORTILE_TIMING_400KHZ;
 800dd16:	4a28      	ldr	r2, [pc, #160]	; (800ddb8 <I2C_SENSORTILE_Init+0xc0>)
  RCC_PeriphCLKInitStruct.PeriphClockSelection = SENSORTILE_I2C_ONBOARD_SENSORS_RCC_PERIPHCLK;
  RCC_PeriphCLKInitStruct.I2c3ClockSelection = SENSORTILE_I2C_ONBOARD_SENSORS_I2CCLKSOURCE;
  HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
  
  /* Enable I2C GPIO clocks */
  SENSORTILE_I2C_ONBOARD_SENSORS_SCL_SDA_GPIO_CLK_ENABLE();
 800dd18:	4d28      	ldr	r5, [pc, #160]	; (800ddbc <I2C_SENSORTILE_Init+0xc4>)
    I2C_SENSORTILE_Handle.Init.Timing = I2C_SENSORTILE_TIMING_400KHZ;
 800dd1a:	6062      	str	r2, [r4, #4]
    I2C_SENSORTILE_Handle.Instance            = SENSORTILE_I2C_ONBOARD_SENSORS;
 800dd1c:	4b28      	ldr	r3, [pc, #160]	; (800ddc0 <I2C_SENSORTILE_Init+0xc8>)
 800dd1e:	6023      	str	r3, [r4, #0]
    I2C_SENSORTILE_Handle.Init.OwnAddress1    = 0x33;
 800dd20:	2233      	movs	r2, #51	; 0x33
 800dd22:	4606      	mov	r6, r0
    I2C_SENSORTILE_Handle.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800dd24:	2701      	movs	r7, #1
    I2C_SENSORTILE_Handle.Init.OwnAddress1    = 0x33;
 800dd26:	60a2      	str	r2, [r4, #8]
  RCC_PeriphCLKInitStruct.I2c3ClockSelection = SENSORTILE_I2C_ONBOARD_SENSORS_I2CCLKSOURCE;
 800dd28:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  RCC_PeriphCLKInitStruct.PeriphClockSelection = SENSORTILE_I2C_ONBOARD_SENSORS_RCC_PERIPHCLK;
 800dd2c:	f44f 7280 	mov.w	r2, #256	; 0x100
  HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
 800dd30:	a808      	add	r0, sp, #32
  RCC_PeriphCLKInitStruct.PeriphClockSelection = SENSORTILE_I2C_ONBOARD_SENSORS_RCC_PERIPHCLK;
 800dd32:	9208      	str	r2, [sp, #32]
  RCC_PeriphCLKInitStruct.I2c3ClockSelection = SENSORTILE_I2C_ONBOARD_SENSORS_I2CCLKSOURCE;
 800dd34:	931e      	str	r3, [sp, #120]	; 0x78
    I2C_SENSORTILE_Handle.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800dd36:	60e7      	str	r7, [r4, #12]
  HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
 800dd38:	f004 fcec 	bl	8012714 <HAL_RCCEx_PeriphCLKConfig>
  SENSORTILE_I2C_ONBOARD_SENSORS_SCL_SDA_GPIO_CLK_ENABLE();
 800dd3c:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
  GPIO_InitStruct.Mode       = GPIO_MODE_AF_OD;
  GPIO_InitStruct.Speed      = GPIO_SPEED_FAST;
  GPIO_InitStruct.Pull       = GPIO_PULLUP;
  GPIO_InitStruct.Alternate  = SENSORTILE_I2C_ONBOARD_SENSORS_SCL_SDA_AF;
  
  HAL_GPIO_Init( SENSORTILE_I2C_ONBOARD_SENSORS_SCL_SDA_GPIO_PORT, &GPIO_InitStruct );
 800dd3e:	4821      	ldr	r0, [pc, #132]	; (800ddc4 <I2C_SENSORTILE_Init+0xcc>)
  SENSORTILE_I2C_ONBOARD_SENSORS_SCL_SDA_GPIO_CLK_ENABLE();
 800dd40:	f043 0304 	orr.w	r3, r3, #4
 800dd44:	64eb      	str	r3, [r5, #76]	; 0x4c
 800dd46:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
  GPIO_InitStruct.Pull       = GPIO_PULLUP;
 800dd48:	9705      	str	r7, [sp, #20]
  SENSORTILE_I2C_ONBOARD_SENSORS_SCL_SDA_GPIO_CLK_ENABLE();
 800dd4a:	f003 0304 	and.w	r3, r3, #4
 800dd4e:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pin        = SENSORTILE_I2C_ONBOARD_SENSORS_SCL_PIN | SENSORTILE_I2C_ONBOARD_SENSORS_SDA_PIN;
 800dd50:	2203      	movs	r2, #3
  GPIO_InitStruct.Mode       = GPIO_MODE_AF_OD;
 800dd52:	2312      	movs	r3, #18
  SENSORTILE_I2C_ONBOARD_SENSORS_SCL_SDA_GPIO_CLK_ENABLE();
 800dd54:	9901      	ldr	r1, [sp, #4]
  GPIO_InitStruct.Pin        = SENSORTILE_I2C_ONBOARD_SENSORS_SCL_PIN | SENSORTILE_I2C_ONBOARD_SENSORS_SDA_PIN;
 800dd56:	9203      	str	r2, [sp, #12]
  GPIO_InitStruct.Mode       = GPIO_MODE_AF_OD;
 800dd58:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Speed      = GPIO_SPEED_FAST;
 800dd5a:	2202      	movs	r2, #2
  GPIO_InitStruct.Alternate  = SENSORTILE_I2C_ONBOARD_SENSORS_SCL_SDA_AF;
 800dd5c:	2304      	movs	r3, #4
  HAL_GPIO_Init( SENSORTILE_I2C_ONBOARD_SENSORS_SCL_SDA_GPIO_PORT, &GPIO_InitStruct );
 800dd5e:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Speed      = GPIO_SPEED_FAST;
 800dd60:	9206      	str	r2, [sp, #24]
  GPIO_InitStruct.Alternate  = SENSORTILE_I2C_ONBOARD_SENSORS_SCL_SDA_AF;
 800dd62:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init( SENSORTILE_I2C_ONBOARD_SENSORS_SCL_SDA_GPIO_PORT, &GPIO_InitStruct );
 800dd64:	f003 fa3e 	bl	80111e4 <HAL_GPIO_Init>
  
  /* Enable the I2C_SENSORTILE peripheral clock */
  SENSORTILE_I2C_ONBOARD_SENSORS_CLK_ENABLE();
 800dd68:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800dd6a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800dd6e:	65ab      	str	r3, [r5, #88]	; 0x58
 800dd70:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800dd72:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800dd76:	9302      	str	r3, [sp, #8]
 800dd78:	9b02      	ldr	r3, [sp, #8]
  
  /* Force the I2C peripheral clock reset */
  SENSORTILE_I2C_ONBOARD_SENSORS_FORCE_RESET();
 800dd7a:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800dd7c:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800dd80:	63ab      	str	r3, [r5, #56]	; 0x38
  
  /* Release the I2C peripheral clock reset */
  SENSORTILE_I2C_ONBOARD_SENSORS_RELEASE_RESET();
 800dd82:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800dd84:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 800dd88:	63ab      	str	r3, [r5, #56]	; 0x38
  
  /* Enable and set I2C_SENSORTILE Interrupt to the highest priority */
  HAL_NVIC_SetPriority(SENSORTILE_I2C_ONBOARD_SENSORS_EV_IRQn, 0, 0);
 800dd8a:	4632      	mov	r2, r6
 800dd8c:	4631      	mov	r1, r6
 800dd8e:	2048      	movs	r0, #72	; 0x48
 800dd90:	f002 fbd8 	bl	8010544 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SENSORTILE_I2C_ONBOARD_SENSORS_EV_IRQn);
 800dd94:	2048      	movs	r0, #72	; 0x48
 800dd96:	f002 fc0b 	bl	80105b0 <HAL_NVIC_EnableIRQ>
  
  /* Enable and set I2C_SENSORTILE Interrupt to the highest priority */
  HAL_NVIC_SetPriority(SENSORTILE_I2C_ONBOARD_SENSORS_ER_IRQn, 0, 0);
 800dd9a:	4632      	mov	r2, r6
 800dd9c:	4631      	mov	r1, r6
 800dd9e:	2049      	movs	r0, #73	; 0x49
 800dda0:	f002 fbd0 	bl	8010544 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SENSORTILE_I2C_ONBOARD_SENSORS_ER_IRQn);
 800dda4:	2049      	movs	r0, #73	; 0x49
 800dda6:	f002 fc03 	bl	80105b0 <HAL_NVIC_EnableIRQ>
    HAL_I2C_Init( &I2C_SENSORTILE_Handle );
 800ddaa:	4620      	mov	r0, r4
 800ddac:	f003 fd2e 	bl	801180c <HAL_I2C_Init>
 800ddb0:	e7a9      	b.n	800dd06 <I2C_SENSORTILE_Init+0xe>
 800ddb2:	bf00      	nop
 800ddb4:	2000174c 	.word	0x2000174c
 800ddb8:	10801541 	.word	0x10801541
 800ddbc:	40021000 	.word	0x40021000
 800ddc0:	40005c00 	.word	0x40005c00
 800ddc4:	48000800 	.word	0x48000800

0800ddc8 <SD_IO_SPI_MspInit.constprop.4>:
/**
  * @brief  Initializes SPI MSP.
  * @param  None
  * @retval None
  */
static void SD_IO_SPI_MspInit(SPI_HandleTypeDef *hspi)
 800ddc8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
{
  GPIO_InitTypeDef  GPIO_InitStructure;  
  
  /* Enable VddIO2 for GPIOG  */
  __HAL_RCC_PWR_CLK_ENABLE();
 800ddcc:	4c3d      	ldr	r4, [pc, #244]	; (800dec4 <SD_IO_SPI_MspInit.constprop.4+0xfc>)
  GPIO_InitStructure.Pin = SENSORTILE_SD_SPI_SCK_PIN;
  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStructure.Pull  = GPIO_NOPULL;
  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
  GPIO_InitStructure.Alternate = SENSORTILE_SD_SPI_SCK_AF;
  HAL_GPIO_Init(SENSORTILE_SD_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
 800ddce:	f8df 9104 	ldr.w	r9, [pc, #260]	; 800ded4 <SD_IO_SPI_MspInit.constprop.4+0x10c>
  __HAL_RCC_PWR_CLK_ENABLE();
 800ddd2:	6da3      	ldr	r3, [r4, #88]	; 0x58

  /*** Configure the SPI peripheral ***/ 

  /*##-3- Configure the DMA ##################################################*/
  /* Configure the DMA handler for Transmission process */
  hdma_tx.Instance                 = DMA2_Channel2;
 800ddd4:	4d3c      	ldr	r5, [pc, #240]	; (800dec8 <SD_IO_SPI_MspInit.constprop.4+0x100>)
  __HAL_RCC_PWR_CLK_ENABLE();
 800ddd6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800ddda:	65a3      	str	r3, [r4, #88]	; 0x58
 800dddc:	6da3      	ldr	r3, [r4, #88]	; 0x58
static void SD_IO_SPI_MspInit(SPI_HandleTypeDef *hspi)
 800ddde:	b08a      	sub	sp, #40	; 0x28
  __HAL_RCC_PWR_CLK_ENABLE();
 800dde0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800dde4:	9300      	str	r3, [sp, #0]
 800dde6:	9b00      	ldr	r3, [sp, #0]
  HAL_PWREx_EnableVddIO2();
 800dde8:	f003 ff62 	bl	8011cb0 <HAL_PWREx_EnableVddIO2>
  SENSORTILE_SD_SPI_CLK_ENABLE();
 800ddec:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800ddee:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800ddf2:	65a3      	str	r3, [r4, #88]	; 0x58
 800ddf4:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800ddf6:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800ddfa:	9301      	str	r3, [sp, #4]
 800ddfc:	9b01      	ldr	r3, [sp, #4]
  __HAL_RCC_DMA2_CLK_ENABLE();
 800ddfe:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800de00:	f043 0302 	orr.w	r3, r3, #2
 800de04:	64a3      	str	r3, [r4, #72]	; 0x48
 800de06:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800de08:	f003 0302 	and.w	r3, r3, #2
 800de0c:	9302      	str	r3, [sp, #8]
 800de0e:	9b02      	ldr	r3, [sp, #8]
  SENSORTILE_SD_SPI_SCK_GPIO_CLK_ENABLE();
 800de10:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800de12:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800de16:	64e3      	str	r3, [r4, #76]	; 0x4c
 800de18:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800de1a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800de1e:	9303      	str	r3, [sp, #12]
 800de20:	9b03      	ldr	r3, [sp, #12]
  SENSORTILE_SD_SPI_MISO_MOSI_GPIO_CLK_ENABLE();
 800de22:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800de24:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800de28:	64e3      	str	r3, [r4, #76]	; 0x4c
 800de2a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800de2c:	f003 0340 	and.w	r3, r3, #64	; 0x40
  GPIO_InitStructure.Pull  = GPIO_NOPULL;
 800de30:	2400      	movs	r4, #0
  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
 800de32:	2602      	movs	r6, #2
  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
 800de34:	2703      	movs	r7, #3
  SENSORTILE_SD_SPI_MISO_MOSI_GPIO_CLK_ENABLE();
 800de36:	9304      	str	r3, [sp, #16]
  GPIO_InitStructure.Alternate = SENSORTILE_SD_SPI_SCK_AF;
 800de38:	f04f 0806 	mov.w	r8, #6
  HAL_GPIO_Init(SENSORTILE_SD_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
 800de3c:	4648      	mov	r0, r9
 800de3e:	a905      	add	r1, sp, #20
  GPIO_InitStructure.Pin = SENSORTILE_SD_SPI_SCK_PIN;
 800de40:	f44f 7300 	mov.w	r3, #512	; 0x200
  SENSORTILE_SD_SPI_MISO_MOSI_GPIO_CLK_ENABLE();
 800de44:	9a04      	ldr	r2, [sp, #16]
  GPIO_InitStructure.Alternate = SENSORTILE_SD_SPI_SCK_AF;
 800de46:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
 800de4a:	e9cd 3605 	strd	r3, r6, [sp, #20]
  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
 800de4e:	e9cd 4707 	strd	r4, r7, [sp, #28]
  HAL_GPIO_Init(SENSORTILE_SD_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
 800de52:	f003 f9c7 	bl	80111e4 <HAL_GPIO_Init>
  HAL_GPIO_Init(SENSORTILE_SD_SPI_MISO_MOSI_GPIO_PORT, &GPIO_InitStructure);
 800de56:	a905      	add	r1, sp, #20
 800de58:	4648      	mov	r0, r9
  GPIO_InitStructure.Pin = (SENSORTILE_SD_SPI_MOSI_PIN);
 800de5a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800de5e:	9305      	str	r3, [sp, #20]
  GPIO_InitStructure.Pull  = GPIO_PULLUP;
 800de60:	f04f 0a01 	mov.w	sl, #1
  GPIO_InitStructure.Pull  = GPIO_NOPULL;
 800de64:	e9cd 6406 	strd	r6, r4, [sp, #24]
  GPIO_InitStructure.Alternate = SENSORTILE_SD_SPI_MISO_MOSI_AF;
 800de68:	e9cd 7808 	strd	r7, r8, [sp, #32]
  HAL_GPIO_Init(SENSORTILE_SD_SPI_MISO_MOSI_GPIO_PORT, &GPIO_InitStructure);
 800de6c:	f003 f9ba 	bl	80111e4 <HAL_GPIO_Init>
  HAL_GPIO_Init(SENSORTILE_SD_SPI_MISO_MOSI_GPIO_PORT, &GPIO_InitStructure);
 800de70:	a905      	add	r1, sp, #20
 800de72:	4648      	mov	r0, r9
  GPIO_InitStructure.Pin = (SENSORTILE_SD_SPI_MISO_PIN );
 800de74:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800de78:	9305      	str	r3, [sp, #20]
  GPIO_InitStructure.Alternate = SENSORTILE_SD_SPI_MISO_MOSI_AF;
 800de7a:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
 800de7e:	9606      	str	r6, [sp, #24]
  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
 800de80:	9708      	str	r7, [sp, #32]
  GPIO_InitStructure.Pull  = GPIO_PULLUP;
 800de82:	f8cd a01c 	str.w	sl, [sp, #28]
  HAL_GPIO_Init(SENSORTILE_SD_SPI_MISO_MOSI_GPIO_PORT, &GPIO_InitStructure);
 800de86:	f003 f9ad 	bl	80111e4 <HAL_GPIO_Init>
  hdma_tx.Instance                 = DMA2_Channel2;
 800de8a:	4910      	ldr	r1, [pc, #64]	; (800decc <SD_IO_SPI_MspInit.constprop.4+0x104>)
 800de8c:	6029      	str	r1, [r5, #0]
  hdma_tx.Init.Request             = DMA_REQUEST_3;
  hdma_tx.Init.Direction           = DMA_MEMORY_TO_PERIPH;
 800de8e:	2210      	movs	r2, #16
  hdma_tx.Init.PeriphInc           = DMA_PINC_DISABLE;
  hdma_tx.Init.MemInc              = DMA_MINC_ENABLE;
 800de90:	2380      	movs	r3, #128	; 0x80
  hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
  hdma_tx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
  hdma_tx.Init.Mode                = DMA_NORMAL;
  hdma_tx.Init.Priority            = DMA_PRIORITY_LOW;
  
  HAL_DMA_Init(&hdma_tx);
 800de92:	4628      	mov	r0, r5
  hdma_tx.Init.Direction           = DMA_MEMORY_TO_PERIPH;
 800de94:	60aa      	str	r2, [r5, #8]
  hdma_tx.Init.MemInc              = DMA_MINC_ENABLE;
 800de96:	612b      	str	r3, [r5, #16]
  hdma_tx.Init.Request             = DMA_REQUEST_3;
 800de98:	606f      	str	r7, [r5, #4]
  hdma_tx.Init.PeriphInc           = DMA_PINC_DISABLE;
 800de9a:	60ec      	str	r4, [r5, #12]
  hdma_tx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
 800de9c:	e9c5 4405 	strd	r4, r4, [r5, #20]
  hdma_tx.Init.Priority            = DMA_PRIORITY_LOW;
 800dea0:	e9c5 4407 	strd	r4, r4, [r5, #28]
  HAL_DMA_Init(&hdma_tx);
 800dea4:	f002 fe20 	bl	8010ae8 <HAL_DMA_Init>
  
  /* Associate the initialized DMA handle to the the SPI handle */
  __HAL_LINKDMA(hspi, hdmatx, hdma_tx);
 800dea8:	4b09      	ldr	r3, [pc, #36]	; (800ded0 <SD_IO_SPI_MspInit.constprop.4+0x108>)
 800deaa:	62ab      	str	r3, [r5, #40]	; 0x28
  
  /*##-4- Configure the NVIC for DMA #########################################*/ 
  /* NVIC configuration for DMA transfer complete interrupt (SPI1_TX) */
  HAL_NVIC_SetPriority(DMA2_Channel2_IRQn, 2, 1);
 800deac:	4652      	mov	r2, sl
 800deae:	4631      	mov	r1, r6
 800deb0:	2039      	movs	r0, #57	; 0x39
  __HAL_LINKDMA(hspi, hdmatx, hdma_tx);
 800deb2:	655d      	str	r5, [r3, #84]	; 0x54
  HAL_NVIC_SetPriority(DMA2_Channel2_IRQn, 2, 1);
 800deb4:	f002 fb46 	bl	8010544 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Channel2_IRQn);
 800deb8:	2039      	movs	r0, #57	; 0x39
 800deba:	f002 fb79 	bl	80105b0 <HAL_NVIC_EnableIRQ>
  
//   /*##-5- Configure the NVIC for SPI #########################################*/
//  HAL_NVIC_SetPriority(SPI3_IRQn, 0, 2);
//  HAL_NVIC_EnableIRQ(SPI3_IRQn);
    
}
 800debe:	b00a      	add	sp, #40	; 0x28
 800dec0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800dec4:	40021000 	.word	0x40021000
 800dec8:	20010450 	.word	0x20010450
 800decc:	4002041c 	.word	0x4002041c
 800ded0:	200103ec 	.word	0x200103ec
 800ded4:	48001800 	.word	0x48001800

0800ded8 <SD_IO_SPI_Init>:
* @brief  Initializes SPI HAL. High baundrate
* @param  None
* @retval None
*/
static void SD_IO_SPI_Init(void)
{
 800ded8:	b570      	push	{r4, r5, r6, lr}
  
  HAL_SPI_DeInit(&SPI_SD_Handle);
 800deda:	4c14      	ldr	r4, [pc, #80]	; (800df2c <SD_IO_SPI_Init+0x54>)
 800dedc:	4620      	mov	r0, r4
 800dede:	f005 fa9d 	bl	801341c <HAL_SPI_DeInit>
  
  HAL_Delay(1);
 800dee2:	2001      	movs	r0, #1
 800dee4:	f00d f910 	bl	801b108 <HAL_Delay>
  
  if(HAL_SPI_GetState(&SPI_SD_Handle) == HAL_SPI_STATE_RESET)
 800dee8:	4620      	mov	r0, r4
 800deea:	f005 fe2d 	bl	8013b48 <HAL_SPI_GetState>
 800deee:	b100      	cbz	r0, 800def2 <SD_IO_SPI_Init+0x1a>
    SPI_SD_Handle.Init.Mode = SPI_MODE_MASTER;
    
    SD_IO_SPI_MspInit(&SPI_SD_Handle);
    HAL_SPI_Init(&SPI_SD_Handle);
  }
}
 800def0:	bd70      	pop	{r4, r5, r6, pc}
    SPI_SD_Handle.Instance = SENSORTILE_SD_SPI;
 800def2:	4b0f      	ldr	r3, [pc, #60]	; (800df30 <SD_IO_SPI_Init+0x58>)
 800def4:	6023      	str	r3, [r4, #0]
    SPI_SD_Handle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;    /* SPI baudrate is PCLK2/SPI_BaudRatePrescaler */
 800def6:	2608      	movs	r6, #8
    SPI_SD_Handle.Init.CRCPolynomial = 7;
 800def8:	2507      	movs	r5, #7
    SPI_SD_Handle.Init.DataSize = SPI_DATASIZE_8BIT;
 800defa:	f44f 61e0 	mov.w	r1, #1792	; 0x700
    SPI_SD_Handle.Init.NSS = SPI_NSS_SOFT;
 800defe:	f44f 7200 	mov.w	r2, #512	; 0x200
    SPI_SD_Handle.Init.Mode = SPI_MODE_MASTER;
 800df02:	f44f 7382 	mov.w	r3, #260	; 0x104
    SPI_SD_Handle.Init.Direction = SPI_DIRECTION_2LINES;
 800df06:	60a0      	str	r0, [r4, #8]
    SPI_SD_Handle.Init.CLKPolarity = SPI_POLARITY_LOW;//SPI_POLARITY_HIGH;
 800df08:	e9c4 0004 	strd	r0, r0, [r4, #16]
    SPI_SD_Handle.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
 800df0c:	62a0      	str	r0, [r4, #40]	; 0x28
    SPI_SD_Handle.Init.TIMode = SPI_TIMODE_DISABLED;
 800df0e:	e9c4 0008 	strd	r0, r0, [r4, #32]
    SPI_SD_Handle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;    /* SPI baudrate is PCLK2/SPI_BaudRatePrescaler */
 800df12:	61e6      	str	r6, [r4, #28]
    SPI_SD_Handle.Init.CRCPolynomial = 7;
 800df14:	62e5      	str	r5, [r4, #44]	; 0x2c
    SPI_SD_Handle.Init.DataSize = SPI_DATASIZE_8BIT;
 800df16:	60e1      	str	r1, [r4, #12]
    SPI_SD_Handle.Init.NSS = SPI_NSS_SOFT;
 800df18:	61a2      	str	r2, [r4, #24]
    SPI_SD_Handle.Init.Mode = SPI_MODE_MASTER;
 800df1a:	6063      	str	r3, [r4, #4]
    SD_IO_SPI_MspInit(&SPI_SD_Handle);
 800df1c:	f7ff ff54 	bl	800ddc8 <SD_IO_SPI_MspInit.constprop.4>
    HAL_SPI_Init(&SPI_SD_Handle);
 800df20:	4620      	mov	r0, r4
}
 800df22:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    HAL_SPI_Init(&SPI_SD_Handle);
 800df26:	f005 ba05 	b.w	8013334 <HAL_SPI_Init>
 800df2a:	bf00      	nop
 800df2c:	200103ec 	.word	0x200103ec
 800df30:	40003c00 	.word	0x40003c00

0800df34 <SD_IO_SPI_Write>:
  * @brief SPI Write a byte to device
  * @param Value: value to be written
  * @retval None
  */
static void SD_IO_SPI_Write(uint8_t Value)
{
 800df34:	b500      	push	{lr}
 800df36:	b083      	sub	sp, #12
 800df38:	a902      	add	r1, sp, #8
  HAL_StatusTypeDef status = HAL_OK;
  
  status = HAL_SPI_Transmit(&SPI_SD_Handle, (uint8_t*) &Value, 1, SpixTimeout);
 800df3a:	4b08      	ldr	r3, [pc, #32]	; (800df5c <SD_IO_SPI_Write+0x28>)
{
 800df3c:	f801 0d01 	strb.w	r0, [r1, #-1]!
  status = HAL_SPI_Transmit(&SPI_SD_Handle, (uint8_t*) &Value, 1, SpixTimeout);
 800df40:	681b      	ldr	r3, [r3, #0]
 800df42:	4807      	ldr	r0, [pc, #28]	; (800df60 <SD_IO_SPI_Write+0x2c>)
 800df44:	2201      	movs	r2, #1
 800df46:	f005 fa7f 	bl	8013448 <HAL_SPI_Transmit>

  /* Check the communication status */
  if(status != HAL_OK)
 800df4a:	b120      	cbz	r0, 800df56 <SD_IO_SPI_Write+0x22>
  * @retval None
  */
static void SD_IO_SPI_Error (void)
{
  /* De-initialize the SPI communication BUS */
  HAL_SPI_DeInit(&SPI_SD_Handle);
 800df4c:	4804      	ldr	r0, [pc, #16]	; (800df60 <SD_IO_SPI_Write+0x2c>)
 800df4e:	f005 fa65 	bl	801341c <HAL_SPI_DeInit>
  
  /* Re- Initiaize the SPI communication BUS */
  SD_IO_SPI_Init();
 800df52:	f7ff ffc1 	bl	800ded8 <SD_IO_SPI_Init>
}
 800df56:	b003      	add	sp, #12
 800df58:	f85d fb04 	ldr.w	pc, [sp], #4
 800df5c:	200003f0 	.word	0x200003f0
 800df60:	200103ec 	.word	0x200103ec

0800df64 <SD_IO_SPI_Read>:
{
 800df64:	b530      	push	{r4, r5, lr}
  status = HAL_SPI_TransmitReceive(&SPI_SD_Handle, (uint8_t*) &writevalue, (uint8_t*) &readvalue, 1, SpixTimeout);
 800df66:	4b0c      	ldr	r3, [pc, #48]	; (800df98 <SD_IO_SPI_Read+0x34>)
 800df68:	480c      	ldr	r0, [pc, #48]	; (800df9c <SD_IO_SPI_Read+0x38>)
 800df6a:	681b      	ldr	r3, [r3, #0]
{
 800df6c:	b085      	sub	sp, #20
  uint32_t readvalue = 0;
 800df6e:	2500      	movs	r5, #0
  status = HAL_SPI_TransmitReceive(&SPI_SD_Handle, (uint8_t*) &writevalue, (uint8_t*) &readvalue, 1, SpixTimeout);
 800df70:	9300      	str	r3, [sp, #0]
  uint32_t writevalue = 0xFFFFFFFF;
 800df72:	f04f 34ff 	mov.w	r4, #4294967295
  status = HAL_SPI_TransmitReceive(&SPI_SD_Handle, (uint8_t*) &writevalue, (uint8_t*) &readvalue, 1, SpixTimeout);
 800df76:	2301      	movs	r3, #1
 800df78:	aa02      	add	r2, sp, #8
 800df7a:	a903      	add	r1, sp, #12
  uint32_t writevalue = 0xFFFFFFFF;
 800df7c:	e9cd 5402 	strd	r5, r4, [sp, #8]
  status = HAL_SPI_TransmitReceive(&SPI_SD_Handle, (uint8_t*) &writevalue, (uint8_t*) &readvalue, 1, SpixTimeout);
 800df80:	f005 fb26 	bl	80135d0 <HAL_SPI_TransmitReceive>
  if(status != HAL_OK)
 800df84:	b120      	cbz	r0, 800df90 <SD_IO_SPI_Read+0x2c>
  HAL_SPI_DeInit(&SPI_SD_Handle);
 800df86:	4805      	ldr	r0, [pc, #20]	; (800df9c <SD_IO_SPI_Read+0x38>)
 800df88:	f005 fa48 	bl	801341c <HAL_SPI_DeInit>
  SD_IO_SPI_Init();
 800df8c:	f7ff ffa4 	bl	800ded8 <SD_IO_SPI_Init>
}
 800df90:	9802      	ldr	r0, [sp, #8]
 800df92:	b005      	add	sp, #20
 800df94:	bd30      	pop	{r4, r5, pc}
 800df96:	bf00      	nop
 800df98:	200003f0 	.word	0x200003f0
 800df9c:	200103ec 	.word	0x200103ec

0800dfa0 <BSP_LED_Init>:
{
 800dfa0:	b530      	push	{r4, r5, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 800dfa2:	4c1b      	ldr	r4, [pc, #108]	; (800e010 <BSP_LED_Init+0x70>)
 800dfa4:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800dfa6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800dfaa:	65a3      	str	r3, [r4, #88]	; 0x58
 800dfac:	6da3      	ldr	r3, [r4, #88]	; 0x58
{
 800dfae:	b089      	sub	sp, #36	; 0x24
  __HAL_RCC_PWR_CLK_ENABLE();
 800dfb0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
{
 800dfb4:	4605      	mov	r5, r0
  __HAL_RCC_PWR_CLK_ENABLE();
 800dfb6:	9300      	str	r3, [sp, #0]
 800dfb8:	9b00      	ldr	r3, [sp, #0]
  HAL_PWREx_EnableVddIO2();
 800dfba:	f003 fe79 	bl	8011cb0 <HAL_PWREx_EnableVddIO2>
  LEDx_GPIO_CLK_ENABLE(Led);
 800dfbe:	b9dd      	cbnz	r5, 800dff8 <BSP_LED_Init+0x58>
 800dfc0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800dfc2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800dfc6:	64e3      	str	r3, [r4, #76]	; 0x4c
 800dfc8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800dfca:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800dfce:	9301      	str	r3, [sp, #4]
 800dfd0:	9b01      	ldr	r3, [sp, #4]
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800dfd2:	4b10      	ldr	r3, [pc, #64]	; (800e014 <BSP_LED_Init+0x74>)
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 800dfd4:	4a10      	ldr	r2, [pc, #64]	; (800e018 <BSP_LED_Init+0x78>)
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800dfd6:	eb03 0385 	add.w	r3, r3, r5, lsl #2
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 800dfda:	f852 2025 	ldr.w	r2, [r2, r5, lsl #2]
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800dfde:	6858      	ldr	r0, [r3, #4]
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 800dfe0:	9203      	str	r2, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 800dfe2:	2302      	movs	r3, #2
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800dfe4:	2200      	movs	r2, #0
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800dfe6:	2401      	movs	r4, #1
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800dfe8:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800dfea:	e9cd 4204 	strd	r4, r2, [sp, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 800dfee:	9306      	str	r3, [sp, #24]
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800dff0:	f003 f8f8 	bl	80111e4 <HAL_GPIO_Init>
}
 800dff4:	b009      	add	sp, #36	; 0x24
 800dff6:	bd30      	pop	{r4, r5, pc}
  LEDx_GPIO_CLK_ENABLE(Led);
 800dff8:	2d01      	cmp	r5, #1
 800dffa:	d1ea      	bne.n	800dfd2 <BSP_LED_Init+0x32>
 800dffc:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800dffe:	f043 0301 	orr.w	r3, r3, #1
 800e002:	64e3      	str	r3, [r4, #76]	; 0x4c
 800e004:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800e006:	f003 0301 	and.w	r3, r3, #1
 800e00a:	9302      	str	r3, [sp, #8]
 800e00c:	9b02      	ldr	r3, [sp, #8]
 800e00e:	e7e0      	b.n	800dfd2 <BSP_LED_Init+0x32>
 800e010:	40021000 	.word	0x40021000
 800e014:	200003f0 	.word	0x200003f0
 800e018:	08022aac 	.word	0x08022aac

0800e01c <BSP_LED_On>:
  if(Led == LED1)
 800e01c:	b110      	cbz	r0, 800e024 <BSP_LED_On+0x8>
  else if (Led == LEDSWD)
 800e01e:	2801      	cmp	r0, #1
 800e020:	d007      	beq.n	800e032 <BSP_LED_On+0x16>
}
 800e022:	4770      	bx	lr
    HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_SET);
 800e024:	4b06      	ldr	r3, [pc, #24]	; (800e040 <BSP_LED_On+0x24>)
 800e026:	2201      	movs	r2, #1
 800e028:	6858      	ldr	r0, [r3, #4]
 800e02a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800e02e:	f003 ba9d 	b.w	801156c <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET);
 800e032:	4b03      	ldr	r3, [pc, #12]	; (800e040 <BSP_LED_On+0x24>)
 800e034:	2200      	movs	r2, #0
 800e036:	6898      	ldr	r0, [r3, #8]
 800e038:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800e03c:	f003 ba96 	b.w	801156c <HAL_GPIO_WritePin>
 800e040:	200003f0 	.word	0x200003f0

0800e044 <BSP_LED_Off>:
  if(Led == LED1)
 800e044:	b110      	cbz	r0, 800e04c <BSP_LED_Off+0x8>
  else if (Led == LEDSWD)
 800e046:	2801      	cmp	r0, #1
 800e048:	d007      	beq.n	800e05a <BSP_LED_Off+0x16>
}
 800e04a:	4770      	bx	lr
    HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET);
 800e04c:	4b06      	ldr	r3, [pc, #24]	; (800e068 <BSP_LED_Off+0x24>)
 800e04e:	4602      	mov	r2, r0
 800e050:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800e054:	6858      	ldr	r0, [r3, #4]
 800e056:	f003 ba89 	b.w	801156c <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_SET);
 800e05a:	4b03      	ldr	r3, [pc, #12]	; (800e068 <BSP_LED_Off+0x24>)
 800e05c:	4602      	mov	r2, r0
 800e05e:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800e062:	6898      	ldr	r0, [r3, #8]
 800e064:	f003 ba82 	b.w	801156c <HAL_GPIO_WritePin>
 800e068:	200003f0 	.word	0x200003f0

0800e06c <BSP_LED_Toggle>:
  HAL_GPIO_TogglePin(GPIO_PORT[Led], GPIO_PIN[Led]);
 800e06c:	4b04      	ldr	r3, [pc, #16]	; (800e080 <BSP_LED_Toggle+0x14>)
 800e06e:	4a05      	ldr	r2, [pc, #20]	; (800e084 <BSP_LED_Toggle+0x18>)
 800e070:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800e074:	f832 1020 	ldrh.w	r1, [r2, r0, lsl #2]
 800e078:	6858      	ldr	r0, [r3, #4]
 800e07a:	f003 ba7d 	b.w	8011578 <HAL_GPIO_TogglePin>
 800e07e:	bf00      	nop
 800e080:	200003f0 	.word	0x200003f0
 800e084:	08022aac 	.word	0x08022aac

0800e088 <Sensor_IO_I2C_Init>:
{
 800e088:	b508      	push	{r3, lr}
  if ( I2C_SENSORTILE_Init() )
 800e08a:	f7ff fe35 	bl	800dcf8 <I2C_SENSORTILE_Init>
}
 800e08e:	3000      	adds	r0, #0
 800e090:	bf18      	it	ne
 800e092:	2001      	movne	r0, #1
 800e094:	bd08      	pop	{r3, pc}
 800e096:	bf00      	nop

0800e098 <Sensor_IO_SPI_Init>:
{
 800e098:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if(HAL_SPI_GetState( &SPI_Sensor_Handle) == HAL_SPI_STATE_RESET )
 800e09c:	4c2e      	ldr	r4, [pc, #184]	; (800e158 <Sensor_IO_SPI_Init+0xc0>)
{
 800e09e:	b089      	sub	sp, #36	; 0x24
  if(HAL_SPI_GetState( &SPI_Sensor_Handle) == HAL_SPI_STATE_RESET )
 800e0a0:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 800e0a4:	f005 fd50 	bl	8013b48 <HAL_SPI_GetState>
 800e0a8:	2800      	cmp	r0, #0
 800e0aa:	d151      	bne.n	800e150 <Sensor_IO_SPI_Init+0xb8>
    SENSORTILE_SENSORS_SPI_CLK_ENABLE();
 800e0ac:	4b2b      	ldr	r3, [pc, #172]	; (800e15c <Sensor_IO_SPI_Init+0xc4>)
    SPI_Sensor_Handle.Instance = SENSORTILE_SENSORS_SPI;
 800e0ae:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 800e164 <Sensor_IO_SPI_Init+0xcc>
    SENSORTILE_SENSORS_SPI_CLK_ENABLE();
 800e0b2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800e0b4:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800e0b8:	659a      	str	r2, [r3, #88]	; 0x58
 800e0ba:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800e0bc:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 800e0c0:	9201      	str	r2, [sp, #4]
 800e0c2:	9a01      	ldr	r2, [sp, #4]
    SENSORTILE_SENSORS_SPI_GPIO_CLK_ENABLE();
 800e0c4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800e0c6:	f042 0202 	orr.w	r2, r2, #2
 800e0ca:	64da      	str	r2, [r3, #76]	; 0x4c
 800e0cc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800e0ce:	f003 0302 	and.w	r3, r3, #2
 800e0d2:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800e0d4:	2601      	movs	r6, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800e0d6:	2303      	movs	r3, #3
 800e0d8:	4605      	mov	r5, r0
    HAL_GPIO_Init(SENSORTILE_SENSORS_SPI_Port, &GPIO_InitStruct);
 800e0da:	a903      	add	r1, sp, #12
 800e0dc:	4820      	ldr	r0, [pc, #128]	; (800e160 <Sensor_IO_SPI_Init+0xc8>)
    SENSORTILE_SENSORS_SPI_GPIO_CLK_ENABLE();
 800e0de:	9a02      	ldr	r2, [sp, #8]
    GPIO_InitStruct.Pin = SENSORTILE_SENSORS_SPI_MOSI_Pin;
 800e0e0:	f44f 4800 	mov.w	r8, #32768	; 0x8000
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800e0e4:	2702      	movs	r7, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800e0e6:	e9cd 6305 	strd	r6, r3, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 800e0ea:	2305      	movs	r3, #5
 800e0ec:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800e0ee:	e9cd 8703 	strd	r8, r7, [sp, #12]
    HAL_GPIO_Init(SENSORTILE_SENSORS_SPI_Port, &GPIO_InitStruct);
 800e0f2:	f003 f877 	bl	80111e4 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = SENSORTILE_SENSORS_SPI_SCK_Pin;
 800e0f6:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    HAL_GPIO_Init(SENSORTILE_SENSORS_SPI_Port, &GPIO_InitStruct);
 800e0fa:	a903      	add	r1, sp, #12
 800e0fc:	4818      	ldr	r0, [pc, #96]	; (800e160 <Sensor_IO_SPI_Init+0xc8>)
    GPIO_InitStruct.Pin = SENSORTILE_SENSORS_SPI_SCK_Pin;
 800e0fe:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800e100:	9605      	str	r6, [sp, #20]
    HAL_GPIO_Init(SENSORTILE_SENSORS_SPI_Port, &GPIO_InitStruct);
 800e102:	f003 f86f 	bl	80111e4 <HAL_GPIO_Init>
    SPI_Sensor_Handle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16; // 5 MHz
 800e106:	2218      	movs	r2, #24
    SPI_Sensor_Handle.Init.CRCPolynomial = 7;
 800e108:	2307      	movs	r3, #7
    SPI_Sensor_Handle.Init.Mode = SPI_MODE_MASTER;
 800e10a:	f44f 7e82 	mov.w	lr, #260	; 0x104
    SPI_Sensor_Handle.Init.DataSize = SPI_DATASIZE_8BIT;
 800e10e:	f44f 6ce0 	mov.w	ip, #1792	; 0x700
    SPI_Sensor_Handle.Init.NSS = SPI_NSS_SOFT;
 800e112:	f44f 7100 	mov.w	r1, #512	; 0x200
    HAL_SPI_Init(&SPI_Sensor_Handle);
 800e116:	f104 004c 	add.w	r0, r4, #76	; 0x4c
    SPI_Sensor_Handle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16; // 5 MHz
 800e11a:	e9c4 1219 	strd	r1, r2, [r4, #100]	; 0x64
    SPI_Sensor_Handle.Init.CRCPolynomial = 7;
 800e11e:	67a3      	str	r3, [r4, #120]	; 0x78
    SPI_Sensor_Handle.Init.Direction = SPI_DIRECTION_1LINE;
 800e120:	f8c4 8054 	str.w	r8, [r4, #84]	; 0x54
    SPI_Sensor_Handle.Init.CLKPolarity = SPI_POLARITY_HIGH;
 800e124:	65e7      	str	r7, [r4, #92]	; 0x5c
    SPI_Sensor_Handle.Init.CLKPhase = SPI_PHASE_2EDGE;
 800e126:	6626      	str	r6, [r4, #96]	; 0x60
    SPI_Sensor_Handle.Init.TIMode = SPI_TIMODE_DISABLED;
 800e128:	e9c4 551b 	strd	r5, r5, [r4, #108]	; 0x6c
    SPI_Sensor_Handle.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
 800e12c:	6765      	str	r5, [r4, #116]	; 0x74
    SPI_Sensor_Handle.Init.NSSPMode = SPI_NSS_PULSE_DISABLED;
 800e12e:	e9c4 551f 	strd	r5, r5, [r4, #124]	; 0x7c
    SPI_Sensor_Handle.Init.Mode = SPI_MODE_MASTER;
 800e132:	e9c4 9e13 	strd	r9, lr, [r4, #76]	; 0x4c
    SPI_Sensor_Handle.Init.DataSize = SPI_DATASIZE_8BIT;
 800e136:	f8c4 c058 	str.w	ip, [r4, #88]	; 0x58
    HAL_SPI_Init(&SPI_Sensor_Handle);
 800e13a:	f005 f8fb 	bl	8013334 <HAL_SPI_Init>
    SPI_1LINE_TX(&SPI_Sensor_Handle);
 800e13e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800e140:	681a      	ldr	r2, [r3, #0]
 800e142:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800e146:	601a      	str	r2, [r3, #0]
    __HAL_SPI_ENABLE(&SPI_Sensor_Handle);
 800e148:	681a      	ldr	r2, [r3, #0]
 800e14a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800e14e:	601a      	str	r2, [r3, #0]
}
 800e150:	2000      	movs	r0, #0
 800e152:	b009      	add	sp, #36	; 0x24
 800e154:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800e158:	2000174c 	.word	0x2000174c
 800e15c:	40021000 	.word	0x40021000
 800e160:	48000400 	.word	0x48000400
 800e164:	40003800 	.word	0x40003800

0800e168 <Sensor_IO_SPI_CS_Init_All>:
{
 800e168:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  HAL_GPIO_WritePin(SENSORTILE_LSM6DSM_SPI_CS_Port, SENSORTILE_LSM6DSM_SPI_CS_Pin, GPIO_PIN_SET);
 800e16c:	4e3e      	ldr	r6, [pc, #248]	; (800e268 <Sensor_IO_SPI_CS_Init_All+0x100>)
  HAL_GPIO_WritePin(SENSORTILE_LSM303AGR_X_SPI_CS_Port, SENSORTILE_LSM303AGR_X_SPI_CS_Pin, GPIO_PIN_SET);
 800e16e:	f8df 9100 	ldr.w	r9, [pc, #256]	; 800e270 <Sensor_IO_SPI_CS_Init_All+0x108>
  SENSORTILE_LSM6DSM_SPI_CS_GPIO_CLK_ENABLE();
 800e172:	4c3e      	ldr	r4, [pc, #248]	; (800e26c <Sensor_IO_SPI_CS_Init_All+0x104>)
{
 800e174:	b08a      	sub	sp, #40	; 0x28
  HAL_GPIO_WritePin(SENSORTILE_LSM6DSM_SPI_CS_Port, SENSORTILE_LSM6DSM_SPI_CS_Pin, GPIO_PIN_SET);
 800e176:	4630      	mov	r0, r6
 800e178:	2201      	movs	r2, #1
 800e17a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800e17e:	f003 f9f5 	bl	801156c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(SENSORTILE_LSM303AGR_X_SPI_CS_Port, SENSORTILE_LSM303AGR_X_SPI_CS_Pin, GPIO_PIN_SET);
 800e182:	4648      	mov	r0, r9
 800e184:	2201      	movs	r2, #1
 800e186:	2110      	movs	r1, #16
 800e188:	f003 f9f0 	bl	801156c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(SENSORTILE_LSM303AGR_M_SPI_CS_Port, SENSORTILE_LSM303AGR_M_SPI_CS_Pin, GPIO_PIN_SET);
 800e18c:	4630      	mov	r0, r6
 800e18e:	2201      	movs	r2, #1
 800e190:	2102      	movs	r1, #2
 800e192:	f003 f9eb 	bl	801156c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(SENSORTILE_LPS22HB_SPI_CS_Port, SENSORTILE_LPS22HB_SPI_CS_Pin, GPIO_PIN_SET);
 800e196:	2201      	movs	r2, #1
 800e198:	2108      	movs	r1, #8
 800e19a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800e19e:	f003 f9e5 	bl	801156c <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e1a2:	f04f 0800 	mov.w	r8, #0
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800e1a6:	2303      	movs	r3, #3
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e1a8:	e9cd 8307 	strd	r8, r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800e1ac:	2701      	movs	r7, #1
 800e1ae:	9706      	str	r7, [sp, #24]
  SENSORTILE_LSM6DSM_SPI_CS_GPIO_CLK_ENABLE();
 800e1b0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800e1b2:	f043 0302 	orr.w	r3, r3, #2
 800e1b6:	64e3      	str	r3, [r4, #76]	; 0x4c
  GPIO_InitStruct.Pin = SENSORTILE_LSM6DSM_SPI_CS_Pin;
 800e1b8:	ad0a      	add	r5, sp, #40	; 0x28
  SENSORTILE_LSM6DSM_SPI_CS_GPIO_CLK_ENABLE();
 800e1ba:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  GPIO_InitStruct.Pin = SENSORTILE_LSM6DSM_SPI_CS_Pin;
 800e1bc:	f44f 5a80 	mov.w	sl, #4096	; 0x1000
 800e1c0:	f845 ad14 	str.w	sl, [r5, #-20]!
  SENSORTILE_LSM6DSM_SPI_CS_GPIO_CLK_ENABLE();
 800e1c4:	f003 0302 	and.w	r3, r3, #2
 800e1c8:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(SENSORTILE_LSM6DSM_SPI_CS_Port, &GPIO_InitStruct);
 800e1ca:	4629      	mov	r1, r5
 800e1cc:	4630      	mov	r0, r6
  SENSORTILE_LSM6DSM_SPI_CS_GPIO_CLK_ENABLE();
 800e1ce:	9b01      	ldr	r3, [sp, #4]
  HAL_GPIO_Init(SENSORTILE_LSM6DSM_SPI_CS_Port, &GPIO_InitStruct);
 800e1d0:	f003 f808 	bl	80111e4 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(SENSORTILE_LSM6DSM_SPI_CS_Port, SENSORTILE_LSM6DSM_SPI_CS_Pin, GPIO_PIN_SET);
 800e1d4:	463a      	mov	r2, r7
 800e1d6:	4651      	mov	r1, sl
 800e1d8:	4630      	mov	r0, r6
 800e1da:	f003 f9c7 	bl	801156c <HAL_GPIO_WritePin>
  SENSORTILE_LSM303AGR_X_SPI_CS_GPIO_CLK_ENABLE();
 800e1de:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800e1e0:	f043 0304 	orr.w	r3, r3, #4
 800e1e4:	64e3      	str	r3, [r4, #76]	; 0x4c
 800e1e6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800e1e8:	f003 0304 	and.w	r3, r3, #4
 800e1ec:	9302      	str	r3, [sp, #8]
  HAL_GPIO_Init(SENSORTILE_LSM303AGR_X_SPI_CS_Port, &GPIO_InitStruct);
 800e1ee:	4629      	mov	r1, r5
 800e1f0:	4648      	mov	r0, r9
  GPIO_InitStruct.Pin = SENSORTILE_LSM303AGR_X_SPI_CS_Pin;
 800e1f2:	f04f 0a10 	mov.w	sl, #16
  SENSORTILE_LSM303AGR_X_SPI_CS_GPIO_CLK_ENABLE();
 800e1f6:	9b02      	ldr	r3, [sp, #8]
  GPIO_InitStruct.Pin = SENSORTILE_LSM303AGR_X_SPI_CS_Pin;
 800e1f8:	f8cd a014 	str.w	sl, [sp, #20]
  HAL_GPIO_Init(SENSORTILE_LSM303AGR_X_SPI_CS_Port, &GPIO_InitStruct);
 800e1fc:	f002 fff2 	bl	80111e4 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(SENSORTILE_LSM303AGR_X_SPI_CS_Port, SENSORTILE_LSM303AGR_X_SPI_CS_Pin, GPIO_PIN_SET);
 800e200:	463a      	mov	r2, r7
 800e202:	4651      	mov	r1, sl
 800e204:	4648      	mov	r0, r9
 800e206:	f003 f9b1 	bl	801156c <HAL_GPIO_WritePin>
  SENSORTILE_LSM303AGR_M_SPI_CS_GPIO_CLK_ENABLE();
 800e20a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800e20c:	f043 0302 	orr.w	r3, r3, #2
 800e210:	64e3      	str	r3, [r4, #76]	; 0x4c
 800e212:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800e214:	f003 0302 	and.w	r3, r3, #2
 800e218:	9303      	str	r3, [sp, #12]
  HAL_GPIO_Init(SENSORTILE_LSM303AGR_M_SPI_CS_Port, &GPIO_InitStruct);
 800e21a:	4629      	mov	r1, r5
 800e21c:	4630      	mov	r0, r6
  GPIO_InitStruct.Pin = SENSORTILE_LSM303AGR_M_SPI_CS_Pin;
 800e21e:	f04f 0902 	mov.w	r9, #2
  SENSORTILE_LSM303AGR_M_SPI_CS_GPIO_CLK_ENABLE();
 800e222:	9b03      	ldr	r3, [sp, #12]
  GPIO_InitStruct.Pin = SENSORTILE_LSM303AGR_M_SPI_CS_Pin;
 800e224:	f8cd 9014 	str.w	r9, [sp, #20]
  HAL_GPIO_Init(SENSORTILE_LSM303AGR_M_SPI_CS_Port, &GPIO_InitStruct);
 800e228:	f002 ffdc 	bl	80111e4 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(SENSORTILE_LSM303AGR_M_SPI_CS_Port, SENSORTILE_LSM303AGR_M_SPI_CS_Pin, GPIO_PIN_SET);
 800e22c:	463a      	mov	r2, r7
 800e22e:	4649      	mov	r1, r9
 800e230:	4630      	mov	r0, r6
 800e232:	f003 f99b 	bl	801156c <HAL_GPIO_WritePin>
  SENSORTILE_LPS22HB_SPI_CS_GPIO_CLK_ENABLE();
 800e236:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800e238:	433b      	orrs	r3, r7
 800e23a:	64e3      	str	r3, [r4, #76]	; 0x4c
 800e23c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800e23e:	403b      	ands	r3, r7
  HAL_GPIO_Init(SENSORTILE_LPS22HB_SPI_CS_Port, &GPIO_InitStruct);
 800e240:	4629      	mov	r1, r5
  SENSORTILE_LPS22HB_SPI_CS_GPIO_CLK_ENABLE();
 800e242:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pin = SENSORTILE_LPS22HB_SPI_CS_Pin;
 800e244:	2408      	movs	r4, #8
  HAL_GPIO_Init(SENSORTILE_LPS22HB_SPI_CS_Port, &GPIO_InitStruct);
 800e246:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  SENSORTILE_LPS22HB_SPI_CS_GPIO_CLK_ENABLE();
 800e24a:	9b04      	ldr	r3, [sp, #16]
  GPIO_InitStruct.Pin = SENSORTILE_LPS22HB_SPI_CS_Pin;
 800e24c:	9405      	str	r4, [sp, #20]
  HAL_GPIO_Init(SENSORTILE_LPS22HB_SPI_CS_Port, &GPIO_InitStruct);
 800e24e:	f002 ffc9 	bl	80111e4 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(SENSORTILE_LPS22HB_SPI_CS_Port, SENSORTILE_LPS22HB_SPI_CS_Pin, GPIO_PIN_SET);
 800e252:	463a      	mov	r2, r7
 800e254:	4621      	mov	r1, r4
 800e256:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800e25a:	f003 f987 	bl	801156c <HAL_GPIO_WritePin>
}
 800e25e:	4640      	mov	r0, r8
 800e260:	b00a      	add	sp, #40	; 0x28
 800e262:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800e266:	bf00      	nop
 800e268:	48000400 	.word	0x48000400
 800e26c:	40021000 	.word	0x40021000
 800e270:	48000800 	.word	0x48000800

0800e274 <Sensor_IO_SPI_CS_Init>:
{
 800e274:	b510      	push	{r4, lr}
 800e276:	b08a      	sub	sp, #40	; 0x28
  switch(ctx->spiDevice)
 800e278:	78c3      	ldrb	r3, [r0, #3]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e27a:	2100      	movs	r1, #0
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800e27c:	2003      	movs	r0, #3
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800e27e:	2201      	movs	r2, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e280:	e9cd 1007 	strd	r1, r0, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800e284:	9206      	str	r2, [sp, #24]
  switch(ctx->spiDevice)
 800e286:	4283      	cmp	r3, r0
 800e288:	d862      	bhi.n	800e350 <Sensor_IO_SPI_CS_Init+0xdc>
 800e28a:	e8df f003 	tbb	[pc, r3]
 800e28e:	364f      	.short	0x364f
 800e290:	021d      	.short	0x021d
    SENSORTILE_LPS22HB_SPI_CS_GPIO_CLK_ENABLE();
 800e292:	4b30      	ldr	r3, [pc, #192]	; (800e354 <Sensor_IO_SPI_CS_Init+0xe0>)
 800e294:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800e296:	f042 0201 	orr.w	r2, r2, #1
 800e29a:	64da      	str	r2, [r3, #76]	; 0x4c
 800e29c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    GPIO_InitStruct.Pin = SENSORTILE_LPS22HB_SPI_CS_Pin;
 800e29e:	ac0a      	add	r4, sp, #40	; 0x28
 800e2a0:	2108      	movs	r1, #8
    SENSORTILE_LPS22HB_SPI_CS_GPIO_CLK_ENABLE();
 800e2a2:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Pin = SENSORTILE_LPS22HB_SPI_CS_Pin;
 800e2a6:	f844 1d14 	str.w	r1, [r4, #-20]!
    SENSORTILE_LPS22HB_SPI_CS_GPIO_CLK_ENABLE();
 800e2aa:	9304      	str	r3, [sp, #16]
    HAL_GPIO_WritePin(SENSORTILE_LPS22HB_SPI_CS_Port, SENSORTILE_LPS22HB_SPI_CS_Pin, GPIO_PIN_SET);
 800e2ac:	2201      	movs	r2, #1
 800e2ae:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    SENSORTILE_LPS22HB_SPI_CS_GPIO_CLK_ENABLE();
 800e2b2:	9b04      	ldr	r3, [sp, #16]
    HAL_GPIO_WritePin(SENSORTILE_LPS22HB_SPI_CS_Port, SENSORTILE_LPS22HB_SPI_CS_Pin, GPIO_PIN_SET);
 800e2b4:	f003 f95a 	bl	801156c <HAL_GPIO_WritePin>
    HAL_GPIO_Init(SENSORTILE_LPS22HB_SPI_CS_Port, &GPIO_InitStruct);
 800e2b8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800e2bc:	4621      	mov	r1, r4
 800e2be:	f002 ff91 	bl	80111e4 <HAL_GPIO_Init>
  return COMPONENT_OK;
 800e2c2:	2000      	movs	r0, #0
}
 800e2c4:	b00a      	add	sp, #40	; 0x28
 800e2c6:	bd10      	pop	{r4, pc}
    SENSORTILE_LSM303AGR_M_SPI_CS_GPIO_CLK_ENABLE();
 800e2c8:	4b22      	ldr	r3, [pc, #136]	; (800e354 <Sensor_IO_SPI_CS_Init+0xe0>)
    HAL_GPIO_WritePin(SENSORTILE_LSM303AGR_M_SPI_CS_Port, SENSORTILE_LSM303AGR_M_SPI_CS_Pin, GPIO_PIN_SET);
 800e2ca:	4823      	ldr	r0, [pc, #140]	; (800e358 <Sensor_IO_SPI_CS_Init+0xe4>)
    SENSORTILE_LSM303AGR_M_SPI_CS_GPIO_CLK_ENABLE();
 800e2cc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800e2ce:	f042 0202 	orr.w	r2, r2, #2
 800e2d2:	64da      	str	r2, [r3, #76]	; 0x4c
 800e2d4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    GPIO_InitStruct.Pin = SENSORTILE_LSM303AGR_M_SPI_CS_Pin;
 800e2d6:	ac0a      	add	r4, sp, #40	; 0x28
    SENSORTILE_LSM303AGR_M_SPI_CS_GPIO_CLK_ENABLE();
 800e2d8:	f003 0302 	and.w	r3, r3, #2
    GPIO_InitStruct.Pin = SENSORTILE_LSM303AGR_M_SPI_CS_Pin;
 800e2dc:	2102      	movs	r1, #2
    SENSORTILE_LSM303AGR_M_SPI_CS_GPIO_CLK_ENABLE();
 800e2de:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pin = SENSORTILE_LSM303AGR_M_SPI_CS_Pin;
 800e2e0:	f844 1d14 	str.w	r1, [r4, #-20]!
    SENSORTILE_LSM303AGR_M_SPI_CS_GPIO_CLK_ENABLE();
 800e2e4:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_WritePin(SENSORTILE_LSM303AGR_M_SPI_CS_Port, SENSORTILE_LSM303AGR_M_SPI_CS_Pin, GPIO_PIN_SET);
 800e2e6:	2201      	movs	r2, #1
 800e2e8:	f003 f940 	bl	801156c <HAL_GPIO_WritePin>
    HAL_GPIO_Init(SENSORTILE_LSM303AGR_M_SPI_CS_Port, &GPIO_InitStruct);
 800e2ec:	4621      	mov	r1, r4
 800e2ee:	481a      	ldr	r0, [pc, #104]	; (800e358 <Sensor_IO_SPI_CS_Init+0xe4>)
 800e2f0:	f002 ff78 	bl	80111e4 <HAL_GPIO_Init>
  return COMPONENT_OK;
 800e2f4:	2000      	movs	r0, #0
}
 800e2f6:	b00a      	add	sp, #40	; 0x28
 800e2f8:	bd10      	pop	{r4, pc}
    SENSORTILE_LSM303AGR_X_SPI_CS_GPIO_CLK_ENABLE();
 800e2fa:	4b16      	ldr	r3, [pc, #88]	; (800e354 <Sensor_IO_SPI_CS_Init+0xe0>)
    HAL_GPIO_WritePin(SENSORTILE_LSM303AGR_X_SPI_CS_Port, SENSORTILE_LSM303AGR_X_SPI_CS_Pin, GPIO_PIN_SET);
 800e2fc:	4817      	ldr	r0, [pc, #92]	; (800e35c <Sensor_IO_SPI_CS_Init+0xe8>)
    SENSORTILE_LSM303AGR_X_SPI_CS_GPIO_CLK_ENABLE();
 800e2fe:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800e300:	f042 0204 	orr.w	r2, r2, #4
 800e304:	64da      	str	r2, [r3, #76]	; 0x4c
 800e306:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    GPIO_InitStruct.Pin = SENSORTILE_LSM303AGR_X_SPI_CS_Pin;
 800e308:	ac0a      	add	r4, sp, #40	; 0x28
 800e30a:	2110      	movs	r1, #16
 800e30c:	f844 1d14 	str.w	r1, [r4, #-20]!
    SENSORTILE_LSM303AGR_X_SPI_CS_GPIO_CLK_ENABLE();
 800e310:	f003 0304 	and.w	r3, r3, #4
 800e314:	9302      	str	r3, [sp, #8]
    HAL_GPIO_WritePin(SENSORTILE_LSM303AGR_X_SPI_CS_Port, SENSORTILE_LSM303AGR_X_SPI_CS_Pin, GPIO_PIN_SET);
 800e316:	2201      	movs	r2, #1
    SENSORTILE_LSM303AGR_X_SPI_CS_GPIO_CLK_ENABLE();
 800e318:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_WritePin(SENSORTILE_LSM303AGR_X_SPI_CS_Port, SENSORTILE_LSM303AGR_X_SPI_CS_Pin, GPIO_PIN_SET);
 800e31a:	f003 f927 	bl	801156c <HAL_GPIO_WritePin>
    HAL_GPIO_Init(SENSORTILE_LSM303AGR_X_SPI_CS_Port, &GPIO_InitStruct);
 800e31e:	4621      	mov	r1, r4
 800e320:	480e      	ldr	r0, [pc, #56]	; (800e35c <Sensor_IO_SPI_CS_Init+0xe8>)
 800e322:	f002 ff5f 	bl	80111e4 <HAL_GPIO_Init>
  return COMPONENT_OK;
 800e326:	2000      	movs	r0, #0
}
 800e328:	b00a      	add	sp, #40	; 0x28
 800e32a:	bd10      	pop	{r4, pc}
    SENSORTILE_LSM6DSM_SPI_CS_GPIO_CLK_ENABLE();
 800e32c:	4b09      	ldr	r3, [pc, #36]	; (800e354 <Sensor_IO_SPI_CS_Init+0xe0>)
    HAL_GPIO_WritePin(SENSORTILE_LSM6DSM_SPI_CS_Port, SENSORTILE_LSM6DSM_SPI_CS_Pin, GPIO_PIN_SET);
 800e32e:	480a      	ldr	r0, [pc, #40]	; (800e358 <Sensor_IO_SPI_CS_Init+0xe4>)
    SENSORTILE_LSM6DSM_SPI_CS_GPIO_CLK_ENABLE();
 800e330:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800e332:	f042 0202 	orr.w	r2, r2, #2
 800e336:	64da      	str	r2, [r3, #76]	; 0x4c
 800e338:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    GPIO_InitStruct.Pin = SENSORTILE_LSM6DSM_SPI_CS_Pin;
 800e33a:	ac0a      	add	r4, sp, #40	; 0x28
    SENSORTILE_LSM6DSM_SPI_CS_GPIO_CLK_ENABLE();
 800e33c:	f003 0302 	and.w	r3, r3, #2
    GPIO_InitStruct.Pin = SENSORTILE_LSM6DSM_SPI_CS_Pin;
 800e340:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    SENSORTILE_LSM6DSM_SPI_CS_GPIO_CLK_ENABLE();
 800e344:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = SENSORTILE_LSM6DSM_SPI_CS_Pin;
 800e346:	f844 1d14 	str.w	r1, [r4, #-20]!
    HAL_GPIO_WritePin(SENSORTILE_LSM6DSM_SPI_CS_Port, SENSORTILE_LSM6DSM_SPI_CS_Pin, GPIO_PIN_SET);
 800e34a:	2201      	movs	r2, #1
    SENSORTILE_LSM6DSM_SPI_CS_GPIO_CLK_ENABLE();
 800e34c:	9b01      	ldr	r3, [sp, #4]
 800e34e:	e7cb      	b.n	800e2e8 <Sensor_IO_SPI_CS_Init+0x74>
    return COMPONENT_NOT_IMPLEMENTED;
 800e350:	2003      	movs	r0, #3
 800e352:	e7b7      	b.n	800e2c4 <Sensor_IO_SPI_CS_Init+0x50>
 800e354:	40021000 	.word	0x40021000
 800e358:	48000400 	.word	0x48000400
 800e35c:	48000800 	.word	0x48000800

0800e360 <Sensor_IO_SPI_CS_Enable>:
{
 800e360:	b508      	push	{r3, lr}
  switch(ctx->spiDevice)
 800e362:	78c3      	ldrb	r3, [r0, #3]
 800e364:	2b03      	cmp	r3, #3
 800e366:	d809      	bhi.n	800e37c <Sensor_IO_SPI_CS_Enable+0x1c>
 800e368:	e8df f003 	tbb	[pc, r3]
 800e36c:	020a1118 	.word	0x020a1118
    HAL_GPIO_WritePin(SENSORTILE_LPS22HB_SPI_CS_Port, SENSORTILE_LPS22HB_SPI_CS_Pin, GPIO_PIN_RESET);
 800e370:	2200      	movs	r2, #0
 800e372:	2108      	movs	r1, #8
 800e374:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800e378:	f003 f8f8 	bl	801156c <HAL_GPIO_WritePin>
}
 800e37c:	2000      	movs	r0, #0
 800e37e:	bd08      	pop	{r3, pc}
    HAL_GPIO_WritePin(SENSORTILE_LSM303AGR_M_SPI_CS_Port, SENSORTILE_LSM303AGR_M_SPI_CS_Pin, GPIO_PIN_RESET);
 800e380:	2200      	movs	r2, #0
 800e382:	2102      	movs	r1, #2
 800e384:	4809      	ldr	r0, [pc, #36]	; (800e3ac <Sensor_IO_SPI_CS_Enable+0x4c>)
 800e386:	f003 f8f1 	bl	801156c <HAL_GPIO_WritePin>
}
 800e38a:	2000      	movs	r0, #0
 800e38c:	bd08      	pop	{r3, pc}
    HAL_GPIO_WritePin(SENSORTILE_LSM303AGR_X_SPI_CS_Port, SENSORTILE_LSM303AGR_X_SPI_CS_Pin, GPIO_PIN_RESET);
 800e38e:	2200      	movs	r2, #0
 800e390:	2110      	movs	r1, #16
 800e392:	4807      	ldr	r0, [pc, #28]	; (800e3b0 <Sensor_IO_SPI_CS_Enable+0x50>)
 800e394:	f003 f8ea 	bl	801156c <HAL_GPIO_WritePin>
}
 800e398:	2000      	movs	r0, #0
 800e39a:	bd08      	pop	{r3, pc}
    HAL_GPIO_WritePin(SENSORTILE_LSM6DSM_SPI_CS_Port, SENSORTILE_LSM6DSM_SPI_CS_Pin, GPIO_PIN_RESET);
 800e39c:	2200      	movs	r2, #0
 800e39e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800e3a2:	4802      	ldr	r0, [pc, #8]	; (800e3ac <Sensor_IO_SPI_CS_Enable+0x4c>)
 800e3a4:	f003 f8e2 	bl	801156c <HAL_GPIO_WritePin>
}
 800e3a8:	2000      	movs	r0, #0
 800e3aa:	bd08      	pop	{r3, pc}
 800e3ac:	48000400 	.word	0x48000400
 800e3b0:	48000800 	.word	0x48000800

0800e3b4 <Sensor_IO_SPI_CS_Disable>:
{
 800e3b4:	b508      	push	{r3, lr}
  switch(ctx->spiDevice)
 800e3b6:	78c3      	ldrb	r3, [r0, #3]
 800e3b8:	2b03      	cmp	r3, #3
 800e3ba:	d809      	bhi.n	800e3d0 <Sensor_IO_SPI_CS_Disable+0x1c>
 800e3bc:	e8df f003 	tbb	[pc, r3]
 800e3c0:	020a1118 	.word	0x020a1118
    HAL_GPIO_WritePin(SENSORTILE_LPS22HB_SPI_CS_Port, SENSORTILE_LPS22HB_SPI_CS_Pin, GPIO_PIN_SET);
 800e3c4:	2201      	movs	r2, #1
 800e3c6:	2108      	movs	r1, #8
 800e3c8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800e3cc:	f003 f8ce 	bl	801156c <HAL_GPIO_WritePin>
}
 800e3d0:	2000      	movs	r0, #0
 800e3d2:	bd08      	pop	{r3, pc}
    HAL_GPIO_WritePin(SENSORTILE_LSM303AGR_M_SPI_CS_Port, SENSORTILE_LSM303AGR_M_SPI_CS_Pin, GPIO_PIN_SET);
 800e3d4:	2201      	movs	r2, #1
 800e3d6:	2102      	movs	r1, #2
 800e3d8:	4809      	ldr	r0, [pc, #36]	; (800e400 <Sensor_IO_SPI_CS_Disable+0x4c>)
 800e3da:	f003 f8c7 	bl	801156c <HAL_GPIO_WritePin>
}
 800e3de:	2000      	movs	r0, #0
 800e3e0:	bd08      	pop	{r3, pc}
    HAL_GPIO_WritePin(SENSORTILE_LSM303AGR_X_SPI_CS_Port, SENSORTILE_LSM303AGR_X_SPI_CS_Pin, GPIO_PIN_SET);
 800e3e2:	2201      	movs	r2, #1
 800e3e4:	2110      	movs	r1, #16
 800e3e6:	4807      	ldr	r0, [pc, #28]	; (800e404 <Sensor_IO_SPI_CS_Disable+0x50>)
 800e3e8:	f003 f8c0 	bl	801156c <HAL_GPIO_WritePin>
}
 800e3ec:	2000      	movs	r0, #0
 800e3ee:	bd08      	pop	{r3, pc}
    HAL_GPIO_WritePin(SENSORTILE_LSM6DSM_SPI_CS_Port, SENSORTILE_LSM6DSM_SPI_CS_Pin, GPIO_PIN_SET);
 800e3f0:	2201      	movs	r2, #1
 800e3f2:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800e3f6:	4802      	ldr	r0, [pc, #8]	; (800e400 <Sensor_IO_SPI_CS_Disable+0x4c>)
 800e3f8:	f003 f8b8 	bl	801156c <HAL_GPIO_WritePin>
}
 800e3fc:	2000      	movs	r0, #0
 800e3fe:	bd08      	pop	{r3, pc}
 800e400:	48000400 	.word	0x48000400
 800e404:	48000800 	.word	0x48000800

0800e408 <Sensor_IO_SPI_Write>:
{
 800e408:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e40a:	461d      	mov	r5, r3
 800e40c:	460c      	mov	r4, r1
 800e40e:	4616      	mov	r6, r2
 800e410:	4607      	mov	r7, r0
  Sensor_IO_SPI_CS_Enable(handle);
 800e412:	f7ff ffa5 	bl	800e360 <Sensor_IO_SPI_CS_Enable>
  while ((xSpiHandle->Instance->SR & SPI_FLAG_TXE) != SPI_FLAG_TXE);
 800e416:	4b12      	ldr	r3, [pc, #72]	; (800e460 <Sensor_IO_SPI_Write+0x58>)
 800e418:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
 800e41a:	6883      	ldr	r3, [r0, #8]
 800e41c:	0799      	lsls	r1, r3, #30
 800e41e:	d5fc      	bpl.n	800e41a <Sensor_IO_SPI_Write+0x12>
  *((__IO uint8_t*) &xSpiHandle->Instance->DR) = val;
 800e420:	7304      	strb	r4, [r0, #12]
  while ((xSpiHandle->Instance->SR & SPI_FLAG_FTLVL) != SPI_FTLVL_EMPTY);
 800e422:	6883      	ldr	r3, [r0, #8]
 800e424:	f413 5fc0 	tst.w	r3, #6144	; 0x1800
 800e428:	d1fb      	bne.n	800e422 <Sensor_IO_SPI_Write+0x1a>
  while ((xSpiHandle->Instance->SR & SPI_FLAG_BSY) == SPI_FLAG_BSY);
 800e42a:	6884      	ldr	r4, [r0, #8]
 800e42c:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 800e430:	d1fb      	bne.n	800e42a <Sensor_IO_SPI_Write+0x22>
  for(i=0;i<nBytesToWrite;i++)
 800e432:	b17d      	cbz	r5, 800e454 <Sensor_IO_SPI_Write+0x4c>
    SPI_Write(&SPI_Sensor_Handle, pBuffer[i]);
 800e434:	5d33      	ldrb	r3, [r6, r4]
  while ((xSpiHandle->Instance->SR & SPI_FLAG_TXE) != SPI_FLAG_TXE);
 800e436:	6881      	ldr	r1, [r0, #8]
 800e438:	078a      	lsls	r2, r1, #30
 800e43a:	d5fc      	bpl.n	800e436 <Sensor_IO_SPI_Write+0x2e>
  *((__IO uint8_t*) &xSpiHandle->Instance->DR) = val;
 800e43c:	7303      	strb	r3, [r0, #12]
  while ((xSpiHandle->Instance->SR & SPI_FLAG_FTLVL) != SPI_FTLVL_EMPTY);
 800e43e:	6881      	ldr	r1, [r0, #8]
 800e440:	f411 5fc0 	tst.w	r1, #6144	; 0x1800
 800e444:	d1fb      	bne.n	800e43e <Sensor_IO_SPI_Write+0x36>
  while ((xSpiHandle->Instance->SR & SPI_FLAG_BSY) == SPI_FLAG_BSY);
 800e446:	6881      	ldr	r1, [r0, #8]
 800e448:	060b      	lsls	r3, r1, #24
 800e44a:	d4fc      	bmi.n	800e446 <Sensor_IO_SPI_Write+0x3e>
  for(i=0;i<nBytesToWrite;i++)
 800e44c:	3401      	adds	r4, #1
 800e44e:	b2e4      	uxtb	r4, r4
 800e450:	42ac      	cmp	r4, r5
 800e452:	d3ef      	bcc.n	800e434 <Sensor_IO_SPI_Write+0x2c>
  Sensor_IO_SPI_CS_Disable(handle);
 800e454:	4638      	mov	r0, r7
 800e456:	f7ff ffad 	bl	800e3b4 <Sensor_IO_SPI_CS_Disable>
}
 800e45a:	2000      	movs	r0, #0
 800e45c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e45e:	bf00      	nop
 800e460:	2000174c 	.word	0x2000174c

0800e464 <Sensor_IO_Write>:
{
 800e464:	b530      	push	{r4, r5, lr}
  if(ctx->ifType == 0)
 800e466:	7844      	ldrb	r4, [r0, #1]
{
 800e468:	b085      	sub	sp, #20
 800e46a:	460d      	mov	r5, r1
  if(ctx->ifType == 0)
 800e46c:	b9ac      	cbnz	r4, 800e49a <Sensor_IO_Write+0x36>
    if ( nBytesToWrite > 1 )
 800e46e:	2b01      	cmp	r3, #1
 800e470:	d904      	bls.n	800e47c <Sensor_IO_Write+0x18>
      if (ctx->who_am_i == HTS221_WHO_AM_I_VAL)
 800e472:	7801      	ldrb	r1, [r0, #0]
 800e474:	29bc      	cmp	r1, #188	; 0xbc
        WriteAddr |= 0x80;  /* Enable I2C multi-bytes Write */
 800e476:	bf08      	it	eq
 800e478:	f045 0580 	orreq.w	r5, r5, #128	; 0x80
  status = HAL_I2C_Mem_Write( &I2C_SENSORTILE_Handle, Addr, ( uint16_t )Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size, I2C_SENSORTILE_Timeout );
 800e47c:	7881      	ldrb	r1, [r0, #2]
 800e47e:	9301      	str	r3, [sp, #4]
 800e480:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800e484:	9200      	str	r2, [sp, #0]
 800e486:	9302      	str	r3, [sp, #8]
 800e488:	462a      	mov	r2, r5
 800e48a:	2301      	movs	r3, #1
 800e48c:	4811      	ldr	r0, [pc, #68]	; (800e4d4 <Sensor_IO_Write+0x70>)
 800e48e:	f003 fa2d 	bl	80118ec <HAL_I2C_Mem_Write>
  if( status != HAL_OK )
 800e492:	b9a8      	cbnz	r0, 800e4c0 <Sensor_IO_Write+0x5c>
}
 800e494:	4620      	mov	r0, r4
 800e496:	b005      	add	sp, #20
 800e498:	bd30      	pop	{r4, r5, pc}
  if(ctx->ifType == 1)
 800e49a:	2c01      	cmp	r4, #1
 800e49c:	d003      	beq.n	800e4a6 <Sensor_IO_Write+0x42>
  return COMPONENT_ERROR;
 800e49e:	2401      	movs	r4, #1
}
 800e4a0:	4620      	mov	r0, r4
 800e4a2:	b005      	add	sp, #20
 800e4a4:	bd30      	pop	{r4, r5, pc}
    if ( nBytesToWrite > 1 ) 
 800e4a6:	2b01      	cmp	r3, #1
 800e4a8:	d904      	bls.n	800e4b4 <Sensor_IO_Write+0x50>
      switch(ctx->who_am_i)
 800e4aa:	7801      	ldrb	r1, [r0, #0]
 800e4ac:	2933      	cmp	r1, #51	; 0x33
          case LSM303AGR_ACC_WHO_AM_I: WriteAddr |= 0x40; break; 
 800e4ae:	bf08      	it	eq
 800e4b0:	f045 0540 	orreq.w	r5, r5, #64	; 0x40
   return Sensor_IO_SPI_Write( handle, WriteAddr, pBuffer, nBytesToWrite );
 800e4b4:	4629      	mov	r1, r5
}
 800e4b6:	b005      	add	sp, #20
 800e4b8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   return Sensor_IO_SPI_Write( handle, WriteAddr, pBuffer, nBytesToWrite );
 800e4bc:	f7ff bfa4 	b.w	800e408 <Sensor_IO_SPI_Write>
  HAL_I2C_DeInit( &I2C_SENSORTILE_Handle );
 800e4c0:	4804      	ldr	r0, [pc, #16]	; (800e4d4 <Sensor_IO_Write+0x70>)
 800e4c2:	f003 f9f9 	bl	80118b8 <HAL_I2C_DeInit>
  I2C_SENSORTILE_Init();
 800e4c6:	f7ff fc17 	bl	800dcf8 <I2C_SENSORTILE_Init>
    return 1;
 800e4ca:	2401      	movs	r4, #1
}
 800e4cc:	4620      	mov	r0, r4
 800e4ce:	b005      	add	sp, #20
 800e4d0:	bd30      	pop	{r4, r5, pc}
 800e4d2:	bf00      	nop
 800e4d4:	2000174c 	.word	0x2000174c

0800e4d8 <LSM6DSM_Sensor_IO_ITConfig>:
  LSM6DSM_INT2_GPIO_CLK_ENABLE();
 800e4d8:	4b12      	ldr	r3, [pc, #72]	; (800e524 <LSM6DSM_Sensor_IO_ITConfig+0x4c>)
  GPIO_InitStructureInt2.Mode = GPIO_MODE_IT_RISING;
 800e4da:	4913      	ldr	r1, [pc, #76]	; (800e528 <LSM6DSM_Sensor_IO_ITConfig+0x50>)
  LSM6DSM_INT2_GPIO_CLK_ENABLE();
 800e4dc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 800e4de:	b530      	push	{r4, r5, lr}
  LSM6DSM_INT2_GPIO_CLK_ENABLE();
 800e4e0:	f042 0201 	orr.w	r2, r2, #1
 800e4e4:	64da      	str	r2, [r3, #76]	; 0x4c
 800e4e6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
{
 800e4e8:	b087      	sub	sp, #28
  GPIO_InitStructureInt2.Pin = LSM6DSM_INT2_PIN;
 800e4ea:	2204      	movs	r2, #4
  LSM6DSM_INT2_GPIO_CLK_ENABLE();
 800e4ec:	f003 0301 	and.w	r3, r3, #1
 800e4f0:	9300      	str	r3, [sp, #0]
  GPIO_InitStructureInt2.Pull  = GPIO_NOPULL;
 800e4f2:	2400      	movs	r4, #0
  GPIO_InitStructureInt2.Speed = GPIO_SPEED_FAST;
 800e4f4:	2302      	movs	r3, #2
  GPIO_InitStructureInt2.Mode = GPIO_MODE_IT_RISING;
 800e4f6:	9102      	str	r1, [sp, #8]
  HAL_GPIO_Init(LSM6DSM_INT2_GPIO_PORT, &GPIO_InitStructureInt2);
 800e4f8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800e4fc:	eb0d 0102 	add.w	r1, sp, r2
  GPIO_InitStructureInt2.Pull  = GPIO_NOPULL;
 800e500:	e9cd 4303 	strd	r4, r3, [sp, #12]
  GPIO_InitStructureInt2.Pin = LSM6DSM_INT2_PIN;
 800e504:	9201      	str	r2, [sp, #4]
  LSM6DSM_INT2_GPIO_CLK_ENABLE();
 800e506:	9d00      	ldr	r5, [sp, #0]
  HAL_GPIO_Init(LSM6DSM_INT2_GPIO_PORT, &GPIO_InitStructureInt2);
 800e508:	f002 fe6c 	bl	80111e4 <HAL_GPIO_Init>
  HAL_NVIC_SetPriority(LSM6DSM_INT2_EXTI_IRQn, 0x08, 0x00);
 800e50c:	2108      	movs	r1, #8
 800e50e:	4608      	mov	r0, r1
 800e510:	4622      	mov	r2, r4
 800e512:	f002 f817 	bl	8010544 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(LSM6DSM_INT2_EXTI_IRQn);
 800e516:	2008      	movs	r0, #8
 800e518:	f002 f84a 	bl	80105b0 <HAL_NVIC_EnableIRQ>
}
 800e51c:	4620      	mov	r0, r4
 800e51e:	b007      	add	sp, #28
 800e520:	bd30      	pop	{r4, r5, pc}
 800e522:	bf00      	nop
 800e524:	40021000 	.word	0x40021000
 800e528:	10110000 	.word	0x10110000

0800e52c <SPI_Read>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e52c:	b672      	cpsid	i
  __HAL_SPI_ENABLE(xSpiHandle);
 800e52e:	6802      	ldr	r2, [r0, #0]
 800e530:	6813      	ldr	r3, [r2, #0]
 800e532:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800e536:	6013      	str	r3, [r2, #0]
  __asm("dsb\n");
 800e538:	f3bf 8f4f 	dsb	sy
  __asm("dsb\n");
 800e53c:	f3bf 8f4f 	dsb	sy
  __HAL_SPI_DISABLE(xSpiHandle);
 800e540:	6802      	ldr	r2, [r0, #0]
 800e542:	6813      	ldr	r3, [r2, #0]
 800e544:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800e548:	6013      	str	r3, [r2, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 800e54a:	b662      	cpsie	i
  while ((xSpiHandle->Instance->SR & SPI_FLAG_RXNE) != SPI_FLAG_RXNE);
 800e54c:	6802      	ldr	r2, [r0, #0]
 800e54e:	6893      	ldr	r3, [r2, #8]
 800e550:	07db      	lsls	r3, r3, #31
 800e552:	d5fc      	bpl.n	800e54e <SPI_Read+0x22>
  *val = *(__IO uint8_t *) &xSpiHandle->Instance->DR;
 800e554:	7b13      	ldrb	r3, [r2, #12]
 800e556:	700b      	strb	r3, [r1, #0]
  while ((xSpiHandle->Instance->SR & SPI_FLAG_BSY) == SPI_FLAG_BSY);
 800e558:	6802      	ldr	r2, [r0, #0]
 800e55a:	6893      	ldr	r3, [r2, #8]
 800e55c:	061b      	lsls	r3, r3, #24
 800e55e:	d4fc      	bmi.n	800e55a <SPI_Read+0x2e>
}
 800e560:	4770      	bx	lr
 800e562:	bf00      	nop

0800e564 <SPI_Read_nBytes>:
{
 800e564:	b410      	push	{r4}
  __ASM volatile ("cpsid i" : : : "memory");
 800e566:	b672      	cpsid	i
  __HAL_SPI_ENABLE(xSpiHandle);
 800e568:	6804      	ldr	r4, [r0, #0]
 800e56a:	6823      	ldr	r3, [r4, #0]
  while (nBytesToRead > 1U)
 800e56c:	2a01      	cmp	r2, #1
  __HAL_SPI_ENABLE(xSpiHandle);
 800e56e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800e572:	6023      	str	r3, [r4, #0]
  while (nBytesToRead > 1U)
 800e574:	d90d      	bls.n	800e592 <SPI_Read_nBytes+0x2e>
    if (xSpiHandle->Instance->SR & SPI_FLAG_RXNE)
 800e576:	6804      	ldr	r4, [r0, #0]
 800e578:	68a3      	ldr	r3, [r4, #8]
 800e57a:	07db      	lsls	r3, r3, #31
 800e57c:	d402      	bmi.n	800e584 <SPI_Read_nBytes+0x20>
 800e57e:	68a3      	ldr	r3, [r4, #8]
 800e580:	07db      	lsls	r3, r3, #31
 800e582:	d5fc      	bpl.n	800e57e <SPI_Read_nBytes+0x1a>
      nBytesToRead--;
 800e584:	3a01      	subs	r2, #1
 800e586:	b292      	uxth	r2, r2
      *val = *(__IO uint8_t *) &xSpiHandle->Instance->DR;
 800e588:	7b23      	ldrb	r3, [r4, #12]
 800e58a:	f801 3b01 	strb.w	r3, [r1], #1
  while (nBytesToRead > 1U)
 800e58e:	2a01      	cmp	r2, #1
 800e590:	d8f1      	bhi.n	800e576 <SPI_Read_nBytes+0x12>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800e592:	f3bf 8f4f 	dsb	sy
 800e596:	f3bf 8f4f 	dsb	sy
  __HAL_SPI_DISABLE(xSpiHandle);
 800e59a:	6802      	ldr	r2, [r0, #0]
 800e59c:	6813      	ldr	r3, [r2, #0]
 800e59e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800e5a2:	6013      	str	r3, [r2, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 800e5a4:	b662      	cpsie	i
  while ((xSpiHandle->Instance->SR & SPI_FLAG_RXNE) != SPI_FLAG_RXNE);
 800e5a6:	6802      	ldr	r2, [r0, #0]
 800e5a8:	6893      	ldr	r3, [r2, #8]
 800e5aa:	07dc      	lsls	r4, r3, #31
 800e5ac:	d5fc      	bpl.n	800e5a8 <SPI_Read_nBytes+0x44>
  *val = *(__IO uint8_t *) &xSpiHandle->Instance->DR;
 800e5ae:	7b13      	ldrb	r3, [r2, #12]
 800e5b0:	700b      	strb	r3, [r1, #0]
  while ((xSpiHandle->Instance->SR & SPI_FLAG_BSY) == SPI_FLAG_BSY);
 800e5b2:	6802      	ldr	r2, [r0, #0]
 800e5b4:	6893      	ldr	r3, [r2, #8]
 800e5b6:	061b      	lsls	r3, r3, #24
 800e5b8:	d4fc      	bmi.n	800e5b4 <SPI_Read_nBytes+0x50>
}
 800e5ba:	f85d 4b04 	ldr.w	r4, [sp], #4
 800e5be:	4770      	bx	lr

0800e5c0 <Sensor_IO_SPI_Read>:
{
 800e5c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  while ((xSpiHandle->Instance->SR & SPI_FLAG_TXE) != SPI_FLAG_TXE);
 800e5c4:	4d1c      	ldr	r5, [pc, #112]	; (800e638 <Sensor_IO_SPI_Read+0x78>)
{
 800e5c6:	460c      	mov	r4, r1
 800e5c8:	4617      	mov	r7, r2
 800e5ca:	4698      	mov	r8, r3
 800e5cc:	4606      	mov	r6, r0
  Sensor_IO_SPI_CS_Enable(handle);
 800e5ce:	f7ff fec7 	bl	800e360 <Sensor_IO_SPI_CS_Enable>
  while ((xSpiHandle->Instance->SR & SPI_FLAG_TXE) != SPI_FLAG_TXE);
 800e5d2:	6ce8      	ldr	r0, [r5, #76]	; 0x4c
  SPI_Write(&SPI_Sensor_Handle, ReadAddr | 0x80);
 800e5d4:	f044 0180 	orr.w	r1, r4, #128	; 0x80
  while ((xSpiHandle->Instance->SR & SPI_FLAG_TXE) != SPI_FLAG_TXE);
 800e5d8:	6884      	ldr	r4, [r0, #8]
 800e5da:	07a2      	lsls	r2, r4, #30
 800e5dc:	d5fc      	bpl.n	800e5d8 <Sensor_IO_SPI_Read+0x18>
  *((__IO uint8_t*) &xSpiHandle->Instance->DR) = val;
 800e5de:	7301      	strb	r1, [r0, #12]
  while ((xSpiHandle->Instance->SR & SPI_FLAG_FTLVL) != SPI_FTLVL_EMPTY);
 800e5e0:	6884      	ldr	r4, [r0, #8]
 800e5e2:	f414 5fc0 	tst.w	r4, #6144	; 0x1800
 800e5e6:	d1fb      	bne.n	800e5e0 <Sensor_IO_SPI_Read+0x20>
  while ((xSpiHandle->Instance->SR & SPI_FLAG_BSY) == SPI_FLAG_BSY);
 800e5e8:	6884      	ldr	r4, [r0, #8]
 800e5ea:	0623      	lsls	r3, r4, #24
 800e5ec:	d4fc      	bmi.n	800e5e8 <Sensor_IO_SPI_Read+0x28>
  __HAL_SPI_DISABLE(&SPI_Sensor_Handle);
 800e5ee:	6801      	ldr	r1, [r0, #0]
 800e5f0:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 800e5f4:	6001      	str	r1, [r0, #0]
  SPI_1LINE_RX(&SPI_Sensor_Handle);
 800e5f6:	6804      	ldr	r4, [r0, #0]
  if(nBytesToRead > 1U)
 800e5f8:	f1b8 0f01 	cmp.w	r8, #1
  SPI_1LINE_RX(&SPI_Sensor_Handle);
 800e5fc:	f424 4480 	bic.w	r4, r4, #16384	; 0x4000
 800e600:	6004      	str	r4, [r0, #0]
  if(nBytesToRead > 1U)
 800e602:	d913      	bls.n	800e62c <Sensor_IO_SPI_Read+0x6c>
    SPI_Read_nBytes(&SPI_Sensor_Handle, pBuffer, nBytesToRead);
 800e604:	4642      	mov	r2, r8
 800e606:	4639      	mov	r1, r7
 800e608:	480c      	ldr	r0, [pc, #48]	; (800e63c <Sensor_IO_SPI_Read+0x7c>)
 800e60a:	f7ff ffab 	bl	800e564 <SPI_Read_nBytes>
  Sensor_IO_SPI_CS_Disable(handle);  
 800e60e:	4630      	mov	r0, r6
 800e610:	f7ff fed0 	bl	800e3b4 <Sensor_IO_SPI_CS_Disable>
  SPI_1LINE_TX(&SPI_Sensor_Handle);
 800e614:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 800e616:	681a      	ldr	r2, [r3, #0]
 800e618:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800e61c:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE(&SPI_Sensor_Handle);
 800e61e:	681a      	ldr	r2, [r3, #0]
 800e620:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800e624:	601a      	str	r2, [r3, #0]
}
 800e626:	2000      	movs	r0, #0
 800e628:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    SPI_Read(&SPI_Sensor_Handle, pBuffer);
 800e62c:	4639      	mov	r1, r7
 800e62e:	4803      	ldr	r0, [pc, #12]	; (800e63c <Sensor_IO_SPI_Read+0x7c>)
 800e630:	f7ff ff7c 	bl	800e52c <SPI_Read>
 800e634:	e7eb      	b.n	800e60e <Sensor_IO_SPI_Read+0x4e>
 800e636:	bf00      	nop
 800e638:	2000174c 	.word	0x2000174c
 800e63c:	20001798 	.word	0x20001798

0800e640 <Sensor_IO_Read>:
{
 800e640:	b530      	push	{r4, r5, lr}
  if(ctx->ifType == 0)
 800e642:	7844      	ldrb	r4, [r0, #1]
{
 800e644:	b085      	sub	sp, #20
 800e646:	460d      	mov	r5, r1
  if(ctx->ifType == 0)
 800e648:	b9ac      	cbnz	r4, 800e676 <Sensor_IO_Read+0x36>
    if ( nBytesToRead > 1 )
 800e64a:	2b01      	cmp	r3, #1
 800e64c:	d904      	bls.n	800e658 <Sensor_IO_Read+0x18>
      if (ctx->who_am_i == HTS221_WHO_AM_I_VAL)
 800e64e:	7801      	ldrb	r1, [r0, #0]
 800e650:	29bc      	cmp	r1, #188	; 0xbc
        ReadAddr |= 0x80;  /* Enable I2C multi-bytes Write */
 800e652:	bf08      	it	eq
 800e654:	f045 0580 	orreq.w	r5, r5, #128	; 0x80
  status = HAL_I2C_Mem_Read( &I2C_SENSORTILE_Handle, Addr, ( uint16_t )Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size, I2C_SENSORTILE_Timeout );
 800e658:	7881      	ldrb	r1, [r0, #2]
 800e65a:	9301      	str	r3, [sp, #4]
 800e65c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800e660:	9200      	str	r2, [sp, #0]
 800e662:	9302      	str	r3, [sp, #8]
 800e664:	462a      	mov	r2, r5
 800e666:	2301      	movs	r3, #1
 800e668:	4811      	ldr	r0, [pc, #68]	; (800e6b0 <Sensor_IO_Read+0x70>)
 800e66a:	f003 fa1f 	bl	8011aac <HAL_I2C_Mem_Read>
  if( status != HAL_OK )
 800e66e:	b9a8      	cbnz	r0, 800e69c <Sensor_IO_Read+0x5c>
}
 800e670:	4620      	mov	r0, r4
 800e672:	b005      	add	sp, #20
 800e674:	bd30      	pop	{r4, r5, pc}
  if(ctx->ifType == 1 )
 800e676:	2c01      	cmp	r4, #1
 800e678:	d003      	beq.n	800e682 <Sensor_IO_Read+0x42>
  return COMPONENT_ERROR;
 800e67a:	2401      	movs	r4, #1
}
 800e67c:	4620      	mov	r0, r4
 800e67e:	b005      	add	sp, #20
 800e680:	bd30      	pop	{r4, r5, pc}
    if ( nBytesToRead > 1 ) {
 800e682:	2b01      	cmp	r3, #1
 800e684:	d904      	bls.n	800e690 <Sensor_IO_Read+0x50>
      switch(ctx->who_am_i)
 800e686:	7801      	ldrb	r1, [r0, #0]
 800e688:	2933      	cmp	r1, #51	; 0x33
          case LSM303AGR_ACC_WHO_AM_I: ReadAddr |= 0x40; break;
 800e68a:	bf08      	it	eq
 800e68c:	f045 0540 	orreq.w	r5, r5, #64	; 0x40
   return Sensor_IO_SPI_Read( handle, ReadAddr, pBuffer, nBytesToRead );
 800e690:	4629      	mov	r1, r5
}
 800e692:	b005      	add	sp, #20
 800e694:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   return Sensor_IO_SPI_Read( handle, ReadAddr, pBuffer, nBytesToRead );
 800e698:	f7ff bf92 	b.w	800e5c0 <Sensor_IO_SPI_Read>
  HAL_I2C_DeInit( &I2C_SENSORTILE_Handle );
 800e69c:	4804      	ldr	r0, [pc, #16]	; (800e6b0 <Sensor_IO_Read+0x70>)
 800e69e:	f003 f90b 	bl	80118b8 <HAL_I2C_DeInit>
  I2C_SENSORTILE_Init();
 800e6a2:	f7ff fb29 	bl	800dcf8 <I2C_SENSORTILE_Init>
    return 1;
 800e6a6:	2401      	movs	r4, #1
}
 800e6a8:	4620      	mov	r0, r4
 800e6aa:	b005      	add	sp, #20
 800e6ac:	bd30      	pop	{r4, r5, pc}
 800e6ae:	bf00      	nop
 800e6b0:	2000174c 	.word	0x2000174c

0800e6b4 <SD_IO_CS_Init>:
void SD_IO_CS_Init(void)
{
  GPIO_InitTypeDef  GPIO_InitStructure;
  
  /* SD_CS_GPIO and SD_DETECT_GPIO Periph clock enable */
  SENSORTILE_SD_CS_GPIO_CLK_ENABLE();
 800e6b4:	4b0c      	ldr	r3, [pc, #48]	; (800e6e8 <SD_IO_CS_Init+0x34>)
  /* Configure SD_CS_PIN pin: SD Card CS pin */
  GPIO_InitStructure.Pin = SENSORTILE_SD_CS_PIN;
  GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStructure.Pull = GPIO_PULLUP;
  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(SENSORTILE_SD_CS_GPIO_PORT, &GPIO_InitStructure);
 800e6b6:	480d      	ldr	r0, [pc, #52]	; (800e6ec <SD_IO_CS_Init+0x38>)
  SENSORTILE_SD_CS_GPIO_CLK_ENABLE();
 800e6b8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 800e6ba:	b530      	push	{r4, r5, lr}
  SENSORTILE_SD_CS_GPIO_CLK_ENABLE();
 800e6bc:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800e6c0:	64da      	str	r2, [r3, #76]	; 0x4c
 800e6c2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
{
 800e6c4:	b087      	sub	sp, #28
  SENSORTILE_SD_CS_GPIO_CLK_ENABLE();
 800e6c6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800e6ca:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
 800e6cc:	2203      	movs	r2, #3
  GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
 800e6ce:	2301      	movs	r3, #1
  GPIO_InitStructure.Pin = SENSORTILE_SD_CS_PIN;
 800e6d0:	f44f 5480 	mov.w	r4, #4096	; 0x1000
  HAL_GPIO_Init(SENSORTILE_SD_CS_GPIO_PORT, &GPIO_InitStructure);
 800e6d4:	a901      	add	r1, sp, #4
  SENSORTILE_SD_CS_GPIO_CLK_ENABLE();
 800e6d6:	9d00      	ldr	r5, [sp, #0]
  GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
 800e6d8:	e9cd 4301 	strd	r4, r3, [sp, #4]
  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
 800e6dc:	e9cd 3203 	strd	r3, r2, [sp, #12]
  HAL_GPIO_Init(SENSORTILE_SD_CS_GPIO_PORT, &GPIO_InitStructure);
 800e6e0:	f002 fd80 	bl	80111e4 <HAL_GPIO_Init>
  
  /* SD chip select high */
//  SENSORTILE_SD_CS_HIGH();
}
 800e6e4:	b007      	add	sp, #28
 800e6e6:	bd30      	pop	{r4, r5, pc}
 800e6e8:	40021000 	.word	0x40021000
 800e6ec:	48001800 	.word	0x48001800

0800e6f0 <SD_IO_Init>:
{
 800e6f0:	b510      	push	{r4, lr}
  SD_IO_CS_Init();
 800e6f2:	f7ff ffdf 	bl	800e6b4 <SD_IO_CS_Init>
  SD_IO_SPI_Init();
 800e6f6:	f7ff fbef 	bl	800ded8 <SD_IO_SPI_Init>
  SENSORTILE_SD_CS_HIGH();
 800e6fa:	2201      	movs	r2, #1
 800e6fc:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800e700:	4805      	ldr	r0, [pc, #20]	; (800e718 <SD_IO_Init+0x28>)
 800e702:	f002 ff33 	bl	801156c <HAL_GPIO_WritePin>
 800e706:	240a      	movs	r4, #10
  * @retval None
  */
void SD_IO_WriteByte(uint8_t Data)
{
  /* Send the byte */
  SD_IO_SPI_Write(Data);
 800e708:	20ff      	movs	r0, #255	; 0xff
 800e70a:	f7ff fc13 	bl	800df34 <SD_IO_SPI_Write>
 800e70e:	1e63      	subs	r3, r4, #1
  for (counter = 0; counter <= 9; counter++)
 800e710:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
 800e714:	d1f8      	bne.n	800e708 <SD_IO_Init+0x18>
}
 800e716:	bd10      	pop	{r4, pc}
 800e718:	48001800 	.word	0x48001800

0800e71c <SD_IO_Init_LS>:
{ 
 800e71c:	b570      	push	{r4, r5, r6, lr}
  if(HAL_SPI_GetState(&SPI_SD_Handle) == HAL_SPI_STATE_RESET)
 800e71e:	4c18      	ldr	r4, [pc, #96]	; (800e780 <SD_IO_Init_LS+0x64>)
  SD_IO_CS_Init();
 800e720:	f7ff ffc8 	bl	800e6b4 <SD_IO_CS_Init>
  if(HAL_SPI_GetState(&SPI_SD_Handle) == HAL_SPI_STATE_RESET)
 800e724:	4620      	mov	r0, r4
 800e726:	f005 fa0f 	bl	8013b48 <HAL_SPI_GetState>
 800e72a:	b9c8      	cbnz	r0, 800e760 <SD_IO_Init_LS+0x44>
    SPI_SD_Handle.Instance = SENSORTILE_SD_SPI;
 800e72c:	4b15      	ldr	r3, [pc, #84]	; (800e784 <SD_IO_Init_LS+0x68>)
 800e72e:	6023      	str	r3, [r4, #0]
    SPI_SD_Handle.Init.DataSize = SPI_DATASIZE_8BIT;
 800e730:	f44f 61e0 	mov.w	r1, #1792	; 0x700
    SPI_SD_Handle.Init.NSS = SPI_NSS_SOFT;
 800e734:	f44f 7200 	mov.w	r2, #512	; 0x200
    SPI_SD_Handle.Init.Mode = SPI_MODE_MASTER;
 800e738:	f44f 7382 	mov.w	r3, #260	; 0x104
    SPI_SD_Handle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_128;    /* SPI baudrate is PCLK2/SPI_BaudRatePrescaler */
 800e73c:	2630      	movs	r6, #48	; 0x30
    SPI_SD_Handle.Init.CRCPolynomial = 7;
 800e73e:	2507      	movs	r5, #7
    SPI_SD_Handle.Init.Direction = SPI_DIRECTION_2LINES;
 800e740:	60a0      	str	r0, [r4, #8]
    SPI_SD_Handle.Init.CLKPolarity = SPI_POLARITY_LOW;//SPI_POLARITY_HIGH;SPI_POLARITY_HIGH;
 800e742:	e9c4 0004 	strd	r0, r0, [r4, #16]
    SPI_SD_Handle.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
 800e746:	62a0      	str	r0, [r4, #40]	; 0x28
    SPI_SD_Handle.Init.TIMode = SPI_TIMODE_DISABLED;
 800e748:	e9c4 0008 	strd	r0, r0, [r4, #32]
    SPI_SD_Handle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_128;    /* SPI baudrate is PCLK2/SPI_BaudRatePrescaler */
 800e74c:	61e6      	str	r6, [r4, #28]
    SPI_SD_Handle.Init.CRCPolynomial = 7;
 800e74e:	62e5      	str	r5, [r4, #44]	; 0x2c
    SPI_SD_Handle.Init.DataSize = SPI_DATASIZE_8BIT;
 800e750:	60e1      	str	r1, [r4, #12]
    SPI_SD_Handle.Init.NSS = SPI_NSS_SOFT;
 800e752:	61a2      	str	r2, [r4, #24]
    SPI_SD_Handle.Init.Mode = SPI_MODE_MASTER;
 800e754:	6063      	str	r3, [r4, #4]
    SD_IO_SPI_MspInit(&SPI_SD_Handle);
 800e756:	f7ff fb37 	bl	800ddc8 <SD_IO_SPI_MspInit.constprop.4>
    HAL_SPI_Init(&SPI_SD_Handle);
 800e75a:	4620      	mov	r0, r4
 800e75c:	f004 fdea 	bl	8013334 <HAL_SPI_Init>
  SENSORTILE_SD_CS_HIGH();
 800e760:	2201      	movs	r2, #1
 800e762:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800e766:	4808      	ldr	r0, [pc, #32]	; (800e788 <SD_IO_Init_LS+0x6c>)
 800e768:	f002 ff00 	bl	801156c <HAL_GPIO_WritePin>
 800e76c:	240a      	movs	r4, #10
  SD_IO_SPI_Write(Data);
 800e76e:	20ff      	movs	r0, #255	; 0xff
 800e770:	f7ff fbe0 	bl	800df34 <SD_IO_SPI_Write>
 800e774:	1e63      	subs	r3, r4, #1
  for (counter = 0; counter <= 9; counter++)
 800e776:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
 800e77a:	d1f8      	bne.n	800e76e <SD_IO_Init_LS+0x52>
}
 800e77c:	bd70      	pop	{r4, r5, r6, pc}
 800e77e:	bf00      	nop
 800e780:	200103ec 	.word	0x200103ec
 800e784:	40003c00 	.word	0x40003c00
 800e788:	48001800 	.word	0x48001800

0800e78c <SD_IO_CS_DeInit>:
{
 800e78c:	b510      	push	{r4, lr}
 800e78e:	b086      	sub	sp, #24
  GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 800e790:	2303      	movs	r3, #3
  GPIO_InitStructure.Pull = GPIO_NOPULL;
 800e792:	2200      	movs	r2, #0
  GPIO_InitStructure.Pin = SENSORTILE_SD_CS_PIN;
 800e794:	f44f 5480 	mov.w	r4, #4096	; 0x1000
  HAL_GPIO_Init(SENSORTILE_SD_CS_GPIO_PORT, &GPIO_InitStructure);
 800e798:	a901      	add	r1, sp, #4
 800e79a:	4804      	ldr	r0, [pc, #16]	; (800e7ac <SD_IO_CS_DeInit+0x20>)
  GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 800e79c:	e9cd 4301 	strd	r4, r3, [sp, #4]
  GPIO_InitStructure.Pull = GPIO_NOPULL;
 800e7a0:	e9cd 2303 	strd	r2, r3, [sp, #12]
  HAL_GPIO_Init(SENSORTILE_SD_CS_GPIO_PORT, &GPIO_InitStructure);
 800e7a4:	f002 fd1e 	bl	80111e4 <HAL_GPIO_Init>
}
 800e7a8:	b006      	add	sp, #24
 800e7aa:	bd10      	pop	{r4, pc}
 800e7ac:	48001800 	.word	0x48001800

0800e7b0 <SD_IO_WriteByte>:
  SD_IO_SPI_Write(Data);
 800e7b0:	f7ff bbc0 	b.w	800df34 <SD_IO_SPI_Write>

0800e7b4 <SD_IO_WriteDMA>:
  * @brief  Writes a block by DMA on the SD.
  * @param  Data: byte to send.
  * @retval None
  */
void SD_IO_WriteDMA(uint8_t *pData, uint16_t Size)
{
 800e7b4:	b508      	push	{r3, lr}
  
  if(HAL_SPI_Transmit_DMA(&SPI_SD_Handle, (uint8_t*)pData, Size) != HAL_OK)
 800e7b6:	460a      	mov	r2, r1
 800e7b8:	4601      	mov	r1, r0
 800e7ba:	4803      	ldr	r0, [pc, #12]	; (800e7c8 <SD_IO_WriteDMA+0x14>)
 800e7bc:	f005 f8ee 	bl	801399c <HAL_SPI_Transmit_DMA>
 800e7c0:	b100      	cbz	r0, 800e7c4 <SD_IO_WriteDMA+0x10>
 800e7c2:	e7fe      	b.n	800e7c2 <SD_IO_WriteDMA+0xe>
  {
    /* Transfer error in transmission process */
    while(1);
  }
  
}
 800e7c4:	bd08      	pop	{r3, pc}
 800e7c6:	bf00      	nop
 800e7c8:	200103ec 	.word	0x200103ec

0800e7cc <SD_IO_ReadByte>:
  * @brief  Reads a byte from the SD.
  * @param  None
  * @retval The received byte.
  */
uint8_t SD_IO_ReadByte(void)
{
 800e7cc:	b508      	push	{r3, lr}
  uint8_t data = 0;
  
  /* Get the received data */
  data = SD_IO_SPI_Read();
 800e7ce:	f7ff fbc9 	bl	800df64 <SD_IO_SPI_Read>

  /* Return the shifted data */
  return data;
}
 800e7d2:	b2c0      	uxtb	r0, r0
 800e7d4:	bd08      	pop	{r3, pc}
 800e7d6:	bf00      	nop

0800e7d8 <SD_IO_WriteCmd_wResp>:
  * @param  Crc: The CRC.
  * @param  Response: Expected response from the SD card
  * @retval  HAL_StatusTypeDef HAL Status
  */
uint8_t SD_IO_WriteCmd_wResp(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
{
 800e7d8:	b570      	push	{r4, r5, r6, lr}
 800e7da:	b082      	sub	sp, #8
  uint32_t n = 0x00, resp;
  uint8_t frame[6];

  /* Prepare Frame to send */
  frame[0] = (Cmd | 0x40); /* Construct byte 1 */
 800e7dc:	f040 0540 	orr.w	r5, r0, #64	; 0x40
  frame[1] = (uint8_t)(Arg >> 24); /* Construct byte 2 */
 800e7e0:	0e08      	lsrs	r0, r1, #24
  frame[2] = (uint8_t)(Arg >> 16); /* Construct byte 3 */
 800e7e2:	0c0c      	lsrs	r4, r1, #16
  frame[3] = (uint8_t)(Arg >> 8); /* Construct byte 4 */
 800e7e4:	0a0b      	lsrs	r3, r1, #8
  frame[4] = (uint8_t)(Arg); /* Construct byte 5 */
  frame[5] = (Crc); /* Construct CRC: byte 6 */
 800e7e6:	f88d 2005 	strb.w	r2, [sp, #5]
  frame[4] = (uint8_t)(Arg); /* Construct byte 5 */
 800e7ea:	f88d 1004 	strb.w	r1, [sp, #4]
  frame[1] = (uint8_t)(Arg >> 24); /* Construct byte 2 */
 800e7ee:	f88d 0001 	strb.w	r0, [sp, #1]
  
  /* SD chip select low */
  SENSORTILE_SD_CS_LOW();
 800e7f2:	2200      	movs	r2, #0
 800e7f4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800e7f8:	480e      	ldr	r0, [pc, #56]	; (800e834 <SD_IO_WriteCmd_wResp+0x5c>)
  frame[2] = (uint8_t)(Arg >> 16); /* Construct byte 3 */
 800e7fa:	f88d 4002 	strb.w	r4, [sp, #2]
  frame[0] = (Cmd | 0x40); /* Construct byte 1 */
 800e7fe:	f88d 5000 	strb.w	r5, [sp]
  frame[3] = (uint8_t)(Arg >> 8); /* Construct byte 4 */
 800e802:	f88d 3003 	strb.w	r3, [sp, #3]
 800e806:	466c      	mov	r4, sp
  SENSORTILE_SD_CS_LOW();
 800e808:	f002 feb0 	bl	801156c <HAL_GPIO_WritePin>
 800e80c:	f10d 0605 	add.w	r6, sp, #5
 800e810:	e001      	b.n	800e816 <SD_IO_WriteCmd_wResp+0x3e>
 800e812:	f814 5f01 	ldrb.w	r5, [r4, #1]!
  SD_IO_SPI_Write(Data);
 800e816:	4628      	mov	r0, r5
 800e818:	f7ff fb8c 	bl	800df34 <SD_IO_SPI_Write>
    
  /* Send Frame */
  for (n = 0; n < 6; n++)
 800e81c:	42b4      	cmp	r4, r6
 800e81e:	d1f8      	bne.n	800e812 <SD_IO_WriteCmd_wResp+0x3a>
 800e820:	240a      	movs	r4, #10
  data = SD_IO_SPI_Read();
 800e822:	f7ff fb9f 	bl	800df64 <SD_IO_SPI_Read>
  }

  n = 10; /* Wait for response (10 bytes max) */
  do {
    resp = SD_IO_ReadByte();
  } while ((resp & 0x80) && --n);
 800e826:	0603      	lsls	r3, r0, #24
 800e828:	d501      	bpl.n	800e82e <SD_IO_WriteCmd_wResp+0x56>
 800e82a:	3c01      	subs	r4, #1
 800e82c:	d1f9      	bne.n	800e822 <SD_IO_WriteCmd_wResp+0x4a>
  
  return resp;	/* Return received response */
}
 800e82e:	b2c0      	uxtb	r0, r0
 800e830:	b002      	add	sp, #8
 800e832:	bd70      	pop	{r4, r5, r6, pc}
 800e834:	48001800 	.word	0x48001800

0800e838 <SD_IO_WriteCmd>:
  * @param  Crc: The CRC.
  * @param  Response: Expected response from the SD card
  * @retval  HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef SD_IO_WriteCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc, uint8_t Response)
{
 800e838:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e83a:	b083      	sub	sp, #12
  uint32_t counter = 0x00;
  uint8_t frame[6];

  /* Prepare Frame to send */
  frame[0] = (Cmd | 0x40); /* Construct byte 1 */
 800e83c:	f040 0540 	orr.w	r5, r0, #64	; 0x40
  frame[1] = (uint8_t)(Arg >> 24); /* Construct byte 2 */
  frame[2] = (uint8_t)(Arg >> 16); /* Construct byte 3 */
 800e840:	0c08      	lsrs	r0, r1, #16
  frame[1] = (uint8_t)(Arg >> 24); /* Construct byte 2 */
 800e842:	0e0f      	lsrs	r7, r1, #24
  frame[3] = (uint8_t)(Arg >> 8); /* Construct byte 4 */
 800e844:	0a0c      	lsrs	r4, r1, #8
  frame[4] = (uint8_t)(Arg); /* Construct byte 5 */
  frame[5] = (Crc); /* Construct CRC: byte 6 */
 800e846:	f88d 2005 	strb.w	r2, [sp, #5]
  frame[4] = (uint8_t)(Arg); /* Construct byte 5 */
 800e84a:	f88d 1004 	strb.w	r1, [sp, #4]
  frame[2] = (uint8_t)(Arg >> 16); /* Construct byte 3 */
 800e84e:	f88d 0002 	strb.w	r0, [sp, #2]
  
  /* SD chip select low */
  SENSORTILE_SD_CS_LOW();
 800e852:	2200      	movs	r2, #0
 800e854:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800e858:	4813      	ldr	r0, [pc, #76]	; (800e8a8 <SD_IO_WriteCmd+0x70>)
  frame[1] = (uint8_t)(Arg >> 24); /* Construct byte 2 */
 800e85a:	f88d 7001 	strb.w	r7, [sp, #1]
  frame[3] = (uint8_t)(Arg >> 8); /* Construct byte 4 */
 800e85e:	f88d 4003 	strb.w	r4, [sp, #3]
  frame[0] = (Cmd | 0x40); /* Construct byte 1 */
 800e862:	f88d 5000 	strb.w	r5, [sp]
{
 800e866:	461e      	mov	r6, r3
 800e868:	466c      	mov	r4, sp
  SENSORTILE_SD_CS_LOW();
 800e86a:	f002 fe7f 	bl	801156c <HAL_GPIO_WritePin>
 800e86e:	f10d 0705 	add.w	r7, sp, #5
 800e872:	e001      	b.n	800e878 <SD_IO_WriteCmd+0x40>
 800e874:	f814 5f01 	ldrb.w	r5, [r4, #1]!
  SD_IO_SPI_Write(Data);
 800e878:	4628      	mov	r0, r5
 800e87a:	f7ff fb5b 	bl	800df34 <SD_IO_SPI_Write>
    
  /* Send Frame */
  for (counter = 0; counter < 6; counter++)
 800e87e:	42bc      	cmp	r4, r7
 800e880:	d1f8      	bne.n	800e874 <SD_IO_WriteCmd+0x3c>
  {
    SD_IO_WriteByte(frame[counter]); /* Send the Cmd bytes */
  }

  if(Response != SENSORTILE_SD_NO_RESPONSE_EXPECTED)
 800e882:	2e80      	cmp	r6, #128	; 0x80
 800e884:	d00a      	beq.n	800e89c <SD_IO_WriteCmd+0x64>
  * @param  Response: Expected response from the SD card
  * @retval  HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef SD_IO_WaitResponse(uint8_t Response)
{
  uint32_t timeout = 0xFF0;//0x400;//
 800e886:	f44f 647f 	mov.w	r4, #4080	; 0xff0
 800e88a:	e001      	b.n	800e890 <SD_IO_WriteCmd+0x58>

  /* Check if response is got or a timeout is happen */
  while ((SD_IO_ReadByte() != Response) && timeout)
 800e88c:	b14c      	cbz	r4, 800e8a2 <SD_IO_WriteCmd+0x6a>
  {
    timeout--;
 800e88e:	3c01      	subs	r4, #1
  data = SD_IO_SPI_Read();
 800e890:	f7ff fb68 	bl	800df64 <SD_IO_SPI_Read>
  while ((SD_IO_ReadByte() != Response) && timeout)
 800e894:	b2c0      	uxtb	r0, r0
 800e896:	4286      	cmp	r6, r0
 800e898:	d1f8      	bne.n	800e88c <SD_IO_WriteCmd+0x54>
  }

  if (timeout == 0)
 800e89a:	b114      	cbz	r4, 800e8a2 <SD_IO_WriteCmd+0x6a>
    return HAL_TIMEOUT;
  }
  else
  {
    /* Right response got */
    return HAL_OK;
 800e89c:	2000      	movs	r0, #0
}
 800e89e:	b003      	add	sp, #12
 800e8a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_TIMEOUT;
 800e8a2:	2003      	movs	r0, #3
}
 800e8a4:	b003      	add	sp, #12
 800e8a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e8a8:	48001800 	.word	0x48001800

0800e8ac <SD_IO_WaitResponse>:
{
 800e8ac:	b538      	push	{r3, r4, r5, lr}
 800e8ae:	4605      	mov	r5, r0
  uint32_t timeout = 0xFF0;//0x400;//
 800e8b0:	f44f 647f 	mov.w	r4, #4080	; 0xff0
  while ((SD_IO_ReadByte() != Response) && timeout)
 800e8b4:	e001      	b.n	800e8ba <SD_IO_WaitResponse+0xe>
 800e8b6:	b154      	cbz	r4, 800e8ce <SD_IO_WaitResponse+0x22>
    timeout--;
 800e8b8:	3c01      	subs	r4, #1
  data = SD_IO_SPI_Read();
 800e8ba:	f7ff fb53 	bl	800df64 <SD_IO_SPI_Read>
  while ((SD_IO_ReadByte() != Response) && timeout)
 800e8be:	b2c0      	uxtb	r0, r0
 800e8c0:	4285      	cmp	r5, r0
 800e8c2:	d1f8      	bne.n	800e8b6 <SD_IO_WaitResponse+0xa>
    return HAL_OK;
 800e8c4:	2c00      	cmp	r4, #0
 800e8c6:	bf0c      	ite	eq
 800e8c8:	2003      	moveq	r0, #3
 800e8ca:	2000      	movne	r0, #0
  }
}
 800e8cc:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_TIMEOUT;
 800e8ce:	2003      	movs	r0, #3
}
 800e8d0:	bd38      	pop	{r3, r4, r5, pc}
 800e8d2:	bf00      	nop

0800e8d4 <SD_IO_WriteDummy>:
  * @brief  Sends dummy byte with CS High
  * @param  None
  * @retval None
  */
void SD_IO_WriteDummy(void)
{
 800e8d4:	b508      	push	{r3, lr}
    /* SD chip select high */
    SENSORTILE_SD_CS_HIGH();
 800e8d6:	4805      	ldr	r0, [pc, #20]	; (800e8ec <SD_IO_WriteDummy+0x18>)
 800e8d8:	2201      	movs	r2, #1
 800e8da:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800e8de:	f002 fe45 	bl	801156c <HAL_GPIO_WritePin>
  SD_IO_SPI_Write(Data);
 800e8e2:	20ff      	movs	r0, #255	; 0xff
    
    /* Send Dummy byte 0xFF */
    SD_IO_WriteByte(SENSORTILE_SD_DUMMY_BYTE);
}
 800e8e4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  SD_IO_SPI_Write(Data);
 800e8e8:	f7ff bb24 	b.w	800df34 <SD_IO_SPI_Write>
 800e8ec:	48001800 	.word	0x48001800

0800e8f0 <BSP_LSM303AGR_ACCELERO_Init>:
  
  return COMPONENT_OK;
}

static DrvStatusTypeDef BSP_LSM303AGR_ACCELERO_Init( void **handle )
{
 800e8f0:	b5f0      	push	{r4, r5, r6, r7, lr}
  ACCELERO_Drv_t *driver = NULL;
  uint8_t data = 0x01;
    
  if(ACCELERO_SensorHandle[ LSM303AGR_X_0 ].isInitialized == 1)
 800e8f2:	4c26      	ldr	r4, [pc, #152]	; (800e98c <BSP_LSM303AGR_ACCELERO_Init+0x9c>)
 800e8f4:	7e63      	ldrb	r3, [r4, #25]
  uint8_t data = 0x01;
 800e8f6:	2501      	movs	r5, #1
{
 800e8f8:	b083      	sub	sp, #12
  if(ACCELERO_SensorHandle[ LSM303AGR_X_0 ].isInitialized == 1)
 800e8fa:	42ab      	cmp	r3, r5
  uint8_t data = 0x01;
 800e8fc:	f88d 5007 	strb.w	r5, [sp, #7]
  if(ACCELERO_SensorHandle[ LSM303AGR_X_0 ].isInitialized == 1)
 800e900:	d030      	beq.n	800e964 <BSP_LSM303AGR_ACCELERO_Init+0x74>
 800e902:	4606      	mov	r6, r0
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
  }
  
  if ( Sensor_IO_SPI_Init() == COMPONENT_ERROR )
 800e904:	f7ff fbc8 	bl	800e098 <Sensor_IO_SPI_Init>
 800e908:	2801      	cmp	r0, #1
 800e90a:	d02b      	beq.n	800e964 <BSP_LSM303AGR_ACCELERO_Init+0x74>
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].isCombo       = 1;
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pData         = ( void * )&ACCELERO_Data[ LSM303AGR_X_0 ];
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pVTable       = ( void * )&LSM303AGR_X_Drv;
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pExtVTable    = 0;

  LSM303AGR_X_0_Data.comboData = &LSM303AGR_Combo_Data[0];  
 800e90c:	4623      	mov	r3, r4
 800e90e:	4f20      	ldr	r7, [pc, #128]	; (800e990 <BSP_LSM303AGR_ACCELERO_Init+0xa0>)
 800e910:	f843 7f38 	str.w	r7, [r3, #56]!
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].who_am_i      = LSM303AGR_ACC_WHO_AM_I;
 800e914:	4a1f      	ldr	r2, [pc, #124]	; (800e994 <BSP_LSM303AGR_ACCELERO_Init+0xa4>)
  ACCELERO_Data[ LSM303AGR_X_0 ].pComponentData = ( void * )&LSM303AGR_X_0_Data;
 800e916:	6323      	str	r3, [r4, #48]	; 0x30
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].spiDevice     = LSM303AGR_X;
 800e918:	4b1f      	ldr	r3, [pc, #124]	; (800e998 <BSP_LSM303AGR_ACCELERO_Init+0xa8>)
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].who_am_i      = LSM303AGR_ACC_WHO_AM_I;
 800e91a:	6162      	str	r2, [r4, #20]
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].spiDevice     = LSM303AGR_X;
 800e91c:	61a3      	str	r3, [r4, #24]
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pData         = ( void * )&ACCELERO_Data[ LSM303AGR_X_0 ];
 800e91e:	f104 0230 	add.w	r2, r4, #48	; 0x30
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pVTable       = ( void * )&LSM303AGR_X_Drv;
 800e922:	4b1e      	ldr	r3, [pc, #120]	; (800e99c <BSP_LSM303AGR_ACCELERO_Init+0xac>)
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pData         = ( void * )&ACCELERO_Data[ LSM303AGR_X_0 ];
 800e924:	61e2      	str	r2, [r4, #28]
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pVTable       = ( void * )&LSM303AGR_X_Drv;
 800e926:	6223      	str	r3, [r4, #32]
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pExtVTable    = 0;
 800e928:	2200      	movs	r2, #0
  ACCELERO_Data[ LSM303AGR_X_0 ].pExtData       = 0;
  
  *handle = (void *)&ACCELERO_SensorHandle[ LSM303AGR_X_0 ];
 800e92a:	f104 0314 	add.w	r3, r4, #20
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pExtVTable    = 0;
 800e92e:	6262      	str	r2, [r4, #36]	; 0x24
  ACCELERO_Data[ LSM303AGR_X_0 ].pExtData       = 0;
 800e930:	6362      	str	r2, [r4, #52]	; 0x34
  
  Sensor_IO_SPI_CS_Init(*handle);
 800e932:	4618      	mov	r0, r3
  *handle = (void *)&ACCELERO_SensorHandle[ LSM303AGR_X_0 ];
 800e934:	6033      	str	r3, [r6, #0]
  Sensor_IO_SPI_CS_Init(*handle);
 800e936:	f7ff fc9d 	bl	800e274 <Sensor_IO_SPI_CS_Init>

  if(LSM303AGR_Combo_Data[0].isMagInitialized == 0)
 800e93a:	787b      	ldrb	r3, [r7, #1]
 800e93c:	b14b      	cbz	r3, 800e952 <BSP_LSM303AGR_ACCELERO_Init+0x62>
    {
      return COMPONENT_ERROR;
    }
  }
 
  driver = ( ACCELERO_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;
 800e93e:	6830      	ldr	r0, [r6, #0]
  
  if ( driver->Init == NULL )
 800e940:	68c3      	ldr	r3, [r0, #12]
 800e942:	681b      	ldr	r3, [r3, #0]
 800e944:	b1d3      	cbz	r3, 800e97c <BSP_LSM303AGR_ACCELERO_Init+0x8c>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }
  
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 800e946:	4798      	blx	r3
 800e948:	2801      	cmp	r0, #1
 800e94a:	d00e      	beq.n	800e96a <BSP_LSM303AGR_ACCELERO_Init+0x7a>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
 800e94c:	2000      	movs	r0, #0
}
 800e94e:	b003      	add	sp, #12
 800e950:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( Sensor_IO_Write(*handle, LSM303AGR_ACC_CTRL_REG4, &data, 1) )
 800e952:	462b      	mov	r3, r5
 800e954:	f10d 0207 	add.w	r2, sp, #7
 800e958:	2123      	movs	r1, #35	; 0x23
 800e95a:	6830      	ldr	r0, [r6, #0]
 800e95c:	f7ff fd82 	bl	800e464 <Sensor_IO_Write>
 800e960:	2800      	cmp	r0, #0
 800e962:	d0ec      	beq.n	800e93e <BSP_LSM303AGR_ACCELERO_Init+0x4e>
    return COMPONENT_ERROR;
 800e964:	2001      	movs	r0, #1
}
 800e966:	b003      	add	sp, #12
 800e968:	bdf0      	pop	{r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800e96a:	6832      	ldr	r2, [r6, #0]
 800e96c:	2300      	movs	r3, #0
 800e96e:	6013      	str	r3, [r2, #0]
 800e970:	6053      	str	r3, [r2, #4]
 800e972:	6093      	str	r3, [r2, #8]
 800e974:	60d3      	str	r3, [r2, #12]
 800e976:	6113      	str	r3, [r2, #16]
    *handle = NULL;
 800e978:	6033      	str	r3, [r6, #0]
    return COMPONENT_ERROR;
 800e97a:	e7f4      	b.n	800e966 <BSP_LSM303AGR_ACCELERO_Init+0x76>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800e97c:	6003      	str	r3, [r0, #0]
 800e97e:	6043      	str	r3, [r0, #4]
 800e980:	6083      	str	r3, [r0, #8]
 800e982:	60c3      	str	r3, [r0, #12]
 800e984:	6103      	str	r3, [r0, #16]
    return COMPONENT_ERROR;
 800e986:	2001      	movs	r0, #1
    *handle = NULL;
 800e988:	6033      	str	r3, [r6, #0]
    return COMPONENT_ERROR;
 800e98a:	e7ec      	b.n	800e966 <BSP_LSM303AGR_ACCELERO_Init+0x76>
 800e98c:	200017fc 	.word	0x200017fc
 800e990:	200103e4 	.word	0x200103e4
 800e994:	01320133 	.word	0x01320133
 800e998:	01000001 	.word	0x01000001
 800e99c:	20000148 	.word	0x20000148

0800e9a0 <BSP_LSM6DSM_ACCELERO_Init>:
{
 800e9a0:	b570      	push	{r4, r5, r6, lr}
  if(ACCELERO_SensorHandle[ LSM6DSM_X_0 ].isInitialized == 1)
 800e9a2:	4c29      	ldr	r4, [pc, #164]	; (800ea48 <BSP_LSM6DSM_ACCELERO_Init+0xa8>)
 800e9a4:	7963      	ldrb	r3, [r4, #5]
{
 800e9a6:	b082      	sub	sp, #8
  uint8_t data = 0x0C;
 800e9a8:	220c      	movs	r2, #12
  if(ACCELERO_SensorHandle[ LSM6DSM_X_0 ].isInitialized == 1)
 800e9aa:	2b01      	cmp	r3, #1
  uint8_t data = 0x0C;
 800e9ac:	f88d 2007 	strb.w	r2, [sp, #7]
  if(ACCELERO_SensorHandle[ LSM6DSM_X_0 ].isInitialized == 1)
 800e9b0:	d036      	beq.n	800ea20 <BSP_LSM6DSM_ACCELERO_Init+0x80>
 800e9b2:	4605      	mov	r5, r0
  if ( Sensor_IO_SPI_Init() == COMPONENT_ERROR )
 800e9b4:	f7ff fb70 	bl	800e098 <Sensor_IO_SPI_Init>
 800e9b8:	2801      	cmp	r0, #1
 800e9ba:	d031      	beq.n	800ea20 <BSP_LSM6DSM_ACCELERO_Init+0x80>
  LSM6DSM_X_0_Data.comboData = &LSM6DSM_Combo_Data[0];
 800e9bc:	4623      	mov	r3, r4
 800e9be:	4e23      	ldr	r6, [pc, #140]	; (800ea4c <BSP_LSM6DSM_ACCELERO_Init+0xac>)
 800e9c0:	f843 6f40 	str.w	r6, [r3, #64]!
  ACCELERO_SensorHandle[ LSM6DSM_X_0 ].spiDevice     = LSM6DSM;
 800e9c4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  ACCELERO_Data[ LSM6DSM_X_0 ].pComponentData = ( void * )&LSM6DSM_X_0_Data;
 800e9c8:	62a3      	str	r3, [r4, #40]	; 0x28
  ACCELERO_SensorHandle[ LSM6DSM_X_0 ].spiDevice     = LSM6DSM;
 800e9ca:	6062      	str	r2, [r4, #4]
  ACCELERO_SensorHandle[ LSM6DSM_X_0 ].pVTable       = ( void * )&LSM6DSM_X_Drv;
 800e9cc:	4920      	ldr	r1, [pc, #128]	; (800ea50 <BSP_LSM6DSM_ACCELERO_Init+0xb0>)
  ACCELERO_SensorHandle[ LSM6DSM_X_0 ].pExtVTable    = ( void * )&LSM6DSM_X_ExtDrv;
 800e9ce:	4a21      	ldr	r2, [pc, #132]	; (800ea54 <BSP_LSM6DSM_ACCELERO_Init+0xb4>)
  ACCELERO_SensorHandle[ LSM6DSM_X_0 ].who_am_i      = LSM6DSM_ACC_GYRO_WHO_AM_I;
 800e9d0:	4821      	ldr	r0, [pc, #132]	; (800ea58 <BSP_LSM6DSM_ACCELERO_Init+0xb8>)
 800e9d2:	6020      	str	r0, [r4, #0]
  ACCELERO_SensorHandle[ LSM6DSM_X_0 ].pData         = ( void * )&ACCELERO_Data[ LSM6DSM_X_0 ];
 800e9d4:	f104 0328 	add.w	r3, r4, #40	; 0x28
 800e9d8:	60a3      	str	r3, [r4, #8]
  ACCELERO_Data[ LSM6DSM_X_0 ].pExtData       = 0;
 800e9da:	2300      	movs	r3, #0
 800e9dc:	62e3      	str	r3, [r4, #44]	; 0x2c
  ACCELERO_SensorHandle[ LSM6DSM_X_0 ].pExtVTable    = ( void * )&LSM6DSM_X_ExtDrv;
 800e9de:	e9c4 1203 	strd	r1, r2, [r4, #12]
  Sensor_IO_SPI_CS_Init(*handle);
 800e9e2:	4620      	mov	r0, r4
  *handle = (void *)&ACCELERO_SensorHandle[ LSM6DSM_X_0 ];
 800e9e4:	602c      	str	r4, [r5, #0]
  Sensor_IO_SPI_CS_Init(*handle);
 800e9e6:	f7ff fc45 	bl	800e274 <Sensor_IO_SPI_CS_Init>
  if(LSM6DSM_Combo_Data[0].isGyroInitialized == 0)
 800e9ea:	7873      	ldrb	r3, [r6, #1]
 800e9ec:	b17b      	cbz	r3, 800ea0e <BSP_LSM6DSM_ACCELERO_Init+0x6e>
  driver = ( ACCELERO_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;
 800e9ee:	6828      	ldr	r0, [r5, #0]
  if ( driver->Init == NULL )
 800e9f0:	68c3      	ldr	r3, [r0, #12]
 800e9f2:	681b      	ldr	r3, [r3, #0]
 800e9f4:	b303      	cbz	r3, 800ea38 <BSP_LSM6DSM_ACCELERO_Init+0x98>
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 800e9f6:	4798      	blx	r3
 800e9f8:	2801      	cmp	r0, #1
 800e9fa:	d014      	beq.n	800ea26 <BSP_LSM6DSM_ACCELERO_Init+0x86>
  if ( LSM6DSM_ACC_GYRO_W_I2C_DISABLE( *handle, LSM6DSM_ACC_GYRO_I2C_DISABLE_SPI_ONLY ) == MEMS_ERROR )
 800e9fc:	6828      	ldr	r0, [r5, #0]
 800e9fe:	2104      	movs	r1, #4
 800ea00:	f7fc f89c 	bl	800ab3c <LSM6DSM_ACC_GYRO_W_I2C_DISABLE>
 800ea04:	b160      	cbz	r0, 800ea20 <BSP_LSM6DSM_ACCELERO_Init+0x80>
  LSM6DSM_Sensor_IO_ITConfig();
 800ea06:	f7ff fd67 	bl	800e4d8 <LSM6DSM_Sensor_IO_ITConfig>
  return COMPONENT_OK;
 800ea0a:	2000      	movs	r0, #0
 800ea0c:	e009      	b.n	800ea22 <BSP_LSM6DSM_ACCELERO_Init+0x82>
    if( Sensor_IO_Write(*handle, LSM6DSM_ACC_GYRO_CTRL3_C, &data, 1) )
 800ea0e:	2301      	movs	r3, #1
 800ea10:	f10d 0207 	add.w	r2, sp, #7
 800ea14:	2112      	movs	r1, #18
 800ea16:	6828      	ldr	r0, [r5, #0]
 800ea18:	f7ff fd24 	bl	800e464 <Sensor_IO_Write>
 800ea1c:	2800      	cmp	r0, #0
 800ea1e:	d0e6      	beq.n	800e9ee <BSP_LSM6DSM_ACCELERO_Init+0x4e>
    return COMPONENT_ERROR;
 800ea20:	2001      	movs	r0, #1
}
 800ea22:	b002      	add	sp, #8
 800ea24:	bd70      	pop	{r4, r5, r6, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800ea26:	682a      	ldr	r2, [r5, #0]
 800ea28:	2300      	movs	r3, #0
 800ea2a:	6013      	str	r3, [r2, #0]
 800ea2c:	6053      	str	r3, [r2, #4]
 800ea2e:	6093      	str	r3, [r2, #8]
 800ea30:	60d3      	str	r3, [r2, #12]
 800ea32:	6113      	str	r3, [r2, #16]
    *handle = NULL;
 800ea34:	602b      	str	r3, [r5, #0]
    return COMPONENT_ERROR;
 800ea36:	e7f4      	b.n	800ea22 <BSP_LSM6DSM_ACCELERO_Init+0x82>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800ea38:	6003      	str	r3, [r0, #0]
 800ea3a:	6043      	str	r3, [r0, #4]
 800ea3c:	6083      	str	r3, [r0, #8]
 800ea3e:	60c3      	str	r3, [r0, #12]
 800ea40:	6103      	str	r3, [r0, #16]
    return COMPONENT_ERROR;
 800ea42:	2001      	movs	r0, #1
    *handle = NULL;
 800ea44:	602b      	str	r3, [r5, #0]
    return COMPONENT_ERROR;
 800ea46:	e7ec      	b.n	800ea22 <BSP_LSM6DSM_ACCELERO_Init+0x82>
 800ea48:	200017fc 	.word	0x200017fc
 800ea4c:	200103e8 	.word	0x200103e8
 800ea50:	20000230 	.word	0x20000230
 800ea54:	200002bc 	.word	0x200002bc
 800ea58:	00d6016a 	.word	0x00d6016a

0800ea5c <BSP_ACCELERO_Init>:
{
 800ea5c:	b538      	push	{r3, r4, r5, lr}
  *handle = NULL;
 800ea5e:	2400      	movs	r4, #0
{
 800ea60:	460d      	mov	r5, r1
  *handle = NULL;
 800ea62:	600c      	str	r4, [r1, #0]
  switch(id)
 800ea64:	b180      	cbz	r0, 800ea88 <BSP_ACCELERO_Init+0x2c>
 800ea66:	2801      	cmp	r0, #1
      if( BSP_LSM303AGR_ACCELERO_Init(handle) == COMPONENT_ERROR )
 800ea68:	4608      	mov	r0, r1
  switch(id)
 800ea6a:	d005      	beq.n	800ea78 <BSP_ACCELERO_Init+0x1c>
      if(BSP_LSM6DSM_ACCELERO_Init(handle) == COMPONENT_ERROR )
 800ea6c:	f7ff ff98 	bl	800e9a0 <BSP_LSM6DSM_ACCELERO_Init>
 800ea70:	2801      	cmp	r0, #1
 800ea72:	d012      	beq.n	800ea9a <BSP_ACCELERO_Init+0x3e>
  return COMPONENT_OK;
 800ea74:	4620      	mov	r0, r4
}
 800ea76:	bd38      	pop	{r3, r4, r5, pc}
      if( BSP_LSM303AGR_ACCELERO_Init(handle) == COMPONENT_ERROR )
 800ea78:	f7ff ff3a 	bl	800e8f0 <BSP_LSM303AGR_ACCELERO_Init>
          return COMPONENT_ERROR;
 800ea7c:	f1a0 0001 	sub.w	r0, r0, #1
 800ea80:	fab0 f080 	clz	r0, r0
 800ea84:	0940      	lsrs	r0, r0, #5
}
 800ea86:	bd38      	pop	{r3, r4, r5, pc}
      if( BSP_LSM6DSM_ACCELERO_Init(handle) == COMPONENT_ERROR )
 800ea88:	4608      	mov	r0, r1
 800ea8a:	f7ff ff89 	bl	800e9a0 <BSP_LSM6DSM_ACCELERO_Init>
          return COMPONENT_ERROR;
 800ea8e:	f1a0 0001 	sub.w	r0, r0, #1
 800ea92:	fab0 f080 	clz	r0, r0
 800ea96:	0940      	lsrs	r0, r0, #5
}
 800ea98:	bd38      	pop	{r3, r4, r5, pc}
        if( BSP_LSM303AGR_ACCELERO_Init(handle) == COMPONENT_ERROR )
 800ea9a:	4628      	mov	r0, r5
 800ea9c:	f7ff ff28 	bl	800e8f0 <BSP_LSM303AGR_ACCELERO_Init>
          return COMPONENT_ERROR;
 800eaa0:	f1a0 0001 	sub.w	r0, r0, #1
 800eaa4:	fab0 f080 	clz	r0, r0
 800eaa8:	0940      	lsrs	r0, r0, #5
}
 800eaaa:	bd38      	pop	{r3, r4, r5, pc}

0800eaac <BSP_ACCELERO_Sensor_Enable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800eaac:	b150      	cbz	r0, 800eac4 <BSP_ACCELERO_Sensor_Enable+0x18>
{
 800eaae:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( ACCELERO_Drv_t * )ctx->pVTable;
  
  if ( driver->Sensor_Enable == NULL )
 800eab0:	68c3      	ldr	r3, [r0, #12]
 800eab2:	689b      	ldr	r3, [r3, #8]
 800eab4:	b143      	cbz	r3, 800eac8 <BSP_ACCELERO_Sensor_Enable+0x1c>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 800eab6:	4798      	blx	r3
    return COMPONENT_ERROR;
 800eab8:	f1a0 0001 	sub.w	r0, r0, #1
 800eabc:	fab0 f080 	clz	r0, r0
 800eac0:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800eac2:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800eac4:	2001      	movs	r0, #1
}
 800eac6:	4770      	bx	lr
    return COMPONENT_ERROR;
 800eac8:	2001      	movs	r0, #1
}
 800eaca:	bd08      	pop	{r3, pc}

0800eacc <BSP_ACCELERO_Sensor_Disable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800eacc:	b150      	cbz	r0, 800eae4 <BSP_ACCELERO_Sensor_Disable+0x18>
{
 800eace:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( ACCELERO_Drv_t * )ctx->pVTable;
  
  if ( driver->Sensor_Disable == NULL )
 800ead0:	68c3      	ldr	r3, [r0, #12]
 800ead2:	68db      	ldr	r3, [r3, #12]
 800ead4:	b143      	cbz	r3, 800eae8 <BSP_ACCELERO_Sensor_Disable+0x1c>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Sensor_Disable( ctx ) == COMPONENT_ERROR )
 800ead6:	4798      	blx	r3
    return COMPONENT_ERROR;
 800ead8:	f1a0 0001 	sub.w	r0, r0, #1
 800eadc:	fab0 f080 	clz	r0, r0
 800eae0:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800eae2:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800eae4:	2001      	movs	r0, #1
}
 800eae6:	4770      	bx	lr
    return COMPONENT_ERROR;
 800eae8:	2001      	movs	r0, #1
}
 800eaea:	bd08      	pop	{r3, pc}

0800eaec <BSP_ACCELERO_Get_Axes>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800eaec:	b158      	cbz	r0, 800eb06 <BSP_ACCELERO_Get_Axes+0x1a>
{
 800eaee:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( ACCELERO_Drv_t * )ctx->pVTable;
  
  if(acceleration == NULL)
 800eaf0:	b159      	cbz	r1, 800eb0a <BSP_ACCELERO_Get_Axes+0x1e>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Get_Axes == NULL )
 800eaf2:	68c3      	ldr	r3, [r0, #12]
 800eaf4:	699b      	ldr	r3, [r3, #24]
 800eaf6:	b143      	cbz	r3, 800eb0a <BSP_ACCELERO_Get_Axes+0x1e>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Get_Axes( ctx, acceleration ) == COMPONENT_ERROR )
 800eaf8:	4798      	blx	r3
    return COMPONENT_ERROR;
 800eafa:	f1a0 0001 	sub.w	r0, r0, #1
 800eafe:	fab0 f080 	clz	r0, r0
 800eb02:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800eb04:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800eb06:	2001      	movs	r0, #1
}
 800eb08:	4770      	bx	lr
    return COMPONENT_ERROR;
 800eb0a:	2001      	movs	r0, #1
}
 800eb0c:	bd08      	pop	{r3, pc}
 800eb0e:	bf00      	nop

0800eb10 <BSP_ACCELERO_Get_Sensitivity>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800eb10:	b158      	cbz	r0, 800eb2a <BSP_ACCELERO_Get_Sensitivity+0x1a>
{
 800eb12:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( ACCELERO_Drv_t * )ctx->pVTable;
  
  if(sensitivity == NULL)
 800eb14:	b159      	cbz	r1, 800eb2e <BSP_ACCELERO_Get_Sensitivity+0x1e>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Get_Sensitivity == NULL )
 800eb16:	68c3      	ldr	r3, [r0, #12]
 800eb18:	6a1b      	ldr	r3, [r3, #32]
 800eb1a:	b143      	cbz	r3, 800eb2e <BSP_ACCELERO_Get_Sensitivity+0x1e>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Get_Sensitivity( ctx, sensitivity ) == COMPONENT_ERROR )
 800eb1c:	4798      	blx	r3
    return COMPONENT_ERROR;
 800eb1e:	f1a0 0001 	sub.w	r0, r0, #1
 800eb22:	fab0 f080 	clz	r0, r0
 800eb26:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800eb28:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800eb2a:	2001      	movs	r0, #1
}
 800eb2c:	4770      	bx	lr
    return COMPONENT_ERROR;
 800eb2e:	2001      	movs	r0, #1
}
 800eb30:	bd08      	pop	{r3, pc}
 800eb32:	bf00      	nop

0800eb34 <BSP_ACCELERO_Get_ODR>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800eb34:	b158      	cbz	r0, 800eb4e <BSP_ACCELERO_Get_ODR+0x1a>
{
 800eb36:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( ACCELERO_Drv_t * )ctx->pVTable;
  
  if(odr == NULL)
 800eb38:	b159      	cbz	r1, 800eb52 <BSP_ACCELERO_Get_ODR+0x1e>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Get_ODR == NULL )
 800eb3a:	68c3      	ldr	r3, [r0, #12]
 800eb3c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800eb3e:	b143      	cbz	r3, 800eb52 <BSP_ACCELERO_Get_ODR+0x1e>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Get_ODR( ctx, odr ) == COMPONENT_ERROR )
 800eb40:	4798      	blx	r3
    return COMPONENT_ERROR;
 800eb42:	f1a0 0001 	sub.w	r0, r0, #1
 800eb46:	fab0 f080 	clz	r0, r0
 800eb4a:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800eb4c:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800eb4e:	2001      	movs	r0, #1
}
 800eb50:	4770      	bx	lr
    return COMPONENT_ERROR;
 800eb52:	2001      	movs	r0, #1
}
 800eb54:	bd08      	pop	{r3, pc}
 800eb56:	bf00      	nop

0800eb58 <BSP_ACCELERO_Set_ODR_Value>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800eb58:	b150      	cbz	r0, 800eb70 <BSP_ACCELERO_Set_ODR_Value+0x18>
{
 800eb5a:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( ACCELERO_Drv_t * )ctx->pVTable;
  
  if ( driver->Set_ODR_Value == NULL )
 800eb5c:	68c3      	ldr	r3, [r0, #12]
 800eb5e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800eb60:	b143      	cbz	r3, 800eb74 <BSP_ACCELERO_Set_ODR_Value+0x1c>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Set_ODR_Value( ctx, odr ) == COMPONENT_ERROR )
 800eb62:	4798      	blx	r3
    return COMPONENT_ERROR;
 800eb64:	f1a0 0001 	sub.w	r0, r0, #1
 800eb68:	fab0 f080 	clz	r0, r0
 800eb6c:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800eb6e:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800eb70:	2001      	movs	r0, #1
}
 800eb72:	4770      	bx	lr
    return COMPONENT_ERROR;
 800eb74:	2001      	movs	r0, #1
}
 800eb76:	bd08      	pop	{r3, pc}

0800eb78 <BSP_ACCELERO_Set_FS_Value>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800eb78:	b150      	cbz	r0, 800eb90 <BSP_ACCELERO_Set_FS_Value+0x18>
{
 800eb7a:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( ACCELERO_Drv_t * )ctx->pVTable;
  
  if ( driver->Set_FS_Value == NULL )
 800eb7c:	68c3      	ldr	r3, [r0, #12]
 800eb7e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800eb80:	b143      	cbz	r3, 800eb94 <BSP_ACCELERO_Set_FS_Value+0x1c>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Set_FS_Value( ctx, fullScale ) == COMPONENT_ERROR )
 800eb82:	4798      	blx	r3
    return COMPONENT_ERROR;
 800eb84:	f1a0 0001 	sub.w	r0, r0, #1
 800eb88:	fab0 f080 	clz	r0, r0
 800eb8c:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800eb8e:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800eb90:	2001      	movs	r0, #1
}
 800eb92:	4770      	bx	lr
    return COMPONENT_ERROR;
 800eb94:	2001      	movs	r0, #1
}
 800eb96:	bd08      	pop	{r3, pc}

0800eb98 <BSP_ACCELERO_Enable_Free_Fall_Detection_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Enable_Free_Fall_Detection_Ext( void *handle, SensorIntPin_t int_pin )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
 
  /*just INT2_PIN is linked to MCU */
  if(int_pin != INT2_PIN)
 800eb98:	2901      	cmp	r1, #1
 800eb9a:	d001      	beq.n	800eba0 <BSP_ACCELERO_Enable_Free_Fall_Detection_Ext+0x8>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800eb9c:	2001      	movs	r0, #1
 800eb9e:	4770      	bx	lr
  if(ctx == NULL)
 800eba0:	2800      	cmp	r0, #0
 800eba2:	d0fb      	beq.n	800eb9c <BSP_ACCELERO_Enable_Free_Fall_Detection_Ext+0x4>
  if ( ctx->pExtVTable == NULL )
 800eba4:	6902      	ldr	r2, [r0, #16]
 800eba6:	2a00      	cmp	r2, #0
 800eba8:	d0f8      	beq.n	800eb9c <BSP_ACCELERO_Enable_Free_Fall_Detection_Ext+0x4>
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ebaa:	7803      	ldrb	r3, [r0, #0]
 800ebac:	2b6a      	cmp	r3, #106	; 0x6a
 800ebae:	d1f5      	bne.n	800eb9c <BSP_ACCELERO_Enable_Free_Fall_Detection_Ext+0x4>
    if ( extDriver->Enable_Free_Fall_Detection == NULL )
 800ebb0:	6813      	ldr	r3, [r2, #0]
 800ebb2:	2b00      	cmp	r3, #0
 800ebb4:	d0f2      	beq.n	800eb9c <BSP_ACCELERO_Enable_Free_Fall_Detection_Ext+0x4>
      return extDriver->Enable_Free_Fall_Detection( ctx , int_pin);
 800ebb6:	4718      	bx	r3

0800ebb8 <BSP_ACCELERO_Disable_Free_Fall_Detection_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Disable_Free_Fall_Detection_Ext( void *handle )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ebb8:	b120      	cbz	r0, 800ebc4 <BSP_ACCELERO_Disable_Free_Fall_Detection_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ebba:	6902      	ldr	r2, [r0, #16]
 800ebbc:	b112      	cbz	r2, 800ebc4 <BSP_ACCELERO_Disable_Free_Fall_Detection_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ebbe:	7803      	ldrb	r3, [r0, #0]
 800ebc0:	2b6a      	cmp	r3, #106	; 0x6a
 800ebc2:	d001      	beq.n	800ebc8 <BSP_ACCELERO_Disable_Free_Fall_Detection_Ext+0x10>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ebc4:	2001      	movs	r0, #1
 800ebc6:	4770      	bx	lr
    if ( extDriver->Disable_Free_Fall_Detection == NULL )
 800ebc8:	6853      	ldr	r3, [r2, #4]
 800ebca:	2b00      	cmp	r3, #0
 800ebcc:	d0fa      	beq.n	800ebc4 <BSP_ACCELERO_Disable_Free_Fall_Detection_Ext+0xc>
      return extDriver->Disable_Free_Fall_Detection( ctx );
 800ebce:	4718      	bx	r3

0800ebd0 <BSP_ACCELERO_Set_Free_Fall_Threshold_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Set_Free_Fall_Threshold_Ext( void *handle, LSM6DSM_ACC_GYRO_FF_THS_t thr )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ebd0:	b120      	cbz	r0, 800ebdc <BSP_ACCELERO_Set_Free_Fall_Threshold_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ebd2:	6902      	ldr	r2, [r0, #16]
 800ebd4:	b112      	cbz	r2, 800ebdc <BSP_ACCELERO_Set_Free_Fall_Threshold_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ebd6:	7803      	ldrb	r3, [r0, #0]
 800ebd8:	2b6a      	cmp	r3, #106	; 0x6a
 800ebda:	d001      	beq.n	800ebe0 <BSP_ACCELERO_Set_Free_Fall_Threshold_Ext+0x10>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ebdc:	2001      	movs	r0, #1
 800ebde:	4770      	bx	lr
    if ( extDriver->Set_Free_Fall_Threshold == NULL )
 800ebe0:	68d3      	ldr	r3, [r2, #12]
 800ebe2:	2b00      	cmp	r3, #0
 800ebe4:	d0fa      	beq.n	800ebdc <BSP_ACCELERO_Set_Free_Fall_Threshold_Ext+0xc>
      return extDriver->Set_Free_Fall_Threshold( ctx, thr );
 800ebe6:	4718      	bx	r3

0800ebe8 <BSP_ACCELERO_Enable_Pedometer_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Enable_Pedometer_Ext( void *handle, SensorIntPin_t int_pin )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if (int_pin != INT2_PIN)
 800ebe8:	2901      	cmp	r1, #1
 800ebea:	d001      	beq.n	800ebf0 <BSP_ACCELERO_Enable_Pedometer_Ext+0x8>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ebec:	2001      	movs	r0, #1
 800ebee:	4770      	bx	lr
  if(ctx == NULL)
 800ebf0:	2800      	cmp	r0, #0
 800ebf2:	d0fb      	beq.n	800ebec <BSP_ACCELERO_Enable_Pedometer_Ext+0x4>
  if ( ctx->pExtVTable == NULL )
 800ebf4:	6902      	ldr	r2, [r0, #16]
 800ebf6:	2a00      	cmp	r2, #0
 800ebf8:	d0f8      	beq.n	800ebec <BSP_ACCELERO_Enable_Pedometer_Ext+0x4>
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ebfa:	7803      	ldrb	r3, [r0, #0]
 800ebfc:	2b6a      	cmp	r3, #106	; 0x6a
 800ebfe:	d1f5      	bne.n	800ebec <BSP_ACCELERO_Enable_Pedometer_Ext+0x4>
    if ( extDriver->Enable_Pedometer == NULL )
 800ec00:	6913      	ldr	r3, [r2, #16]
 800ec02:	2b00      	cmp	r3, #0
 800ec04:	d0f2      	beq.n	800ebec <BSP_ACCELERO_Enable_Pedometer_Ext+0x4>
      return extDriver->Enable_Pedometer( ctx,int_pin );
 800ec06:	4718      	bx	r3

0800ec08 <BSP_ACCELERO_Disable_Pedometer_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Disable_Pedometer_Ext( void *handle )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ec08:	b120      	cbz	r0, 800ec14 <BSP_ACCELERO_Disable_Pedometer_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ec0a:	6902      	ldr	r2, [r0, #16]
 800ec0c:	b112      	cbz	r2, 800ec14 <BSP_ACCELERO_Disable_Pedometer_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ec0e:	7803      	ldrb	r3, [r0, #0]
 800ec10:	2b6a      	cmp	r3, #106	; 0x6a
 800ec12:	d001      	beq.n	800ec18 <BSP_ACCELERO_Disable_Pedometer_Ext+0x10>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ec14:	2001      	movs	r0, #1
 800ec16:	4770      	bx	lr
    if ( extDriver->Disable_Pedometer == NULL )
 800ec18:	6953      	ldr	r3, [r2, #20]
 800ec1a:	2b00      	cmp	r3, #0
 800ec1c:	d0fa      	beq.n	800ec14 <BSP_ACCELERO_Disable_Pedometer_Ext+0xc>
      return extDriver->Disable_Pedometer( ctx );
 800ec1e:	4718      	bx	r3

0800ec20 <BSP_ACCELERO_Get_Step_Count_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Get_Step_Count_Ext( void *handle, uint16_t *step_count )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ec20:	b150      	cbz	r0, 800ec38 <BSP_ACCELERO_Get_Step_Count_Ext+0x18>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ec22:	6902      	ldr	r2, [r0, #16]
 800ec24:	b142      	cbz	r2, 800ec38 <BSP_ACCELERO_Get_Step_Count_Ext+0x18>
{
 800ec26:	b410      	push	{r4}
  {
    return COMPONENT_ERROR;
  }
  
  if ( step_count == NULL )
 800ec28:	b111      	cbz	r1, 800ec30 <BSP_ACCELERO_Get_Step_Count_Ext+0x10>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ec2a:	7803      	ldrb	r3, [r0, #0]
 800ec2c:	2b6a      	cmp	r3, #106	; 0x6a
 800ec2e:	d005      	beq.n	800ec3c <BSP_ACCELERO_Get_Step_Count_Ext+0x1c>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ec30:	2001      	movs	r0, #1
 800ec32:	f85d 4b04 	ldr.w	r4, [sp], #4
 800ec36:	4770      	bx	lr
 800ec38:	2001      	movs	r0, #1
 800ec3a:	4770      	bx	lr
    if ( extDriver->Get_Step_Count == NULL )
 800ec3c:	69d3      	ldr	r3, [r2, #28]
 800ec3e:	2b00      	cmp	r3, #0
 800ec40:	d0f6      	beq.n	800ec30 <BSP_ACCELERO_Get_Step_Count_Ext+0x10>
}
 800ec42:	f85d 4b04 	ldr.w	r4, [sp], #4
      return extDriver->Get_Step_Count( ctx, step_count );
 800ec46:	4718      	bx	r3

0800ec48 <BSP_ACCELERO_Reset_Step_Counter_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Reset_Step_Counter_Ext( void *handle )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ec48:	b1e8      	cbz	r0, 800ec86 <BSP_ACCELERO_Reset_Step_Counter_Ext+0x3e>
{
 800ec4a:	b538      	push	{r3, r4, r5, lr}
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ec4c:	6905      	ldr	r5, [r0, #16]
 800ec4e:	4604      	mov	r4, r0
 800ec50:	b115      	cbz	r5, 800ec58 <BSP_ACCELERO_Reset_Step_Counter_Ext+0x10>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ec52:	7802      	ldrb	r2, [r0, #0]
 800ec54:	2a6a      	cmp	r2, #106	; 0x6a
 800ec56:	d001      	beq.n	800ec5c <BSP_ACCELERO_Reset_Step_Counter_Ext+0x14>
    return COMPONENT_ERROR;
 800ec58:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800ec5a:	bd38      	pop	{r3, r4, r5, pc}
    if ( extDriver->Enable_Step_Counter_Reset == NULL || extDriver->Disable_Step_Counter_Reset == NULL )
 800ec5c:	6a2a      	ldr	r2, [r5, #32]
 800ec5e:	2a00      	cmp	r2, #0
 800ec60:	d0fa      	beq.n	800ec58 <BSP_ACCELERO_Reset_Step_Counter_Ext+0x10>
 800ec62:	6a69      	ldr	r1, [r5, #36]	; 0x24
 800ec64:	2900      	cmp	r1, #0
 800ec66:	d0f7      	beq.n	800ec58 <BSP_ACCELERO_Reset_Step_Counter_Ext+0x10>
      if( extDriver->Enable_Step_Counter_Reset( ctx ) == COMPONENT_ERROR )
 800ec68:	4790      	blx	r2
 800ec6a:	2801      	cmp	r0, #1
 800ec6c:	d0f4      	beq.n	800ec58 <BSP_ACCELERO_Reset_Step_Counter_Ext+0x10>
      HAL_Delay( 10 );
 800ec6e:	200a      	movs	r0, #10
 800ec70:	f00c fa4a 	bl	801b108 <HAL_Delay>
      if( extDriver->Disable_Step_Counter_Reset( ctx ) == COMPONENT_ERROR )
 800ec74:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800ec76:	4620      	mov	r0, r4
 800ec78:	4798      	blx	r3
    return COMPONENT_ERROR;
 800ec7a:	f1a0 0001 	sub.w	r0, r0, #1
 800ec7e:	fab0 f080 	clz	r0, r0
 800ec82:	0940      	lsrs	r0, r0, #5
}
 800ec84:	bd38      	pop	{r3, r4, r5, pc}
    return COMPONENT_ERROR;
 800ec86:	2001      	movs	r0, #1
}
 800ec88:	4770      	bx	lr
 800ec8a:	bf00      	nop

0800ec8c <BSP_ACCELERO_Enable_Tilt_Detection_Ext>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
   
    /*just INT2_PIN is linked to MCU */
  if(int_pin != INT2_PIN)
 800ec8c:	2901      	cmp	r1, #1
 800ec8e:	d001      	beq.n	800ec94 <BSP_ACCELERO_Enable_Tilt_Detection_Ext+0x8>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ec90:	2001      	movs	r0, #1
 800ec92:	4770      	bx	lr
  if(ctx == NULL)
 800ec94:	2800      	cmp	r0, #0
 800ec96:	d0fb      	beq.n	800ec90 <BSP_ACCELERO_Enable_Tilt_Detection_Ext+0x4>
  if ( ctx->pExtVTable == NULL )
 800ec98:	6902      	ldr	r2, [r0, #16]
 800ec9a:	2a00      	cmp	r2, #0
 800ec9c:	d0f8      	beq.n	800ec90 <BSP_ACCELERO_Enable_Tilt_Detection_Ext+0x4>
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ec9e:	7803      	ldrb	r3, [r0, #0]
 800eca0:	2b6a      	cmp	r3, #106	; 0x6a
 800eca2:	d1f5      	bne.n	800ec90 <BSP_ACCELERO_Enable_Tilt_Detection_Ext+0x4>
    if ( extDriver->Enable_Tilt_Detection == NULL )
 800eca4:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 800eca6:	2b00      	cmp	r3, #0
 800eca8:	d0f2      	beq.n	800ec90 <BSP_ACCELERO_Enable_Tilt_Detection_Ext+0x4>
      return extDriver->Enable_Tilt_Detection( ctx ,int_pin);
 800ecaa:	4718      	bx	r3

0800ecac <BSP_ACCELERO_Disable_Tilt_Detection_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Disable_Tilt_Detection_Ext( void *handle )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ecac:	b120      	cbz	r0, 800ecb8 <BSP_ACCELERO_Disable_Tilt_Detection_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ecae:	6902      	ldr	r2, [r0, #16]
 800ecb0:	b112      	cbz	r2, 800ecb8 <BSP_ACCELERO_Disable_Tilt_Detection_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ecb2:	7803      	ldrb	r3, [r0, #0]
 800ecb4:	2b6a      	cmp	r3, #106	; 0x6a
 800ecb6:	d001      	beq.n	800ecbc <BSP_ACCELERO_Disable_Tilt_Detection_Ext+0x10>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ecb8:	2001      	movs	r0, #1
 800ecba:	4770      	bx	lr
    if ( extDriver->Disable_Tilt_Detection == NULL )
 800ecbc:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800ecbe:	2b00      	cmp	r3, #0
 800ecc0:	d0fa      	beq.n	800ecb8 <BSP_ACCELERO_Disable_Tilt_Detection_Ext+0xc>
      return extDriver->Disable_Tilt_Detection( ctx );
 800ecc2:	4718      	bx	r3

0800ecc4 <BSP_ACCELERO_Enable_Wake_Up_Detection_Ext>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
   
    /*just INT2_PIN is linked to MCU */
  if(int_pin != INT2_PIN)
 800ecc4:	2901      	cmp	r1, #1
 800ecc6:	d001      	beq.n	800eccc <BSP_ACCELERO_Enable_Wake_Up_Detection_Ext+0x8>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ecc8:	2001      	movs	r0, #1
 800ecca:	4770      	bx	lr
  if(ctx == NULL)
 800eccc:	2800      	cmp	r0, #0
 800ecce:	d0fb      	beq.n	800ecc8 <BSP_ACCELERO_Enable_Wake_Up_Detection_Ext+0x4>
  if ( ctx->pExtVTable == NULL )
 800ecd0:	6902      	ldr	r2, [r0, #16]
 800ecd2:	2a00      	cmp	r2, #0
 800ecd4:	d0f8      	beq.n	800ecc8 <BSP_ACCELERO_Enable_Wake_Up_Detection_Ext+0x4>
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ecd6:	7803      	ldrb	r3, [r0, #0]
 800ecd8:	2b6a      	cmp	r3, #106	; 0x6a
 800ecda:	d1f5      	bne.n	800ecc8 <BSP_ACCELERO_Enable_Wake_Up_Detection_Ext+0x4>
    if ( extDriver->Enable_Wake_Up_Detection == NULL )
 800ecdc:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800ecde:	2b00      	cmp	r3, #0
 800ece0:	d0f2      	beq.n	800ecc8 <BSP_ACCELERO_Enable_Wake_Up_Detection_Ext+0x4>
      return extDriver->Enable_Wake_Up_Detection( ctx ,int_pin);
 800ece2:	4718      	bx	r3

0800ece4 <BSP_ACCELERO_Disable_Wake_Up_Detection_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Disable_Wake_Up_Detection_Ext( void *handle )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ece4:	b120      	cbz	r0, 800ecf0 <BSP_ACCELERO_Disable_Wake_Up_Detection_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ece6:	6902      	ldr	r2, [r0, #16]
 800ece8:	b112      	cbz	r2, 800ecf0 <BSP_ACCELERO_Disable_Wake_Up_Detection_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ecea:	7803      	ldrb	r3, [r0, #0]
 800ecec:	2b6a      	cmp	r3, #106	; 0x6a
 800ecee:	d001      	beq.n	800ecf4 <BSP_ACCELERO_Disable_Wake_Up_Detection_Ext+0x10>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ecf0:	2001      	movs	r0, #1
 800ecf2:	4770      	bx	lr
    if ( extDriver->Disable_Wake_Up_Detection == NULL )
 800ecf4:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 800ecf6:	2b00      	cmp	r3, #0
 800ecf8:	d0fa      	beq.n	800ecf0 <BSP_ACCELERO_Disable_Wake_Up_Detection_Ext+0xc>
      return extDriver->Disable_Wake_Up_Detection( ctx );
 800ecfa:	4718      	bx	r3

0800ecfc <BSP_ACCELERO_Enable_Single_Tap_Detection_Ext>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
   
    /*just INT2_PIN is linked to MCU */
  if(int_pin != INT2_PIN)
 800ecfc:	2901      	cmp	r1, #1
 800ecfe:	d001      	beq.n	800ed04 <BSP_ACCELERO_Enable_Single_Tap_Detection_Ext+0x8>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ed00:	2001      	movs	r0, #1
 800ed02:	4770      	bx	lr
  if(ctx == NULL)
 800ed04:	2800      	cmp	r0, #0
 800ed06:	d0fb      	beq.n	800ed00 <BSP_ACCELERO_Enable_Single_Tap_Detection_Ext+0x4>
  if ( ctx->pExtVTable == NULL )
 800ed08:	6902      	ldr	r2, [r0, #16]
 800ed0a:	2a00      	cmp	r2, #0
 800ed0c:	d0f8      	beq.n	800ed00 <BSP_ACCELERO_Enable_Single_Tap_Detection_Ext+0x4>
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ed0e:	7803      	ldrb	r3, [r0, #0]
 800ed10:	2b6a      	cmp	r3, #106	; 0x6a
 800ed12:	d1f5      	bne.n	800ed00 <BSP_ACCELERO_Enable_Single_Tap_Detection_Ext+0x4>
    if ( extDriver->Enable_Single_Tap_Detection == NULL )
 800ed14:	6c93      	ldr	r3, [r2, #72]	; 0x48
 800ed16:	2b00      	cmp	r3, #0
 800ed18:	d0f2      	beq.n	800ed00 <BSP_ACCELERO_Enable_Single_Tap_Detection_Ext+0x4>
      return extDriver->Enable_Single_Tap_Detection( ctx ,int_pin);
 800ed1a:	4718      	bx	r3

0800ed1c <BSP_ACCELERO_Disable_Single_Tap_Detection_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Disable_Single_Tap_Detection_Ext( void *handle )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ed1c:	b120      	cbz	r0, 800ed28 <BSP_ACCELERO_Disable_Single_Tap_Detection_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ed1e:	6902      	ldr	r2, [r0, #16]
 800ed20:	b112      	cbz	r2, 800ed28 <BSP_ACCELERO_Disable_Single_Tap_Detection_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ed22:	7803      	ldrb	r3, [r0, #0]
 800ed24:	2b6a      	cmp	r3, #106	; 0x6a
 800ed26:	d001      	beq.n	800ed2c <BSP_ACCELERO_Disable_Single_Tap_Detection_Ext+0x10>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ed28:	2001      	movs	r0, #1
 800ed2a:	4770      	bx	lr
    if ( extDriver->Disable_Single_Tap_Detection == NULL )
 800ed2c:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 800ed2e:	2b00      	cmp	r3, #0
 800ed30:	d0fa      	beq.n	800ed28 <BSP_ACCELERO_Disable_Single_Tap_Detection_Ext+0xc>
      return extDriver->Disable_Single_Tap_Detection( ctx );
 800ed32:	4718      	bx	r3

0800ed34 <BSP_ACCELERO_Enable_Double_Tap_Detection_Ext>:

{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  /*just INT2_PIN is linked to MCU */
  if(int_pin != INT2_PIN)
 800ed34:	2901      	cmp	r1, #1
 800ed36:	d001      	beq.n	800ed3c <BSP_ACCELERO_Enable_Double_Tap_Detection_Ext+0x8>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ed38:	2001      	movs	r0, #1
 800ed3a:	4770      	bx	lr
  if(ctx == NULL)
 800ed3c:	2800      	cmp	r0, #0
 800ed3e:	d0fb      	beq.n	800ed38 <BSP_ACCELERO_Enable_Double_Tap_Detection_Ext+0x4>
  if ( ctx->pExtVTable == NULL )
 800ed40:	6902      	ldr	r2, [r0, #16]
 800ed42:	2a00      	cmp	r2, #0
 800ed44:	d0f8      	beq.n	800ed38 <BSP_ACCELERO_Enable_Double_Tap_Detection_Ext+0x4>
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ed46:	7803      	ldrb	r3, [r0, #0]
 800ed48:	2b6a      	cmp	r3, #106	; 0x6a
 800ed4a:	d1f5      	bne.n	800ed38 <BSP_ACCELERO_Enable_Double_Tap_Detection_Ext+0x4>
    if ( extDriver->Enable_Double_Tap_Detection == NULL )
 800ed4c:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800ed4e:	2b00      	cmp	r3, #0
 800ed50:	d0f2      	beq.n	800ed38 <BSP_ACCELERO_Enable_Double_Tap_Detection_Ext+0x4>
      return extDriver->Enable_Double_Tap_Detection( ctx ,int_pin);
 800ed52:	4718      	bx	r3

0800ed54 <BSP_ACCELERO_Disable_Double_Tap_Detection_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Disable_Double_Tap_Detection_Ext( void *handle )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ed54:	b120      	cbz	r0, 800ed60 <BSP_ACCELERO_Disable_Double_Tap_Detection_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ed56:	6902      	ldr	r2, [r0, #16]
 800ed58:	b112      	cbz	r2, 800ed60 <BSP_ACCELERO_Disable_Double_Tap_Detection_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ed5a:	7803      	ldrb	r3, [r0, #0]
 800ed5c:	2b6a      	cmp	r3, #106	; 0x6a
 800ed5e:	d001      	beq.n	800ed64 <BSP_ACCELERO_Disable_Double_Tap_Detection_Ext+0x10>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ed60:	2001      	movs	r0, #1
 800ed62:	4770      	bx	lr
    if ( extDriver->Disable_Double_Tap_Detection == NULL )
 800ed64:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800ed66:	2b00      	cmp	r3, #0
 800ed68:	d0fa      	beq.n	800ed60 <BSP_ACCELERO_Disable_Double_Tap_Detection_Ext+0xc>
      return extDriver->Disable_Double_Tap_Detection( ctx );
 800ed6a:	4718      	bx	r3

0800ed6c <BSP_ACCELERO_Set_Tap_Threshold_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Set_Tap_Threshold_Ext( void *handle, uint8_t thr )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ed6c:	b120      	cbz	r0, 800ed78 <BSP_ACCELERO_Set_Tap_Threshold_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ed6e:	6902      	ldr	r2, [r0, #16]
 800ed70:	b112      	cbz	r2, 800ed78 <BSP_ACCELERO_Set_Tap_Threshold_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ed72:	7803      	ldrb	r3, [r0, #0]
 800ed74:	2b6a      	cmp	r3, #106	; 0x6a
 800ed76:	d001      	beq.n	800ed7c <BSP_ACCELERO_Set_Tap_Threshold_Ext+0x10>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ed78:	2001      	movs	r0, #1
 800ed7a:	4770      	bx	lr
    if ( extDriver->Set_Tap_Threshold == NULL )
 800ed7c:	6e13      	ldr	r3, [r2, #96]	; 0x60
 800ed7e:	2b00      	cmp	r3, #0
 800ed80:	d0fa      	beq.n	800ed78 <BSP_ACCELERO_Set_Tap_Threshold_Ext+0xc>
      return extDriver->Set_Tap_Threshold( ctx, thr );
 800ed82:	4718      	bx	r3

0800ed84 <BSP_ACCELERO_Enable_6D_Orientation_Ext>:

{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  /*just INT2_PIN is linked to MCU */
  if(int_pin != INT2_PIN)
 800ed84:	2901      	cmp	r1, #1
 800ed86:	d001      	beq.n	800ed8c <BSP_ACCELERO_Enable_6D_Orientation_Ext+0x8>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ed88:	2001      	movs	r0, #1
 800ed8a:	4770      	bx	lr
  if(ctx == NULL)
 800ed8c:	2800      	cmp	r0, #0
 800ed8e:	d0fb      	beq.n	800ed88 <BSP_ACCELERO_Enable_6D_Orientation_Ext+0x4>
  if ( ctx->pExtVTable == NULL )
 800ed90:	6902      	ldr	r2, [r0, #16]
 800ed92:	2a00      	cmp	r2, #0
 800ed94:	d0f8      	beq.n	800ed88 <BSP_ACCELERO_Enable_6D_Orientation_Ext+0x4>
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ed96:	7803      	ldrb	r3, [r0, #0]
 800ed98:	2b6a      	cmp	r3, #106	; 0x6a
 800ed9a:	d1f5      	bne.n	800ed88 <BSP_ACCELERO_Enable_6D_Orientation_Ext+0x4>
    if ( extDriver->Enable_6D_Orientation == NULL )
 800ed9c:	6f13      	ldr	r3, [r2, #112]	; 0x70
 800ed9e:	2b00      	cmp	r3, #0
 800eda0:	d0f2      	beq.n	800ed88 <BSP_ACCELERO_Enable_6D_Orientation_Ext+0x4>
      return extDriver->Enable_6D_Orientation( ctx ,int_pin);
 800eda2:	4718      	bx	r3

0800eda4 <BSP_ACCELERO_Disable_6D_Orientation_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Disable_6D_Orientation_Ext( void *handle )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800eda4:	b120      	cbz	r0, 800edb0 <BSP_ACCELERO_Disable_6D_Orientation_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800eda6:	6902      	ldr	r2, [r0, #16]
 800eda8:	b112      	cbz	r2, 800edb0 <BSP_ACCELERO_Disable_6D_Orientation_Ext+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800edaa:	7803      	ldrb	r3, [r0, #0]
 800edac:	2b6a      	cmp	r3, #106	; 0x6a
 800edae:	d001      	beq.n	800edb4 <BSP_ACCELERO_Disable_6D_Orientation_Ext+0x10>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800edb0:	2001      	movs	r0, #1
 800edb2:	4770      	bx	lr
    if ( extDriver->Disable_6D_Orientation == NULL )
 800edb4:	6f53      	ldr	r3, [r2, #116]	; 0x74
 800edb6:	2b00      	cmp	r3, #0
 800edb8:	d0fa      	beq.n	800edb0 <BSP_ACCELERO_Disable_6D_Orientation_Ext+0xc>
      return extDriver->Disable_6D_Orientation( ctx );
 800edba:	4718      	bx	r3

0800edbc <BSP_ACCELERO_Get_6D_Orientation_XL_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Get_6D_Orientation_XL_Ext( void *handle, uint8_t *xl )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800edbc:	b150      	cbz	r0, 800edd4 <BSP_ACCELERO_Get_6D_Orientation_XL_Ext+0x18>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800edbe:	6902      	ldr	r2, [r0, #16]
 800edc0:	b142      	cbz	r2, 800edd4 <BSP_ACCELERO_Get_6D_Orientation_XL_Ext+0x18>
{
 800edc2:	b410      	push	{r4}
  {
    return COMPONENT_ERROR;
  }
  
  if ( xl == NULL )
 800edc4:	b111      	cbz	r1, 800edcc <BSP_ACCELERO_Get_6D_Orientation_XL_Ext+0x10>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800edc6:	7803      	ldrb	r3, [r0, #0]
 800edc8:	2b6a      	cmp	r3, #106	; 0x6a
 800edca:	d005      	beq.n	800edd8 <BSP_ACCELERO_Get_6D_Orientation_XL_Ext+0x1c>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800edcc:	2001      	movs	r0, #1
 800edce:	f85d 4b04 	ldr.w	r4, [sp], #4
 800edd2:	4770      	bx	lr
 800edd4:	2001      	movs	r0, #1
 800edd6:	4770      	bx	lr
    if ( extDriver->Get_6D_Orientation_XL == NULL )
 800edd8:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
 800edda:	2b00      	cmp	r3, #0
 800eddc:	d0f6      	beq.n	800edcc <BSP_ACCELERO_Get_6D_Orientation_XL_Ext+0x10>
}
 800edde:	f85d 4b04 	ldr.w	r4, [sp], #4
      return extDriver->Get_6D_Orientation_XL( ctx, xl );
 800ede2:	4718      	bx	r3

0800ede4 <BSP_ACCELERO_Get_6D_Orientation_XH_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Get_6D_Orientation_XH_Ext( void *handle, uint8_t *xh )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ede4:	b150      	cbz	r0, 800edfc <BSP_ACCELERO_Get_6D_Orientation_XH_Ext+0x18>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ede6:	6902      	ldr	r2, [r0, #16]
 800ede8:	b142      	cbz	r2, 800edfc <BSP_ACCELERO_Get_6D_Orientation_XH_Ext+0x18>
{
 800edea:	b410      	push	{r4}
  {
    return COMPONENT_ERROR;
  }
  
  if ( xh == NULL )
 800edec:	b111      	cbz	r1, 800edf4 <BSP_ACCELERO_Get_6D_Orientation_XH_Ext+0x10>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800edee:	7803      	ldrb	r3, [r0, #0]
 800edf0:	2b6a      	cmp	r3, #106	; 0x6a
 800edf2:	d005      	beq.n	800ee00 <BSP_ACCELERO_Get_6D_Orientation_XH_Ext+0x1c>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800edf4:	2001      	movs	r0, #1
 800edf6:	f85d 4b04 	ldr.w	r4, [sp], #4
 800edfa:	4770      	bx	lr
 800edfc:	2001      	movs	r0, #1
 800edfe:	4770      	bx	lr
    if ( extDriver->Get_6D_Orientation_XH == NULL )
 800ee00:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 800ee04:	2b00      	cmp	r3, #0
 800ee06:	d0f5      	beq.n	800edf4 <BSP_ACCELERO_Get_6D_Orientation_XH_Ext+0x10>
}
 800ee08:	f85d 4b04 	ldr.w	r4, [sp], #4
      return extDriver->Get_6D_Orientation_XH( ctx, xh );
 800ee0c:	4718      	bx	r3
 800ee0e:	bf00      	nop

0800ee10 <BSP_ACCELERO_Get_6D_Orientation_YL_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Get_6D_Orientation_YL_Ext( void *handle, uint8_t *yl )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ee10:	b150      	cbz	r0, 800ee28 <BSP_ACCELERO_Get_6D_Orientation_YL_Ext+0x18>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ee12:	6902      	ldr	r2, [r0, #16]
 800ee14:	b142      	cbz	r2, 800ee28 <BSP_ACCELERO_Get_6D_Orientation_YL_Ext+0x18>
{
 800ee16:	b410      	push	{r4}
  {
    return COMPONENT_ERROR;
  }
  
  if ( yl == NULL )
 800ee18:	b111      	cbz	r1, 800ee20 <BSP_ACCELERO_Get_6D_Orientation_YL_Ext+0x10>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ee1a:	7803      	ldrb	r3, [r0, #0]
 800ee1c:	2b6a      	cmp	r3, #106	; 0x6a
 800ee1e:	d005      	beq.n	800ee2c <BSP_ACCELERO_Get_6D_Orientation_YL_Ext+0x1c>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ee20:	2001      	movs	r0, #1
 800ee22:	f85d 4b04 	ldr.w	r4, [sp], #4
 800ee26:	4770      	bx	lr
 800ee28:	2001      	movs	r0, #1
 800ee2a:	4770      	bx	lr
    if ( extDriver->Get_6D_Orientation_YL == NULL )
 800ee2c:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
 800ee30:	2b00      	cmp	r3, #0
 800ee32:	d0f5      	beq.n	800ee20 <BSP_ACCELERO_Get_6D_Orientation_YL_Ext+0x10>
}
 800ee34:	f85d 4b04 	ldr.w	r4, [sp], #4
      return extDriver->Get_6D_Orientation_YL( ctx, yl );
 800ee38:	4718      	bx	r3
 800ee3a:	bf00      	nop

0800ee3c <BSP_ACCELERO_Get_6D_Orientation_YH_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Get_6D_Orientation_YH_Ext( void *handle, uint8_t *yh )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ee3c:	b150      	cbz	r0, 800ee54 <BSP_ACCELERO_Get_6D_Orientation_YH_Ext+0x18>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ee3e:	6902      	ldr	r2, [r0, #16]
 800ee40:	b142      	cbz	r2, 800ee54 <BSP_ACCELERO_Get_6D_Orientation_YH_Ext+0x18>
{
 800ee42:	b410      	push	{r4}
  {
    return COMPONENT_ERROR;
  }
  
  if ( yh == NULL )
 800ee44:	b111      	cbz	r1, 800ee4c <BSP_ACCELERO_Get_6D_Orientation_YH_Ext+0x10>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ee46:	7803      	ldrb	r3, [r0, #0]
 800ee48:	2b6a      	cmp	r3, #106	; 0x6a
 800ee4a:	d005      	beq.n	800ee58 <BSP_ACCELERO_Get_6D_Orientation_YH_Ext+0x1c>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ee4c:	2001      	movs	r0, #1
 800ee4e:	f85d 4b04 	ldr.w	r4, [sp], #4
 800ee52:	4770      	bx	lr
 800ee54:	2001      	movs	r0, #1
 800ee56:	4770      	bx	lr
    if ( extDriver->Get_6D_Orientation_YH == NULL )
 800ee58:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800ee5c:	2b00      	cmp	r3, #0
 800ee5e:	d0f5      	beq.n	800ee4c <BSP_ACCELERO_Get_6D_Orientation_YH_Ext+0x10>
}
 800ee60:	f85d 4b04 	ldr.w	r4, [sp], #4
      return extDriver->Get_6D_Orientation_YH( ctx, yh );
 800ee64:	4718      	bx	r3
 800ee66:	bf00      	nop

0800ee68 <BSP_ACCELERO_Get_6D_Orientation_ZL_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Get_6D_Orientation_ZL_Ext( void *handle, uint8_t *zl )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ee68:	b150      	cbz	r0, 800ee80 <BSP_ACCELERO_Get_6D_Orientation_ZL_Ext+0x18>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ee6a:	6902      	ldr	r2, [r0, #16]
 800ee6c:	b142      	cbz	r2, 800ee80 <BSP_ACCELERO_Get_6D_Orientation_ZL_Ext+0x18>
{
 800ee6e:	b410      	push	{r4}
  {
    return COMPONENT_ERROR;
  }
  
  if ( zl == NULL )
 800ee70:	b111      	cbz	r1, 800ee78 <BSP_ACCELERO_Get_6D_Orientation_ZL_Ext+0x10>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ee72:	7803      	ldrb	r3, [r0, #0]
 800ee74:	2b6a      	cmp	r3, #106	; 0x6a
 800ee76:	d005      	beq.n	800ee84 <BSP_ACCELERO_Get_6D_Orientation_ZL_Ext+0x1c>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800ee78:	2001      	movs	r0, #1
 800ee7a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800ee7e:	4770      	bx	lr
 800ee80:	2001      	movs	r0, #1
 800ee82:	4770      	bx	lr
    if ( extDriver->Get_6D_Orientation_ZL == NULL )
 800ee84:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 800ee88:	2b00      	cmp	r3, #0
 800ee8a:	d0f5      	beq.n	800ee78 <BSP_ACCELERO_Get_6D_Orientation_ZL_Ext+0x10>
}
 800ee8c:	f85d 4b04 	ldr.w	r4, [sp], #4
      return extDriver->Get_6D_Orientation_ZL( ctx, zl );
 800ee90:	4718      	bx	r3
 800ee92:	bf00      	nop

0800ee94 <BSP_ACCELERO_Get_6D_Orientation_ZH_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Get_6D_Orientation_ZH_Ext( void *handle, uint8_t *zh )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 800ee94:	b150      	cbz	r0, 800eeac <BSP_ACCELERO_Get_6D_Orientation_ZH_Ext+0x18>
  {
    return COMPONENT_ERROR;
  }
  
  if ( ctx->pExtVTable == NULL )
 800ee96:	6902      	ldr	r2, [r0, #16]
 800ee98:	b142      	cbz	r2, 800eeac <BSP_ACCELERO_Get_6D_Orientation_ZH_Ext+0x18>
{
 800ee9a:	b410      	push	{r4}
  {
    return COMPONENT_ERROR;
  }
  
  if ( zh == NULL )
 800ee9c:	b111      	cbz	r1, 800eea4 <BSP_ACCELERO_Get_6D_Orientation_ZH_Ext+0x10>
  {
    return COMPONENT_ERROR;
  }
  
  /* At the moment this feature is only implemented for LSM6DSM */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800ee9e:	7803      	ldrb	r3, [r0, #0]
 800eea0:	2b6a      	cmp	r3, #106	; 0x6a
 800eea2:	d005      	beq.n	800eeb0 <BSP_ACCELERO_Get_6D_Orientation_ZH_Ext+0x1c>
  
  else
  {
    return COMPONENT_ERROR;
  }
}
 800eea4:	2001      	movs	r0, #1
 800eea6:	f85d 4b04 	ldr.w	r4, [sp], #4
 800eeaa:	4770      	bx	lr
 800eeac:	2001      	movs	r0, #1
 800eeae:	4770      	bx	lr
    if ( extDriver->Get_6D_Orientation_ZH == NULL )
 800eeb0:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 800eeb4:	2b00      	cmp	r3, #0
 800eeb6:	d0f5      	beq.n	800eea4 <BSP_ACCELERO_Get_6D_Orientation_ZH_Ext+0x10>
}
 800eeb8:	f85d 4b04 	ldr.w	r4, [sp], #4
      return extDriver->Get_6D_Orientation_ZH( ctx, zh );
 800eebc:	4718      	bx	r3
 800eebe:	bf00      	nop

0800eec0 <BSP_ACCELERO_Get_Event_Status_Ext>:
DrvStatusTypeDef BSP_ACCELERO_Get_Event_Status_Ext( void *handle, ACCELERO_Event_Status_t *status )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;

  if(ctx == NULL)
 800eec0:	b150      	cbz	r0, 800eed8 <BSP_ACCELERO_Get_Event_Status_Ext+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( ctx->pExtVTable == NULL )
 800eec2:	6902      	ldr	r2, [r0, #16]
 800eec4:	b142      	cbz	r2, 800eed8 <BSP_ACCELERO_Get_Event_Status_Ext+0x18>
{
 800eec6:	b410      	push	{r4}
  {
    return COMPONENT_ERROR;
  }

  if ( status == NULL )
 800eec8:	b111      	cbz	r1, 800eed0 <BSP_ACCELERO_Get_Event_Status_Ext+0x10>
  {
    return COMPONENT_ERROR;
  }

  /* At the moment this feature is only implemented for LSM6DSL */
  if ( ctx->who_am_i == LSM6DSM_ACC_GYRO_WHO_AM_I )
 800eeca:	7803      	ldrb	r3, [r0, #0]
 800eecc:	2b6a      	cmp	r3, #106	; 0x6a
 800eece:	d005      	beq.n	800eedc <BSP_ACCELERO_Get_Event_Status_Ext+0x1c>

  else
  {
    return COMPONENT_ERROR;
  }
}
 800eed0:	2001      	movs	r0, #1
 800eed2:	f85d 4b04 	ldr.w	r4, [sp], #4
 800eed6:	4770      	bx	lr
 800eed8:	2001      	movs	r0, #1
 800eeda:	4770      	bx	lr
    if ( extDriver->Get_Event_Status == NULL )
 800eedc:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 800eee0:	2b00      	cmp	r3, #0
 800eee2:	d0f5      	beq.n	800eed0 <BSP_ACCELERO_Get_Event_Status_Ext+0x10>
}
 800eee4:	f85d 4b04 	ldr.w	r4, [sp], #4
      return extDriver->Get_Event_Status( ctx, status );
 800eee8:	4718      	bx	r3
 800eeea:	bf00      	nop

0800eeec <DFSDMx_FilterMspInit>:
static void DFSDMx_FilterMspInit(DFSDM_Filter_HandleTypeDef *hdfsdm_filter) 
{
  DMA_HandleTypeDef *hdma_dfsdmReg=NULL;
  
  /* Enable DFSDM clock */
  AUDIO_IN_DFSDM_CLK_ENABLE();  
 800eeec:	4b51      	ldr	r3, [pc, #324]	; (800f034 <DFSDMx_FilterMspInit+0x148>)
  /* Enable the DMA clock */
  AUDIO_IN_DFSDM_DMA_CLK_ENABLE() ;
  
  if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_1st_FILTER) 
 800eeee:	4952      	ldr	r1, [pc, #328]	; (800f038 <DFSDMx_FilterMspInit+0x14c>)
  AUDIO_IN_DFSDM_CLK_ENABLE();  
 800eef0:	6e1a      	ldr	r2, [r3, #96]	; 0x60
{
 800eef2:	b530      	push	{r4, r5, lr}
  AUDIO_IN_DFSDM_CLK_ENABLE();  
 800eef4:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800eef8:	661a      	str	r2, [r3, #96]	; 0x60
 800eefa:	6e1a      	ldr	r2, [r3, #96]	; 0x60
{
 800eefc:	b083      	sub	sp, #12
  AUDIO_IN_DFSDM_CLK_ENABLE();  
 800eefe:	f002 7280 	and.w	r2, r2, #16777216	; 0x1000000
 800ef02:	9200      	str	r2, [sp, #0]
 800ef04:	9a00      	ldr	r2, [sp, #0]
  AUDIO_IN_DFSDM_DMA_CLK_ENABLE() ;
 800ef06:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800ef08:	f042 0201 	orr.w	r2, r2, #1
 800ef0c:	649a      	str	r2, [r3, #72]	; 0x48
 800ef0e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_1st_FILTER) 
 800ef10:	6802      	ldr	r2, [r0, #0]
  AUDIO_IN_DFSDM_DMA_CLK_ENABLE() ;
 800ef12:	f003 0301 	and.w	r3, r3, #1
 800ef16:	9301      	str	r3, [sp, #4]
  if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_1st_FILTER) 
 800ef18:	428a      	cmp	r2, r1
  AUDIO_IN_DFSDM_DMA_CLK_ENABLE() ;
 800ef1a:	9b01      	ldr	r3, [sp, #4]
  if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_1st_FILTER) 
 800ef1c:	d030      	beq.n	800ef80 <DFSDMx_FilterMspInit+0x94>
  {
    hdma_dfsdmReg = &hdma_dfsdmReg_FLT[0];
  } 
  else if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_2st_FILTER) 
 800ef1e:	4b47      	ldr	r3, [pc, #284]	; (800f03c <DFSDMx_FilterMspInit+0x150>)
 800ef20:	429a      	cmp	r2, r3
 800ef22:	d008      	beq.n	800ef36 <DFSDMx_FilterMspInit+0x4a>
  {
    hdma_dfsdmReg = &hdma_dfsdmReg_FLT[1];
  } 
  else if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_3rd_FILTER) 
 800ef24:	3380      	adds	r3, #128	; 0x80
 800ef26:	429a      	cmp	r2, r3
 800ef28:	d04a      	beq.n	800efc0 <DFSDMx_FilterMspInit+0xd4>
  {
    hdma_dfsdmReg = &hdma_dfsdmReg_FLT[2];
  } 
  else if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_4th_FILTER) 
 800ef2a:	3380      	adds	r3, #128	; 0x80
 800ef2c:	429a      	cmp	r2, r3
 800ef2e:	d064      	beq.n	800effa <DFSDMx_FilterMspInit+0x10e>
  {
    hdma_dfsdmReg = &hdma_dfsdmReg_FLT[3];
  }
  
  /* Configure the hdma_dfsdmReg handle parameters */
  hdma_dfsdmReg->Init.Request = DMA_REQUEST_0;
 800ef30:	2300      	movs	r3, #0
 800ef32:	605b      	str	r3, [r3, #4]
 800ef34:	deff      	udf	#255	; 0xff
 800ef36:	4a42      	ldr	r2, [pc, #264]	; (800f040 <DFSDMx_FilterMspInit+0x154>)
  {
    hdma_dfsdmReg->Instance = AUDIO_IN_DFSDM_DMA_1st_CHANNEL;
  } 
  else if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_2st_FILTER) 
  {
    hdma_dfsdmReg->Instance = AUDIO_IN_DFSDM_DMA_2nd_CHANNEL;
 800ef38:	4c42      	ldr	r4, [pc, #264]	; (800f044 <DFSDMx_FilterMspInit+0x158>)
  hdma_dfsdmReg->Init.PeriphDataAlignment = AUDIO_IN_DFSDM_DMA_PERIPH_DATA_SIZE;
 800ef3a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800ef3e:	65d1      	str	r1, [r2, #92]	; 0x5c
  hdma_dfsdmReg->Init.Mode = DMA_CIRCULAR;
 800ef40:	2120      	movs	r1, #32
  hdma_dfsdmReg->Init.MemInc = DMA_MINC_ENABLE;
 800ef42:	2580      	movs	r5, #128	; 0x80
    hdma_dfsdmReg->Instance = AUDIO_IN_DFSDM_DMA_2nd_CHANNEL;
 800ef44:	4613      	mov	r3, r2
  hdma_dfsdmReg->Init.Mode = DMA_CIRCULAR;
 800ef46:	6651      	str	r1, [r2, #100]	; 0x64
  hdma_dfsdmReg->Init.Request = DMA_REQUEST_0;
 800ef48:	2100      	movs	r1, #0
  hdma_dfsdmReg->Init.MemInc = DMA_MINC_ENABLE;
 800ef4a:	6595      	str	r5, [r2, #88]	; 0x58
  hdma_dfsdmReg->Init.Direction = DMA_PERIPH_TO_MEMORY;
 800ef4c:	e9c2 1113 	strd	r1, r1, [r2, #76]	; 0x4c
  hdma_dfsdmReg->Init.MemDataAlignment = AUDIO_IN_DFSDM_DMA_MEM_DATA_SIZE;
 800ef50:	f44f 6500 	mov.w	r5, #2048	; 0x800
 800ef54:	6615      	str	r5, [r2, #96]	; 0x60
    hdma_dfsdmReg->Instance = AUDIO_IN_DFSDM_DMA_2nd_CHANNEL;
 800ef56:	f843 4f48 	str.w	r4, [r3, #72]!
  hdma_dfsdmReg->Init.Priority = DMA_PRIORITY_HIGH;
 800ef5a:	f44f 5500 	mov.w	r5, #8192	; 0x2000
 800ef5e:	6695      	str	r5, [r2, #104]	; 0x68
  hdma_dfsdmReg->Init.PeriphInc = DMA_PINC_DISABLE;
 800ef60:	6551      	str	r1, [r2, #84]	; 0x54
 800ef62:	4604      	mov	r4, r0
  
  /* Associate the DMA handle */
  __HAL_LINKDMA(hdfsdm_filter, hdmaReg, *hdma_dfsdmReg);
  
  /* Reset DMA handle state */
  __HAL_DMA_RESET_HANDLE_STATE(hdma_dfsdmReg);
 800ef64:	2500      	movs	r5, #0
  __HAL_LINKDMA(hdfsdm_filter, hdmaReg, *hdma_dfsdmReg);
 800ef66:	6283      	str	r3, [r0, #40]	; 0x28
  
  /* Configure the DMA Channel */
  HAL_DMA_Init(hdma_dfsdmReg);
 800ef68:	4618      	mov	r0, r3
  __HAL_LINKDMA(hdfsdm_filter, hdmaReg, *hdma_dfsdmReg);
 800ef6a:	629c      	str	r4, [r3, #40]	; 0x28
  __HAL_DMA_RESET_HANDLE_STATE(hdma_dfsdmReg);
 800ef6c:	f883 5025 	strb.w	r5, [r3, #37]	; 0x25
  HAL_DMA_Init(hdma_dfsdmReg);
 800ef70:	f001 fdba 	bl	8010ae8 <HAL_DMA_Init>
  
  /* DMA IRQ Channel configuration */
  if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_1st_FILTER) 
 800ef74:	6822      	ldr	r2, [r4, #0]
 800ef76:	4b30      	ldr	r3, [pc, #192]	; (800f038 <DFSDMx_FilterMspInit+0x14c>)
 800ef78:	429a      	cmp	r2, r3
 800ef7a:	d016      	beq.n	800efaa <DFSDMx_FilterMspInit+0xbe>
  {
    HAL_NVIC_SetPriority(AUDIO_IN_DFSDM_DMA_1st_CH_IRQn,
                         AUDIO_IN_IRQ_PREPRIO, 0);
    HAL_NVIC_EnableIRQ(AUDIO_IN_DFSDM_DMA_1st_CH_IRQn);
  } 
}
 800ef7c:	b003      	add	sp, #12
 800ef7e:	bd30      	pop	{r4, r5, pc}
  hdma_dfsdmReg->Init.Request = DMA_REQUEST_0;
 800ef80:	4b2f      	ldr	r3, [pc, #188]	; (800f040 <DFSDMx_FilterMspInit+0x154>)
    hdma_dfsdmReg->Instance = AUDIO_IN_DFSDM_DMA_1st_CHANNEL;
 800ef82:	4a31      	ldr	r2, [pc, #196]	; (800f048 <DFSDMx_FilterMspInit+0x15c>)
 800ef84:	601a      	str	r2, [r3, #0]
  hdma_dfsdmReg->Init.MemInc = DMA_MINC_ENABLE;
 800ef86:	2180      	movs	r1, #128	; 0x80
  hdma_dfsdmReg->Init.PeriphDataAlignment = AUDIO_IN_DFSDM_DMA_PERIPH_DATA_SIZE;
 800ef88:	f44f 7200 	mov.w	r2, #512	; 0x200
  hdma_dfsdmReg->Init.MemDataAlignment = AUDIO_IN_DFSDM_DMA_MEM_DATA_SIZE;
 800ef8c:	f44f 6500 	mov.w	r5, #2048	; 0x800
  hdma_dfsdmReg->Init.Mode = DMA_CIRCULAR;
 800ef90:	2420      	movs	r4, #32
  hdma_dfsdmReg->Init.MemInc = DMA_MINC_ENABLE;
 800ef92:	6119      	str	r1, [r3, #16]
  hdma_dfsdmReg->Init.PeriphDataAlignment = AUDIO_IN_DFSDM_DMA_PERIPH_DATA_SIZE;
 800ef94:	615a      	str	r2, [r3, #20]
  hdma_dfsdmReg->Init.Priority = DMA_PRIORITY_HIGH;
 800ef96:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  hdma_dfsdmReg->Init.Request = DMA_REQUEST_0;
 800ef9a:	2200      	movs	r2, #0
  hdma_dfsdmReg->Init.Mode = DMA_CIRCULAR;
 800ef9c:	e9c3 5406 	strd	r5, r4, [r3, #24]
  hdma_dfsdmReg->Init.Priority = DMA_PRIORITY_HIGH;
 800efa0:	6219      	str	r1, [r3, #32]
  hdma_dfsdmReg->Init.Direction = DMA_PERIPH_TO_MEMORY;
 800efa2:	e9c3 2201 	strd	r2, r2, [r3, #4]
  hdma_dfsdmReg->Init.PeriphInc = DMA_PINC_DISABLE;
 800efa6:	60da      	str	r2, [r3, #12]
 800efa8:	e7db      	b.n	800ef62 <DFSDMx_FilterMspInit+0x76>
    HAL_NVIC_SetPriority(AUDIO_IN_DFSDM_DMA_1st_CH_IRQn,
 800efaa:	462a      	mov	r2, r5
 800efac:	2106      	movs	r1, #6
 800efae:	200e      	movs	r0, #14
 800efb0:	f001 fac8 	bl	8010544 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(AUDIO_IN_DFSDM_DMA_1st_CH_IRQn);
 800efb4:	200e      	movs	r0, #14
}
 800efb6:	b003      	add	sp, #12
 800efb8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    HAL_NVIC_EnableIRQ(AUDIO_IN_DFSDM_DMA_1st_CH_IRQn);
 800efbc:	f001 baf8 	b.w	80105b0 <HAL_NVIC_EnableIRQ>
  hdma_dfsdmReg->Init.Request = DMA_REQUEST_0;
 800efc0:	4a1f      	ldr	r2, [pc, #124]	; (800f040 <DFSDMx_FilterMspInit+0x154>)
    hdma_dfsdmReg->Instance = AUDIO_IN_DFSDM_DMA_3rd_CHANNEL;
 800efc2:	4c22      	ldr	r4, [pc, #136]	; (800f04c <DFSDMx_FilterMspInit+0x160>)
  hdma_dfsdmReg->Init.MemInc = DMA_MINC_ENABLE;
 800efc4:	2580      	movs	r5, #128	; 0x80
  hdma_dfsdmReg->Init.PeriphDataAlignment = AUDIO_IN_DFSDM_DMA_PERIPH_DATA_SIZE;
 800efc6:	f44f 7100 	mov.w	r1, #512	; 0x200
    hdma_dfsdmReg->Instance = AUDIO_IN_DFSDM_DMA_3rd_CHANNEL;
 800efca:	4613      	mov	r3, r2
  hdma_dfsdmReg->Init.MemInc = DMA_MINC_ENABLE;
 800efcc:	f8c2 50a0 	str.w	r5, [r2, #160]	; 0xa0
  hdma_dfsdmReg->Init.PeriphDataAlignment = AUDIO_IN_DFSDM_DMA_PERIPH_DATA_SIZE;
 800efd0:	f8c2 10a4 	str.w	r1, [r2, #164]	; 0xa4
  hdma_dfsdmReg->Init.MemDataAlignment = AUDIO_IN_DFSDM_DMA_MEM_DATA_SIZE;
 800efd4:	f44f 6500 	mov.w	r5, #2048	; 0x800
  hdma_dfsdmReg->Init.Mode = DMA_CIRCULAR;
 800efd8:	2120      	movs	r1, #32
  hdma_dfsdmReg->Init.MemDataAlignment = AUDIO_IN_DFSDM_DMA_MEM_DATA_SIZE;
 800efda:	f8c2 50a8 	str.w	r5, [r2, #168]	; 0xa8
  hdma_dfsdmReg->Init.Mode = DMA_CIRCULAR;
 800efde:	f8c2 10ac 	str.w	r1, [r2, #172]	; 0xac
  hdma_dfsdmReg->Init.Priority = DMA_PRIORITY_HIGH;
 800efe2:	f44f 5500 	mov.w	r5, #8192	; 0x2000
  hdma_dfsdmReg->Init.Request = DMA_REQUEST_0;
 800efe6:	2100      	movs	r1, #0
  hdma_dfsdmReg->Init.Priority = DMA_PRIORITY_HIGH;
 800efe8:	f8c2 50b0 	str.w	r5, [r2, #176]	; 0xb0
    hdma_dfsdmReg->Instance = AUDIO_IN_DFSDM_DMA_3rd_CHANNEL;
 800efec:	f843 4f90 	str.w	r4, [r3, #144]!
  hdma_dfsdmReg->Init.Direction = DMA_PERIPH_TO_MEMORY;
 800eff0:	e9c2 1125 	strd	r1, r1, [r2, #148]	; 0x94
  hdma_dfsdmReg->Init.PeriphInc = DMA_PINC_DISABLE;
 800eff4:	f8c2 109c 	str.w	r1, [r2, #156]	; 0x9c
 800eff8:	e7b3      	b.n	800ef62 <DFSDMx_FilterMspInit+0x76>
  hdma_dfsdmReg->Init.Request = DMA_REQUEST_0;
 800effa:	4a11      	ldr	r2, [pc, #68]	; (800f040 <DFSDMx_FilterMspInit+0x154>)
    hdma_dfsdmReg->Instance = AUDIO_IN_DFSDM_DMA_4th_CHANNEL;
 800effc:	4c14      	ldr	r4, [pc, #80]	; (800f050 <DFSDMx_FilterMspInit+0x164>)
  hdma_dfsdmReg->Init.MemInc = DMA_MINC_ENABLE;
 800effe:	2580      	movs	r5, #128	; 0x80
  hdma_dfsdmReg->Init.PeriphDataAlignment = AUDIO_IN_DFSDM_DMA_PERIPH_DATA_SIZE;
 800f000:	f44f 7100 	mov.w	r1, #512	; 0x200
    hdma_dfsdmReg->Instance = AUDIO_IN_DFSDM_DMA_4th_CHANNEL;
 800f004:	4613      	mov	r3, r2
  hdma_dfsdmReg->Init.MemInc = DMA_MINC_ENABLE;
 800f006:	f8c2 50e8 	str.w	r5, [r2, #232]	; 0xe8
  hdma_dfsdmReg->Init.PeriphDataAlignment = AUDIO_IN_DFSDM_DMA_PERIPH_DATA_SIZE;
 800f00a:	f8c2 10ec 	str.w	r1, [r2, #236]	; 0xec
  hdma_dfsdmReg->Init.MemDataAlignment = AUDIO_IN_DFSDM_DMA_MEM_DATA_SIZE;
 800f00e:	f44f 6500 	mov.w	r5, #2048	; 0x800
  hdma_dfsdmReg->Init.Mode = DMA_CIRCULAR;
 800f012:	2120      	movs	r1, #32
  hdma_dfsdmReg->Init.MemDataAlignment = AUDIO_IN_DFSDM_DMA_MEM_DATA_SIZE;
 800f014:	f8c2 50f0 	str.w	r5, [r2, #240]	; 0xf0
  hdma_dfsdmReg->Init.Mode = DMA_CIRCULAR;
 800f018:	f8c2 10f4 	str.w	r1, [r2, #244]	; 0xf4
  hdma_dfsdmReg->Init.Priority = DMA_PRIORITY_HIGH;
 800f01c:	f44f 5500 	mov.w	r5, #8192	; 0x2000
  hdma_dfsdmReg->Init.Request = DMA_REQUEST_0;
 800f020:	2100      	movs	r1, #0
  hdma_dfsdmReg->Init.Priority = DMA_PRIORITY_HIGH;
 800f022:	f8c2 50f8 	str.w	r5, [r2, #248]	; 0xf8
    hdma_dfsdmReg->Instance = AUDIO_IN_DFSDM_DMA_4th_CHANNEL;
 800f026:	f843 4fd8 	str.w	r4, [r3, #216]!
  hdma_dfsdmReg->Init.Direction = DMA_PERIPH_TO_MEMORY;
 800f02a:	e9c2 1137 	strd	r1, r1, [r2, #220]	; 0xdc
  hdma_dfsdmReg->Init.PeriphInc = DMA_PINC_DISABLE;
 800f02e:	f8c2 10e4 	str.w	r1, [r2, #228]	; 0xe4
 800f032:	e796      	b.n	800ef62 <DFSDMx_FilterMspInit+0x76>
 800f034:	40021000 	.word	0x40021000
 800f038:	40016100 	.word	0x40016100
 800f03c:	40016180 	.word	0x40016180
 800f040:	20010498 	.word	0x20010498
 800f044:	40020058 	.word	0x40020058
 800f048:	40020044 	.word	0x40020044
 800f04c:	4002006c 	.word	0x4002006c
 800f050:	40020080 	.word	0x40020080

0800f054 <BSP_AUDIO_IN_DeInit>:
{
 800f054:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
static uint8_t DFSDMx_DeInit(void)
{
  /* De-initializes the DFSDM filters to allow access to DFSDM internal registers */
  uint16_t index = 0;
  
  for (index = 0; index < SENSORTILE_AudioIn_Handler.MicChannels; index ++)
 800f058:	4f21      	ldr	r7, [pc, #132]	; (800f0e0 <BSP_AUDIO_IN_DeInit+0x8c>)
 800f05a:	683b      	ldr	r3, [r7, #0]
 800f05c:	2b00      	cmp	r3, #0
 800f05e:	d03c      	beq.n	800f0da <BSP_AUDIO_IN_DeInit+0x86>
 800f060:	4e20      	ldr	r6, [pc, #128]	; (800f0e4 <BSP_AUDIO_IN_DeInit+0x90>)
*/
static void DFSDMx_FilterMspDeInit(DFSDM_Filter_HandleTypeDef *hdfsdm_filter)
{
  DMA_HandleTypeDef *hdma_dfsdmReg = NULL;
  
  if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_1st_FILTER) 
 800f062:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 800f108 <BSP_AUDIO_IN_DeInit+0xb4>
  {
    hdma_dfsdmReg = &hdma_dfsdmReg_FLT[0];
  } 
  else if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_2st_FILTER) 
 800f066:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 800f10c <BSP_AUDIO_IN_DeInit+0xb8>
  } 
  else if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_3rd_FILTER) 
  {
    hdma_dfsdmReg = &hdma_dfsdmReg_FLT[2];
  } 
  else if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_4th_FILTER) 
 800f06a:	f8df a0a4 	ldr.w	sl, [pc, #164]	; 800f110 <BSP_AUDIO_IN_DeInit+0xbc>
  for (index = 0; index < SENSORTILE_AudioIn_Handler.MicChannels; index ++)
 800f06e:	2400      	movs	r4, #0
 800f070:	e017      	b.n	800f0a2 <BSP_AUDIO_IN_DeInit+0x4e>
  else if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_2st_FILTER) 
 800f072:	4548      	cmp	r0, r9
  DMA_HandleTypeDef *hdma_dfsdmReg = NULL;
 800f074:	4b1c      	ldr	r3, [pc, #112]	; (800f0e8 <BSP_AUDIO_IN_DeInit+0x94>)
  else if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_2st_FILTER) 
 800f076:	d029      	beq.n	800f0cc <BSP_AUDIO_IN_DeInit+0x78>
  else if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_3rd_FILTER) 
 800f078:	4290      	cmp	r0, r2
 800f07a:	d029      	beq.n	800f0d0 <BSP_AUDIO_IN_DeInit+0x7c>
  DMA_HandleTypeDef *hdma_dfsdmReg = NULL;
 800f07c:	4550      	cmp	r0, sl
 800f07e:	bf0c      	ite	eq
 800f080:	4618      	moveq	r0, r3
 800f082:	2000      	movne	r0, #0
  {
    hdma_dfsdmReg = &hdma_dfsdmReg_FLT[3];
  }
  
  /* Configure the DMA Channel */
  HAL_DMA_DeInit(hdma_dfsdmReg);
 800f084:	f001 fd94 	bl	8010bb0 <HAL_DMA_DeInit>
  HAL_GPIO_DeInit(AUDIO_IN_DFSDM_CKOUT_GPIO_PORT, GPIO_InitStruct.Pin);
 800f088:	2104      	movs	r1, #4
 800f08a:	4818      	ldr	r0, [pc, #96]	; (800f0ec <BSP_AUDIO_IN_DeInit+0x98>)
 800f08c:	f002 f9be 	bl	801140c <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(AUDIO_IN_DFSDM_CH12_DATIN_GPIO_PORT, GPIO_InitStruct.Pin); 
 800f090:	2140      	movs	r1, #64	; 0x40
 800f092:	4817      	ldr	r0, [pc, #92]	; (800f0f0 <BSP_AUDIO_IN_DeInit+0x9c>)
 800f094:	f002 f9ba 	bl	801140c <HAL_GPIO_DeInit>
  for (index = 0; index < SENSORTILE_AudioIn_Handler.MicChannels; index ++)
 800f098:	3401      	adds	r4, #1
 800f09a:	683b      	ldr	r3, [r7, #0]
 800f09c:	b2a4      	uxth	r4, r4
 800f09e:	429c      	cmp	r4, r3
 800f0a0:	d21b      	bcs.n	800f0da <BSP_AUDIO_IN_DeInit+0x86>
    if(HAL_OK != HAL_DFSDM_FilterDeInit(&haudio_in_dfsdmfilter[index]))
 800f0a2:	2554      	movs	r5, #84	; 0x54
 800f0a4:	fb05 f504 	mul.w	r5, r5, r4
 800f0a8:	1970      	adds	r0, r6, r5
 800f0aa:	f001 fc63 	bl	8010974 <HAL_DFSDM_FilterDeInit>
    if(HAL_OK != HAL_DFSDM_ChannelDeInit(&haudio_in_dfsdmchannel[index]))
 800f0ae:	4b11      	ldr	r3, [pc, #68]	; (800f0f4 <BSP_AUDIO_IN_DeInit+0xa0>)
 800f0b0:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
    if(HAL_OK != HAL_DFSDM_FilterDeInit(&haudio_in_dfsdmfilter[index]))
 800f0b4:	b970      	cbnz	r0, 800f0d4 <BSP_AUDIO_IN_DeInit+0x80>
    if(HAL_OK != HAL_DFSDM_ChannelDeInit(&haudio_in_dfsdmchannel[index]))
 800f0b6:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
 800f0ba:	f001 fbaf 	bl	801081c <HAL_DFSDM_ChannelDeInit>
  else if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_3rd_FILTER) 
 800f0be:	4a0e      	ldr	r2, [pc, #56]	; (800f0f8 <BSP_AUDIO_IN_DeInit+0xa4>)
    if(HAL_OK != HAL_DFSDM_ChannelDeInit(&haudio_in_dfsdmchannel[index]))
 800f0c0:	b940      	cbnz	r0, 800f0d4 <BSP_AUDIO_IN_DeInit+0x80>
    DFSDMx_FilterMspDeInit(&haudio_in_dfsdmfilter[index]);  
 800f0c2:	5970      	ldr	r0, [r6, r5]
  if (hdfsdm_filter->Instance == AUDIO_IN_DFSDM_1st_FILTER) 
 800f0c4:	4540      	cmp	r0, r8
 800f0c6:	d1d4      	bne.n	800f072 <BSP_AUDIO_IN_DeInit+0x1e>
    hdma_dfsdmReg = &hdma_dfsdmReg_FLT[0];
 800f0c8:	480c      	ldr	r0, [pc, #48]	; (800f0fc <BSP_AUDIO_IN_DeInit+0xa8>)
 800f0ca:	e7db      	b.n	800f084 <BSP_AUDIO_IN_DeInit+0x30>
    hdma_dfsdmReg = &hdma_dfsdmReg_FLT[1];
 800f0cc:	480c      	ldr	r0, [pc, #48]	; (800f100 <BSP_AUDIO_IN_DeInit+0xac>)
 800f0ce:	e7d9      	b.n	800f084 <BSP_AUDIO_IN_DeInit+0x30>
    hdma_dfsdmReg = &hdma_dfsdmReg_FLT[2];
 800f0d0:	480c      	ldr	r0, [pc, #48]	; (800f104 <BSP_AUDIO_IN_DeInit+0xb0>)
 800f0d2:	e7d7      	b.n	800f084 <BSP_AUDIO_IN_DeInit+0x30>
      return AUDIO_ERROR;
 800f0d4:	2001      	movs	r0, #1
}
 800f0d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  return AUDIO_OK;
 800f0da:	2000      	movs	r0, #0
}
 800f0dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800f0e0:	20001844 	.word	0x20001844
 800f0e4:	20011298 	.word	0x20011298
 800f0e8:	20010570 	.word	0x20010570
 800f0ec:	48000800 	.word	0x48000800
 800f0f0:	48000400 	.word	0x48000400
 800f0f4:	200111b8 	.word	0x200111b8
 800f0f8:	40016200 	.word	0x40016200
 800f0fc:	20010498 	.word	0x20010498
 800f100:	200104e0 	.word	0x200104e0
 800f104:	20010528 	.word	0x20010528
 800f108:	40016100 	.word	0x40016100
 800f10c:	40016180 	.word	0x40016180
 800f110:	40016280 	.word	0x40016280

0800f114 <BSP_AUDIO_IN_ClockConfig>:
{ 
 800f114:	b530      	push	{r4, r5, lr}
 800f116:	b0a3      	sub	sp, #140	; 0x8c
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1N = 43;
 800f118:	232b      	movs	r3, #43	; 0x2b
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1P = 7;
 800f11a:	2007      	movs	r0, #7
  RCC_ExCLKInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLLSAI1;
 800f11c:	2100      	movs	r1, #0
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_MSI;
 800f11e:	2201      	movs	r2, #1
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1N = 43;
 800f120:	9303      	str	r3, [sp, #12]
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1P = 7;
 800f122:	9004      	str	r0, [sp, #16]
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1M = 6;  
 800f124:	2306      	movs	r3, #6
  RCC_ExCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SAI1;
 800f126:	f44f 6500 	mov.w	r5, #2048	; 0x800
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_SAI1CLK;
 800f12a:	f44f 3480 	mov.w	r4, #65536	; 0x10000
  if(HAL_RCCEx_PeriphCLKConfig(&RCC_ExCLKInitStruct) != HAL_OK)
 800f12e:	4668      	mov	r0, sp
  RCC_ExCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SAI1;
 800f130:	9500      	str	r5, [sp, #0]
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_SAI1CLK;
 800f132:	9407      	str	r4, [sp, #28]
  RCC_ExCLKInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLLSAI1;
 800f134:	9119      	str	r1, [sp, #100]	; 0x64
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1M = 6;  
 800f136:	e9cd 2301 	strd	r2, r3, [sp, #4]
  if(HAL_RCCEx_PeriphCLKConfig(&RCC_ExCLKInitStruct) != HAL_OK)
 800f13a:	f003 faeb 	bl	8012714 <HAL_RCCEx_PeriphCLKConfig>
}
 800f13e:	3000      	adds	r0, #0
 800f140:	bf18      	it	ne
 800f142:	2001      	movne	r0, #1
 800f144:	b023      	add	sp, #140	; 0x8c
 800f146:	bd30      	pop	{r4, r5, pc}

0800f148 <BSP_AUDIO_IN_Init>:
{
 800f148:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  SENSORTILE_AudioIn_Handler.MicChannels = ChnlNbr;
 800f14c:	4b72      	ldr	r3, [pc, #456]	; (800f318 <BSP_AUDIO_IN_Init+0x1d0>)
{
 800f14e:	4605      	mov	r5, r0
 800f150:	b08f      	sub	sp, #60	; 0x3c
  BSP_AUDIO_IN_ClockConfig(SENSORTILE_AudioIn_Handler.Sampling_Freq, NULL);
 800f152:	2100      	movs	r1, #0
{
 800f154:	4617      	mov	r7, r2
  SENSORTILE_AudioIn_Handler.Sampling_Freq = AudioFreq;
 800f156:	e9c3 2000 	strd	r2, r0, [r3]
  BSP_AUDIO_IN_ClockConfig(SENSORTILE_AudioIn_Handler.Sampling_Freq, NULL);
 800f15a:	f7ff ffdb 	bl	800f114 <BSP_AUDIO_IN_ClockConfig>
  if(OverSampling(AudioFreq) == 32)
 800f15e:	f5b5 5ffa 	cmp.w	r5, #8000	; 0x1f40
 800f162:	f000 80c8 	beq.w	800f2f6 <BSP_AUDIO_IN_Init+0x1ae>
 800f166:	f642 3311 	movw	r3, #11025	; 0x2b11
 800f16a:	429d      	cmp	r5, r3
 800f16c:	d046      	beq.n	800f1fc <BSP_AUDIO_IN_Init+0xb4>
 800f16e:	f5b5 5f7a 	cmp.w	r5, #16000	; 0x3e80
 800f172:	f000 80ad 	beq.w	800f2d0 <BSP_AUDIO_IN_Init+0x188>
 800f176:	f245 6322 	movw	r3, #22050	; 0x5622
 800f17a:	429d      	cmp	r5, r3
 800f17c:	f000 80a8 	beq.w	800f2d0 <BSP_AUDIO_IN_Init+0x188>
 800f180:	f5b5 4ffa 	cmp.w	r5, #32000	; 0x7d00
 800f184:	f000 821a 	beq.w	800f5bc <BSP_AUDIO_IN_Init+0x474>
 800f188:	f64a 4344 	movw	r3, #44100	; 0xac44
 800f18c:	429d      	cmp	r5, r3
 800f18e:	f000 8215 	beq.w	800f5bc <BSP_AUDIO_IN_Init+0x474>
 800f192:	f64b 3380 	movw	r3, #48000	; 0xbb80
 800f196:	429d      	cmp	r5, r3
 800f198:	f000 8210 	beq.w	800f5bc <BSP_AUDIO_IN_Init+0x474>
  if (ChnlNbr == 1)
 800f19c:	2f01      	cmp	r7, #1
 800f19e:	f000 834f 	beq.w	800f840 <BSP_AUDIO_IN_Init+0x6f8>
    if (ChnlNbr >= 2)
 800f1a2:	f200 838b 	bhi.w	800f8bc <BSP_AUDIO_IN_Init+0x774>
    SincOrder = DFSDM_FILTER_SINC5_ORDER;
 800f1a6:	f04f 4920 	mov.w	r9, #2684354560	; 0xa0000000
    shift_amount = 5;
 800f1aa:	f04f 0805 	mov.w	r8, #5
    if (ChnlNbr >= 4)
 800f1ae:	2f03      	cmp	r7, #3
 800f1b0:	f240 8196 	bls.w	800f4e0 <BSP_AUDIO_IN_Init+0x398>
      haudio_in_dfsdmchannel[2].Init.OutputClock.Activation   = ENABLE;
 800f1b4:	4c59      	ldr	r4, [pc, #356]	; (800f31c <BSP_AUDIO_IN_Init+0x1d4>)
 800f1b6:	2201      	movs	r2, #1
      haudio_in_dfsdmchannel[2].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f1b8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
      haudio_in_dfsdmchannel[2].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f1bc:	f5b5 5ffa 	cmp.w	r5, #8000	; 0x1f40
      haudio_in_dfsdmchannel[2].Init.OutputClock.Activation   = ENABLE;
 800f1c0:	f884 2074 	strb.w	r2, [r4, #116]	; 0x74
      haudio_in_dfsdmchannel[2].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f1c4:	67a3      	str	r3, [r4, #120]	; 0x78
      haudio_in_dfsdmchannel[2].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f1c6:	f000 8339 	beq.w	800f83c <BSP_AUDIO_IN_Init+0x6f4>
 800f1ca:	f642 3311 	movw	r3, #11025	; 0x2b11
 800f1ce:	429d      	cmp	r5, r3
 800f1d0:	f000 835a 	beq.w	800f888 <BSP_AUDIO_IN_Init+0x740>
 800f1d4:	f5b5 5f7a 	cmp.w	r5, #16000	; 0x3e80
 800f1d8:	f000 8330 	beq.w	800f83c <BSP_AUDIO_IN_Init+0x6f4>
 800f1dc:	f245 6322 	movw	r3, #22050	; 0x5622
 800f1e0:	429d      	cmp	r5, r3
 800f1e2:	f000 8351 	beq.w	800f888 <BSP_AUDIO_IN_Init+0x740>
 800f1e6:	f5b5 4ffa 	cmp.w	r5, #32000	; 0x7d00
 800f1ea:	f000 8327 	beq.w	800f83c <BSP_AUDIO_IN_Init+0x6f4>
 800f1ee:	f64a 4744 	movw	r7, #44100	; 0xac44
 800f1f2:	42bd      	cmp	r5, r7
 800f1f4:	bf14      	ite	ne
 800f1f6:	2710      	movne	r7, #16
 800f1f8:	2704      	moveq	r7, #4
 800f1fa:	e0a4      	b.n	800f346 <BSP_AUDIO_IN_Init+0x1fe>
    SincOrder = DFSDM_FILTER_SINC3_ORDER;
 800f1fc:	f04f 49c0 	mov.w	r9, #1610612736	; 0x60000000
    shift_amount = 4;
 800f200:	f04f 0804 	mov.w	r8, #4
  if (ChnlNbr == 1)
 800f204:	2f01      	cmp	r7, #1
 800f206:	d069      	beq.n	800f2dc <BSP_AUDIO_IN_Init+0x194>
    if (ChnlNbr >= 2)
 800f208:	d9d1      	bls.n	800f1ae <BSP_AUDIO_IN_Init+0x66>
      haudio_in_dfsdmchannel[0].Init.OutputClock.Activation   = ENABLE;
 800f20a:	4c44      	ldr	r4, [pc, #272]	; (800f31c <BSP_AUDIO_IN_Init+0x1d4>)
 800f20c:	2301      	movs	r3, #1
 800f20e:	7123      	strb	r3, [r4, #4]
      haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f210:	f642 3311 	movw	r3, #11025	; 0x2b11
      haudio_in_dfsdmchannel[0].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f214:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
      haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f218:	429d      	cmp	r5, r3
      haudio_in_dfsdmchannel[0].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f21a:	60a2      	str	r2, [r4, #8]
      haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f21c:	f040 817b 	bne.w	800f516 <BSP_AUDIO_IN_Init+0x3ce>
 800f220:	f04f 0a04 	mov.w	sl, #4
      haudio_in_dfsdmchannel[0].Init.Input.Multiplexer        = DFSDM_CHANNEL_EXTERNAL_INPUTS;
 800f224:	2300      	movs	r3, #0
      haudio_in_dfsdmchannel[0].Init.Awd.FilterOrder          = DFSDM_CHANNEL_SINC1_ORDER;
 800f226:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
      haudio_in_dfsdmchannel[0].Init.Awd.Oversampling         = 10;
 800f22a:	220a      	movs	r2, #10
      haudio_in_dfsdmchannel[0].Init.Input.DataPacking        = DFSDM_CHANNEL_STANDARD_MODE;
 800f22c:	e9c4 3304 	strd	r3, r3, [r4, #16]
      haudio_in_dfsdmchannel[0].Init.SerialInterface.Type     = DFSDM_CHANNEL_SPI_RISING;
 800f230:	e9c4 3306 	strd	r3, r3, [r4, #24]
      haudio_in_dfsdmchannel[0].Init.Offset                   = 0;
 800f234:	62e3      	str	r3, [r4, #44]	; 0x2c
      haudio_in_dfsdmchannel[0].Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 800f236:	f04f 0b04 	mov.w	fp, #4
      haudio_in_dfsdmchannel[0].Instance                      = DFSDM_Channel6;
 800f23a:	4b39      	ldr	r3, [pc, #228]	; (800f320 <BSP_AUDIO_IN_Init+0x1d8>)
      haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f23c:	f8c4 a00c 	str.w	sl, [r4, #12]
      haudio_in_dfsdmchannel[0].Init.RightBitShift            = shift_amount;
 800f240:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
      haudio_in_dfsdmchannel[0].Init.Awd.FilterOrder          = DFSDM_CHANNEL_SINC1_ORDER;
 800f244:	e9c4 b108 	strd	fp, r1, [r4, #32]
      if(HAL_DFSDM_ChannelGetState(&haudio_in_dfsdmchannel[0]) == HAL_DFSDM_CHANNEL_STATE_RESET)
 800f248:	4834      	ldr	r0, [pc, #208]	; (800f31c <BSP_AUDIO_IN_Init+0x1d4>)
      haudio_in_dfsdmchannel[0].Init.Awd.Oversampling         = 10;
 800f24a:	62a2      	str	r2, [r4, #40]	; 0x28
      haudio_in_dfsdmchannel[0].Instance                      = DFSDM_Channel6;
 800f24c:	6023      	str	r3, [r4, #0]
      if(HAL_DFSDM_ChannelGetState(&haudio_in_dfsdmchannel[0]) == HAL_DFSDM_CHANNEL_STATE_RESET)
 800f24e:	f001 fb15 	bl	801087c <HAL_DFSDM_ChannelGetState>
 800f252:	4606      	mov	r6, r0
 800f254:	2800      	cmp	r0, #0
 800f256:	f000 8174 	beq.w	800f542 <BSP_AUDIO_IN_Init+0x3fa>
      if(HAL_OK != HAL_DFSDM_ChannelInit(&haudio_in_dfsdmchannel[0]))
 800f25a:	4830      	ldr	r0, [pc, #192]	; (800f31c <BSP_AUDIO_IN_Init+0x1d4>)
 800f25c:	f001 fa66 	bl	801072c <HAL_DFSDM_ChannelInit>
 800f260:	2800      	cmp	r0, #0
 800f262:	f040 8154 	bne.w	800f50e <BSP_AUDIO_IN_Init+0x3c6>
      haudio_in_dfsdmfilter[0].Init.RegularParam.Trigger         = DFSDM_FILTER_SW_TRIGGER;
 800f266:	4e2f      	ldr	r6, [pc, #188]	; (800f324 <BSP_AUDIO_IN_Init+0x1dc>)
      haudio_in_dfsdmfilter[0].Init.InjectedParam.ExtTrigger     = DFSDM_FILTER_EXT_TRIG_TIM8_TRGO;
 800f268:	f44f 7300 	mov.w	r3, #512	; 0x200
      haudio_in_dfsdmfilter[0].Init.InjectedParam.ExtTriggerEdge = DFSDM_FILTER_EXT_TRIG_BOTH_EDGES;
 800f26c:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
      haudio_in_dfsdmfilter[0].Init.InjectedParam.ExtTrigger     = DFSDM_FILTER_EXT_TRIG_TIM8_TRGO;
 800f270:	6173      	str	r3, [r6, #20]
      haudio_in_dfsdmfilter[0].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f272:	f5b5 5ffa 	cmp.w	r5, #8000	; 0x1f40
      haudio_in_dfsdmfilter[0].Init.RegularParam.FastMode        = ENABLE;
 800f276:	f04f 0301 	mov.w	r3, #1
      haudio_in_dfsdmfilter[0].Init.RegularParam.Trigger         = DFSDM_FILTER_SW_TRIGGER;
 800f27a:	6070      	str	r0, [r6, #4]
      haudio_in_dfsdmfilter[0].Init.InjectedParam.Trigger        = DFSDM_FILTER_SW_TRIGGER;
 800f27c:	60f0      	str	r0, [r6, #12]
      haudio_in_dfsdmfilter[0].Init.InjectedParam.ScanMode       = DISABLE;
 800f27e:	7430      	strb	r0, [r6, #16]
      haudio_in_dfsdmfilter[0].Init.InjectedParam.DmaMode        = DISABLE;
 800f280:	7470      	strb	r0, [r6, #17]
      haudio_in_dfsdmfilter[0].Init.FilterParam.SincOrder        = SincOrder;
 800f282:	f8c6 901c 	str.w	r9, [r6, #28]
      haudio_in_dfsdmfilter[0].Init.InjectedParam.ExtTriggerEdge = DFSDM_FILTER_EXT_TRIG_BOTH_EDGES;
 800f286:	61b2      	str	r2, [r6, #24]
      haudio_in_dfsdmfilter[0].Init.RegularParam.FastMode        = ENABLE;
 800f288:	7233      	strb	r3, [r6, #8]
      haudio_in_dfsdmfilter[0].Init.RegularParam.DmaMode         = ENABLE;
 800f28a:	7273      	strb	r3, [r6, #9]
      haudio_in_dfsdmfilter[0].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f28c:	f000 819b 	beq.w	800f5c6 <BSP_AUDIO_IN_Init+0x47e>
 800f290:	f642 3311 	movw	r3, #11025	; 0x2b11
 800f294:	429d      	cmp	r5, r3
 800f296:	f000 8196 	beq.w	800f5c6 <BSP_AUDIO_IN_Init+0x47e>
 800f29a:	f5b5 5f7a 	cmp.w	r5, #16000	; 0x3e80
 800f29e:	f000 8123 	beq.w	800f4e8 <BSP_AUDIO_IN_Init+0x3a0>
 800f2a2:	f245 6322 	movw	r3, #22050	; 0x5622
 800f2a6:	429d      	cmp	r5, r3
 800f2a8:	f000 811e 	beq.w	800f4e8 <BSP_AUDIO_IN_Init+0x3a0>
 800f2ac:	f5b5 4ffa 	cmp.w	r5, #32000	; 0x7d00
 800f2b0:	f000 82ef 	beq.w	800f892 <BSP_AUDIO_IN_Init+0x74a>
 800f2b4:	f64a 4344 	movw	r3, #44100	; 0xac44
 800f2b8:	429d      	cmp	r5, r3
 800f2ba:	f000 82ea 	beq.w	800f892 <BSP_AUDIO_IN_Init+0x74a>
 800f2be:	f64b 3b80 	movw	fp, #48000	; 0xbb80
 800f2c2:	455d      	cmp	r5, fp
 800f2c4:	bf14      	ite	ne
 800f2c6:	f04f 0b20 	movne.w	fp, #32
 800f2ca:	f04f 0b40 	moveq.w	fp, #64	; 0x40
 800f2ce:	e10d      	b.n	800f4ec <BSP_AUDIO_IN_Init+0x3a4>
  if (ChnlNbr == 1)
 800f2d0:	2f01      	cmp	r7, #1
    SincOrder = DFSDM_FILTER_SINC4_ORDER;
 800f2d2:	f04f 4900 	mov.w	r9, #2147483648	; 0x80000000
    shift_amount = 8;
 800f2d6:	f04f 0808 	mov.w	r8, #8
  if (ChnlNbr == 1)
 800f2da:	d195      	bne.n	800f208 <BSP_AUDIO_IN_Init+0xc0>
    haudio_in_dfsdmchannel[0].Init.OutputClock.Activation   = ENABLE;
 800f2dc:	4c0f      	ldr	r4, [pc, #60]	; (800f31c <BSP_AUDIO_IN_Init+0x1d4>)
    haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f2de:	f642 3311 	movw	r3, #11025	; 0x2b11
    haudio_in_dfsdmchannel[0].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f2e2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f2e6:	429d      	cmp	r5, r3
 800f2e8:	4641      	mov	r1, r8
    haudio_in_dfsdmchannel[0].Init.OutputClock.Activation   = ENABLE;
 800f2ea:	7127      	strb	r7, [r4, #4]
    haudio_in_dfsdmchannel[0].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f2ec:	60a2      	str	r2, [r4, #8]
    haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f2ee:	f040 81e3 	bne.w	800f6b8 <BSP_AUDIO_IN_Init+0x570>
 800f2f2:	2204      	movs	r2, #4
 800f2f4:	e193      	b.n	800f61e <BSP_AUDIO_IN_Init+0x4d6>
  if (ChnlNbr == 1)
 800f2f6:	2f01      	cmp	r7, #1
 800f2f8:	f000 8188 	beq.w	800f60c <BSP_AUDIO_IN_Init+0x4c4>
    if (ChnlNbr >= 2)
 800f2fc:	d914      	bls.n	800f328 <BSP_AUDIO_IN_Init+0x1e0>
      haudio_in_dfsdmchannel[0].Init.OutputClock.Activation   = ENABLE;
 800f2fe:	4c07      	ldr	r4, [pc, #28]	; (800f31c <BSP_AUDIO_IN_Init+0x1d4>)
 800f300:	2201      	movs	r2, #1
      haudio_in_dfsdmchannel[0].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f302:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
      haudio_in_dfsdmchannel[0].Init.OutputClock.Activation   = ENABLE;
 800f306:	7122      	strb	r2, [r4, #4]
      haudio_in_dfsdmchannel[0].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f308:	60a3      	str	r3, [r4, #8]
    SincOrder = DFSDM_FILTER_SINC3_ORDER;
 800f30a:	f04f 49c0 	mov.w	r9, #1610612736	; 0x60000000
    shift_amount = 4;
 800f30e:	f04f 0804 	mov.w	r8, #4
      haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f312:	f04f 0a18 	mov.w	sl, #24
 800f316:	e785      	b.n	800f224 <BSP_AUDIO_IN_Init+0xdc>
 800f318:	20001844 	.word	0x20001844
 800f31c:	200111b8 	.word	0x200111b8
 800f320:	400160c0 	.word	0x400160c0
 800f324:	20011298 	.word	0x20011298
    if (ChnlNbr >= 4)
 800f328:	2f03      	cmp	r7, #3
 800f32a:	f240 80d9 	bls.w	800f4e0 <BSP_AUDIO_IN_Init+0x398>
      haudio_in_dfsdmchannel[2].Init.OutputClock.Activation   = ENABLE;
 800f32e:	4ca7      	ldr	r4, [pc, #668]	; (800f5cc <BSP_AUDIO_IN_Init+0x484>)
 800f330:	2201      	movs	r2, #1
      haudio_in_dfsdmchannel[2].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f332:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
      haudio_in_dfsdmchannel[2].Init.OutputClock.Activation   = ENABLE;
 800f336:	f884 2074 	strb.w	r2, [r4, #116]	; 0x74
      haudio_in_dfsdmchannel[2].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f33a:	67a3      	str	r3, [r4, #120]	; 0x78
    shift_amount = 4;
 800f33c:	f04f 0804 	mov.w	r8, #4
    SincOrder = DFSDM_FILTER_SINC3_ORDER;
 800f340:	f04f 49c0 	mov.w	r9, #1610612736	; 0x60000000
      haudio_in_dfsdmchannel[2].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f344:	2718      	movs	r7, #24
      haudio_in_dfsdmchannel[2].Init.Input.Multiplexer        = DFSDM_CHANNEL_EXTERNAL_INPUTS;
 800f346:	2300      	movs	r3, #0
      haudio_in_dfsdmchannel[2].Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 800f348:	2004      	movs	r0, #4
      haudio_in_dfsdmchannel[2].Init.Awd.FilterOrder          = DFSDM_CHANNEL_SINC1_ORDER;
 800f34a:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
      haudio_in_dfsdmchannel[2].Init.Input.DataPacking        = DFSDM_CHANNEL_STANDARD_MODE;
 800f34e:	e9c4 3320 	strd	r3, r3, [r4, #128]	; 0x80
      haudio_in_dfsdmchannel[2].Init.SerialInterface.Type     = DFSDM_CHANNEL_SPI_RISING;
 800f352:	e9c4 3322 	strd	r3, r3, [r4, #136]	; 0x88
      haudio_in_dfsdmchannel[2].Init.Offset                   = 0;
 800f356:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
      haudio_in_dfsdmchannel[2].Init.Awd.Oversampling         = 10;
 800f35a:	220a      	movs	r2, #10
      haudio_in_dfsdmchannel[2].Instance                      = DFSDM_Channel4;
 800f35c:	4b9c      	ldr	r3, [pc, #624]	; (800f5d0 <BSP_AUDIO_IN_Init+0x488>)
      haudio_in_dfsdmchannel[2].Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 800f35e:	f8c4 0090 	str.w	r0, [r4, #144]	; 0x90
      haudio_in_dfsdmchannel[2].Instance                      = DFSDM_Channel4;
 800f362:	6723      	str	r3, [r4, #112]	; 0x70
      haudio_in_dfsdmchannel[2].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f364:	67e7      	str	r7, [r4, #124]	; 0x7c
      haudio_in_dfsdmchannel[2].Init.RightBitShift            = shift_amount;    
 800f366:	f8c4 80a0 	str.w	r8, [r4, #160]	; 0xa0
      haudio_in_dfsdmchannel[2].Init.Awd.FilterOrder          = DFSDM_CHANNEL_SINC1_ORDER;
 800f36a:	f8c4 1094 	str.w	r1, [r4, #148]	; 0x94
      if(HAL_DFSDM_ChannelGetState(&haudio_in_dfsdmchannel[2]) == HAL_DFSDM_CHANNEL_STATE_RESET)
 800f36e:	4899      	ldr	r0, [pc, #612]	; (800f5d4 <BSP_AUDIO_IN_Init+0x48c>)
      haudio_in_dfsdmchannel[2].Init.Awd.Oversampling         = 10;
 800f370:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
      if(HAL_DFSDM_ChannelGetState(&haudio_in_dfsdmchannel[2]) == HAL_DFSDM_CHANNEL_STATE_RESET)
 800f374:	f001 fa82 	bl	801087c <HAL_DFSDM_ChannelGetState>
 800f378:	4603      	mov	r3, r0
 800f37a:	2800      	cmp	r0, #0
 800f37c:	f000 826c 	beq.w	800f858 <BSP_AUDIO_IN_Init+0x710>
      if(HAL_OK != HAL_DFSDM_ChannelInit(&haudio_in_dfsdmchannel[2]))
 800f380:	4894      	ldr	r0, [pc, #592]	; (800f5d4 <BSP_AUDIO_IN_Init+0x48c>)
 800f382:	f001 f9d3 	bl	801072c <HAL_DFSDM_ChannelInit>
 800f386:	2800      	cmp	r0, #0
 800f388:	f040 80c1 	bne.w	800f50e <BSP_AUDIO_IN_Init+0x3c6>
      haudio_in_dfsdmfilter[2].Init.RegularParam.Trigger         = DFSDM_FILTER_SYNC_TRIGGER;
 800f38c:	4e92      	ldr	r6, [pc, #584]	; (800f5d8 <BSP_AUDIO_IN_Init+0x490>)
      haudio_in_dfsdmfilter[2].Init.InjectedParam.ExtTrigger     = DFSDM_FILTER_EXT_TRIG_TIM8_TRGO;
 800f38e:	f44f 7300 	mov.w	r3, #512	; 0x200
      haudio_in_dfsdmfilter[2].Init.InjectedParam.ExtTriggerEdge = DFSDM_FILTER_EXT_TRIG_BOTH_EDGES;
 800f392:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
      haudio_in_dfsdmfilter[2].Init.InjectedParam.ExtTrigger     = DFSDM_FILTER_EXT_TRIG_TIM8_TRGO;
 800f396:	f8c6 30bc 	str.w	r3, [r6, #188]	; 0xbc
      haudio_in_dfsdmfilter[2].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f39a:	f5b5 5ffa 	cmp.w	r5, #8000	; 0x1f40
      haudio_in_dfsdmfilter[2].Init.RegularParam.Trigger         = DFSDM_FILTER_SYNC_TRIGGER;
 800f39e:	f04f 0301 	mov.w	r3, #1
      haudio_in_dfsdmfilter[2].Init.InjectedParam.Trigger        = DFSDM_FILTER_SW_TRIGGER;
 800f3a2:	f8c6 00b4 	str.w	r0, [r6, #180]	; 0xb4
      haudio_in_dfsdmfilter[2].Init.InjectedParam.ScanMode       = DISABLE;
 800f3a6:	f886 00b8 	strb.w	r0, [r6, #184]	; 0xb8
      haudio_in_dfsdmfilter[2].Init.InjectedParam.DmaMode        = DISABLE;
 800f3aa:	f886 00b9 	strb.w	r0, [r6, #185]	; 0xb9
      haudio_in_dfsdmfilter[2].Init.FilterParam.SincOrder        = SincOrder;
 800f3ae:	f8c6 90c4 	str.w	r9, [r6, #196]	; 0xc4
      haudio_in_dfsdmfilter[2].Init.InjectedParam.ExtTriggerEdge = DFSDM_FILTER_EXT_TRIG_BOTH_EDGES;
 800f3b2:	f8c6 20c0 	str.w	r2, [r6, #192]	; 0xc0
      haudio_in_dfsdmfilter[2].Init.RegularParam.Trigger         = DFSDM_FILTER_SYNC_TRIGGER;
 800f3b6:	f8c6 30ac 	str.w	r3, [r6, #172]	; 0xac
      haudio_in_dfsdmfilter[2].Init.RegularParam.FastMode        = ENABLE;
 800f3ba:	f886 30b0 	strb.w	r3, [r6, #176]	; 0xb0
      haudio_in_dfsdmfilter[2].Init.RegularParam.DmaMode         = ENABLE;
 800f3be:	f886 30b1 	strb.w	r3, [r6, #177]	; 0xb1
      haudio_in_dfsdmfilter[2].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f3c2:	f000 8263 	beq.w	800f88c <BSP_AUDIO_IN_Init+0x744>
 800f3c6:	f642 3311 	movw	r3, #11025	; 0x2b11
 800f3ca:	429d      	cmp	r5, r3
 800f3cc:	f000 825e 	beq.w	800f88c <BSP_AUDIO_IN_Init+0x744>
 800f3d0:	f5b5 5f7a 	cmp.w	r5, #16000	; 0x3e80
 800f3d4:	f000 8266 	beq.w	800f8a4 <BSP_AUDIO_IN_Init+0x75c>
 800f3d8:	f245 6322 	movw	r3, #22050	; 0x5622
 800f3dc:	429d      	cmp	r5, r3
 800f3de:	f000 8261 	beq.w	800f8a4 <BSP_AUDIO_IN_Init+0x75c>
 800f3e2:	f5b5 4ffa 	cmp.w	r5, #32000	; 0x7d00
 800f3e6:	f000 825f 	beq.w	800f8a8 <BSP_AUDIO_IN_Init+0x760>
 800f3ea:	f64a 4344 	movw	r3, #44100	; 0xac44
 800f3ee:	429d      	cmp	r5, r3
 800f3f0:	f000 825a 	beq.w	800f8a8 <BSP_AUDIO_IN_Init+0x760>
 800f3f4:	f64b 3380 	movw	r3, #48000	; 0xbb80
 800f3f8:	429d      	cmp	r5, r3
 800f3fa:	bf14      	ite	ne
 800f3fc:	2520      	movne	r5, #32
 800f3fe:	2540      	moveq	r5, #64	; 0x40
      haudio_in_dfsdmfilter[2].Init.FilterParam.IntOversampling  = 1;    
 800f400:	2201      	movs	r2, #1
      haudio_in_dfsdmfilter[2].Instance                          = AUDIO_IN_DFSDM_3rd_FILTER;
 800f402:	4b76      	ldr	r3, [pc, #472]	; (800f5dc <BSP_AUDIO_IN_Init+0x494>)
      if(HAL_DFSDM_FilterGetState(&haudio_in_dfsdmfilter[2]) == HAL_DFSDM_FILTER_STATE_RESET)
 800f404:	4876      	ldr	r0, [pc, #472]	; (800f5e0 <BSP_AUDIO_IN_Init+0x498>)
      haudio_in_dfsdmfilter[2].Instance                          = AUDIO_IN_DFSDM_3rd_FILTER;
 800f406:	f8c6 30a8 	str.w	r3, [r6, #168]	; 0xa8
      haudio_in_dfsdmfilter[2].Init.FilterParam.IntOversampling  = 1;    
 800f40a:	e9c6 5232 	strd	r5, r2, [r6, #200]	; 0xc8
      if(HAL_DFSDM_FilterGetState(&haudio_in_dfsdmfilter[2]) == HAL_DFSDM_FILTER_STATE_RESET)
 800f40e:	f001 fb67 	bl	8010ae0 <HAL_DFSDM_FilterGetState>
 800f412:	2800      	cmp	r0, #0
 800f414:	f000 8240 	beq.w	800f898 <BSP_AUDIO_IN_Init+0x750>
      if(HAL_OK != HAL_DFSDM_FilterInit(&haudio_in_dfsdmfilter[2]))
 800f418:	4871      	ldr	r0, [pc, #452]	; (800f5e0 <BSP_AUDIO_IN_Init+0x498>)
 800f41a:	f001 fa35 	bl	8010888 <HAL_DFSDM_FilterInit>
 800f41e:	2800      	cmp	r0, #0
 800f420:	d175      	bne.n	800f50e <BSP_AUDIO_IN_Init+0x3c6>
      if(HAL_OK != HAL_DFSDM_FilterConfigRegChannel(&haudio_in_dfsdmfilter[2], DFSDM_CHANNEL_4, DFSDM_CONTINUOUS_CONV_ON))
 800f422:	2201      	movs	r2, #1
 800f424:	496f      	ldr	r1, [pc, #444]	; (800f5e4 <BSP_AUDIO_IN_Init+0x49c>)
 800f426:	486e      	ldr	r0, [pc, #440]	; (800f5e0 <BSP_AUDIO_IN_Init+0x498>)
 800f428:	f001 fab4 	bl	8010994 <HAL_DFSDM_FilterConfigRegChannel>
 800f42c:	2800      	cmp	r0, #0
 800f42e:	d16e      	bne.n	800f50e <BSP_AUDIO_IN_Init+0x3c6>
      haudio_in_dfsdmchannel[3].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f430:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
      haudio_in_dfsdmchannel[3].Init.Input.Pins               = DFSDM_CHANNEL_FOLLOWING_CHANNEL_PINS;
 800f434:	f44f 7280 	mov.w	r2, #256	; 0x100
      haudio_in_dfsdmchannel[3].Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 800f438:	2304      	movs	r3, #4
      haudio_in_dfsdmchannel[3].Init.OutputClock.Activation   = ENABLE;
 800f43a:	f04f 0a01 	mov.w	sl, #1
      haudio_in_dfsdmchannel[3].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f43e:	f8c4 10b0 	str.w	r1, [r4, #176]	; 0xb0
      haudio_in_dfsdmchannel[3].Init.Input.Pins               = DFSDM_CHANNEL_FOLLOWING_CHANNEL_PINS;
 800f442:	f8c4 20c0 	str.w	r2, [r4, #192]	; 0xc0
      haudio_in_dfsdmchannel[3].Init.Awd.FilterOrder          = DFSDM_CHANNEL_SINC1_ORDER;
 800f446:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
      haudio_in_dfsdmchannel[3].Init.Awd.Oversampling         = 10;
 800f44a:	220a      	movs	r2, #10
      haudio_in_dfsdmchannel[3].Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 800f44c:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
      haudio_in_dfsdmchannel[3].Instance                      = DFSDM_Channel3;
 800f450:	4b65      	ldr	r3, [pc, #404]	; (800f5e8 <BSP_AUDIO_IN_Init+0x4a0>)
      haudio_in_dfsdmchannel[3].Init.Offset                   = 0;
 800f452:	f8c4 00d4 	str.w	r0, [r4, #212]	; 0xd4
      haudio_in_dfsdmchannel[3].Init.Input.DataPacking        = DFSDM_CHANNEL_STANDARD_MODE;
 800f456:	e9c4 002e 	strd	r0, r0, [r4, #184]	; 0xb8
      haudio_in_dfsdmchannel[3].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f45a:	f8c4 70b4 	str.w	r7, [r4, #180]	; 0xb4
      haudio_in_dfsdmchannel[3].Init.RightBitShift            = shift_amount;    
 800f45e:	f8c4 80d8 	str.w	r8, [r4, #216]	; 0xd8
      haudio_in_dfsdmchannel[3].Init.OutputClock.Activation   = ENABLE;
 800f462:	f884 a0ac 	strb.w	sl, [r4, #172]	; 0xac
      haudio_in_dfsdmchannel[3].Init.SerialInterface.Type     = DFSDM_CHANNEL_SPI_FALLING;
 800f466:	f8c4 a0c4 	str.w	sl, [r4, #196]	; 0xc4
      haudio_in_dfsdmchannel[3].Init.Awd.FilterOrder          = DFSDM_CHANNEL_SINC1_ORDER;
 800f46a:	f8c4 10cc 	str.w	r1, [r4, #204]	; 0xcc
      if(HAL_OK != HAL_DFSDM_ChannelInit(&haudio_in_dfsdmchannel[3]))
 800f46e:	485f      	ldr	r0, [pc, #380]	; (800f5ec <BSP_AUDIO_IN_Init+0x4a4>)
      haudio_in_dfsdmchannel[3].Init.Awd.Oversampling         = 10;
 800f470:	f8c4 20d0 	str.w	r2, [r4, #208]	; 0xd0
      haudio_in_dfsdmchannel[3].Instance                      = DFSDM_Channel3;
 800f474:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
      if(HAL_OK != HAL_DFSDM_ChannelInit(&haudio_in_dfsdmchannel[3]))
 800f478:	f001 f958 	bl	801072c <HAL_DFSDM_ChannelInit>
 800f47c:	2800      	cmp	r0, #0
 800f47e:	d146      	bne.n	800f50e <BSP_AUDIO_IN_Init+0x3c6>
      haudio_in_dfsdmfilter[3].Init.InjectedParam.ExtTrigger     = DFSDM_FILTER_EXT_TRIG_TIM8_TRGO;
 800f480:	f44f 7100 	mov.w	r1, #512	; 0x200
      haudio_in_dfsdmfilter[3].Init.InjectedParam.ExtTriggerEdge = DFSDM_FILTER_EXT_TRIG_BOTH_EDGES;
 800f484:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
      haudio_in_dfsdmfilter[3].Instance                          = AUDIO_IN_DFSDM_4th_FILTER;
 800f488:	4b59      	ldr	r3, [pc, #356]	; (800f5f0 <BSP_AUDIO_IN_Init+0x4a8>)
      haudio_in_dfsdmfilter[3].Init.InjectedParam.Trigger        = DFSDM_FILTER_SW_TRIGGER;
 800f48a:	f8c6 0108 	str.w	r0, [r6, #264]	; 0x108
      haudio_in_dfsdmfilter[3].Init.InjectedParam.ScanMode       = DISABLE;
 800f48e:	f886 010c 	strb.w	r0, [r6, #268]	; 0x10c
      haudio_in_dfsdmfilter[3].Init.InjectedParam.DmaMode        = DISABLE;
 800f492:	f886 010d 	strb.w	r0, [r6, #269]	; 0x10d
      haudio_in_dfsdmfilter[3].Init.RegularParam.Trigger         = DFSDM_FILTER_SYNC_TRIGGER;
 800f496:	f8c6 a100 	str.w	sl, [r6, #256]	; 0x100
      haudio_in_dfsdmfilter[3].Init.RegularParam.FastMode        = ENABLE;
 800f49a:	f886 a104 	strb.w	sl, [r6, #260]	; 0x104
      haudio_in_dfsdmfilter[3].Init.RegularParam.DmaMode         = ENABLE;
 800f49e:	f886 a105 	strb.w	sl, [r6, #261]	; 0x105
      haudio_in_dfsdmfilter[3].Init.FilterParam.SincOrder        = SincOrder;
 800f4a2:	f8c6 9118 	str.w	r9, [r6, #280]	; 0x118
      haudio_in_dfsdmfilter[3].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f4a6:	f8c6 511c 	str.w	r5, [r6, #284]	; 0x11c
      if(HAL_DFSDM_FilterGetState(&haudio_in_dfsdmfilter[3]) == HAL_DFSDM_FILTER_STATE_RESET)
 800f4aa:	4852      	ldr	r0, [pc, #328]	; (800f5f4 <BSP_AUDIO_IN_Init+0x4ac>)
      haudio_in_dfsdmfilter[3].Init.FilterParam.IntOversampling  = 1;    
 800f4ac:	f8c6 a120 	str.w	sl, [r6, #288]	; 0x120
      haudio_in_dfsdmfilter[3].Init.InjectedParam.ExtTrigger     = DFSDM_FILTER_EXT_TRIG_TIM8_TRGO;
 800f4b0:	f8c6 1110 	str.w	r1, [r6, #272]	; 0x110
      haudio_in_dfsdmfilter[3].Init.InjectedParam.ExtTriggerEdge = DFSDM_FILTER_EXT_TRIG_BOTH_EDGES;
 800f4b4:	f8c6 2114 	str.w	r2, [r6, #276]	; 0x114
      haudio_in_dfsdmfilter[3].Instance                          = AUDIO_IN_DFSDM_4th_FILTER;
 800f4b8:	f8c6 30fc 	str.w	r3, [r6, #252]	; 0xfc
      if(HAL_DFSDM_FilterGetState(&haudio_in_dfsdmfilter[3]) == HAL_DFSDM_FILTER_STATE_RESET)
 800f4bc:	f001 fb10 	bl	8010ae0 <HAL_DFSDM_FilterGetState>
 800f4c0:	2800      	cmp	r0, #0
 800f4c2:	f000 81f7 	beq.w	800f8b4 <BSP_AUDIO_IN_Init+0x76c>
      if(HAL_OK != HAL_DFSDM_FilterInit(&haudio_in_dfsdmfilter[3]))
 800f4c6:	484b      	ldr	r0, [pc, #300]	; (800f5f4 <BSP_AUDIO_IN_Init+0x4ac>)
 800f4c8:	f001 f9de 	bl	8010888 <HAL_DFSDM_FilterInit>
 800f4cc:	b9f8      	cbnz	r0, 800f50e <BSP_AUDIO_IN_Init+0x3c6>
      if(HAL_OK != HAL_DFSDM_FilterConfigRegChannel(&haudio_in_dfsdmfilter[3], DFSDM_CHANNEL_3, DFSDM_CONTINUOUS_CONV_ON))
 800f4ce:	2201      	movs	r2, #1
 800f4d0:	4949      	ldr	r1, [pc, #292]	; (800f5f8 <BSP_AUDIO_IN_Init+0x4b0>)
 800f4d2:	4848      	ldr	r0, [pc, #288]	; (800f5f4 <BSP_AUDIO_IN_Init+0x4ac>)
 800f4d4:	f001 fa5e 	bl	8010994 <HAL_DFSDM_FilterConfigRegChannel>
      return AUDIO_ERROR;
 800f4d8:	3000      	adds	r0, #0
 800f4da:	bf18      	it	ne
 800f4dc:	2001      	movne	r0, #1
 800f4de:	e000      	b.n	800f4e2 <BSP_AUDIO_IN_Init+0x39a>
  return AUDIO_OK;
 800f4e0:	2000      	movs	r0, #0
}
 800f4e2:	b00f      	add	sp, #60	; 0x3c
 800f4e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      haudio_in_dfsdmfilter[0].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f4e8:	f04f 0b80 	mov.w	fp, #128	; 0x80
      haudio_in_dfsdmfilter[0].Init.FilterParam.IntOversampling  = 1;  
 800f4ec:	2201      	movs	r2, #1
      haudio_in_dfsdmfilter[0].Instance                          = AUDIO_IN_DFSDM_1st_FILTER;
 800f4ee:	4b43      	ldr	r3, [pc, #268]	; (800f5fc <BSP_AUDIO_IN_Init+0x4b4>)
      if(HAL_DFSDM_FilterGetState(&haudio_in_dfsdmfilter[0]) == HAL_DFSDM_FILTER_STATE_RESET)
 800f4f0:	4839      	ldr	r0, [pc, #228]	; (800f5d8 <BSP_AUDIO_IN_Init+0x490>)
      haudio_in_dfsdmfilter[0].Instance                          = AUDIO_IN_DFSDM_1st_FILTER;
 800f4f2:	6033      	str	r3, [r6, #0]
      haudio_in_dfsdmfilter[0].Init.FilterParam.IntOversampling  = 1;  
 800f4f4:	e9c6 b208 	strd	fp, r2, [r6, #32]
      if(HAL_DFSDM_FilterGetState(&haudio_in_dfsdmfilter[0]) == HAL_DFSDM_FILTER_STATE_RESET)
 800f4f8:	f001 faf2 	bl	8010ae0 <HAL_DFSDM_FilterGetState>
 800f4fc:	2800      	cmp	r0, #0
 800f4fe:	f000 8193 	beq.w	800f828 <BSP_AUDIO_IN_Init+0x6e0>
      if(HAL_OK != HAL_DFSDM_FilterInit(&haudio_in_dfsdmfilter[0]))
 800f502:	4835      	ldr	r0, [pc, #212]	; (800f5d8 <BSP_AUDIO_IN_Init+0x490>)
 800f504:	f001 f9c0 	bl	8010888 <HAL_DFSDM_FilterInit>
 800f508:	2800      	cmp	r0, #0
 800f50a:	f000 813a 	beq.w	800f782 <BSP_AUDIO_IN_Init+0x63a>
      return AUDIO_ERROR;
 800f50e:	2001      	movs	r0, #1
}
 800f510:	b00f      	add	sp, #60	; 0x3c
 800f512:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f516:	f5b5 5f7a 	cmp.w	r5, #16000	; 0x3e80
 800f51a:	f000 812f 	beq.w	800f77c <BSP_AUDIO_IN_Init+0x634>
 800f51e:	f245 6322 	movw	r3, #22050	; 0x5622
 800f522:	429d      	cmp	r5, r3
 800f524:	f43f ae7c 	beq.w	800f220 <BSP_AUDIO_IN_Init+0xd8>
 800f528:	f5b5 4ffa 	cmp.w	r5, #32000	; 0x7d00
 800f52c:	f000 8126 	beq.w	800f77c <BSP_AUDIO_IN_Init+0x634>
 800f530:	f64a 4a44 	movw	sl, #44100	; 0xac44
 800f534:	4555      	cmp	r5, sl
 800f536:	bf14      	ite	ne
 800f538:	f04f 0a10 	movne.w	sl, #16
 800f53c:	f04f 0a04 	moveq.w	sl, #4
 800f540:	e670      	b.n	800f224 <BSP_AUDIO_IN_Init+0xdc>
        AUDIO_IN_DFSDM_CLK_ENABLE();  
 800f542:	4b2f      	ldr	r3, [pc, #188]	; (800f600 <BSP_AUDIO_IN_Init+0x4b8>)
        HAL_GPIO_Init(AUDIO_IN_DFSDM_CKOUT_GPIO_PORT, &GPIO_InitStruct);
 800f544:	482f      	ldr	r0, [pc, #188]	; (800f604 <BSP_AUDIO_IN_Init+0x4bc>)
        AUDIO_IN_DFSDM_CLK_ENABLE();  
 800f546:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800f548:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800f54c:	661a      	str	r2, [r3, #96]	; 0x60
 800f54e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800f550:	f002 7280 	and.w	r2, r2, #16777216	; 0x1000000
 800f554:	9205      	str	r2, [sp, #20]
 800f556:	9a05      	ldr	r2, [sp, #20]
        AUDIO_IN_DFSDM_CKOUT_GPIO_CLK_ENABLE(); 
 800f558:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800f55a:	ea42 020b 	orr.w	r2, r2, fp
 800f55e:	64da      	str	r2, [r3, #76]	; 0x4c
 800f560:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800f562:	ea02 020b 	and.w	r2, r2, fp
 800f566:	9206      	str	r2, [sp, #24]
 800f568:	9a06      	ldr	r2, [sp, #24]
        AUDIO_IN_DFSDM_CH12_EXT_DATAIN_GPIO_CLK_ENABLE();
 800f56a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800f56c:	f042 0202 	orr.w	r2, r2, #2
 800f570:	64da      	str	r2, [r3, #76]	; 0x4c
 800f572:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
        GPIO_InitStruct.Pin = AUDIO_IN_DFSDM_CKOUT_PIN;
 800f574:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
        AUDIO_IN_DFSDM_CH12_EXT_DATAIN_GPIO_CLK_ENABLE();
 800f578:	f003 0302 	and.w	r3, r3, #2
 800f57c:	9307      	str	r3, [sp, #28]
        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800f57e:	2202      	movs	r2, #2
        GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800f580:	2303      	movs	r3, #3
        HAL_GPIO_Init(AUDIO_IN_DFSDM_CKOUT_GPIO_PORT, &GPIO_InitStruct);
 800f582:	a909      	add	r1, sp, #36	; 0x24
        GPIO_InitStruct.Alternate = AUDIO_IN_DFSDM_CKOUT_DATIN_AF;
 800f584:	f04f 0b06 	mov.w	fp, #6
        AUDIO_IN_DFSDM_CH12_EXT_DATAIN_GPIO_CLK_ENABLE();
 800f588:	f8dd c01c 	ldr.w	ip, [sp, #28]
        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800f58c:	9201      	str	r2, [sp, #4]
 800f58e:	e9cd 260a 	strd	r2, r6, [sp, #40]	; 0x28
        GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800f592:	930c      	str	r3, [sp, #48]	; 0x30
 800f594:	9300      	str	r3, [sp, #0]
        GPIO_InitStruct.Alternate = AUDIO_IN_DFSDM_CKOUT_DATIN_AF;
 800f596:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
        HAL_GPIO_Init(AUDIO_IN_DFSDM_CKOUT_GPIO_PORT, &GPIO_InitStruct);
 800f59a:	f001 fe23 	bl	80111e4 <HAL_GPIO_Init>
        GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800f59e:	9b00      	ldr	r3, [sp, #0]
        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800f5a0:	9a01      	ldr	r2, [sp, #4]
        HAL_GPIO_Init(AUDIO_IN_DFSDM_CH12_EXT_DATIN_GPIO_PORT, &GPIO_InitStruct);
 800f5a2:	4819      	ldr	r0, [pc, #100]	; (800f608 <BSP_AUDIO_IN_Init+0x4c0>)
        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800f5a4:	920a      	str	r2, [sp, #40]	; 0x28
        GPIO_InitStruct.Pin = AUDIO_IN_DFSDM_CH12_EXT_DATIN_PIN;
 800f5a6:	f44f 7c80 	mov.w	ip, #256	; 0x100
        HAL_GPIO_Init(AUDIO_IN_DFSDM_CH12_EXT_DATIN_GPIO_PORT, &GPIO_InitStruct);
 800f5aa:	a909      	add	r1, sp, #36	; 0x24
        GPIO_InitStruct.Alternate = AUDIO_IN_DFSDM_CKOUT_DATIN_AF;
 800f5ac:	e9cd 3b0c 	strd	r3, fp, [sp, #48]	; 0x30
        GPIO_InitStruct.Pull = GPIO_NOPULL;
 800f5b0:	960b      	str	r6, [sp, #44]	; 0x2c
        GPIO_InitStruct.Pin = AUDIO_IN_DFSDM_CH12_EXT_DATIN_PIN;
 800f5b2:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
        HAL_GPIO_Init(AUDIO_IN_DFSDM_CH12_EXT_DATIN_GPIO_PORT, &GPIO_InitStruct);
 800f5b6:	f001 fe15 	bl	80111e4 <HAL_GPIO_Init>
 800f5ba:	e64e      	b.n	800f25a <BSP_AUDIO_IN_Init+0x112>
    SincOrder = DFSDM_FILTER_SINC5_ORDER;
 800f5bc:	f04f 4920 	mov.w	r9, #2684354560	; 0xa0000000
    shift_amount = 10;
 800f5c0:	f04f 080a 	mov.w	r8, #10
 800f5c4:	e61e      	b.n	800f204 <BSP_AUDIO_IN_Init+0xbc>
      haudio_in_dfsdmfilter[0].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f5c6:	f44f 7b80 	mov.w	fp, #256	; 0x100
 800f5ca:	e78f      	b.n	800f4ec <BSP_AUDIO_IN_Init+0x3a4>
 800f5cc:	200111b8 	.word	0x200111b8
 800f5d0:	40016080 	.word	0x40016080
 800f5d4:	20011228 	.word	0x20011228
 800f5d8:	20011298 	.word	0x20011298
 800f5dc:	40016200 	.word	0x40016200
 800f5e0:	20011340 	.word	0x20011340
 800f5e4:	00040010 	.word	0x00040010
 800f5e8:	40016060 	.word	0x40016060
 800f5ec:	20011260 	.word	0x20011260
 800f5f0:	40016280 	.word	0x40016280
 800f5f4:	20011394 	.word	0x20011394
 800f5f8:	00030008 	.word	0x00030008
 800f5fc:	40016100 	.word	0x40016100
 800f600:	40021000 	.word	0x40021000
 800f604:	48000800 	.word	0x48000800
 800f608:	48000400 	.word	0x48000400
    haudio_in_dfsdmchannel[0].Init.OutputClock.Activation   = ENABLE;
 800f60c:	4cb2      	ldr	r4, [pc, #712]	; (800f8d8 <BSP_AUDIO_IN_Init+0x790>)
    haudio_in_dfsdmchannel[0].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f60e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    haudio_in_dfsdmchannel[0].Init.OutputClock.Activation   = ENABLE;
 800f612:	7127      	strb	r7, [r4, #4]
    haudio_in_dfsdmchannel[0].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f614:	60a3      	str	r3, [r4, #8]
 800f616:	2104      	movs	r1, #4
    SincOrder = DFSDM_FILTER_SINC3_ORDER;
 800f618:	f04f 49c0 	mov.w	r9, #1610612736	; 0x60000000
    haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f61c:	2218      	movs	r2, #24
    haudio_in_dfsdmchannel[0].Init.Input.Multiplexer        = DFSDM_CHANNEL_EXTERNAL_INPUTS;
 800f61e:	2300      	movs	r3, #0
    haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f620:	60e2      	str	r2, [r4, #12]
    haudio_in_dfsdmchannel[0].Init.RightBitShift            = shift_amount;
 800f622:	6321      	str	r1, [r4, #48]	; 0x30
    haudio_in_dfsdmchannel[0].Init.Input.DataPacking        = DFSDM_CHANNEL_STANDARD_MODE;
 800f624:	e9c4 3304 	strd	r3, r3, [r4, #16]
    haudio_in_dfsdmchannel[0].Init.SerialInterface.Type     = DFSDM_CHANNEL_SPI_RISING;
 800f628:	e9c4 3306 	strd	r3, r3, [r4, #24]
    haudio_in_dfsdmchannel[0].Init.Offset                   = 0;
 800f62c:	62e3      	str	r3, [r4, #44]	; 0x2c
    haudio_in_dfsdmchannel[0].Init.Awd.FilterOrder          = DFSDM_CHANNEL_SINC1_ORDER;
 800f62e:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
    haudio_in_dfsdmchannel[0].Init.Awd.Oversampling         = 10;
 800f632:	220a      	movs	r2, #10
    haudio_in_dfsdmchannel[0].Instance                      = DFSDM_Channel5;
 800f634:	4ba9      	ldr	r3, [pc, #676]	; (800f8dc <BSP_AUDIO_IN_Init+0x794>)
    haudio_in_dfsdmchannel[0].Init.Awd.Oversampling         = 10;
 800f636:	62a2      	str	r2, [r4, #40]	; 0x28
    haudio_in_dfsdmchannel[0].Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 800f638:	2604      	movs	r6, #4
    haudio_in_dfsdmchannel[0].Init.Awd.FilterOrder          = DFSDM_CHANNEL_SINC1_ORDER;
 800f63a:	e9c4 6108 	strd	r6, r1, [r4, #32]
    haudio_in_dfsdmchannel[0].Instance                      = DFSDM_Channel5;
 800f63e:	6023      	str	r3, [r4, #0]
    if(HAL_DFSDM_ChannelGetState(&haudio_in_dfsdmchannel[0]) == HAL_DFSDM_CHANNEL_STATE_RESET)
 800f640:	48a5      	ldr	r0, [pc, #660]	; (800f8d8 <BSP_AUDIO_IN_Init+0x790>)
 800f642:	f001 f91b 	bl	801087c <HAL_DFSDM_ChannelGetState>
 800f646:	4604      	mov	r4, r0
 800f648:	2800      	cmp	r0, #0
 800f64a:	d049      	beq.n	800f6e0 <BSP_AUDIO_IN_Init+0x598>
    if(HAL_OK != HAL_DFSDM_ChannelInit(&haudio_in_dfsdmchannel[0]))
 800f64c:	48a2      	ldr	r0, [pc, #648]	; (800f8d8 <BSP_AUDIO_IN_Init+0x790>)
 800f64e:	f001 f86d 	bl	801072c <HAL_DFSDM_ChannelInit>
 800f652:	2800      	cmp	r0, #0
 800f654:	f47f af5b 	bne.w	800f50e <BSP_AUDIO_IN_Init+0x3c6>
    haudio_in_dfsdmfilter[0].Init.RegularParam.Trigger         = DFSDM_FILTER_SW_TRIGGER;
 800f658:	4ea1      	ldr	r6, [pc, #644]	; (800f8e0 <BSP_AUDIO_IN_Init+0x798>)
    haudio_in_dfsdmfilter[0].Init.RegularParam.FastMode        = ENABLE;
 800f65a:	2301      	movs	r3, #1
    haudio_in_dfsdmfilter[0].Init.InjectedParam.ExtTrigger     = DFSDM_FILTER_EXT_TRIG_TIM8_TRGO;
 800f65c:	f44f 7100 	mov.w	r1, #512	; 0x200
    haudio_in_dfsdmfilter[0].Init.InjectedParam.ExtTriggerEdge = DFSDM_FILTER_EXT_TRIG_BOTH_EDGES;
 800f660:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    haudio_in_dfsdmfilter[0].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f664:	f5b5 5ffa 	cmp.w	r5, #8000	; 0x1f40
    haudio_in_dfsdmfilter[0].Init.RegularParam.Trigger         = DFSDM_FILTER_SW_TRIGGER;
 800f668:	6070      	str	r0, [r6, #4]
    haudio_in_dfsdmfilter[0].Init.InjectedParam.Trigger        = DFSDM_FILTER_SW_TRIGGER;
 800f66a:	60f0      	str	r0, [r6, #12]
    haudio_in_dfsdmfilter[0].Init.InjectedParam.ScanMode       = DISABLE;
 800f66c:	7430      	strb	r0, [r6, #16]
    haudio_in_dfsdmfilter[0].Init.InjectedParam.DmaMode        = DISABLE;
 800f66e:	7470      	strb	r0, [r6, #17]
    haudio_in_dfsdmfilter[0].Init.FilterParam.SincOrder        = SincOrder;
 800f670:	f8c6 901c 	str.w	r9, [r6, #28]
    haudio_in_dfsdmfilter[0].Init.InjectedParam.ExtTriggerEdge = DFSDM_FILTER_EXT_TRIG_BOTH_EDGES;
 800f674:	e9c6 1205 	strd	r1, r2, [r6, #20]
    haudio_in_dfsdmfilter[0].Init.RegularParam.FastMode        = ENABLE;
 800f678:	7233      	strb	r3, [r6, #8]
    haudio_in_dfsdmfilter[0].Init.RegularParam.DmaMode         = ENABLE;
 800f67a:	7273      	strb	r3, [r6, #9]
    haudio_in_dfsdmfilter[0].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f67c:	d063      	beq.n	800f746 <BSP_AUDIO_IN_Init+0x5fe>
 800f67e:	f642 3311 	movw	r3, #11025	; 0x2b11
 800f682:	429d      	cmp	r5, r3
 800f684:	d05f      	beq.n	800f746 <BSP_AUDIO_IN_Init+0x5fe>
 800f686:	f5b5 5f7a 	cmp.w	r5, #16000	; 0x3e80
 800f68a:	f000 80e3 	beq.w	800f854 <BSP_AUDIO_IN_Init+0x70c>
 800f68e:	f245 6322 	movw	r3, #22050	; 0x5622
 800f692:	429d      	cmp	r5, r3
 800f694:	f000 80de 	beq.w	800f854 <BSP_AUDIO_IN_Init+0x70c>
 800f698:	f5b5 4ffa 	cmp.w	r5, #32000	; 0x7d00
 800f69c:	f000 8100 	beq.w	800f8a0 <BSP_AUDIO_IN_Init+0x758>
 800f6a0:	f64a 4344 	movw	r3, #44100	; 0xac44
 800f6a4:	429d      	cmp	r5, r3
 800f6a6:	f000 80fb 	beq.w	800f8a0 <BSP_AUDIO_IN_Init+0x758>
 800f6aa:	f64b 3380 	movw	r3, #48000	; 0xbb80
 800f6ae:	429d      	cmp	r5, r3
 800f6b0:	bf14      	ite	ne
 800f6b2:	2520      	movne	r5, #32
 800f6b4:	2540      	moveq	r5, #64	; 0x40
 800f6b6:	e048      	b.n	800f74a <BSP_AUDIO_IN_Init+0x602>
    haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f6b8:	f5b5 5f7a 	cmp.w	r5, #16000	; 0x3e80
 800f6bc:	f000 80b8 	beq.w	800f830 <BSP_AUDIO_IN_Init+0x6e8>
 800f6c0:	f245 6322 	movw	r3, #22050	; 0x5622
 800f6c4:	429d      	cmp	r5, r3
 800f6c6:	f43f ae14 	beq.w	800f2f2 <BSP_AUDIO_IN_Init+0x1aa>
 800f6ca:	f5b5 4ffa 	cmp.w	r5, #32000	; 0x7d00
 800f6ce:	f000 80af 	beq.w	800f830 <BSP_AUDIO_IN_Init+0x6e8>
 800f6d2:	f64a 4244 	movw	r2, #44100	; 0xac44
 800f6d6:	4295      	cmp	r5, r2
 800f6d8:	bf14      	ite	ne
 800f6da:	2210      	movne	r2, #16
 800f6dc:	2204      	moveq	r2, #4
 800f6de:	e79e      	b.n	800f61e <BSP_AUDIO_IN_Init+0x4d6>
      AUDIO_IN_DFSDM_CLK_ENABLE();  
 800f6e0:	4b80      	ldr	r3, [pc, #512]	; (800f8e4 <BSP_AUDIO_IN_Init+0x79c>)
      HAL_GPIO_Init(AUDIO_IN_DFSDM_CKOUT_GPIO_PORT, &GPIO_InitStruct);
 800f6e2:	4881      	ldr	r0, [pc, #516]	; (800f8e8 <BSP_AUDIO_IN_Init+0x7a0>)
      AUDIO_IN_DFSDM_CLK_ENABLE();  
 800f6e4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800f6e6:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800f6ea:	661a      	str	r2, [r3, #96]	; 0x60
 800f6ec:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800f6ee:	f002 7280 	and.w	r2, r2, #16777216	; 0x1000000
 800f6f2:	9202      	str	r2, [sp, #8]
 800f6f4:	9a02      	ldr	r2, [sp, #8]
      AUDIO_IN_DFSDM_CKOUT_GPIO_CLK_ENABLE(); 
 800f6f6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800f6f8:	4332      	orrs	r2, r6
 800f6fa:	64da      	str	r2, [r3, #76]	; 0x4c
 800f6fc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800f6fe:	4032      	ands	r2, r6
 800f700:	9203      	str	r2, [sp, #12]
 800f702:	9a03      	ldr	r2, [sp, #12]
      AUDIO_IN_DFSDM_CH12_DATAIN_GPIO_CLK_ENABLE();
 800f704:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800f706:	f042 0202 	orr.w	r2, r2, #2
 800f70a:	64da      	str	r2, [r3, #76]	; 0x4c
 800f70c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
      GPIO_InitStruct.Pin = AUDIO_IN_DFSDM_CKOUT_PIN;
 800f70e:	9609      	str	r6, [sp, #36]	; 0x24
      AUDIO_IN_DFSDM_CH12_DATAIN_GPIO_CLK_ENABLE();
 800f710:	f003 0302 	and.w	r3, r3, #2
 800f714:	9304      	str	r3, [sp, #16]
      HAL_GPIO_Init(AUDIO_IN_DFSDM_CKOUT_GPIO_PORT, &GPIO_InitStruct);
 800f716:	a909      	add	r1, sp, #36	; 0x24
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800f718:	f04f 0802 	mov.w	r8, #2
      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800f71c:	2703      	movs	r7, #3
      GPIO_InitStruct.Alternate = AUDIO_IN_DFSDM_CKOUT_DATIN_AF;
 800f71e:	2606      	movs	r6, #6
      AUDIO_IN_DFSDM_CH12_DATAIN_GPIO_CLK_ENABLE();
 800f720:	9b04      	ldr	r3, [sp, #16]
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800f722:	e9cd 840a 	strd	r8, r4, [sp, #40]	; 0x28
      GPIO_InitStruct.Alternate = AUDIO_IN_DFSDM_CKOUT_DATIN_AF;
 800f726:	e9cd 760c 	strd	r7, r6, [sp, #48]	; 0x30
      HAL_GPIO_Init(AUDIO_IN_DFSDM_CKOUT_GPIO_PORT, &GPIO_InitStruct);
 800f72a:	f001 fd5b 	bl	80111e4 <HAL_GPIO_Init>
      GPIO_InitStruct.Pin = AUDIO_IN_DFSDM_CH12_DATIN_PIN;
 800f72e:	2340      	movs	r3, #64	; 0x40
      HAL_GPIO_Init(AUDIO_IN_DFSDM_CH12_DATIN_GPIO_PORT, &GPIO_InitStruct); 
 800f730:	a909      	add	r1, sp, #36	; 0x24
 800f732:	486e      	ldr	r0, [pc, #440]	; (800f8ec <BSP_AUDIO_IN_Init+0x7a4>)
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800f734:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
      GPIO_InitStruct.Alternate = AUDIO_IN_DFSDM_CKOUT_DATIN_AF;
 800f738:	e9cd 760c 	strd	r7, r6, [sp, #48]	; 0x30
      GPIO_InitStruct.Pull = GPIO_NOPULL;
 800f73c:	940b      	str	r4, [sp, #44]	; 0x2c
      GPIO_InitStruct.Pin = AUDIO_IN_DFSDM_CH12_DATIN_PIN;
 800f73e:	9309      	str	r3, [sp, #36]	; 0x24
      HAL_GPIO_Init(AUDIO_IN_DFSDM_CH12_DATIN_GPIO_PORT, &GPIO_InitStruct); 
 800f740:	f001 fd50 	bl	80111e4 <HAL_GPIO_Init>
 800f744:	e782      	b.n	800f64c <BSP_AUDIO_IN_Init+0x504>
    haudio_in_dfsdmfilter[0].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f746:	f44f 7580 	mov.w	r5, #256	; 0x100
    haudio_in_dfsdmfilter[0].Init.FilterParam.IntOversampling  = 1;  
 800f74a:	2201      	movs	r2, #1
    haudio_in_dfsdmfilter[0].Instance                          = AUDIO_IN_DFSDM_1st_FILTER;
 800f74c:	4b68      	ldr	r3, [pc, #416]	; (800f8f0 <BSP_AUDIO_IN_Init+0x7a8>)
    if(HAL_DFSDM_FilterGetState(&haudio_in_dfsdmfilter[0]) == HAL_DFSDM_FILTER_STATE_RESET)
 800f74e:	4864      	ldr	r0, [pc, #400]	; (800f8e0 <BSP_AUDIO_IN_Init+0x798>)
    haudio_in_dfsdmfilter[0].Instance                          = AUDIO_IN_DFSDM_1st_FILTER;
 800f750:	6033      	str	r3, [r6, #0]
    haudio_in_dfsdmfilter[0].Init.FilterParam.IntOversampling  = 1;  
 800f752:	e9c6 5208 	strd	r5, r2, [r6, #32]
    if(HAL_DFSDM_FilterGetState(&haudio_in_dfsdmfilter[0]) == HAL_DFSDM_FILTER_STATE_RESET)
 800f756:	f001 f9c3 	bl	8010ae0 <HAL_DFSDM_FilterGetState>
 800f75a:	2800      	cmp	r0, #0
 800f75c:	d06a      	beq.n	800f834 <BSP_AUDIO_IN_Init+0x6ec>
    if(HAL_OK != HAL_DFSDM_FilterInit(&haudio_in_dfsdmfilter[0]))
 800f75e:	4860      	ldr	r0, [pc, #384]	; (800f8e0 <BSP_AUDIO_IN_Init+0x798>)
 800f760:	f001 f892 	bl	8010888 <HAL_DFSDM_FilterInit>
 800f764:	2800      	cmp	r0, #0
 800f766:	f47f aed2 	bne.w	800f50e <BSP_AUDIO_IN_Init+0x3c6>
    if(HAL_OK != HAL_DFSDM_FilterConfigRegChannel(&haudio_in_dfsdmfilter[0], DFSDM_CHANNEL_5, DFSDM_CONTINUOUS_CONV_ON))
 800f76a:	2201      	movs	r2, #1
 800f76c:	4961      	ldr	r1, [pc, #388]	; (800f8f4 <BSP_AUDIO_IN_Init+0x7ac>)
 800f76e:	485c      	ldr	r0, [pc, #368]	; (800f8e0 <BSP_AUDIO_IN_Init+0x798>)
 800f770:	f001 f910 	bl	8010994 <HAL_DFSDM_FilterConfigRegChannel>
      return AUDIO_ERROR;
 800f774:	3000      	adds	r0, #0
 800f776:	bf18      	it	ne
 800f778:	2001      	movne	r0, #1
 800f77a:	e6b2      	b.n	800f4e2 <BSP_AUDIO_IN_Init+0x39a>
      haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f77c:	f04f 0a18 	mov.w	sl, #24
 800f780:	e550      	b.n	800f224 <BSP_AUDIO_IN_Init+0xdc>
      if(HAL_OK != HAL_DFSDM_FilterConfigRegChannel(&haudio_in_dfsdmfilter[0], DFSDM_CHANNEL_6, DFSDM_CONTINUOUS_CONV_ON))
 800f782:	2201      	movs	r2, #1
 800f784:	495c      	ldr	r1, [pc, #368]	; (800f8f8 <BSP_AUDIO_IN_Init+0x7b0>)
 800f786:	4856      	ldr	r0, [pc, #344]	; (800f8e0 <BSP_AUDIO_IN_Init+0x798>)
 800f788:	f001 f904 	bl	8010994 <HAL_DFSDM_FilterConfigRegChannel>
 800f78c:	2800      	cmp	r0, #0
 800f78e:	f47f aebe 	bne.w	800f50e <BSP_AUDIO_IN_Init+0x3c6>
      haudio_in_dfsdmchannel[1].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f792:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
      haudio_in_dfsdmchannel[1].Init.Input.Pins               = DFSDM_CHANNEL_FOLLOWING_CHANNEL_PINS;
 800f796:	f44f 7280 	mov.w	r2, #256	; 0x100
      haudio_in_dfsdmchannel[1].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f79a:	6421      	str	r1, [r4, #64]	; 0x40
      haudio_in_dfsdmchannel[1].Init.Input.Pins               = DFSDM_CHANNEL_FOLLOWING_CHANNEL_PINS;
 800f79c:	6522      	str	r2, [r4, #80]	; 0x50
      haudio_in_dfsdmchannel[1].Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 800f79e:	2104      	movs	r1, #4
      haudio_in_dfsdmchannel[1].Init.Awd.FilterOrder          = DFSDM_CHANNEL_SINC1_ORDER;
 800f7a0:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
      haudio_in_dfsdmchannel[1].Init.OutputClock.Activation   = ENABLE;
 800f7a4:	2301      	movs	r3, #1
      haudio_in_dfsdmchannel[1].Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 800f7a6:	65a1      	str	r1, [r4, #88]	; 0x58
      haudio_in_dfsdmchannel[1].Init.Awd.FilterOrder          = DFSDM_CHANNEL_SINC1_ORDER;
 800f7a8:	65e2      	str	r2, [r4, #92]	; 0x5c
      haudio_in_dfsdmchannel[1].Init.Awd.Oversampling         = 10;
 800f7aa:	210a      	movs	r1, #10
      haudio_in_dfsdmchannel[1].Instance                      = DFSDM_Channel5; 
 800f7ac:	4a4b      	ldr	r2, [pc, #300]	; (800f8dc <BSP_AUDIO_IN_Init+0x794>)
      haudio_in_dfsdmchannel[1].Init.Offset                   = 0;
 800f7ae:	6660      	str	r0, [r4, #100]	; 0x64
      haudio_in_dfsdmchannel[1].Init.Input.DataPacking        = DFSDM_CHANNEL_STANDARD_MODE;
 800f7b0:	e9c4 0012 	strd	r0, r0, [r4, #72]	; 0x48
      haudio_in_dfsdmchannel[1].Init.OutputClock.Activation   = ENABLE;
 800f7b4:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
      haudio_in_dfsdmchannel[1].Init.SerialInterface.Type     = DFSDM_CHANNEL_SPI_FALLING;
 800f7b8:	6563      	str	r3, [r4, #84]	; 0x54
      haudio_in_dfsdmchannel[1].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f7ba:	f8c4 a044 	str.w	sl, [r4, #68]	; 0x44
      haudio_in_dfsdmchannel[1].Init.RightBitShift            = shift_amount;
 800f7be:	f8c4 8068 	str.w	r8, [r4, #104]	; 0x68
      haudio_in_dfsdmchannel[1].Init.Awd.Oversampling         = 10;
 800f7c2:	6621      	str	r1, [r4, #96]	; 0x60
      if(HAL_OK != HAL_DFSDM_ChannelInit(&haudio_in_dfsdmchannel[1]))
 800f7c4:	484d      	ldr	r0, [pc, #308]	; (800f8fc <BSP_AUDIO_IN_Init+0x7b4>)
      haudio_in_dfsdmchannel[1].Instance                      = DFSDM_Channel5; 
 800f7c6:	63a2      	str	r2, [r4, #56]	; 0x38
      haudio_in_dfsdmchannel[1].Init.SerialInterface.Type     = DFSDM_CHANNEL_SPI_FALLING;
 800f7c8:	9300      	str	r3, [sp, #0]
      if(HAL_OK != HAL_DFSDM_ChannelInit(&haudio_in_dfsdmchannel[1]))
 800f7ca:	f000 ffaf 	bl	801072c <HAL_DFSDM_ChannelInit>
 800f7ce:	9b00      	ldr	r3, [sp, #0]
 800f7d0:	2800      	cmp	r0, #0
 800f7d2:	f47f ae9c 	bne.w	800f50e <BSP_AUDIO_IN_Init+0x3c6>
      haudio_in_dfsdmfilter[1].Init.InjectedParam.ExtTrigger     = DFSDM_FILTER_EXT_TRIG_TIM8_TRGO;    
 800f7d6:	f44f 7400 	mov.w	r4, #512	; 0x200
        haudio_in_dfsdmfilter[1].Init.InjectedParam.ExtTriggerEdge = DFSDM_FILTER_EXT_TRIG_BOTH_EDGES;      
 800f7da:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
      haudio_in_dfsdmfilter[1].Instance                          = AUDIO_IN_DFSDM_2st_FILTER;    
 800f7de:	4a48      	ldr	r2, [pc, #288]	; (800f900 <BSP_AUDIO_IN_Init+0x7b8>)
      haudio_in_dfsdmfilter[1].Init.InjectedParam.Trigger        = DFSDM_FILTER_SW_TRIGGER;
 800f7e0:	6630      	str	r0, [r6, #96]	; 0x60
      haudio_in_dfsdmfilter[1].Init.RegularParam.Trigger         = DFSDM_FILTER_SYNC_TRIGGER;
 800f7e2:	65b3      	str	r3, [r6, #88]	; 0x58
      haudio_in_dfsdmfilter[1].Init.RegularParam.FastMode        = ENABLE;
 800f7e4:	f886 305c 	strb.w	r3, [r6, #92]	; 0x5c
      haudio_in_dfsdmfilter[1].Init.RegularParam.DmaMode         = ENABLE;
 800f7e8:	f886 305d 	strb.w	r3, [r6, #93]	; 0x5d
      haudio_in_dfsdmfilter[1].Init.InjectedParam.ScanMode       = ENABLE;
 800f7ec:	f886 3064 	strb.w	r3, [r6, #100]	; 0x64
      haudio_in_dfsdmfilter[1].Init.InjectedParam.DmaMode        = ENABLE;
 800f7f0:	f886 3065 	strb.w	r3, [r6, #101]	; 0x65
      haudio_in_dfsdmfilter[1].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f7f4:	e9c6 9b1c 	strd	r9, fp, [r6, #112]	; 0x70
      haudio_in_dfsdmfilter[1].Init.FilterParam.IntOversampling  = 1;    
 800f7f8:	67b3      	str	r3, [r6, #120]	; 0x78
      if(HAL_DFSDM_FilterGetState(&haudio_in_dfsdmfilter[1]) == HAL_DFSDM_FILTER_STATE_RESET)
 800f7fa:	4842      	ldr	r0, [pc, #264]	; (800f904 <BSP_AUDIO_IN_Init+0x7bc>)
      haudio_in_dfsdmfilter[1].Instance                          = AUDIO_IN_DFSDM_2st_FILTER;    
 800f7fc:	6572      	str	r2, [r6, #84]	; 0x54
        haudio_in_dfsdmfilter[1].Init.InjectedParam.ExtTriggerEdge = DFSDM_FILTER_EXT_TRIG_BOTH_EDGES;      
 800f7fe:	e9c6 411a 	strd	r4, r1, [r6, #104]	; 0x68
      if(HAL_DFSDM_FilterGetState(&haudio_in_dfsdmfilter[1]) == HAL_DFSDM_FILTER_STATE_RESET)
 800f802:	f001 f96d 	bl	8010ae0 <HAL_DFSDM_FilterGetState>
 800f806:	2800      	cmp	r0, #0
 800f808:	d050      	beq.n	800f8ac <BSP_AUDIO_IN_Init+0x764>
      if(HAL_OK != HAL_DFSDM_FilterInit(&haudio_in_dfsdmfilter[1]))
 800f80a:	483e      	ldr	r0, [pc, #248]	; (800f904 <BSP_AUDIO_IN_Init+0x7bc>)
 800f80c:	f001 f83c 	bl	8010888 <HAL_DFSDM_FilterInit>
 800f810:	2800      	cmp	r0, #0
 800f812:	f47f ae7c 	bne.w	800f50e <BSP_AUDIO_IN_Init+0x3c6>
      if(HAL_OK != HAL_DFSDM_FilterConfigRegChannel(&haudio_in_dfsdmfilter[1], DFSDM_CHANNEL_5, DFSDM_CONTINUOUS_CONV_ON))
 800f816:	2201      	movs	r2, #1
 800f818:	4936      	ldr	r1, [pc, #216]	; (800f8f4 <BSP_AUDIO_IN_Init+0x7ac>)
 800f81a:	483a      	ldr	r0, [pc, #232]	; (800f904 <BSP_AUDIO_IN_Init+0x7bc>)
 800f81c:	f001 f8ba 	bl	8010994 <HAL_DFSDM_FilterConfigRegChannel>
 800f820:	2800      	cmp	r0, #0
 800f822:	f43f acc4 	beq.w	800f1ae <BSP_AUDIO_IN_Init+0x66>
 800f826:	e672      	b.n	800f50e <BSP_AUDIO_IN_Init+0x3c6>
        DFSDMx_FilterMspInit(&haudio_in_dfsdmfilter[0]);
 800f828:	482d      	ldr	r0, [pc, #180]	; (800f8e0 <BSP_AUDIO_IN_Init+0x798>)
 800f82a:	f7ff fb5f 	bl	800eeec <DFSDMx_FilterMspInit>
 800f82e:	e668      	b.n	800f502 <BSP_AUDIO_IN_Init+0x3ba>
    haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f830:	2218      	movs	r2, #24
 800f832:	e6f4      	b.n	800f61e <BSP_AUDIO_IN_Init+0x4d6>
      DFSDMx_FilterMspInit(&haudio_in_dfsdmfilter[0]);
 800f834:	482a      	ldr	r0, [pc, #168]	; (800f8e0 <BSP_AUDIO_IN_Init+0x798>)
 800f836:	f7ff fb59 	bl	800eeec <DFSDMx_FilterMspInit>
 800f83a:	e790      	b.n	800f75e <BSP_AUDIO_IN_Init+0x616>
      haudio_in_dfsdmchannel[2].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f83c:	2718      	movs	r7, #24
 800f83e:	e582      	b.n	800f346 <BSP_AUDIO_IN_Init+0x1fe>
    haudio_in_dfsdmchannel[0].Init.OutputClock.Activation   = ENABLE;
 800f840:	4c25      	ldr	r4, [pc, #148]	; (800f8d8 <BSP_AUDIO_IN_Init+0x790>)
    haudio_in_dfsdmchannel[0].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f842:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    haudio_in_dfsdmchannel[0].Init.OutputClock.Activation   = ENABLE;
 800f846:	7127      	strb	r7, [r4, #4]
    haudio_in_dfsdmchannel[0].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f848:	60a3      	str	r3, [r4, #8]
 800f84a:	2105      	movs	r1, #5
    SincOrder = DFSDM_FILTER_SINC5_ORDER;
 800f84c:	f04f 4920 	mov.w	r9, #2684354560	; 0xa0000000
    haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f850:	2210      	movs	r2, #16
 800f852:	e6e4      	b.n	800f61e <BSP_AUDIO_IN_Init+0x4d6>
    haudio_in_dfsdmfilter[0].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f854:	2580      	movs	r5, #128	; 0x80
 800f856:	e778      	b.n	800f74a <BSP_AUDIO_IN_Init+0x602>
        AUDIO_IN_DFSDM_CH34_EXT_DATAIN_GPIO_CLK_ENABLE();
 800f858:	4a22      	ldr	r2, [pc, #136]	; (800f8e4 <BSP_AUDIO_IN_Init+0x79c>)
        HAL_GPIO_Init(AUDIO_IN_DFSDM_CH34_EXT_DATIN_GPIO_PORT, &GPIO_InitStruct);
 800f85a:	4823      	ldr	r0, [pc, #140]	; (800f8e8 <BSP_AUDIO_IN_Init+0x7a0>)
        AUDIO_IN_DFSDM_CH34_EXT_DATAIN_GPIO_CLK_ENABLE();
 800f85c:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 800f85e:	f041 0104 	orr.w	r1, r1, #4
 800f862:	64d1      	str	r1, [r2, #76]	; 0x4c
 800f864:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
        GPIO_InitStruct.Pull = GPIO_NOPULL;
 800f866:	930b      	str	r3, [sp, #44]	; 0x2c
        AUDIO_IN_DFSDM_CH34_EXT_DATAIN_GPIO_CLK_ENABLE();
 800f868:	f002 0204 	and.w	r2, r2, #4
        GPIO_InitStruct.Pin = AUDIO_IN_DFSDM_CH34_EXT_DATIN_PIN;
 800f86c:	2301      	movs	r3, #1
        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800f86e:	2102      	movs	r1, #2
        AUDIO_IN_DFSDM_CH34_EXT_DATAIN_GPIO_CLK_ENABLE();
 800f870:	9208      	str	r2, [sp, #32]
        GPIO_InitStruct.Pin = AUDIO_IN_DFSDM_CH34_EXT_DATIN_PIN;
 800f872:	9309      	str	r3, [sp, #36]	; 0x24
        GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800f874:	2203      	movs	r2, #3
        GPIO_InitStruct.Alternate = AUDIO_IN_DFSDM_CKOUT_DATIN_AF;
 800f876:	2306      	movs	r3, #6
        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800f878:	910a      	str	r1, [sp, #40]	; 0x28
        HAL_GPIO_Init(AUDIO_IN_DFSDM_CH34_EXT_DATIN_GPIO_PORT, &GPIO_InitStruct);
 800f87a:	a909      	add	r1, sp, #36	; 0x24
        AUDIO_IN_DFSDM_CH34_EXT_DATAIN_GPIO_CLK_ENABLE();
 800f87c:	9e08      	ldr	r6, [sp, #32]
        GPIO_InitStruct.Alternate = AUDIO_IN_DFSDM_CKOUT_DATIN_AF;
 800f87e:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
        HAL_GPIO_Init(AUDIO_IN_DFSDM_CH34_EXT_DATIN_GPIO_PORT, &GPIO_InitStruct);
 800f882:	f001 fcaf 	bl	80111e4 <HAL_GPIO_Init>
 800f886:	e57b      	b.n	800f380 <BSP_AUDIO_IN_Init+0x238>
      haudio_in_dfsdmchannel[2].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f888:	2704      	movs	r7, #4
 800f88a:	e55c      	b.n	800f346 <BSP_AUDIO_IN_Init+0x1fe>
      haudio_in_dfsdmfilter[2].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f88c:	f44f 7580 	mov.w	r5, #256	; 0x100
 800f890:	e5b6      	b.n	800f400 <BSP_AUDIO_IN_Init+0x2b8>
      haudio_in_dfsdmfilter[0].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f892:	f04f 0b40 	mov.w	fp, #64	; 0x40
 800f896:	e629      	b.n	800f4ec <BSP_AUDIO_IN_Init+0x3a4>
        DFSDMx_FilterMspInit(&haudio_in_dfsdmfilter[2]);
 800f898:	481b      	ldr	r0, [pc, #108]	; (800f908 <BSP_AUDIO_IN_Init+0x7c0>)
 800f89a:	f7ff fb27 	bl	800eeec <DFSDMx_FilterMspInit>
 800f89e:	e5bb      	b.n	800f418 <BSP_AUDIO_IN_Init+0x2d0>
    haudio_in_dfsdmfilter[0].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f8a0:	2540      	movs	r5, #64	; 0x40
 800f8a2:	e752      	b.n	800f74a <BSP_AUDIO_IN_Init+0x602>
      haudio_in_dfsdmfilter[2].Init.FilterParam.Oversampling     = OverSampling(AudioFreq);
 800f8a4:	2580      	movs	r5, #128	; 0x80
 800f8a6:	e5ab      	b.n	800f400 <BSP_AUDIO_IN_Init+0x2b8>
 800f8a8:	2540      	movs	r5, #64	; 0x40
 800f8aa:	e5a9      	b.n	800f400 <BSP_AUDIO_IN_Init+0x2b8>
        DFSDMx_FilterMspInit(&haudio_in_dfsdmfilter[1]);
 800f8ac:	4815      	ldr	r0, [pc, #84]	; (800f904 <BSP_AUDIO_IN_Init+0x7bc>)
 800f8ae:	f7ff fb1d 	bl	800eeec <DFSDMx_FilterMspInit>
 800f8b2:	e7aa      	b.n	800f80a <BSP_AUDIO_IN_Init+0x6c2>
        DFSDMx_FilterMspInit(&haudio_in_dfsdmfilter[3]);
 800f8b4:	4815      	ldr	r0, [pc, #84]	; (800f90c <BSP_AUDIO_IN_Init+0x7c4>)
 800f8b6:	f7ff fb19 	bl	800eeec <DFSDMx_FilterMspInit>
 800f8ba:	e604      	b.n	800f4c6 <BSP_AUDIO_IN_Init+0x37e>
      haudio_in_dfsdmchannel[0].Init.OutputClock.Activation   = ENABLE;
 800f8bc:	4c06      	ldr	r4, [pc, #24]	; (800f8d8 <BSP_AUDIO_IN_Init+0x790>)
 800f8be:	2201      	movs	r2, #1
      haudio_in_dfsdmchannel[0].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f8c0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
      haudio_in_dfsdmchannel[0].Init.OutputClock.Activation   = ENABLE;
 800f8c4:	7122      	strb	r2, [r4, #4]
      haudio_in_dfsdmchannel[0].Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800f8c6:	60a3      	str	r3, [r4, #8]
    SincOrder = DFSDM_FILTER_SINC5_ORDER;
 800f8c8:	f04f 4920 	mov.w	r9, #2684354560	; 0xa0000000
    shift_amount = 5;
 800f8cc:	f04f 0805 	mov.w	r8, #5
      haudio_in_dfsdmchannel[0].Init.OutputClock.Divider      = ClockDivider(AudioFreq);
 800f8d0:	f04f 0a10 	mov.w	sl, #16
 800f8d4:	e4a6      	b.n	800f224 <BSP_AUDIO_IN_Init+0xdc>
 800f8d6:	bf00      	nop
 800f8d8:	200111b8 	.word	0x200111b8
 800f8dc:	400160a0 	.word	0x400160a0
 800f8e0:	20011298 	.word	0x20011298
 800f8e4:	40021000 	.word	0x40021000
 800f8e8:	48000800 	.word	0x48000800
 800f8ec:	48000400 	.word	0x48000400
 800f8f0:	40016100 	.word	0x40016100
 800f8f4:	00050020 	.word	0x00050020
 800f8f8:	00060040 	.word	0x00060040
 800f8fc:	200111f0 	.word	0x200111f0
 800f900:	40016180 	.word	0x40016180
 800f904:	200112ec 	.word	0x200112ec
 800f908:	20011340 	.word	0x20011340
 800f90c:	20011394 	.word	0x20011394

0800f910 <BSP_AUDIO_IN_Record>:
{  
 800f910:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  SENSORTILE_AudioIn_Handler.PCM_Data = pbuf;
 800f914:	4e14      	ldr	r6, [pc, #80]	; (800f968 <BSP_AUDIO_IN_Record+0x58>)
  for (counter = SENSORTILE_AudioIn_Handler.MicChannels; counter > 0; counter --)
 800f916:	6834      	ldr	r4, [r6, #0]
  SENSORTILE_AudioIn_Handler.PCM_Data = pbuf;
 800f918:	63b0      	str	r0, [r6, #56]	; 0x38
  for (counter = SENSORTILE_AudioIn_Handler.MicChannels; counter > 0; counter --)
 800f91a:	2c00      	cmp	r4, #0
 800f91c:	dd20      	ble.n	800f960 <BSP_AUDIO_IN_Record+0x50>
 800f91e:	4b13      	ldr	r3, [pc, #76]	; (800f96c <BSP_AUDIO_IN_Record+0x5c>)
 800f920:	4d13      	ldr	r5, [pc, #76]	; (800f970 <BSP_AUDIO_IN_Record+0x60>)
                                                   SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000 * 2)) 
 800f922:	4f14      	ldr	r7, [pc, #80]	; (800f974 <BSP_AUDIO_IN_Record+0x64>)
 800f924:	3c01      	subs	r4, #1
 800f926:	f04f 0854 	mov.w	r8, #84	; 0x54
 800f92a:	fb08 3804 	mla	r8, r8, r4, r3
 800f92e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 800f932:	eb05 2503 	add.w	r5, r5, r3, lsl #8
 800f936:	e005      	b.n	800f944 <BSP_AUDIO_IN_Record+0x34>
 800f938:	f1a8 0854 	sub.w	r8, r8, #84	; 0x54
 800f93c:	f5a5 7540 	sub.w	r5, r5, #768	; 0x300
  for (counter = SENSORTILE_AudioIn_Handler.MicChannels; counter > 0; counter --)
 800f940:	b174      	cbz	r4, 800f960 <BSP_AUDIO_IN_Record+0x50>
 800f942:	3c01      	subs	r4, #1
                                                   SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000 * 2)) 
 800f944:	6872      	ldr	r2, [r6, #4]
 800f946:	fba7 3202 	umull	r3, r2, r7, r2
 800f94a:	0992      	lsrs	r2, r2, #6
    if (HAL_OK != HAL_DFSDM_FilterRegularStart_DMA(&haudio_in_dfsdmfilter[counter-1],
 800f94c:	0052      	lsls	r2, r2, #1
 800f94e:	4629      	mov	r1, r5
 800f950:	4640      	mov	r0, r8
 800f952:	f001 f83f 	bl	80109d4 <HAL_DFSDM_FilterRegularStart_DMA>
 800f956:	2800      	cmp	r0, #0
 800f958:	d0ee      	beq.n	800f938 <BSP_AUDIO_IN_Record+0x28>
      return AUDIO_ERROR;
 800f95a:	2001      	movs	r0, #1
}
 800f95c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return AUDIO_OK;
 800f960:	2000      	movs	r0, #0
}
 800f962:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800f966:	bf00      	nop
 800f968:	20001844 	.word	0x20001844
 800f96c:	20011298 	.word	0x20011298
 800f970:	200105b8 	.word	0x200105b8
 800f974:	10624dd3 	.word	0x10624dd3

0800f978 <BSP_AUDIO_IN_Stop>:
{
 800f978:	b538      	push	{r3, r4, r5, lr}
  for (counter = SENSORTILE_AudioIn_Handler.MicChannels; counter > 0; counter --)
 800f97a:	4b0b      	ldr	r3, [pc, #44]	; (800f9a8 <BSP_AUDIO_IN_Stop+0x30>)
 800f97c:	681c      	ldr	r4, [r3, #0]
 800f97e:	2c00      	cmp	r4, #0
 800f980:	dd0f      	ble.n	800f9a2 <BSP_AUDIO_IN_Stop+0x2a>
 800f982:	4b0a      	ldr	r3, [pc, #40]	; (800f9ac <BSP_AUDIO_IN_Stop+0x34>)
 800f984:	3c01      	subs	r4, #1
 800f986:	2554      	movs	r5, #84	; 0x54
 800f988:	fb05 3504 	mla	r5, r5, r4, r3
 800f98c:	e002      	b.n	800f994 <BSP_AUDIO_IN_Stop+0x1c>
 800f98e:	3d54      	subs	r5, #84	; 0x54
 800f990:	b13c      	cbz	r4, 800f9a2 <BSP_AUDIO_IN_Stop+0x2a>
 800f992:	3c01      	subs	r4, #1
    if (HAL_OK != HAL_DFSDM_FilterRegularStop_DMA(&haudio_in_dfsdmfilter[counter-1])) 
 800f994:	4628      	mov	r0, r5
 800f996:	f001 f871 	bl	8010a7c <HAL_DFSDM_FilterRegularStop_DMA>
 800f99a:	2800      	cmp	r0, #0
 800f99c:	d0f7      	beq.n	800f98e <BSP_AUDIO_IN_Stop+0x16>
      return AUDIO_ERROR;
 800f99e:	2001      	movs	r0, #1
}
 800f9a0:	bd38      	pop	{r3, r4, r5, pc}
  return AUDIO_OK;
 800f9a2:	2000      	movs	r0, #0
}
 800f9a4:	bd38      	pop	{r3, r4, r5, pc}
 800f9a6:	bf00      	nop
 800f9a8:	20001844 	.word	0x20001844
 800f9ac:	20011298 	.word	0x20011298

0800f9b0 <BSP_AUDIO_IN_SetVolume>:
  AudioInVolume = Volume;
 800f9b0:	4b01      	ldr	r3, [pc, #4]	; (800f9b8 <BSP_AUDIO_IN_SetVolume+0x8>)
 800f9b2:	8018      	strh	r0, [r3, #0]
}
 800f9b4:	2000      	movs	r0, #0
 800f9b6:	4770      	bx	lr
 800f9b8:	200003fc 	.word	0x200003fc

0800f9bc <HAL_DFSDM_FilterRegConvCpltCallback>:
*/
void HAL_DFSDM_FilterRegConvCpltCallback(DFSDM_Filter_HandleTypeDef *hdfsdm_filter)
{  
  uint32_t i, j = 0;
  
  if (hdfsdm_filter == &haudio_in_dfsdmfilter[0]) 
 800f9bc:	4b30      	ldr	r3, [pc, #192]	; (800fa80 <HAL_DFSDM_FilterRegConvCpltCallback+0xc4>)
 800f9be:	4283      	cmp	r3, r0
 800f9c0:	d000      	beq.n	800f9c4 <HAL_DFSDM_FilterRegConvCpltCallback+0x8>
 800f9c2:	4770      	bx	lr
{  
 800f9c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  {
    for(j=0; j < SENSORTILE_AudioIn_Handler.MicChannels; j ++)
 800f9c8:	4b2e      	ldr	r3, [pc, #184]	; (800fa84 <HAL_DFSDM_FilterRegConvCpltCallback+0xc8>)
{  
 800f9ca:	b085      	sub	sp, #20
    for(j=0; j < SENSORTILE_AudioIn_Handler.MicChannels; j ++)
 800f9cc:	681d      	ldr	r5, [r3, #0]
 800f9ce:	9501      	str	r5, [sp, #4]
 800f9d0:	2d00      	cmp	r5, #0
 800f9d2:	d050      	beq.n	800fa76 <HAL_DFSDM_FilterRegConvCpltCallback+0xba>
    {
      for (i = 0; i < SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000; i++)
 800f9d4:	685a      	ldr	r2, [r3, #4]
 800f9d6:	482c      	ldr	r0, [pc, #176]	; (800fa88 <HAL_DFSDM_FilterRegConvCpltCallback+0xcc>)
      {
        SENSORTILE_AudioIn_Handler.HP_Filters[j].Z = ((RecBuff[j][i + SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000] >> 8) * AudioInVolume) >> 7;
 800f9d8:	4c2c      	ldr	r4, [pc, #176]	; (800fa8c <HAL_DFSDM_FilterRegConvCpltCallback+0xd0>)
 800f9da:	492d      	ldr	r1, [pc, #180]	; (800fa90 <HAL_DFSDM_FilterRegConvCpltCallback+0xd4>)
        SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut = (0xFC * (SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut + SENSORTILE_AudioIn_Handler.HP_Filters[j].Z - SENSORTILE_AudioIn_Handler.HP_Filters[j].oldIn)) / 256;
        SENSORTILE_AudioIn_Handler.HP_Filters[j].oldIn = SENSORTILE_AudioIn_Handler.HP_Filters[j].Z;
        SENSORTILE_AudioIn_Handler.PCM_Data[i * SENSORTILE_AudioIn_Handler.MicChannels + j] = SaturaLH(SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut, -32760, 32760);
 800f9dc:	f8df c0b4 	ldr.w	ip, [pc, #180]	; 800fa94 <HAL_DFSDM_FilterRegConvCpltCallback+0xd8>
        SENSORTILE_AudioIn_Handler.HP_Filters[j].Z = ((RecBuff[j][i + SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000] >> 8) * AudioInVolume) >> 7;
 800f9e0:	8827      	ldrh	r7, [r4, #0]
 800f9e2:	469e      	mov	lr, r3
      for (i = 0; i < SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000; i++)
 800f9e4:	fba0 0202 	umull	r0, r2, r0, r2
 800f9e8:	0993      	lsrs	r3, r2, #6
 800f9ea:	9302      	str	r3, [sp, #8]
 800f9ec:	f8de a038 	ldr.w	sl, [lr, #56]	; 0x38
 800f9f0:	009b      	lsls	r3, r3, #2
 800f9f2:	9303      	str	r3, [sp, #12]
 800f9f4:	eb03 0801 	add.w	r8, r3, r1
 800f9f8:	006e      	lsls	r6, r5, #1
    for(j=0; j < SENSORTILE_AudioIn_Handler.MicChannels; j ++)
 800f9fa:	f04f 0900 	mov.w	r9, #0
        SENSORTILE_AudioIn_Handler.PCM_Data[i * SENSORTILE_AudioIn_Handler.MicChannels + j] = SaturaLH(SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut, -32760, 32760);
 800f9fe:	f647 7bf8 	movw	fp, #32760	; 0x7ff8
      for (i = 0; i < SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000; i++)
 800fa02:	9b02      	ldr	r3, [sp, #8]
 800fa04:	b363      	cbz	r3, 800fa60 <HAL_DFSDM_FilterRegConvCpltCallback+0xa4>
 800fa06:	9a03      	ldr	r2, [sp, #12]
 800fa08:	e9de 3403 	ldrd	r3, r4, [lr, #12]
 800fa0c:	eb02 0508 	add.w	r5, r2, r8
 800fa10:	4650      	mov	r0, sl
 800fa12:	4641      	mov	r1, r8
 800fa14:	e009      	b.n	800fa2a <HAL_DFSDM_FilterRegConvCpltCallback+0x6e>
        SENSORTILE_AudioIn_Handler.PCM_Data[i * SENSORTILE_AudioIn_Handler.MicChannels + j] = SaturaLH(SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut, -32760, 32760);
 800fa16:	455b      	cmp	r3, fp
 800fa18:	461c      	mov	r4, r3
 800fa1a:	bfa8      	it	ge
 800fa1c:	465c      	movge	r4, fp
 800fa1e:	b2a4      	uxth	r4, r4
      for (i = 0; i < SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000; i++)
 800fa20:	42a9      	cmp	r1, r5
        SENSORTILE_AudioIn_Handler.PCM_Data[i * SENSORTILE_AudioIn_Handler.MicChannels + j] = SaturaLH(SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut, -32760, 32760);
 800fa22:	8004      	strh	r4, [r0, #0]
        SENSORTILE_AudioIn_Handler.HP_Filters[j].Z = ((RecBuff[j][i + SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000] >> 8) * AudioInVolume) >> 7;
 800fa24:	4614      	mov	r4, r2
 800fa26:	4430      	add	r0, r6
      for (i = 0; i < SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000; i++)
 800fa28:	d016      	beq.n	800fa58 <HAL_DFSDM_FilterRegConvCpltCallback+0x9c>
        SENSORTILE_AudioIn_Handler.HP_Filters[j].Z = ((RecBuff[j][i + SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000] >> 8) * AudioInVolume) >> 7;
 800fa2a:	f851 2f04 	ldr.w	r2, [r1, #4]!
 800fa2e:	1212      	asrs	r2, r2, #8
 800fa30:	fb07 f202 	mul.w	r2, r7, r2
 800fa34:	11d2      	asrs	r2, r2, #7
        SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut = (0xFC * (SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut + SENSORTILE_AudioIn_Handler.HP_Filters[j].Z - SENSORTILE_AudioIn_Handler.HP_Filters[j].oldIn)) / 256;
 800fa36:	4413      	add	r3, r2
 800fa38:	1b1b      	subs	r3, r3, r4
 800fa3a:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
 800fa3e:	009b      	lsls	r3, r3, #2
 800fa40:	bf48      	it	mi
 800fa42:	33ff      	addmi	r3, #255	; 0xff
 800fa44:	121b      	asrs	r3, r3, #8
        SENSORTILE_AudioIn_Handler.PCM_Data[i * SENSORTILE_AudioIn_Handler.MicChannels + j] = SaturaLH(SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut, -32760, 32760);
 800fa46:	4563      	cmp	r3, ip
 800fa48:	dae5      	bge.n	800fa16 <HAL_DFSDM_FilterRegConvCpltCallback+0x5a>
 800fa4a:	f248 0408 	movw	r4, #32776	; 0x8008
      for (i = 0; i < SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000; i++)
 800fa4e:	42a9      	cmp	r1, r5
        SENSORTILE_AudioIn_Handler.PCM_Data[i * SENSORTILE_AudioIn_Handler.MicChannels + j] = SaturaLH(SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut, -32760, 32760);
 800fa50:	8004      	strh	r4, [r0, #0]
        SENSORTILE_AudioIn_Handler.HP_Filters[j].Z = ((RecBuff[j][i + SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000] >> 8) * AudioInVolume) >> 7;
 800fa52:	4614      	mov	r4, r2
 800fa54:	4430      	add	r0, r6
      for (i = 0; i < SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000; i++)
 800fa56:	d1e8      	bne.n	800fa2a <HAL_DFSDM_FilterRegConvCpltCallback+0x6e>
 800fa58:	e9ce 2302 	strd	r2, r3, [lr, #8]
 800fa5c:	f8ce 2010 	str.w	r2, [lr, #16]
    for(j=0; j < SENSORTILE_AudioIn_Handler.MicChannels; j ++)
 800fa60:	9b01      	ldr	r3, [sp, #4]
 800fa62:	f109 0901 	add.w	r9, r9, #1
 800fa66:	4599      	cmp	r9, r3
 800fa68:	f10e 0e0c 	add.w	lr, lr, #12
 800fa6c:	f508 7840 	add.w	r8, r8, #768	; 0x300
 800fa70:	f10a 0a02 	add.w	sl, sl, #2
 800fa74:	d1c5      	bne.n	800fa02 <HAL_DFSDM_FilterRegConvCpltCallback+0x46>
      }		
    }
    BSP_AUDIO_IN_TransferComplete_CallBack();
 800fa76:	f00b f9cf 	bl	801ae18 <BSP_AUDIO_IN_TransferComplete_CallBack>
  }  
}
 800fa7a:	b005      	add	sp, #20
 800fa7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fa80:	20011298 	.word	0x20011298
 800fa84:	20001844 	.word	0x20001844
 800fa88:	10624dd3 	.word	0x10624dd3
 800fa8c:	200003fc 	.word	0x200003fc
 800fa90:	200105b4 	.word	0x200105b4
 800fa94:	ffff8008 	.word	0xffff8008

0800fa98 <HAL_DFSDM_FilterRegConvHalfCpltCallback>:
* @retval None
*/
void HAL_DFSDM_FilterRegConvHalfCpltCallback(DFSDM_Filter_HandleTypeDef *hdfsdm_filter) 
{  
  uint32_t i, j = 0;  
  if (hdfsdm_filter == &haudio_in_dfsdmfilter[0]) 
 800fa98:	4b30      	ldr	r3, [pc, #192]	; (800fb5c <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xc4>)
 800fa9a:	4283      	cmp	r3, r0
 800fa9c:	d000      	beq.n	800faa0 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x8>
 800fa9e:	4770      	bx	lr
{  
 800faa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  {
    for(j=0; j < SENSORTILE_AudioIn_Handler.MicChannels; j ++)
 800faa4:	4b2e      	ldr	r3, [pc, #184]	; (800fb60 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xc8>)
{  
 800faa6:	b085      	sub	sp, #20
    for(j=0; j < SENSORTILE_AudioIn_Handler.MicChannels; j ++)
 800faa8:	681c      	ldr	r4, [r3, #0]
 800faaa:	9401      	str	r4, [sp, #4]
 800faac:	2c00      	cmp	r4, #0
 800faae:	d04f      	beq.n	800fb50 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xb8>
    {
      for (i = 0; i < SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000; i++)
 800fab0:	685a      	ldr	r2, [r3, #4]
 800fab2:	492c      	ldr	r1, [pc, #176]	; (800fb64 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xcc>)
      {
        SENSORTILE_AudioIn_Handler.HP_Filters[j].Z = ((RecBuff[j][i] >> 8) * AudioInVolume) >> 7;
 800fab4:	482c      	ldr	r0, [pc, #176]	; (800fb68 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xd0>)
 800fab6:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 800fb70 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xd8>
 800faba:	f8b0 c000 	ldrh.w	ip, [r0]
        SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut = (0xFC * (SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut + SENSORTILE_AudioIn_Handler.HP_Filters[j].Z - SENSORTILE_AudioIn_Handler.HP_Filters[j].oldIn)) / 256;
        SENSORTILE_AudioIn_Handler.HP_Filters[j].oldIn = SENSORTILE_AudioIn_Handler.HP_Filters[j].Z;
        SENSORTILE_AudioIn_Handler.PCM_Data[i * SENSORTILE_AudioIn_Handler.MicChannels + j] = SaturaLH(SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut, -32760, 32760);        
 800fabe:	4f2b      	ldr	r7, [pc, #172]	; (800fb6c <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xd4>)
 800fac0:	469e      	mov	lr, r3
      for (i = 0; i < SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000; i++)
 800fac2:	fba1 2302 	umull	r2, r3, r1, r2
 800fac6:	099b      	lsrs	r3, r3, #6
 800fac8:	9302      	str	r3, [sp, #8]
 800faca:	f8de a038 	ldr.w	sl, [lr, #56]	; 0x38
 800face:	009b      	lsls	r3, r3, #2
 800fad0:	9303      	str	r3, [sp, #12]
 800fad2:	0066      	lsls	r6, r4, #1
    for(j=0; j < SENSORTILE_AudioIn_Handler.MicChannels; j ++)
 800fad4:	f04f 0900 	mov.w	r9, #0
        SENSORTILE_AudioIn_Handler.PCM_Data[i * SENSORTILE_AudioIn_Handler.MicChannels + j] = SaturaLH(SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut, -32760, 32760);        
 800fad8:	f647 7bf8 	movw	fp, #32760	; 0x7ff8
      for (i = 0; i < SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000; i++)
 800fadc:	9b02      	ldr	r3, [sp, #8]
 800fade:	b363      	cbz	r3, 800fb3a <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xa2>
 800fae0:	9a03      	ldr	r2, [sp, #12]
 800fae2:	e9de 3403 	ldrd	r3, r4, [lr, #12]
 800fae6:	eb02 0508 	add.w	r5, r2, r8
 800faea:	4650      	mov	r0, sl
 800faec:	4641      	mov	r1, r8
 800faee:	e009      	b.n	800fb04 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x6c>
        SENSORTILE_AudioIn_Handler.PCM_Data[i * SENSORTILE_AudioIn_Handler.MicChannels + j] = SaturaLH(SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut, -32760, 32760);        
 800faf0:	455b      	cmp	r3, fp
 800faf2:	461c      	mov	r4, r3
 800faf4:	bfa8      	it	ge
 800faf6:	465c      	movge	r4, fp
 800faf8:	b2a4      	uxth	r4, r4
      for (i = 0; i < SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000; i++)
 800fafa:	42a9      	cmp	r1, r5
        SENSORTILE_AudioIn_Handler.PCM_Data[i * SENSORTILE_AudioIn_Handler.MicChannels + j] = SaturaLH(SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut, -32760, 32760);        
 800fafc:	8004      	strh	r4, [r0, #0]
        SENSORTILE_AudioIn_Handler.HP_Filters[j].Z = ((RecBuff[j][i] >> 8) * AudioInVolume) >> 7;
 800fafe:	4614      	mov	r4, r2
 800fb00:	4430      	add	r0, r6
      for (i = 0; i < SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000; i++)
 800fb02:	d016      	beq.n	800fb32 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x9a>
        SENSORTILE_AudioIn_Handler.HP_Filters[j].Z = ((RecBuff[j][i] >> 8) * AudioInVolume) >> 7;
 800fb04:	f851 2f04 	ldr.w	r2, [r1, #4]!
 800fb08:	1212      	asrs	r2, r2, #8
 800fb0a:	fb0c f202 	mul.w	r2, ip, r2
 800fb0e:	11d2      	asrs	r2, r2, #7
        SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut = (0xFC * (SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut + SENSORTILE_AudioIn_Handler.HP_Filters[j].Z - SENSORTILE_AudioIn_Handler.HP_Filters[j].oldIn)) / 256;
 800fb10:	4413      	add	r3, r2
 800fb12:	1b1b      	subs	r3, r3, r4
 800fb14:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
 800fb18:	009b      	lsls	r3, r3, #2
 800fb1a:	bf48      	it	mi
 800fb1c:	33ff      	addmi	r3, #255	; 0xff
 800fb1e:	121b      	asrs	r3, r3, #8
        SENSORTILE_AudioIn_Handler.PCM_Data[i * SENSORTILE_AudioIn_Handler.MicChannels + j] = SaturaLH(SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut, -32760, 32760);        
 800fb20:	42bb      	cmp	r3, r7
 800fb22:	dae5      	bge.n	800faf0 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x58>
 800fb24:	f248 0408 	movw	r4, #32776	; 0x8008
      for (i = 0; i < SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000; i++)
 800fb28:	42a9      	cmp	r1, r5
        SENSORTILE_AudioIn_Handler.PCM_Data[i * SENSORTILE_AudioIn_Handler.MicChannels + j] = SaturaLH(SENSORTILE_AudioIn_Handler.HP_Filters[j].oldOut, -32760, 32760);        
 800fb2a:	8004      	strh	r4, [r0, #0]
        SENSORTILE_AudioIn_Handler.HP_Filters[j].Z = ((RecBuff[j][i] >> 8) * AudioInVolume) >> 7;
 800fb2c:	4614      	mov	r4, r2
 800fb2e:	4430      	add	r0, r6
      for (i = 0; i < SENSORTILE_AudioIn_Handler.Sampling_Freq / 1000; i++)
 800fb30:	d1e8      	bne.n	800fb04 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x6c>
 800fb32:	e9ce 2302 	strd	r2, r3, [lr, #8]
 800fb36:	f8ce 2010 	str.w	r2, [lr, #16]
    for(j=0; j < SENSORTILE_AudioIn_Handler.MicChannels; j ++)
 800fb3a:	9b01      	ldr	r3, [sp, #4]
 800fb3c:	f109 0901 	add.w	r9, r9, #1
 800fb40:	4599      	cmp	r9, r3
 800fb42:	f10e 0e0c 	add.w	lr, lr, #12
 800fb46:	f508 7840 	add.w	r8, r8, #768	; 0x300
 800fb4a:	f10a 0a02 	add.w	sl, sl, #2
 800fb4e:	d1c5      	bne.n	800fadc <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x44>
      }		
    }
    BSP_AUDIO_IN_HalfTransfer_CallBack();
 800fb50:	f00b f960 	bl	801ae14 <BSP_AUDIO_IN_HalfTransfer_CallBack>
  }
}
 800fb54:	b005      	add	sp, #20
 800fb56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fb5a:	bf00      	nop
 800fb5c:	20011298 	.word	0x20011298
 800fb60:	20001844 	.word	0x20001844
 800fb64:	10624dd3 	.word	0x10624dd3
 800fb68:	200003fc 	.word	0x200003fc
 800fb6c:	ffff8008 	.word	0xffff8008
 800fb70:	200105b4 	.word	0x200105b4

0800fb74 <BSP_GG_Init>:
 * @param handle pointer to the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_GG_Init( void **handle )
{
 800fb74:	b570      	push	{r4, r5, r6, lr}
  GG_Drv_t *driver = NULL;
  
  if(GG_SensorHandle[ STC3115_0 ].isInitialized == 1)
 800fb76:	4c1a      	ldr	r4, [pc, #104]	; (800fbe0 <BSP_GG_Init+0x6c>)
 800fb78:	7963      	ldrb	r3, [r4, #5]
 800fb7a:	2b01      	cmp	r3, #1
 800fb7c:	d01e      	beq.n	800fbbc <BSP_GG_Init+0x48>
 800fb7e:	4606      	mov	r6, r0
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
  }
  
  if ( Sensor_IO_I2C_Init() == COMPONENT_ERROR )
 800fb80:	f7fe fa82 	bl	800e088 <Sensor_IO_I2C_Init>
 800fb84:	2801      	cmp	r0, #1
 800fb86:	d019      	beq.n	800fbbc <BSP_GG_Init+0x48>
  GG_SensorHandle[ STC3115_0 ].instance      = STC3115_0;
  GG_SensorHandle[ STC3115_0 ].isInitialized = 0;
  GG_SensorHandle[ STC3115_0 ].isEnabled     = 0;
  GG_SensorHandle[ STC3115_0 ].isCombo       = 1;
  GG_SensorHandle[ STC3115_0 ].pData         = ( void * )&GG_Data[ STC3115_0 ];
  GG_SensorHandle[ STC3115_0 ].pVTable       = ( void * )&STC3115_Drv;
 800fb88:	4a16      	ldr	r2, [pc, #88]	; (800fbe4 <BSP_GG_Init+0x70>)
  GG_SensorHandle[ STC3115_0 ].who_am_i      = STC3115_ID;
 800fb8a:	4b17      	ldr	r3, [pc, #92]	; (800fbe8 <BSP_GG_Init+0x74>)
 800fb8c:	6023      	str	r3, [r4, #0]
  GG_SensorHandle[ STC3115_0 ].pData         = ( void * )&GG_Data[ STC3115_0 ];
 800fb8e:	f104 0114 	add.w	r1, r4, #20
  GG_SensorHandle[ STC3115_0 ].spiDevice     = 0;
 800fb92:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
  GG_SensorHandle[ STC3115_0 ].pVTable       = ( void * )&STC3115_Drv;
 800fb96:	e9c4 1202 	strd	r1, r2, [r4, #8]
  GG_SensorHandle[ STC3115_0 ].spiDevice     = 0;
 800fb9a:	6063      	str	r3, [r4, #4]
  GG_SensorHandle[ STC3115_0 ].pExtVTable    = 0;
 800fb9c:	2500      	movs	r5, #0
      
  GG_Data[ STC3115_0 ].pComponentData = ( void * )&STC3115_0_Data;
 800fb9e:	f104 031c 	add.w	r3, r4, #28
 800fba2:	e9c4 3505 	strd	r3, r5, [r4, #20]
  GG_SensorHandle[ STC3115_0 ].pExtVTable    = 0;
 800fba6:	6125      	str	r5, [r4, #16]
  GG_Data[ STC3115_0 ].pExtData       = 0;
      
  *handle = (void *)&GG_SensorHandle[ STC3115_0 ];
 800fba8:	6034      	str	r4, [r6, #0]
//  *handle = (void *)GG_SensorHandle;
  
  driver = ( GG_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;
  
  if ( driver->Init == NULL )
 800fbaa:	68e3      	ldr	r3, [r4, #12]
 800fbac:	681b      	ldr	r3, [r3, #0]
 800fbae:	b17b      	cbz	r3, 800fbd0 <BSP_GG_Init+0x5c>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }
  
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 800fbb0:	4620      	mov	r0, r4
 800fbb2:	4798      	blx	r3
 800fbb4:	2801      	cmp	r0, #1
 800fbb6:	d003      	beq.n	800fbc0 <BSP_GG_Init+0x4c>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
 800fbb8:	4628      	mov	r0, r5
}
 800fbba:	bd70      	pop	{r4, r5, r6, pc}
    return COMPONENT_ERROR;
 800fbbc:	2001      	movs	r0, #1
}
 800fbbe:	bd70      	pop	{r4, r5, r6, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800fbc0:	6833      	ldr	r3, [r6, #0]
 800fbc2:	601d      	str	r5, [r3, #0]
 800fbc4:	605d      	str	r5, [r3, #4]
 800fbc6:	609d      	str	r5, [r3, #8]
 800fbc8:	60dd      	str	r5, [r3, #12]
 800fbca:	611d      	str	r5, [r3, #16]
    *handle = NULL;
 800fbcc:	6035      	str	r5, [r6, #0]
}
 800fbce:	bd70      	pop	{r4, r5, r6, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800fbd0:	e9c4 3300 	strd	r3, r3, [r4]
 800fbd4:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800fbd8:	6123      	str	r3, [r4, #16]
    return COMPONENT_ERROR;
 800fbda:	2001      	movs	r0, #1
    *handle = NULL;
 800fbdc:	6033      	str	r3, [r6, #0]
}
 800fbde:	bd70      	pop	{r4, r5, r6, pc}
 800fbe0:	20001880 	.word	0x20001880
 800fbe4:	20000390 	.word	0x20000390
 800fbe8:	00e00014 	.word	0x00e00014

0800fbec <BSP_GG_Task>:
DrvStatusTypeDef BSP_GG_Task(void *handle, uint8_t* vm_mode)
{  
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GG_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800fbec:	b118      	cbz	r0, 800fbf6 <BSP_GG_Task+0xa>
    return COMPONENT_ERROR;
  }
  
  driver = ( GG_Drv_t * )ctx->pVTable;
  
  if(driver->Task == NULL)
 800fbee:	68c3      	ldr	r3, [r0, #12]
 800fbf0:	695b      	ldr	r3, [r3, #20]
 800fbf2:	b103      	cbz	r3, 800fbf6 <BSP_GG_Task+0xa>
  {
    return COMPONENT_ERROR;
  }
  
  return driver->Task( ctx, vm_mode );
 800fbf4:	4718      	bx	r3
}
 800fbf6:	2001      	movs	r0, #1
 800fbf8:	4770      	bx	lr
 800fbfa:	bf00      	nop

0800fbfc <BSP_GG_GetSOC>:
DrvStatusTypeDef BSP_GG_GetSOC(void *handle, uint32_t* soc)
{ 
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GG_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800fbfc:	b118      	cbz	r0, 800fc06 <BSP_GG_GetSOC+0xa>
    return COMPONENT_ERROR;
  }
  
  driver = ( GG_Drv_t * )ctx->pVTable;
  
  if(driver->GetSOC == NULL)
 800fbfe:	68c3      	ldr	r3, [r0, #12]
 800fc00:	6a1b      	ldr	r3, [r3, #32]
 800fc02:	b103      	cbz	r3, 800fc06 <BSP_GG_GetSOC+0xa>
  {
    return COMPONENT_ERROR;
  }
  
  return driver->GetSOC( ctx, soc);
 800fc04:	4718      	bx	r3
}
 800fc06:	2001      	movs	r0, #1
 800fc08:	4770      	bx	lr
 800fc0a:	bf00      	nop

0800fc0c <BSP_GG_GetCurrent>:
DrvStatusTypeDef BSP_GG_GetCurrent(void *handle, int32_t* current)
{  
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GG_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800fc0c:	b118      	cbz	r0, 800fc16 <BSP_GG_GetCurrent+0xa>
    return COMPONENT_ERROR;
  }
  
  driver = ( GG_Drv_t * )ctx->pVTable;
  
  if(driver->GetCurrent == NULL)
 800fc0e:	68c3      	ldr	r3, [r0, #12]
 800fc10:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800fc12:	b103      	cbz	r3, 800fc16 <BSP_GG_GetCurrent+0xa>
  {
    return COMPONENT_ERROR;
  }
  
  return driver->GetCurrent( ctx, current);
 800fc14:	4718      	bx	r3
}
 800fc16:	2001      	movs	r0, #1
 800fc18:	4770      	bx	lr
 800fc1a:	bf00      	nop

0800fc1c <BSP_GG_GetVoltage>:
DrvStatusTypeDef BSP_GG_GetVoltage(void *handle, uint32_t* voltage)
{ 
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GG_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800fc1c:	b118      	cbz	r0, 800fc26 <BSP_GG_GetVoltage+0xa>
    return COMPONENT_ERROR;
  }
  
  driver = ( GG_Drv_t * )ctx->pVTable;
  
  if(driver->GetVoltage == NULL)
 800fc1e:	68c3      	ldr	r3, [r0, #12]
 800fc20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fc22:	b103      	cbz	r3, 800fc26 <BSP_GG_GetVoltage+0xa>
  {
    return COMPONENT_ERROR;
  }
  
  return driver->GetVoltage( ctx, voltage);
 800fc24:	4718      	bx	r3
}
 800fc26:	2001      	movs	r0, #1
 800fc28:	4770      	bx	lr
 800fc2a:	bf00      	nop

0800fc2c <BSP_LSM6DSM_GYRO_Init>:
}



static DrvStatusTypeDef BSP_LSM6DSM_GYRO_Init( void **handle )
{
 800fc2c:	b570      	push	{r4, r5, r6, lr}
  GYRO_Drv_t *driver = NULL;
  uint8_t data = 0x0C;
  
  if(GYRO_SensorHandle[ LSM6DSM_G_0 ].isInitialized == 1)
 800fc2e:	4c29      	ldr	r4, [pc, #164]	; (800fcd4 <BSP_LSM6DSM_GYRO_Init+0xa8>)
 800fc30:	7963      	ldrb	r3, [r4, #5]
{
 800fc32:	b082      	sub	sp, #8
  uint8_t data = 0x0C;
 800fc34:	220c      	movs	r2, #12
  if(GYRO_SensorHandle[ LSM6DSM_G_0 ].isInitialized == 1)
 800fc36:	2b01      	cmp	r3, #1
  uint8_t data = 0x0C;
 800fc38:	f88d 2007 	strb.w	r2, [sp, #7]
  if(GYRO_SensorHandle[ LSM6DSM_G_0 ].isInitialized == 1)
 800fc3c:	d035      	beq.n	800fcaa <BSP_LSM6DSM_GYRO_Init+0x7e>
 800fc3e:	4605      	mov	r5, r0
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
  }
  
  if ( Sensor_IO_SPI_Init() == COMPONENT_ERROR )
 800fc40:	f7fe fa2a 	bl	800e098 <Sensor_IO_SPI_Init>
 800fc44:	2801      	cmp	r0, #1
 800fc46:	d030      	beq.n	800fcaa <BSP_LSM6DSM_GYRO_Init+0x7e>
  GYRO_SensorHandle[ LSM6DSM_G_0 ].isCombo       = 1;
  GYRO_SensorHandle[ LSM6DSM_G_0 ].pData         = ( void * )&GYRO_Data[ LSM6DSM_G_0 ];
  GYRO_SensorHandle[ LSM6DSM_G_0 ].pVTable       = ( void * )&LSM6DSM_G_Drv;
  GYRO_SensorHandle[ LSM6DSM_G_0 ].pExtVTable    = 0;

  LSM6DSM_G_0_Data.comboData = &LSM6DSM_Combo_Data[0];
 800fc48:	4623      	mov	r3, r4
 800fc4a:	4e23      	ldr	r6, [pc, #140]	; (800fcd8 <BSP_LSM6DSM_GYRO_Init+0xac>)
 800fc4c:	f843 6f1c 	str.w	r6, [r3, #28]!
  GYRO_SensorHandle[ LSM6DSM_G_0 ].who_am_i      = LSM6DSM_ACC_GYRO_WHO_AM_I;
 800fc50:	4922      	ldr	r1, [pc, #136]	; (800fcdc <BSP_LSM6DSM_GYRO_Init+0xb0>)
  GYRO_Data[ LSM6DSM_G_0 ].pComponentData = ( void * )&LSM6DSM_G_0_Data;
 800fc52:	6163      	str	r3, [r4, #20]
  GYRO_SensorHandle[ LSM6DSM_G_0 ].pVTable       = ( void * )&LSM6DSM_G_Drv;
 800fc54:	4a22      	ldr	r2, [pc, #136]	; (800fce0 <BSP_LSM6DSM_GYRO_Init+0xb4>)
  GYRO_SensorHandle[ LSM6DSM_G_0 ].who_am_i      = LSM6DSM_ACC_GYRO_WHO_AM_I;
 800fc56:	6021      	str	r1, [r4, #0]
  GYRO_SensorHandle[ LSM6DSM_G_0 ].spiDevice     = LSM6DSM;
 800fc58:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800fc5c:	6063      	str	r3, [r4, #4]
  GYRO_SensorHandle[ LSM6DSM_G_0 ].pData         = ( void * )&GYRO_Data[ LSM6DSM_G_0 ];
 800fc5e:	f104 0114 	add.w	r1, r4, #20
  GYRO_SensorHandle[ LSM6DSM_G_0 ].pExtVTable    = 0;
 800fc62:	2300      	movs	r3, #0
 800fc64:	6123      	str	r3, [r4, #16]
  GYRO_Data[ LSM6DSM_G_0 ].pExtData       = 0;
 800fc66:	61a3      	str	r3, [r4, #24]
  GYRO_SensorHandle[ LSM6DSM_G_0 ].pVTable       = ( void * )&LSM6DSM_G_Drv;
 800fc68:	e9c4 1202 	strd	r1, r2, [r4, #8]
  
  *handle = (void *)&GYRO_SensorHandle[ LSM6DSM_G_0 ];
  
  Sensor_IO_SPI_CS_Init(*handle);
 800fc6c:	4620      	mov	r0, r4
  *handle = (void *)&GYRO_SensorHandle[ LSM6DSM_G_0 ];
 800fc6e:	602c      	str	r4, [r5, #0]
  Sensor_IO_SPI_CS_Init(*handle);
 800fc70:	f7fe fb00 	bl	800e274 <Sensor_IO_SPI_CS_Init>
  
  if(LSM6DSM_Combo_Data[0].isAccInitialized == 0)
 800fc74:	7833      	ldrb	r3, [r6, #0]
 800fc76:	b17b      	cbz	r3, 800fc98 <BSP_LSM6DSM_GYRO_Init+0x6c>
    {
      return COMPONENT_ERROR;
    }
  }
  
  driver = ( GYRO_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;
 800fc78:	6828      	ldr	r0, [r5, #0]
  
  if ( driver->Init == NULL )
 800fc7a:	68c3      	ldr	r3, [r0, #12]
 800fc7c:	681b      	ldr	r3, [r3, #0]
 800fc7e:	b303      	cbz	r3, 800fcc2 <BSP_LSM6DSM_GYRO_Init+0x96>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }
  
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 800fc80:	4798      	blx	r3
 800fc82:	2801      	cmp	r0, #1
 800fc84:	d014      	beq.n	800fcb0 <BSP_LSM6DSM_GYRO_Init+0x84>
    *handle = NULL;
    return COMPONENT_ERROR;
  }
  
  /* Disable I2C interface */
  if ( LSM6DSM_ACC_GYRO_W_I2C_DISABLE( *handle, LSM6DSM_ACC_GYRO_I2C_DISABLE_SPI_ONLY ) == MEMS_ERROR )
 800fc86:	6828      	ldr	r0, [r5, #0]
 800fc88:	2104      	movs	r1, #4
 800fc8a:	f7fa ff57 	bl	800ab3c <LSM6DSM_ACC_GYRO_W_I2C_DISABLE>
    return COMPONENT_ERROR;
 800fc8e:	fab0 f080 	clz	r0, r0
 800fc92:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800fc94:	b002      	add	sp, #8
 800fc96:	bd70      	pop	{r4, r5, r6, pc}
    if( Sensor_IO_Write(*handle, LSM6DSM_ACC_GYRO_CTRL3_C, &data, 1) )
 800fc98:	2301      	movs	r3, #1
 800fc9a:	f10d 0207 	add.w	r2, sp, #7
 800fc9e:	2112      	movs	r1, #18
 800fca0:	6828      	ldr	r0, [r5, #0]
 800fca2:	f7fe fbdf 	bl	800e464 <Sensor_IO_Write>
 800fca6:	2800      	cmp	r0, #0
 800fca8:	d0e6      	beq.n	800fc78 <BSP_LSM6DSM_GYRO_Init+0x4c>
    return COMPONENT_ERROR;
 800fcaa:	2001      	movs	r0, #1
}
 800fcac:	b002      	add	sp, #8
 800fcae:	bd70      	pop	{r4, r5, r6, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800fcb0:	682a      	ldr	r2, [r5, #0]
 800fcb2:	2300      	movs	r3, #0
 800fcb4:	6013      	str	r3, [r2, #0]
 800fcb6:	6053      	str	r3, [r2, #4]
 800fcb8:	6093      	str	r3, [r2, #8]
 800fcba:	60d3      	str	r3, [r2, #12]
 800fcbc:	6113      	str	r3, [r2, #16]
    *handle = NULL;
 800fcbe:	602b      	str	r3, [r5, #0]
    return COMPONENT_ERROR;
 800fcc0:	e7f4      	b.n	800fcac <BSP_LSM6DSM_GYRO_Init+0x80>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800fcc2:	6003      	str	r3, [r0, #0]
 800fcc4:	6043      	str	r3, [r0, #4]
 800fcc6:	6083      	str	r3, [r0, #8]
 800fcc8:	60c3      	str	r3, [r0, #12]
 800fcca:	6103      	str	r3, [r0, #16]
    return COMPONENT_ERROR;
 800fccc:	2001      	movs	r0, #1
    *handle = NULL;
 800fcce:	602b      	str	r3, [r5, #0]
    return COMPONENT_ERROR;
 800fcd0:	e7ec      	b.n	800fcac <BSP_LSM6DSM_GYRO_Init+0x80>
 800fcd2:	bf00      	nop
 800fcd4:	20001908 	.word	0x20001908
 800fcd8:	200103e8 	.word	0x200103e8
 800fcdc:	00d6016a 	.word	0x00d6016a
 800fce0:	200001e0 	.word	0x200001e0

0800fce4 <BSP_GYRO_Init>:
{
 800fce4:	b508      	push	{r3, lr}
  *handle = NULL;
 800fce6:	2300      	movs	r3, #0
 800fce8:	600b      	str	r3, [r1, #0]
      if( BSP_LSM6DSM_GYRO_Init(handle) == COMPONENT_ERROR )
 800fcea:	4608      	mov	r0, r1
 800fcec:	f7ff ff9e 	bl	800fc2c <BSP_LSM6DSM_GYRO_Init>
}
 800fcf0:	f1a0 0001 	sub.w	r0, r0, #1
 800fcf4:	fab0 f080 	clz	r0, r0
 800fcf8:	0940      	lsrs	r0, r0, #5
 800fcfa:	bd08      	pop	{r3, pc}

0800fcfc <BSP_GYRO_Sensor_Enable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GYRO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800fcfc:	b150      	cbz	r0, 800fd14 <BSP_GYRO_Sensor_Enable+0x18>
{
 800fcfe:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( GYRO_Drv_t * )ctx->pVTable;
  
  if ( driver->Sensor_Enable == NULL )
 800fd00:	68c3      	ldr	r3, [r0, #12]
 800fd02:	689b      	ldr	r3, [r3, #8]
 800fd04:	b143      	cbz	r3, 800fd18 <BSP_GYRO_Sensor_Enable+0x1c>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 800fd06:	4798      	blx	r3
    return COMPONENT_ERROR;
 800fd08:	f1a0 0001 	sub.w	r0, r0, #1
 800fd0c:	fab0 f080 	clz	r0, r0
 800fd10:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800fd12:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800fd14:	2001      	movs	r0, #1
}
 800fd16:	4770      	bx	lr
    return COMPONENT_ERROR;
 800fd18:	2001      	movs	r0, #1
}
 800fd1a:	bd08      	pop	{r3, pc}

0800fd1c <BSP_GYRO_Sensor_Disable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GYRO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800fd1c:	b150      	cbz	r0, 800fd34 <BSP_GYRO_Sensor_Disable+0x18>
{
 800fd1e:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( GYRO_Drv_t * )ctx->pVTable;
  
  if ( driver->Sensor_Disable == NULL )
 800fd20:	68c3      	ldr	r3, [r0, #12]
 800fd22:	68db      	ldr	r3, [r3, #12]
 800fd24:	b143      	cbz	r3, 800fd38 <BSP_GYRO_Sensor_Disable+0x1c>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Sensor_Disable( ctx ) == COMPONENT_ERROR )
 800fd26:	4798      	blx	r3
    return COMPONENT_ERROR;
 800fd28:	f1a0 0001 	sub.w	r0, r0, #1
 800fd2c:	fab0 f080 	clz	r0, r0
 800fd30:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800fd32:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800fd34:	2001      	movs	r0, #1
}
 800fd36:	4770      	bx	lr
    return COMPONENT_ERROR;
 800fd38:	2001      	movs	r0, #1
}
 800fd3a:	bd08      	pop	{r3, pc}

0800fd3c <BSP_GYRO_Get_Axes>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GYRO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800fd3c:	b158      	cbz	r0, 800fd56 <BSP_GYRO_Get_Axes+0x1a>
{
 800fd3e:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( GYRO_Drv_t * )ctx->pVTable;
  
  if ( angular_velocity == NULL )
 800fd40:	b159      	cbz	r1, 800fd5a <BSP_GYRO_Get_Axes+0x1e>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Axes == NULL )
 800fd42:	68c3      	ldr	r3, [r0, #12]
 800fd44:	699b      	ldr	r3, [r3, #24]
 800fd46:	b143      	cbz	r3, 800fd5a <BSP_GYRO_Get_Axes+0x1e>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Axes( ctx, angular_velocity ) == COMPONENT_ERROR )
 800fd48:	4798      	blx	r3
    return COMPONENT_ERROR;
 800fd4a:	f1a0 0001 	sub.w	r0, r0, #1
 800fd4e:	fab0 f080 	clz	r0, r0
 800fd52:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800fd54:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800fd56:	2001      	movs	r0, #1
}
 800fd58:	4770      	bx	lr
    return COMPONENT_ERROR;
 800fd5a:	2001      	movs	r0, #1
}
 800fd5c:	bd08      	pop	{r3, pc}
 800fd5e:	bf00      	nop

0800fd60 <BSP_GYRO_Get_ODR>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GYRO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800fd60:	b158      	cbz	r0, 800fd7a <BSP_GYRO_Get_ODR+0x1a>
{
 800fd62:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( GYRO_Drv_t * )ctx->pVTable;
  
  if ( odr == NULL )
 800fd64:	b159      	cbz	r1, 800fd7e <BSP_GYRO_Get_ODR+0x1e>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_ODR == NULL )
 800fd66:	68c3      	ldr	r3, [r0, #12]
 800fd68:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800fd6a:	b143      	cbz	r3, 800fd7e <BSP_GYRO_Get_ODR+0x1e>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_ODR( ctx, odr ) == COMPONENT_ERROR )
 800fd6c:	4798      	blx	r3
    return COMPONENT_ERROR;
 800fd6e:	f1a0 0001 	sub.w	r0, r0, #1
 800fd72:	fab0 f080 	clz	r0, r0
 800fd76:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800fd78:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800fd7a:	2001      	movs	r0, #1
}
 800fd7c:	4770      	bx	lr
    return COMPONENT_ERROR;
 800fd7e:	2001      	movs	r0, #1
}
 800fd80:	bd08      	pop	{r3, pc}
 800fd82:	bf00      	nop

0800fd84 <BSP_GYRO_Set_ODR_Value>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GYRO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800fd84:	b150      	cbz	r0, 800fd9c <BSP_GYRO_Set_ODR_Value+0x18>
{
 800fd86:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( GYRO_Drv_t * )ctx->pVTable;
  
  if ( driver->Set_ODR_Value == NULL )
 800fd88:	68c3      	ldr	r3, [r0, #12]
 800fd8a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800fd8c:	b143      	cbz	r3, 800fda0 <BSP_GYRO_Set_ODR_Value+0x1c>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Set_ODR_Value( ctx, odr ) == COMPONENT_ERROR )
 800fd8e:	4798      	blx	r3
    return COMPONENT_ERROR;
 800fd90:	f1a0 0001 	sub.w	r0, r0, #1
 800fd94:	fab0 f080 	clz	r0, r0
 800fd98:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800fd9a:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800fd9c:	2001      	movs	r0, #1
}
 800fd9e:	4770      	bx	lr
    return COMPONENT_ERROR;
 800fda0:	2001      	movs	r0, #1
}
 800fda2:	bd08      	pop	{r3, pc}

0800fda4 <BSP_LSM303AGR_MAGNETO_Init>:
  return COMPONENT_OK;
}


static DrvStatusTypeDef BSP_LSM303AGR_MAGNETO_Init( void **handle )
{
 800fda4:	b570      	push	{r4, r5, r6, lr}
  MAGNETO_Drv_t *driver = NULL;
  
  if(MAGNETO_SensorHandle[ LSM303AGR_M_0 ].isInitialized == 1)
 800fda6:	4c1f      	ldr	r4, [pc, #124]	; (800fe24 <BSP_LSM303AGR_MAGNETO_Init+0x80>)
 800fda8:	7963      	ldrb	r3, [r4, #5]
 800fdaa:	2b01      	cmp	r3, #1
 800fdac:	d027      	beq.n	800fdfe <BSP_LSM303AGR_MAGNETO_Init+0x5a>
 800fdae:	4606      	mov	r6, r0
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
  }
  
  if ( Sensor_IO_SPI_Init() == COMPONENT_ERROR )
 800fdb0:	f7fe f972 	bl	800e098 <Sensor_IO_SPI_Init>
 800fdb4:	2801      	cmp	r0, #1
 800fdb6:	d022      	beq.n	800fdfe <BSP_LSM303AGR_MAGNETO_Init+0x5a>
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].isCombo       = 0;
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pData         = ( void * )&MAGNETO_Data[ LSM303AGR_M_0 ];
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pVTable       = ( void * )&LSM303AGR_M_Drv;
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pExtVTable    = 0;

  LSM303AGR_M_0_Data.comboData = &LSM303AGR_Combo_Data[0];  
 800fdb8:	4623      	mov	r3, r4
 800fdba:	4a1b      	ldr	r2, [pc, #108]	; (800fe28 <BSP_LSM303AGR_MAGNETO_Init+0x84>)
 800fdbc:	f843 2f1c 	str.w	r2, [r3, #28]!
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].who_am_i      = LSM303AGR_MAG_WHO_AM_I;
 800fdc0:	491a      	ldr	r1, [pc, #104]	; (800fe2c <BSP_LSM303AGR_MAGNETO_Init+0x88>)
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pVTable       = ( void * )&LSM303AGR_M_Drv;
 800fdc2:	4a1b      	ldr	r2, [pc, #108]	; (800fe30 <BSP_LSM303AGR_MAGNETO_Init+0x8c>)
  MAGNETO_Data[ LSM303AGR_M_0 ].pComponentData = ( void * )&LSM303AGR_M_0_Data;
 800fdc4:	6163      	str	r3, [r4, #20]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].spiDevice     = LSM303AGR_M;
 800fdc6:	2500      	movs	r5, #0
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pData         = ( void * )&MAGNETO_Data[ LSM303AGR_M_0 ];
 800fdc8:	f104 0314 	add.w	r3, r4, #20
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pVTable       = ( void * )&LSM303AGR_M_Drv;
 800fdcc:	e9c4 3202 	strd	r3, r2, [r4, #8]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].spiDevice     = LSM303AGR_M;
 800fdd0:	e9c4 1500 	strd	r1, r5, [r4]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pExtVTable    = 0;
 800fdd4:	6125      	str	r5, [r4, #16]
  MAGNETO_Data[ LSM303AGR_M_0 ].pExtData       = 0;
 800fdd6:	61a5      	str	r5, [r4, #24]
  
  *handle = (void *)&MAGNETO_SensorHandle[ LSM303AGR_M_0 ];
  
  Sensor_IO_SPI_CS_Init(*handle);
 800fdd8:	4620      	mov	r0, r4
  *handle = (void *)&MAGNETO_SensorHandle[ LSM303AGR_M_0 ];
 800fdda:	6034      	str	r4, [r6, #0]
  Sensor_IO_SPI_CS_Init(*handle);
 800fddc:	f7fe fa4a 	bl	800e274 <Sensor_IO_SPI_CS_Init>
  
  driver = ( MAGNETO_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;
 800fde0:	6830      	ldr	r0, [r6, #0]
  
  if ( driver->Init == NULL )
 800fde2:	68c3      	ldr	r3, [r0, #12]
 800fde4:	681b      	ldr	r3, [r3, #0]
 800fde6:	b1a3      	cbz	r3, 800fe12 <BSP_LSM303AGR_MAGNETO_Init+0x6e>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }
  
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 800fde8:	4798      	blx	r3
 800fdea:	2801      	cmp	r0, #1
 800fdec:	d009      	beq.n	800fe02 <BSP_LSM303AGR_MAGNETO_Init+0x5e>
    *handle = NULL;
    return COMPONENT_ERROR;
  }

  /* Disable I2C interface */
  if ( LSM303AGR_MAG_W_I2C_DIS( *handle, LSM303AGR_MAG_I2C_DISABLED ) == MEMS_ERROR )
 800fdee:	6830      	ldr	r0, [r6, #0]
 800fdf0:	2120      	movs	r1, #32
 800fdf2:	f7fa f9d3 	bl	800a19c <LSM303AGR_MAG_W_I2C_DIS>
    return COMPONENT_ERROR;
 800fdf6:	fab0 f080 	clz	r0, r0
 800fdfa:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800fdfc:	bd70      	pop	{r4, r5, r6, pc}
    return COMPONENT_ERROR;
 800fdfe:	2001      	movs	r0, #1
}
 800fe00:	bd70      	pop	{r4, r5, r6, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800fe02:	6833      	ldr	r3, [r6, #0]
 800fe04:	601d      	str	r5, [r3, #0]
 800fe06:	605d      	str	r5, [r3, #4]
 800fe08:	609d      	str	r5, [r3, #8]
 800fe0a:	60dd      	str	r5, [r3, #12]
 800fe0c:	611d      	str	r5, [r3, #16]
    *handle = NULL;
 800fe0e:	6035      	str	r5, [r6, #0]
}
 800fe10:	bd70      	pop	{r4, r5, r6, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800fe12:	6003      	str	r3, [r0, #0]
 800fe14:	6043      	str	r3, [r0, #4]
 800fe16:	6083      	str	r3, [r0, #8]
 800fe18:	60c3      	str	r3, [r0, #12]
 800fe1a:	6103      	str	r3, [r0, #16]
    return COMPONENT_ERROR;
 800fe1c:	2001      	movs	r0, #1
    *handle = NULL;
 800fe1e:	6033      	str	r3, [r6, #0]
}
 800fe20:	bd70      	pop	{r4, r5, r6, pc}
 800fe22:	bf00      	nop
 800fe24:	2000192c 	.word	0x2000192c
 800fe28:	200103e4 	.word	0x200103e4
 800fe2c:	023c0140 	.word	0x023c0140
 800fe30:	20000198 	.word	0x20000198

0800fe34 <BSP_MAGNETO_Init>:
{
 800fe34:	b508      	push	{r3, lr}
  *handle = NULL;
 800fe36:	2300      	movs	r3, #0
 800fe38:	600b      	str	r3, [r1, #0]
      if( BSP_LSM303AGR_MAGNETO_Init(handle)  == COMPONENT_ERROR )
 800fe3a:	4608      	mov	r0, r1
 800fe3c:	f7ff ffb2 	bl	800fda4 <BSP_LSM303AGR_MAGNETO_Init>
}
 800fe40:	f1a0 0001 	sub.w	r0, r0, #1
 800fe44:	fab0 f080 	clz	r0, r0
 800fe48:	0940      	lsrs	r0, r0, #5
 800fe4a:	bd08      	pop	{r3, pc}

0800fe4c <BSP_MAGNETO_Sensor_Enable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  MAGNETO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800fe4c:	b150      	cbz	r0, 800fe64 <BSP_MAGNETO_Sensor_Enable+0x18>
{
 800fe4e:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( MAGNETO_Drv_t * )ctx->pVTable;
  
  if ( driver->Sensor_Enable == NULL )
 800fe50:	68c3      	ldr	r3, [r0, #12]
 800fe52:	689b      	ldr	r3, [r3, #8]
 800fe54:	b143      	cbz	r3, 800fe68 <BSP_MAGNETO_Sensor_Enable+0x1c>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 800fe56:	4798      	blx	r3
    return COMPONENT_ERROR;
 800fe58:	f1a0 0001 	sub.w	r0, r0, #1
 800fe5c:	fab0 f080 	clz	r0, r0
 800fe60:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800fe62:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800fe64:	2001      	movs	r0, #1
}
 800fe66:	4770      	bx	lr
    return COMPONENT_ERROR;
 800fe68:	2001      	movs	r0, #1
}
 800fe6a:	bd08      	pop	{r3, pc}

0800fe6c <BSP_MAGNETO_Sensor_Disable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  MAGNETO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800fe6c:	b150      	cbz	r0, 800fe84 <BSP_MAGNETO_Sensor_Disable+0x18>
{
 800fe6e:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( MAGNETO_Drv_t * )ctx->pVTable;
  
  if ( driver->Sensor_Disable == NULL )
 800fe70:	68c3      	ldr	r3, [r0, #12]
 800fe72:	68db      	ldr	r3, [r3, #12]
 800fe74:	b143      	cbz	r3, 800fe88 <BSP_MAGNETO_Sensor_Disable+0x1c>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Sensor_Disable( ctx ) == COMPONENT_ERROR )
 800fe76:	4798      	blx	r3
    return COMPONENT_ERROR;
 800fe78:	f1a0 0001 	sub.w	r0, r0, #1
 800fe7c:	fab0 f080 	clz	r0, r0
 800fe80:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800fe82:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800fe84:	2001      	movs	r0, #1
}
 800fe86:	4770      	bx	lr
    return COMPONENT_ERROR;
 800fe88:	2001      	movs	r0, #1
}
 800fe8a:	bd08      	pop	{r3, pc}

0800fe8c <BSP_MAGNETO_Get_Axes>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  MAGNETO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800fe8c:	b158      	cbz	r0, 800fea6 <BSP_MAGNETO_Get_Axes+0x1a>
{
 800fe8e:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( MAGNETO_Drv_t * )ctx->pVTable;
  
  if ( magnetic_field == NULL )
 800fe90:	b159      	cbz	r1, 800feaa <BSP_MAGNETO_Get_Axes+0x1e>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Axes == NULL )
 800fe92:	68c3      	ldr	r3, [r0, #12]
 800fe94:	699b      	ldr	r3, [r3, #24]
 800fe96:	b143      	cbz	r3, 800feaa <BSP_MAGNETO_Get_Axes+0x1e>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Axes( ctx, magnetic_field ) == COMPONENT_ERROR )
 800fe98:	4798      	blx	r3
    return COMPONENT_ERROR;
 800fe9a:	f1a0 0001 	sub.w	r0, r0, #1
 800fe9e:	fab0 f080 	clz	r0, r0
 800fea2:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800fea4:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800fea6:	2001      	movs	r0, #1
}
 800fea8:	4770      	bx	lr
    return COMPONENT_ERROR;
 800feaa:	2001      	movs	r0, #1
}
 800feac:	bd08      	pop	{r3, pc}
 800feae:	bf00      	nop

0800feb0 <BSP_MAGNETO_Get_ODR>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  MAGNETO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800feb0:	b158      	cbz	r0, 800feca <BSP_MAGNETO_Get_ODR+0x1a>
{
 800feb2:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( MAGNETO_Drv_t * )ctx->pVTable;
  
  if ( odr == NULL )
 800feb4:	b159      	cbz	r1, 800fece <BSP_MAGNETO_Get_ODR+0x1e>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_ODR == NULL )
 800feb6:	68c3      	ldr	r3, [r0, #12]
 800feb8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800feba:	b143      	cbz	r3, 800fece <BSP_MAGNETO_Get_ODR+0x1e>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_ODR( ctx, odr ) == COMPONENT_ERROR )
 800febc:	4798      	blx	r3
    return COMPONENT_ERROR;
 800febe:	f1a0 0001 	sub.w	r0, r0, #1
 800fec2:	fab0 f080 	clz	r0, r0
 800fec6:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800fec8:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800feca:	2001      	movs	r0, #1
}
 800fecc:	4770      	bx	lr
    return COMPONENT_ERROR;
 800fece:	2001      	movs	r0, #1
}
 800fed0:	bd08      	pop	{r3, pc}
 800fed2:	bf00      	nop

0800fed4 <BSP_MAGNETO_Set_ODR_Value>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  MAGNETO_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 800fed4:	b150      	cbz	r0, 800feec <BSP_MAGNETO_Set_ODR_Value+0x18>
{
 800fed6:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( MAGNETO_Drv_t * )ctx->pVTable;
  
  if ( driver->Set_ODR_Value == NULL )
 800fed8:	68c3      	ldr	r3, [r0, #12]
 800feda:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800fedc:	b143      	cbz	r3, 800fef0 <BSP_MAGNETO_Set_ODR_Value+0x1c>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Set_ODR_Value( ctx, odr ) == COMPONENT_ERROR )
 800fede:	4798      	blx	r3
    return COMPONENT_ERROR;
 800fee0:	f1a0 0001 	sub.w	r0, r0, #1
 800fee4:	fab0 f080 	clz	r0, r0
 800fee8:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 800feea:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800feec:	2001      	movs	r0, #1
}
 800feee:	4770      	bx	lr
    return COMPONENT_ERROR;
 800fef0:	2001      	movs	r0, #1
}
 800fef2:	bd08      	pop	{r3, pc}

0800fef4 <BSP_SD_Init>:
  * @retval The SD Response: 
  *         - MSD_ERROR : Sequence failed
  *         - MSD_OK    : Sequence succeed
  */
uint8_t BSP_SD_Init(void)
{ 
 800fef4:	b570      	push	{r4, r5, r6, lr}
 800fef6:	b082      	sub	sp, #8
  /* Configure SPI in Low Speed mode for initialization */
  SD_IO_Init_LS();
 800fef8:	f7fe fc10 	bl	800e71c <SD_IO_Init_LS>
  */
static uint8_t SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc, uint8_t Response)
{
  uint8_t status = MSD_ERROR;
  
  if(SD_IO_WriteCmd(Cmd, Arg, Crc, Response) == HAL_OK)
 800fefc:	2100      	movs	r1, #0
 800fefe:	4608      	mov	r0, r1
 800ff00:	2301      	movs	r3, #1
 800ff02:	2295      	movs	r2, #149	; 0x95
 800ff04:	f7fe fc98 	bl	800e838 <SD_IO_WriteCmd>
 800ff08:	bb78      	cbnz	r0, 800ff6a <BSP_SD_Init+0x76>
 800ff0a:	4604      	mov	r4, r0
  {
    status = MSD_OK;
  }
  
  /* Send Dummy Byte */
  SD_IO_WriteDummy();
 800ff0c:	f7fe fce2 	bl	800e8d4 <SD_IO_WriteDummy>
  return SD_IO_WriteCmd_wResp(Cmd, Arg, Crc);
 800ff10:	2287      	movs	r2, #135	; 0x87
 800ff12:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 800ff16:	2008      	movs	r0, #8
 800ff18:	f7fe fc5e 	bl	800e7d8 <SD_IO_WriteCmd_wResp>
    /* No Idle State Response: return an error */
    return MSD_ERROR;
  }

  /* Send CMD8 */
  if(SD_SendCmd_wResp(SD_CMD_HS_SEND_EXT_CSD, 0x000001AA, 0x87) == 1)  /* SDv2? */
 800ff1c:	2801      	cmp	r0, #1
 800ff1e:	d02c      	beq.n	800ff7a <BSP_SD_Init+0x86>
      SD_IO_WriteDummy();
    }
  }
  else /* Not SDv2 card */
  {
    SD_CardType = STD_CAPACITY_SD_CARD_V1_1;
 800ff20:	4d33      	ldr	r5, [pc, #204]	; (800fff0 <BSP_SD_Init+0xfc>)
 800ff22:	702c      	strb	r4, [r5, #0]
  }
  
  SD_IO_WriteDummy();
 800ff24:	f7fe fcd6 	bl	800e8d4 <SD_IO_WriteDummy>
    SdStatus = SD_PRESENT;
 800ff28:	4b32      	ldr	r3, [pc, #200]	; (800fff4 <BSP_SD_Init+0x100>)
 800ff2a:	2001      	movs	r0, #1
 800ff2c:	7018      	strb	r0, [r3, #0]
    if(SD_CardType != HIGH_CAPACITY_SD_CARD)
 800ff2e:	782b      	ldrb	r3, [r5, #0]
 800ff30:	2b02      	cmp	r3, #2
 800ff32:	d033      	beq.n	800ff9c <BSP_SD_Init+0xa8>
}
 800ff34:	b002      	add	sp, #8
 800ff36:	bd70      	pop	{r4, r5, r6, pc}
  SD_IO_WriteDummy();
 800ff38:	f7fe fccc 	bl	800e8d4 <SD_IO_WriteDummy>
  if(SD_IO_WriteCmd(Cmd, Arg, Crc, Response) == HAL_OK)
 800ff3c:	462b      	mov	r3, r5
 800ff3e:	22ff      	movs	r2, #255	; 0xff
 800ff40:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 800ff44:	2029      	movs	r0, #41	; 0x29
 800ff46:	f7fe fc77 	bl	800e838 <SD_IO_WriteCmd>
 800ff4a:	4605      	mov	r5, r0
 800ff4c:	b380      	cbz	r0, 800ffb0 <BSP_SD_Init+0xbc>
  SD_IO_WriteDummy();
 800ff4e:	f7fe fcc1 	bl	800e8d4 <SD_IO_WriteDummy>
        HAL_Delay(100);
 800ff52:	2064      	movs	r0, #100	; 0x64
 800ff54:	f00b f8d8 	bl	801b108 <HAL_Delay>
  if(SD_IO_WriteCmd(Cmd, Arg, Crc, Response) == HAL_OK)
 800ff58:	2301      	movs	r3, #1
 800ff5a:	22ff      	movs	r2, #255	; 0xff
 800ff5c:	2100      	movs	r1, #0
 800ff5e:	2037      	movs	r0, #55	; 0x37
 800ff60:	f7fe fc6a 	bl	800e838 <SD_IO_WriteCmd>
 800ff64:	4605      	mov	r5, r0
 800ff66:	2800      	cmp	r0, #0
 800ff68:	d0e6      	beq.n	800ff38 <BSP_SD_Init+0x44>
  SD_IO_WriteDummy();
 800ff6a:	f7fe fcb3 	bl	800e8d4 <SD_IO_WriteDummy>
    SdStatus = SD_NOT_PRESENT;
 800ff6e:	4b21      	ldr	r3, [pc, #132]	; (800fff4 <BSP_SD_Init+0x100>)
 800ff70:	2200      	movs	r2, #0
    return MSD_ERROR;
 800ff72:	2001      	movs	r0, #1
    SdStatus = SD_NOT_PRESENT;
 800ff74:	701a      	strb	r2, [r3, #0]
}
 800ff76:	b002      	add	sp, #8
 800ff78:	bd70      	pop	{r4, r5, r6, pc}
 800ff7a:	ae01      	add	r6, sp, #4
  if(SD_SendCmd_wResp(SD_CMD_HS_SEND_EXT_CSD, 0x000001AA, 0x87) == 1)  /* SDv2? */
 800ff7c:	4634      	mov	r4, r6
 800ff7e:	ad02      	add	r5, sp, #8
      resp[n] = SD_IO_ReadByte();	/* Get 32 bit return value of R7 resp */
 800ff80:	f7fe fc24 	bl	800e7cc <SD_IO_ReadByte>
 800ff84:	f804 0b01 	strb.w	r0, [r4], #1
    for (n = 0; n < 4; n++)
 800ff88:	42a5      	cmp	r5, r4
 800ff8a:	d1f9      	bne.n	800ff80 <BSP_SD_Init+0x8c>
    SD_IO_WriteDummy();
 800ff8c:	f7fe fca2 	bl	800e8d4 <SD_IO_WriteDummy>
    if (resp[2] == 0x01 && resp[3] == 0xAA)  /* the card supports vcc of 2.7-3.6V? */
 800ff90:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800ff94:	2b01      	cmp	r3, #1
 800ff96:	d006      	beq.n	800ffa6 <BSP_SD_Init+0xb2>
 800ff98:	4d15      	ldr	r5, [pc, #84]	; (800fff0 <BSP_SD_Init+0xfc>)
 800ff9a:	e7c3      	b.n	800ff24 <BSP_SD_Init+0x30>
    SD_IO_Init();
 800ff9c:	f7fe fba8 	bl	800e6f0 <SD_IO_Init>
    return MSD_OK;
 800ffa0:	2000      	movs	r0, #0
}
 800ffa2:	b002      	add	sp, #8
 800ffa4:	bd70      	pop	{r4, r5, r6, pc}
    if (resp[2] == 0x01 && resp[3] == 0xAA)  /* the card supports vcc of 2.7-3.6V? */
 800ffa6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800ffaa:	2baa      	cmp	r3, #170	; 0xaa
 800ffac:	d1f4      	bne.n	800ff98 <BSP_SD_Init+0xa4>
 800ffae:	e7d0      	b.n	800ff52 <BSP_SD_Init+0x5e>
  SD_IO_WriteDummy();
 800ffb0:	f7fe fc90 	bl	800e8d4 <SD_IO_WriteDummy>
      HAL_Delay(10);
 800ffb4:	200a      	movs	r0, #10
 800ffb6:	f00b f8a7 	bl	801b108 <HAL_Delay>
  return SD_IO_WriteCmd_wResp(Cmd, Arg, Crc);
 800ffba:	4629      	mov	r1, r5
 800ffbc:	22ff      	movs	r2, #255	; 0xff
 800ffbe:	203a      	movs	r0, #58	; 0x3a
 800ffc0:	f7fe fc0a 	bl	800e7d8 <SD_IO_WriteCmd_wResp>
      resp[0] = SD_SendCmd_wResp(SD_CMD_SDMMC_READ_OCR, 0, 0xFF);
 800ffc4:	f88d 0004 	strb.w	r0, [sp, #4]
      if(resp[0] == 0)
 800ffc8:	b118      	cbz	r0, 800ffd2 <BSP_SD_Init+0xde>
 800ffca:	4d09      	ldr	r5, [pc, #36]	; (800fff0 <BSP_SD_Init+0xfc>)
      SD_IO_WriteDummy();
 800ffcc:	f7fe fc82 	bl	800e8d4 <SD_IO_WriteDummy>
 800ffd0:	e7a8      	b.n	800ff24 <BSP_SD_Init+0x30>
          resp[n] = SD_IO_ReadByte();	/* Get 32 bit return value of R7 resp */
 800ffd2:	f7fe fbfb 	bl	800e7cc <SD_IO_ReadByte>
 800ffd6:	f806 0b01 	strb.w	r0, [r6], #1
        for (n = 0; n < 4; n++)
 800ffda:	42a6      	cmp	r6, r4
 800ffdc:	d1f9      	bne.n	800ffd2 <BSP_SD_Init+0xde>
        if(resp[0]&0x40)
 800ffde:	f89d 3004 	ldrb.w	r3, [sp, #4]
          SD_CardType = HIGH_CAPACITY_SD_CARD;  /* Card id SDv2 and High Capacity */
 800ffe2:	4d03      	ldr	r5, [pc, #12]	; (800fff0 <BSP_SD_Init+0xfc>)
        if(resp[0]&0x40)
 800ffe4:	065b      	lsls	r3, r3, #25
          SD_CardType = HIGH_CAPACITY_SD_CARD;  /* Card id SDv2 and High Capacity */
 800ffe6:	bf4c      	ite	mi
 800ffe8:	2302      	movmi	r3, #2
          SD_CardType = STD_CAPACITY_SD_CARD_V2_0;  /* Card id SDv2 */
 800ffea:	2301      	movpl	r3, #1
 800ffec:	702b      	strb	r3, [r5, #0]
 800ffee:	e7ed      	b.n	800ffcc <BSP_SD_Init+0xd8>
 800fff0:	2000194c 	.word	0x2000194c
 800fff4:	200003fe 	.word	0x200003fe

0800fff8 <BSP_SD_GetCardInfo>:
{
 800fff8:	b570      	push	{r4, r5, r6, lr}
  if (SD_IO_WriteCmd(SD_CMD_SEND_CSD, 0, 0xFF, SD_RESPONSE_NO_ERROR) == HAL_OK)
 800fffa:	2300      	movs	r3, #0
{
 800fffc:	b084      	sub	sp, #16
 800fffe:	4604      	mov	r4, r0
  if (SD_IO_WriteCmd(SD_CMD_SEND_CSD, 0, 0xFF, SD_RESPONSE_NO_ERROR) == HAL_OK)
 8010000:	4619      	mov	r1, r3
 8010002:	22ff      	movs	r2, #255	; 0xff
 8010004:	2009      	movs	r0, #9
 8010006:	f7fe fc17 	bl	800e838 <SD_IO_WriteCmd>
 801000a:	2800      	cmp	r0, #0
 801000c:	f040 80be 	bne.w	801018c <BSP_SD_GetCardInfo+0x194>
    if (SD_IO_WaitResponse(SD_START_DATA_SINGLE_BLOCK_READ) == HAL_OK)
 8010010:	20fe      	movs	r0, #254	; 0xfe
 8010012:	f7fe fc4b 	bl	800e8ac <SD_IO_WaitResponse>
 8010016:	2800      	cmp	r0, #0
 8010018:	f040 80b8 	bne.w	801018c <BSP_SD_GetCardInfo+0x194>
 801001c:	f10d 35ff 	add.w	r5, sp, #4294967295
 8010020:	f10d 060f 	add.w	r6, sp, #15
        CSD_Tab[counter] = SD_IO_ReadByte();
 8010024:	f7fe fbd2 	bl	800e7cc <SD_IO_ReadByte>
 8010028:	f805 0f01 	strb.w	r0, [r5, #1]!
      for (counter = 0; counter < 16; counter++)
 801002c:	42b5      	cmp	r5, r6
 801002e:	d1f9      	bne.n	8010024 <BSP_SD_GetCardInfo+0x2c>
      SD_IO_WriteByte(SD_DUMMY_BYTE);
 8010030:	20ff      	movs	r0, #255	; 0xff
 8010032:	f7fe fbbd 	bl	800e7b0 <SD_IO_WriteByte>
      SD_IO_WriteByte(SD_DUMMY_BYTE);
 8010036:	20ff      	movs	r0, #255	; 0xff
 8010038:	f7fe fbba 	bl	800e7b0 <SD_IO_WriteByte>
  SD_IO_WriteDummy();
 801003c:	f7fe fc4a 	bl	800e8d4 <SD_IO_WriteDummy>
    Csd->CSDStruct = (CSD_Tab[0] & 0xC0) >> 6;
 8010040:	f89d 3000 	ldrb.w	r3, [sp]
    Csd->CardComdClasses = CSD_Tab[4] << 4;
 8010044:	f89d 2004 	ldrb.w	r2, [sp, #4]
    Csd->TAAC = CSD_Tab[1];
 8010048:	f89d 5001 	ldrb.w	r5, [sp, #1]
    Csd->NSAC = CSD_Tab[2];
 801004c:	f89d 0002 	ldrb.w	r0, [sp, #2]
    Csd->MaxBusClkFrec = CSD_Tab[3];
 8010050:	f89d 1003 	ldrb.w	r1, [sp, #3]
    Csd->CSDStruct = (CSD_Tab[0] & 0xC0) >> 6;
 8010054:	099e      	lsrs	r6, r3, #6
 8010056:	7026      	strb	r6, [r4, #0]
    Csd->CardComdClasses = CSD_Tab[4] << 4;
 8010058:	0112      	lsls	r2, r2, #4
    Csd->SysSpecVersion = (CSD_Tab[0] & 0x3C) >> 2;
 801005a:	f3c3 0683 	ubfx	r6, r3, #2, #4
    Csd->Reserved1 = CSD_Tab[0] & 0x03;
 801005e:	f003 0303 	and.w	r3, r3, #3
    Csd->SysSpecVersion = (CSD_Tab[0] & 0x3C) >> 2;
 8010062:	7066      	strb	r6, [r4, #1]
    Csd->Reserved1 = CSD_Tab[0] & 0x03;
 8010064:	70a3      	strb	r3, [r4, #2]
    Csd->TAAC = CSD_Tab[1];
 8010066:	70e5      	strb	r5, [r4, #3]
    Csd->NSAC = CSD_Tab[2];
 8010068:	7120      	strb	r0, [r4, #4]
    Csd->MaxBusClkFrec = CSD_Tab[3];
 801006a:	7161      	strb	r1, [r4, #5]
    Csd->CardComdClasses = CSD_Tab[4] << 4;
 801006c:	80e2      	strh	r2, [r4, #6]
    Csd->CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
 801006e:	88e5      	ldrh	r5, [r4, #6]
 8010070:	f89d 1005 	ldrb.w	r1, [sp, #5]
    Csd->PartBlockRead = (CSD_Tab[6] & 0x80) >> 7;
 8010074:	f89d 3006 	ldrb.w	r3, [sp, #6]
    Csd->DeviceSize |= (CSD_Tab[7]) << 2;
 8010078:	f89d 6007 	ldrb.w	r6, [sp, #7]
    Csd->MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
 801007c:	f89d 2009 	ldrb.w	r2, [sp, #9]
    Csd->CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
 8010080:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    Csd->RdBlockLen = CSD_Tab[5] & 0x0F;
 8010084:	f001 010f 	and.w	r1, r1, #15
    Csd->CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
 8010088:	80e5      	strh	r5, [r4, #6]
    Csd->RdBlockLen = CSD_Tab[5] & 0x0F;
 801008a:	7221      	strb	r1, [r4, #8]
    Csd->PartBlockRead = (CSD_Tab[6] & 0x80) >> 7;
 801008c:	09d9      	lsrs	r1, r3, #7
 801008e:	7261      	strb	r1, [r4, #9]
    Csd->WrBlockMisalign = (CSD_Tab[6] & 0x40) >> 6;
 8010090:	f3c3 1180 	ubfx	r1, r3, #6, #1
 8010094:	72a1      	strb	r1, [r4, #10]
    Csd->DeviceSize = (CSD_Tab[6] & 0x03) << 10;
 8010096:	029d      	lsls	r5, r3, #10
    Csd->RdBlockMisalign = (CSD_Tab[6] & 0x20) >> 5;
 8010098:	f3c3 1140 	ubfx	r1, r3, #5, #1
 801009c:	72e1      	strb	r1, [r4, #11]
    Csd->DeviceSize = (CSD_Tab[6] & 0x03) << 10;
 801009e:	f405 6540 	and.w	r5, r5, #3072	; 0xc00
    Csd->Reserved2 = 0; /*!< Reserved */
 80100a2:	2100      	movs	r1, #0
    Csd->DSRImpl = (CSD_Tab[6] & 0x10) >> 4;
 80100a4:	f3c3 1300 	ubfx	r3, r3, #4, #1
 80100a8:	7323      	strb	r3, [r4, #12]
    Csd->Reserved2 = 0; /*!< Reserved */
 80100aa:	7361      	strb	r1, [r4, #13]
    Csd->DeviceSize = (CSD_Tab[6] & 0x03) << 10;
 80100ac:	6125      	str	r5, [r4, #16]
    Csd->DeviceSize |= (CSD_Tab[7]) << 2;
 80100ae:	6920      	ldr	r0, [r4, #16]
    Csd->DeviceSize |= (CSD_Tab[8] & 0xC0) >> 6;
 80100b0:	f89d 3008 	ldrb.w	r3, [sp, #8]
    Csd->DeviceSize |= (CSD_Tab[7]) << 2;
 80100b4:	ea40 0086 	orr.w	r0, r0, r6, lsl #2
 80100b8:	6120      	str	r0, [r4, #16]
    Csd->DeviceSize |= (CSD_Tab[8] & 0xC0) >> 6;
 80100ba:	6925      	ldr	r5, [r4, #16]
 80100bc:	ea45 1593 	orr.w	r5, r5, r3, lsr #6
 80100c0:	6125      	str	r5, [r4, #16]
    Csd->DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
 80100c2:	0050      	lsls	r0, r2, #1
    Csd->MaxRdCurrentVDDMin = (CSD_Tab[8] & 0x38) >> 3;
 80100c4:	f3c3 05c2 	ubfx	r5, r3, #3, #3
 80100c8:	7525      	strb	r5, [r4, #20]
    Csd->DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
 80100ca:	f000 0006 	and.w	r0, r0, #6
    Csd->MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
 80100ce:	0955      	lsrs	r5, r2, #5
    Csd->MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
 80100d0:	f003 0307 	and.w	r3, r3, #7
    Csd->MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
 80100d4:	f3c2 0282 	ubfx	r2, r2, #2, #3
    Csd->MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
 80100d8:	7563      	strb	r3, [r4, #21]
    Csd->MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
 80100da:	75a5      	strb	r5, [r4, #22]
    Csd->MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
 80100dc:	75e2      	strb	r2, [r4, #23]
    Csd->DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
 80100de:	7620      	strb	r0, [r4, #24]
    Csd->DeviceSizeMul |= (CSD_Tab[10] & 0x80) >> 7;
 80100e0:	7e25      	ldrb	r5, [r4, #24]
 80100e2:	f89d 200a 	ldrb.w	r2, [sp, #10]
    Csd->EraseGrMul |= (CSD_Tab[11] & 0x80) >> 7;
 80100e6:	f89d 000b 	ldrb.w	r0, [sp, #11]
    Csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
 80100ea:	f89d 300c 	ldrb.w	r3, [sp, #12]
    Csd->DeviceSizeMul |= (CSD_Tab[10] & 0x80) >> 7;
 80100ee:	ea45 15d2 	orr.w	r5, r5, r2, lsr #7
 80100f2:	7625      	strb	r5, [r4, #24]
    Csd->EraseGrMul = (CSD_Tab[10] & 0x3F) << 1;
 80100f4:	0055      	lsls	r5, r2, #1
 80100f6:	f005 057e 	and.w	r5, r5, #126	; 0x7e
    Csd->EraseGrSize = (CSD_Tab[10] & 0x40) >> 6;
 80100fa:	f3c2 1280 	ubfx	r2, r2, #6, #1
 80100fe:	7662      	strb	r2, [r4, #25]
    Csd->EraseGrMul = (CSD_Tab[10] & 0x3F) << 1;
 8010100:	76a5      	strb	r5, [r4, #26]
    Csd->EraseGrMul |= (CSD_Tab[11] & 0x80) >> 7;
 8010102:	7ea5      	ldrb	r5, [r4, #26]
    Csd->MaxWrBlockLen |= (CSD_Tab[13] & 0xC0) >> 6;
 8010104:	f89d 200d 	ldrb.w	r2, [sp, #13]
    Csd->EraseGrMul |= (CSD_Tab[11] & 0x80) >> 7;
 8010108:	ea45 15d0 	orr.w	r5, r5, r0, lsr #7
    Csd->WrProtectGrSize = (CSD_Tab[11] & 0x7F);
 801010c:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    Csd->EraseGrMul |= (CSD_Tab[11] & 0x80) >> 7;
 8010110:	76a5      	strb	r5, [r4, #26]
    Csd->WrProtectGrSize = (CSD_Tab[11] & 0x7F);
 8010112:	76e0      	strb	r0, [r4, #27]
    Csd->MaxWrBlockLen = (CSD_Tab[12] & 0x03) << 2;
 8010114:	009d      	lsls	r5, r3, #2
    Csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
 8010116:	09d8      	lsrs	r0, r3, #7
 8010118:	7720      	strb	r0, [r4, #28]
    Csd->MaxWrBlockLen = (CSD_Tab[12] & 0x03) << 2;
 801011a:	f005 050c 	and.w	r5, r5, #12
    Csd->ManDeflECC = (CSD_Tab[12] & 0x60) >> 5;
 801011e:	f3c3 1041 	ubfx	r0, r3, #5, #2
    Csd->WrSpeedFact = (CSD_Tab[12] & 0x1C) >> 2;
 8010122:	f3c3 0382 	ubfx	r3, r3, #2, #3
    Csd->ManDeflECC = (CSD_Tab[12] & 0x60) >> 5;
 8010126:	7760      	strb	r0, [r4, #29]
    Csd->WrSpeedFact = (CSD_Tab[12] & 0x1C) >> 2;
 8010128:	77a3      	strb	r3, [r4, #30]
    Csd->MaxWrBlockLen = (CSD_Tab[12] & 0x03) << 2;
 801012a:	77e5      	strb	r5, [r4, #31]
    Csd->MaxWrBlockLen |= (CSD_Tab[13] & 0xC0) >> 6;
 801012c:	7fe5      	ldrb	r5, [r4, #31]
    Csd->FileFormatGrouop = (CSD_Tab[14] & 0x80) >> 7;
 801012e:	f89d 300e 	ldrb.w	r3, [sp, #14]
    Csd->CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
 8010132:	f89d 000f 	ldrb.w	r0, [sp, #15]
    Csd->MaxWrBlockLen |= (CSD_Tab[13] & 0xC0) >> 6;
 8010136:	ea45 1592 	orr.w	r5, r5, r2, lsr #6
 801013a:	77e5      	strb	r5, [r4, #31]
    Csd->WriteBlockPaPartial = (CSD_Tab[13] & 0x20) >> 5;
 801013c:	f3c2 1540 	ubfx	r5, r2, #5, #1
    Csd->ContentProtectAppli = (CSD_Tab[13] & 0x01);
 8010140:	f002 0201 	and.w	r2, r2, #1
    Csd->WriteBlockPaPartial = (CSD_Tab[13] & 0x20) >> 5;
 8010144:	f884 5020 	strb.w	r5, [r4, #32]
    Csd->Reserved3 = 0;
 8010148:	f884 1021 	strb.w	r1, [r4, #33]	; 0x21
    Csd->FileFormatGrouop = (CSD_Tab[14] & 0x80) >> 7;
 801014c:	09dd      	lsrs	r5, r3, #7
    Csd->ContentProtectAppli = (CSD_Tab[13] & 0x01);
 801014e:	f884 2022 	strb.w	r2, [r4, #34]	; 0x22
    Csd->CopyFlag = (CSD_Tab[14] & 0x40) >> 6;
 8010152:	f3c3 1180 	ubfx	r1, r3, #6, #1
    Csd->PermWrProtect = (CSD_Tab[14] & 0x20) >> 5;
 8010156:	f3c3 1240 	ubfx	r2, r3, #5, #1
    Csd->FileFormatGrouop = (CSD_Tab[14] & 0x80) >> 7;
 801015a:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23
    Csd->CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
 801015e:	0840      	lsrs	r0, r0, #1
    Csd->CopyFlag = (CSD_Tab[14] & 0x40) >> 6;
 8010160:	f884 1024 	strb.w	r1, [r4, #36]	; 0x24
    Csd->TempWrProtect = (CSD_Tab[14] & 0x10) >> 4;
 8010164:	f3c3 1500 	ubfx	r5, r3, #4, #1
    Csd->PermWrProtect = (CSD_Tab[14] & 0x20) >> 5;
 8010168:	f884 2025 	strb.w	r2, [r4, #37]	; 0x25
    Csd->FileFormat = (CSD_Tab[14] & 0x0C) >> 2;
 801016c:	f3c3 0181 	ubfx	r1, r3, #2, #2
    Csd->Reserved4 = 1;
 8010170:	2201      	movs	r2, #1
    Csd->ECC = (CSD_Tab[14] & 0x03);
 8010172:	f003 0303 	and.w	r3, r3, #3
    Csd->TempWrProtect = (CSD_Tab[14] & 0x10) >> 4;
 8010176:	f884 5026 	strb.w	r5, [r4, #38]	; 0x26
    Csd->FileFormat = (CSD_Tab[14] & 0x0C) >> 2;
 801017a:	f884 1027 	strb.w	r1, [r4, #39]	; 0x27
    Csd->ECC = (CSD_Tab[14] & 0x03);
 801017e:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    Csd->CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
 8010182:	f884 0029 	strb.w	r0, [r4, #41]	; 0x29
    Csd->Reserved4 = 1;
 8010186:	f884 202a 	strb.w	r2, [r4, #42]	; 0x2a
 801018a:	e001      	b.n	8010190 <BSP_SD_GetCardInfo+0x198>
  SD_IO_WriteDummy();
 801018c:	f7fe fba2 	bl	800e8d4 <SD_IO_WriteDummy>
  if (SD_IO_WriteCmd(SD_CMD_SEND_CID, 0, 0xFF, SD_RESPONSE_NO_ERROR) == HAL_OK)
 8010190:	2300      	movs	r3, #0
 8010192:	4619      	mov	r1, r3
 8010194:	22ff      	movs	r2, #255	; 0xff
 8010196:	200a      	movs	r0, #10
 8010198:	f7fe fb4e 	bl	800e838 <SD_IO_WriteCmd>
 801019c:	2800      	cmp	r0, #0
 801019e:	d170      	bne.n	8010282 <BSP_SD_GetCardInfo+0x28a>
    if (SD_IO_WaitResponse(SD_START_DATA_SINGLE_BLOCK_READ) == HAL_OK)
 80101a0:	20fe      	movs	r0, #254	; 0xfe
 80101a2:	f7fe fb83 	bl	800e8ac <SD_IO_WaitResponse>
 80101a6:	2800      	cmp	r0, #0
 80101a8:	d16b      	bne.n	8010282 <BSP_SD_GetCardInfo+0x28a>
 80101aa:	f10d 35ff 	add.w	r5, sp, #4294967295
 80101ae:	f10d 060f 	add.w	r6, sp, #15
        CID_Tab[counter] = SD_IO_ReadByte();
 80101b2:	f7fe fb0b 	bl	800e7cc <SD_IO_ReadByte>
 80101b6:	f805 0f01 	strb.w	r0, [r5, #1]!
      for (counter = 0; counter < 16; counter++)
 80101ba:	42ae      	cmp	r6, r5
 80101bc:	d1f9      	bne.n	80101b2 <BSP_SD_GetCardInfo+0x1ba>
      SD_IO_WriteByte(SD_DUMMY_BYTE);
 80101be:	20ff      	movs	r0, #255	; 0xff
 80101c0:	f7fe faf6 	bl	800e7b0 <SD_IO_WriteByte>
      SD_IO_WriteByte(SD_DUMMY_BYTE);
 80101c4:	20ff      	movs	r0, #255	; 0xff
 80101c6:	f7fe faf3 	bl	800e7b0 <SD_IO_WriteByte>
  SD_IO_WriteDummy();
 80101ca:	f7fe fb83 	bl	800e8d4 <SD_IO_WriteDummy>
    Cid->OEM_AppliID = CID_Tab[1] << 8;
 80101ce:	f89d 3001 	ldrb.w	r3, [sp, #1]
    Cid->ManufacturerID = CID_Tab[0];
 80101d2:	f89d 2000 	ldrb.w	r2, [sp]
 80101d6:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
    Cid->OEM_AppliID = CID_Tab[1] << 8;
 80101da:	021b      	lsls	r3, r3, #8
 80101dc:	85e3      	strh	r3, [r4, #46]	; 0x2e
    Cid->OEM_AppliID |= CID_Tab[2];
 80101de:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 80101e0:	f89d 2002 	ldrb.w	r2, [sp, #2]
    Cid->ProdName1 = CID_Tab[3] << 24;
 80101e4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    Cid->ProdName1 |= CID_Tab[4] << 16;
 80101e8:	f89d 1004 	ldrb.w	r1, [sp, #4]
    Cid->ProdName1 |= CID_Tab[5] << 8;
 80101ec:	f89d 5005 	ldrb.w	r5, [sp, #5]
    Cid->OEM_AppliID |= CID_Tab[2];
 80101f0:	4302      	orrs	r2, r0
    Cid->ProdName1 = CID_Tab[3] << 24;
 80101f2:	061b      	lsls	r3, r3, #24
    Cid->OEM_AppliID |= CID_Tab[2];
 80101f4:	85e2      	strh	r2, [r4, #46]	; 0x2e
    Cid->ProdName1 = CID_Tab[3] << 24;
 80101f6:	6323      	str	r3, [r4, #48]	; 0x30
    Cid->ProdName1 |= CID_Tab[4] << 16;
 80101f8:	6b20      	ldr	r0, [r4, #48]	; 0x30
    Cid->ProdName1 |= CID_Tab[6];
 80101fa:	f89d 2006 	ldrb.w	r2, [sp, #6]
    Cid->ProdSN = CID_Tab[9] << 24;
 80101fe:	f89d 3009 	ldrb.w	r3, [sp, #9]
    Cid->ProdName1 |= CID_Tab[4] << 16;
 8010202:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8010206:	6320      	str	r0, [r4, #48]	; 0x30
    Cid->ProdName1 |= CID_Tab[5] << 8;
 8010208:	6b21      	ldr	r1, [r4, #48]	; 0x30
    Cid->ProdName2 = CID_Tab[7];
 801020a:	f89d 0007 	ldrb.w	r0, [sp, #7]
    Cid->ProdName1 |= CID_Tab[5] << 8;
 801020e:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
 8010212:	6321      	str	r1, [r4, #48]	; 0x30
    Cid->ProdName1 |= CID_Tab[6];
 8010214:	6b25      	ldr	r5, [r4, #48]	; 0x30
    Cid->ProdRev = CID_Tab[8];
 8010216:	f89d 1008 	ldrb.w	r1, [sp, #8]
    Cid->ProdName1 |= CID_Tab[6];
 801021a:	432a      	orrs	r2, r5
    Cid->ProdSN = CID_Tab[9] << 24;
 801021c:	061b      	lsls	r3, r3, #24
    Cid->ProdName1 |= CID_Tab[6];
 801021e:	6322      	str	r2, [r4, #48]	; 0x30
    Cid->ProdName2 = CID_Tab[7];
 8010220:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    Cid->ProdRev = CID_Tab[8];
 8010224:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
    Cid->ProdSN = CID_Tab[9] << 24;
 8010228:	63a3      	str	r3, [r4, #56]	; 0x38
    Cid->ProdSN |= CID_Tab[10] << 16;
 801022a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 801022c:	f89d 200a 	ldrb.w	r2, [sp, #10]
    Cid->ProdSN |= CID_Tab[11] << 8;
 8010230:	f89d 000b 	ldrb.w	r0, [sp, #11]
    Cid->ProdSN |= CID_Tab[12];
 8010234:	f89d 300c 	ldrb.w	r3, [sp, #12]
    Cid->ProdSN |= CID_Tab[10] << 16;
 8010238:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 801023c:	63a1      	str	r1, [r4, #56]	; 0x38
    Cid->ProdSN |= CID_Tab[11] << 8;
 801023e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8010240:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8010244:	63a2      	str	r2, [r4, #56]	; 0x38
    Cid->ProdSN |= CID_Tab[12];
 8010246:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8010248:	4313      	orrs	r3, r2
 801024a:	63a3      	str	r3, [r4, #56]	; 0x38
    Cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
 801024c:	f89d 500d 	ldrb.w	r5, [sp, #13]
 8010250:	f894 003c 	ldrb.w	r0, [r4, #60]	; 0x3c
    Cid->ManufactDate |= CID_Tab[14];
 8010254:	f89d 200e 	ldrb.w	r2, [sp, #14]
    Cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
 8010258:	f89d 300f 	ldrb.w	r3, [sp, #15]
    Cid->ManufactDate = (CID_Tab[13] & 0x0F) << 8;
 801025c:	0229      	lsls	r1, r5, #8
 801025e:	f401 6170 	and.w	r1, r1, #3840	; 0xf00
    Cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
 8010262:	ea40 1015 	orr.w	r0, r0, r5, lsr #4
 8010266:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
    Cid->ManufactDate = (CID_Tab[13] & 0x0F) << 8;
 801026a:	87e1      	strh	r1, [r4, #62]	; 0x3e
    Cid->ManufactDate |= CID_Tab[14];
 801026c:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
    Cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
 801026e:	085b      	lsrs	r3, r3, #1
    Cid->ManufactDate |= CID_Tab[14];
 8010270:	430a      	orrs	r2, r1
    Cid->Reserved2 = 1;
 8010272:	2101      	movs	r1, #1
    Cid->ManufactDate |= CID_Tab[14];
 8010274:	87e2      	strh	r2, [r4, #62]	; 0x3e
      rvalue = MSD_OK;
 8010276:	2000      	movs	r0, #0
    Cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
 8010278:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    Cid->Reserved2 = 1;
 801027c:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
 8010280:	e002      	b.n	8010288 <BSP_SD_GetCardInfo+0x290>
  SD_IO_WriteDummy();
 8010282:	f7fe fb27 	bl	800e8d4 <SD_IO_WriteDummy>
  uint8_t rvalue = MSD_ERROR;
 8010286:	2001      	movs	r0, #1
  pCardInfo->CardCapacity = (pCardInfo->Csd.DeviceSize + 1) ;
 8010288:	6923      	ldr	r3, [r4, #16]
  pCardInfo->CardCapacity *= (1 << (pCardInfo->Csd.DeviceSizeMul + 2));
 801028a:	7e21      	ldrb	r1, [r4, #24]
  pCardInfo->CardBlockSize = 1 << (pCardInfo->Csd.RdBlockLen);
 801028c:	7a22      	ldrb	r2, [r4, #8]
  pCardInfo->CardCapacity *= (1 << (pCardInfo->Csd.DeviceSizeMul + 2));
 801028e:	3102      	adds	r1, #2
  pCardInfo->CardCapacity = (pCardInfo->Csd.DeviceSize + 1) ;
 8010290:	3301      	adds	r3, #1
  pCardInfo->CardCapacity *= (1 << (pCardInfo->Csd.DeviceSizeMul + 2));
 8010292:	408b      	lsls	r3, r1
  pCardInfo->CardBlockSize = 1 << (pCardInfo->Csd.RdBlockLen);
 8010294:	b2d2      	uxtb	r2, r2
  pCardInfo->CardCapacity *= pCardInfo->CardBlockSize;
 8010296:	4093      	lsls	r3, r2
  pCardInfo->CardBlockSize = 1 << (pCardInfo->Csd.RdBlockLen);
 8010298:	2101      	movs	r1, #1
 801029a:	fa01 f202 	lsl.w	r2, r1, r2
  pCardInfo->LogBlockNbr= (pCardInfo->CardCapacity)/BLOCK_SIZE;
 801029e:	0a5d      	lsrs	r5, r3, #9
  pCardInfo->LogBlockSize= BLOCK_SIZE;
 80102a0:	f44f 7100 	mov.w	r1, #512	; 0x200
  pCardInfo->CardCapacity *= pCardInfo->CardBlockSize;
 80102a4:	6463      	str	r3, [r4, #68]	; 0x44
  pCardInfo->LogBlockNbr= (pCardInfo->CardCapacity)/BLOCK_SIZE;
 80102a6:	6525      	str	r5, [r4, #80]	; 0x50
  pCardInfo->CardBlockSize = 1 << (pCardInfo->Csd.RdBlockLen);
 80102a8:	64a2      	str	r2, [r4, #72]	; 0x48
  pCardInfo->LogBlockSize= BLOCK_SIZE;
 80102aa:	6561      	str	r1, [r4, #84]	; 0x54
}
 80102ac:	b004      	add	sp, #16
 80102ae:	bd70      	pop	{r4, r5, r6, pc}

080102b0 <BSP_SD_ReadBlocks>:
{
 80102b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (SD_IO_WriteCmd(SD_CMD_SET_BLOCKLEN, BlockSize, 0xFF, SD_RESPONSE_NO_ERROR) != HAL_OK)
 80102b4:	f44f 7100 	mov.w	r1, #512	; 0x200
{
 80102b8:	4604      	mov	r4, r0
 80102ba:	4690      	mov	r8, r2
  if (SD_IO_WriteCmd(SD_CMD_SET_BLOCKLEN, BlockSize, 0xFF, SD_RESPONSE_NO_ERROR) != HAL_OK)
 80102bc:	2300      	movs	r3, #0
 80102be:	22ff      	movs	r2, #255	; 0xff
 80102c0:	2010      	movs	r0, #16
{
 80102c2:	9e08      	ldr	r6, [sp, #32]
  if (SD_IO_WriteCmd(SD_CMD_SET_BLOCKLEN, BlockSize, 0xFF, SD_RESPONSE_NO_ERROR) != HAL_OK)
 80102c4:	f7fe fab8 	bl	800e838 <SD_IO_WriteCmd>
 80102c8:	bbb0      	cbnz	r0, 8010338 <BSP_SD_ReadBlocks+0x88>
  if(SD_CardType != HIGH_CAPACITY_SD_CARD)
 80102ca:	f8df 9074 	ldr.w	r9, [pc, #116]	; 8010340 <BSP_SD_ReadBlocks+0x90>
 80102ce:	f899 3000 	ldrb.w	r3, [r9]
 80102d2:	2b02      	cmp	r3, #2
 80102d4:	d001      	beq.n	80102da <BSP_SD_ReadBlocks+0x2a>
    Sector *= 512;
 80102d6:	ea4f 2848 	mov.w	r8, r8, lsl #9
      rvalue = MSD_ERROR;
 80102da:	2501      	movs	r5, #1
 80102dc:	2700      	movs	r7, #0
  while (NumberOfBlocks--)
 80102de:	b18e      	cbz	r6, 8010304 <BSP_SD_ReadBlocks+0x54>
    SD_IO_WriteDummy();
 80102e0:	f7fe faf8 	bl	800e8d4 <SD_IO_WriteDummy>
    if (SD_IO_WriteCmd(SD_CMD_READ_SINGLE_BLOCK, Sector + offset, 0xFF, SD_RESPONSE_NO_ERROR) != HAL_OK)
 80102e4:	2300      	movs	r3, #0
 80102e6:	22ff      	movs	r2, #255	; 0xff
 80102e8:	eb07 0108 	add.w	r1, r7, r8
 80102ec:	2011      	movs	r0, #17
 80102ee:	f7fe faa3 	bl	800e838 <SD_IO_WriteCmd>
 80102f2:	bb08      	cbnz	r0, 8010338 <BSP_SD_ReadBlocks+0x88>
    if (SD_IO_WaitResponse(SD_START_DATA_SINGLE_BLOCK_READ) == HAL_OK)
 80102f4:	20fe      	movs	r0, #254	; 0xfe
 80102f6:	f7fe fad9 	bl	800e8ac <SD_IO_WaitResponse>
 80102fa:	b140      	cbz	r0, 801030e <BSP_SD_ReadBlocks+0x5e>
      rvalue = MSD_ERROR;
 80102fc:	2501      	movs	r5, #1
 80102fe:	3e01      	subs	r6, #1
  while (NumberOfBlocks--)
 8010300:	2e00      	cmp	r6, #0
 8010302:	d1ed      	bne.n	80102e0 <BSP_SD_ReadBlocks+0x30>
  SD_IO_WriteDummy();
 8010304:	f7fe fae6 	bl	800e8d4 <SD_IO_WriteDummy>
}
 8010308:	4628      	mov	r0, r5
 801030a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801030e:	f504 7500 	add.w	r5, r4, #512	; 0x200
        *pData = SD_IO_ReadByte();
 8010312:	f7fe fa5b 	bl	800e7cc <SD_IO_ReadByte>
 8010316:	f804 0b01 	strb.w	r0, [r4], #1
      for (counter = 0; counter < BlockSize; counter++)
 801031a:	42a5      	cmp	r5, r4
 801031c:	d1f9      	bne.n	8010312 <BSP_SD_ReadBlocks+0x62>
      if(SD_CardType != HIGH_CAPACITY_SD_CARD)
 801031e:	f899 3000 	ldrb.w	r3, [r9]
 8010322:	2b02      	cmp	r3, #2
        offset += BlockSize;
 8010324:	bf14      	ite	ne
 8010326:	f507 7700 	addne.w	r7, r7, #512	; 0x200
        offset += 1;
 801032a:	3701      	addeq	r7, #1
      rvalue = MSD_OK;
 801032c:	2500      	movs	r5, #0
      SD_IO_ReadByte();
 801032e:	f7fe fa4d 	bl	800e7cc <SD_IO_ReadByte>
      SD_IO_ReadByte();
 8010332:	f7fe fa4b 	bl	800e7cc <SD_IO_ReadByte>
 8010336:	e7e2      	b.n	80102fe <BSP_SD_ReadBlocks+0x4e>
    return MSD_ERROR;
 8010338:	2501      	movs	r5, #1
}
 801033a:	4628      	mov	r0, r5
 801033c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8010340:	2000194c 	.word	0x2000194c

08010344 <BSP_SD_WriteBlocks>:
{
 8010344:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if(SD_CardType != HIGH_CAPACITY_SD_CARD)
 8010348:	4c38      	ldr	r4, [pc, #224]	; (801042c <BSP_SD_WriteBlocks+0xe8>)
{
 801034a:	9e08      	ldr	r6, [sp, #32]
 801034c:	4681      	mov	r9, r0
 801034e:	4617      	mov	r7, r2
  SENSORTILE_SD_CS_HIGH();
 8010350:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8010354:	2201      	movs	r2, #1
 8010356:	4836      	ldr	r0, [pc, #216]	; (8010430 <BSP_SD_WriteBlocks+0xec>)
 8010358:	f001 f908 	bl	801156c <HAL_GPIO_WritePin>
  if(SD_CardType != HIGH_CAPACITY_SD_CARD)
 801035c:	7823      	ldrb	r3, [r4, #0]
 801035e:	2b02      	cmp	r3, #2
 8010360:	d000      	beq.n	8010364 <BSP_SD_WriteBlocks+0x20>
    Sector *= BlockSize;
 8010362:	027f      	lsls	r7, r7, #9
      rvalue = MSD_ERROR;
 8010364:	2500      	movs	r5, #0
    if (SD_IO_WriteCmd(SD_CMD_WRITE_SINGLE_BLOCK, Sector + offset, 0xFF, SD_RESPONSE_NO_ERROR) != HAL_OK)
 8010366:	46a8      	mov	r8, r5
      rvalue = MSD_ERROR;
 8010368:	f04f 0a01 	mov.w	sl, #1
  while (NumberOfBlocks--)
 801036c:	2e00      	cmp	r6, #0
 801036e:	d053      	beq.n	8010418 <BSP_SD_WriteBlocks+0xd4>
    if (SD_IO_WriteCmd(SD_CMD_WRITE_SINGLE_BLOCK, Sector + offset, 0xFF, SD_RESPONSE_NO_ERROR) != HAL_OK)
 8010370:	2300      	movs	r3, #0
 8010372:	22ff      	movs	r2, #255	; 0xff
 8010374:	19e9      	adds	r1, r5, r7
 8010376:	2018      	movs	r0, #24
 8010378:	f7fe fa5e 	bl	800e838 <SD_IO_WriteCmd>
 801037c:	2800      	cmp	r0, #0
 801037e:	d150      	bne.n	8010422 <BSP_SD_WriteBlocks+0xde>
    SD_IO_WriteByte(SD_DUMMY_BYTE);
 8010380:	20ff      	movs	r0, #255	; 0xff
 8010382:	f7fe fa15 	bl	800e7b0 <SD_IO_WriteByte>
    SD_IO_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
 8010386:	20fe      	movs	r0, #254	; 0xfe
 8010388:	f7fe fa12 	bl	800e7b0 <SD_IO_WriteByte>
    SD_IO_WriteDMA((uint8_t*)pData, BlockSize);
 801038c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8010390:	4648      	mov	r0, r9
 8010392:	f7fe fa0f 	bl	800e7b4 <SD_IO_WriteDMA>
    while (wTransferState == TRANSFER_WAIT)
 8010396:	6863      	ldr	r3, [r4, #4]
 8010398:	2b00      	cmp	r3, #0
 801039a:	d0fc      	beq.n	8010396 <BSP_SD_WriteBlocks+0x52>
    wTransferState = TRANSFER_WAIT;
 801039c:	f8c4 8004 	str.w	r8, [r4, #4]
    if(SD_CardType != HIGH_CAPACITY_SD_CARD)
 80103a0:	7823      	ldrb	r3, [r4, #0]
 80103a2:	2b02      	cmp	r3, #2
      offset += BlockSize;
 80103a4:	bf14      	ite	ne
 80103a6:	f505 7500 	addne.w	r5, r5, #512	; 0x200
      offset += 1;
 80103aa:	3501      	addeq	r5, #1
    SD_IO_ReadByte();
 80103ac:	f7fe fa0e 	bl	800e7cc <SD_IO_ReadByte>
    SD_IO_ReadByte();
 80103b0:	f7fe fa0c 	bl	800e7cc <SD_IO_ReadByte>
    response = (SD_Info)SD_IO_ReadByte();
 80103b4:	f7fe fa0a 	bl	800e7cc <SD_IO_ReadByte>
    switch (response)
 80103b8:	f000 001f 	and.w	r0, r0, #31
 80103bc:	280d      	cmp	r0, #13
 80103be:	d8f9      	bhi.n	80103b4 <BSP_SD_WriteBlocks+0x70>
 80103c0:	a301      	add	r3, pc, #4	; (adr r3, 80103c8 <BSP_SD_WriteBlocks+0x84>)
 80103c2:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
 80103c6:	bf00      	nop
 80103c8:	08010401 	.word	0x08010401
 80103cc:	080103b5 	.word	0x080103b5
 80103d0:	080103b5 	.word	0x080103b5
 80103d4:	080103b5 	.word	0x080103b5
 80103d8:	080103b5 	.word	0x080103b5
 80103dc:	08010401 	.word	0x08010401
 80103e0:	080103b5 	.word	0x080103b5
 80103e4:	080103b5 	.word	0x080103b5
 80103e8:	080103b5 	.word	0x080103b5
 80103ec:	080103b5 	.word	0x080103b5
 80103f0:	080103b5 	.word	0x080103b5
 80103f4:	0801040f 	.word	0x0801040f
 80103f8:	080103b5 	.word	0x080103b5
 80103fc:	0801040f 	.word	0x0801040f
  while (SD_IO_ReadByte() == 0);
 8010400:	f7fe f9e4 	bl	800e7cc <SD_IO_ReadByte>
 8010404:	2800      	cmp	r0, #0
 8010406:	d0fb      	beq.n	8010400 <BSP_SD_WriteBlocks+0xbc>
      rvalue = MSD_OK;
 8010408:	f04f 0a00 	mov.w	sl, #0
 801040c:	e001      	b.n	8010412 <BSP_SD_WriteBlocks+0xce>
      rvalue = MSD_ERROR;
 801040e:	f04f 0a01 	mov.w	sl, #1
 8010412:	3e01      	subs	r6, #1
  while (NumberOfBlocks--)
 8010414:	2e00      	cmp	r6, #0
 8010416:	d1ab      	bne.n	8010370 <BSP_SD_WriteBlocks+0x2c>
  SD_IO_WriteDummy();
 8010418:	f7fe fa5c 	bl	800e8d4 <SD_IO_WriteDummy>
}
 801041c:	4650      	mov	r0, sl
 801041e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      return MSD_ERROR;
 8010422:	f04f 0a01 	mov.w	sl, #1
}
 8010426:	4650      	mov	r0, sl
 8010428:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801042c:	2000194c 	.word	0x2000194c
 8010430:	48001800 	.word	0x48001800

08010434 <HAL_SPI_TxCpltCallback>:
  wTransferState = TRANSFER_COMPLETE;
 8010434:	4b01      	ldr	r3, [pc, #4]	; (801043c <HAL_SPI_TxCpltCallback+0x8>)
 8010436:	2201      	movs	r2, #1
 8010438:	605a      	str	r2, [r3, #4]
}
 801043a:	4770      	bx	lr
 801043c:	2000194c 	.word	0x2000194c

08010440 <BSP_SD_GetCardState>:
}
 8010440:	2000      	movs	r0, #0
 8010442:	4770      	bx	lr

08010444 <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8010444:	4910      	ldr	r1, [pc, #64]	; (8010488 <SystemInit+0x44>)
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8010446:	4b11      	ldr	r3, [pc, #68]	; (801048c <SystemInit+0x48>)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8010448:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 801044c:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
{
 8010450:	b430      	push	{r4, r5}
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8010452:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  RCC->CR |= RCC_CR_MSION;
 8010456:	681a      	ldr	r2, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8010458:	4c0d      	ldr	r4, [pc, #52]	; (8010490 <SystemInit+0x4c>)
  RCC->CFGR = 0x00000000U;
 801045a:	2000      	movs	r0, #0
  RCC->CR |= RCC_CR_MSION;
 801045c:	f042 0201 	orr.w	r2, r2, #1
 8010460:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000U;
 8010462:	6098      	str	r0, [r3, #8]
  RCC->CR &= 0xEAF6FFFFU;
 8010464:	681a      	ldr	r2, [r3, #0]
 8010466:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 801046a:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
  RCC->PLLCFGR = 0x00001000U;
 801046e:	f44f 5580 	mov.w	r5, #4096	; 0x1000
  RCC->CR &= 0xEAF6FFFFU;
 8010472:	601a      	str	r2, [r3, #0]
  RCC->PLLCFGR = 0x00001000U;
 8010474:	60dd      	str	r5, [r3, #12]
  RCC->CR &= 0xFFFBFFFFU;
 8010476:	681a      	ldr	r2, [r3, #0]
 8010478:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 801047c:	601a      	str	r2, [r3, #0]
  RCC->CIER = 0x00000000U;
 801047e:	6198      	str	r0, [r3, #24]
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8010480:	608c      	str	r4, [r1, #8]
#endif
}
 8010482:	bc30      	pop	{r4, r5}
 8010484:	4770      	bx	lr
 8010486:	bf00      	nop
 8010488:	e000ed00 	.word	0xe000ed00
 801048c:	40021000 	.word	0x40021000
 8010490:	08004000 	.word	0x08004000

08010494 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 8010494:	4770      	bx	lr
 8010496:	bf00      	nop

08010498 <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000);
 8010498:	4b08      	ldr	r3, [pc, #32]	; (80104bc <HAL_InitTick+0x24>)
 801049a:	4a09      	ldr	r2, [pc, #36]	; (80104c0 <HAL_InitTick+0x28>)
 801049c:	681b      	ldr	r3, [r3, #0]
{
 801049e:	b510      	push	{r4, lr}
  HAL_SYSTICK_Config(SystemCoreClock/1000);
 80104a0:	fba2 2303 	umull	r2, r3, r2, r3
{
 80104a4:	4604      	mov	r4, r0
  HAL_SYSTICK_Config(SystemCoreClock/1000);
 80104a6:	0998      	lsrs	r0, r3, #6
 80104a8:	f000 f89c 	bl	80105e4 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 80104ac:	4621      	mov	r1, r4
 80104ae:	2200      	movs	r2, #0
 80104b0:	f04f 30ff 	mov.w	r0, #4294967295
 80104b4:	f000 f846 	bl	8010544 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 80104b8:	2000      	movs	r0, #0
 80104ba:	bd10      	pop	{r4, pc}
 80104bc:	20000400 	.word	0x20000400
 80104c0:	10624dd3 	.word	0x10624dd3

080104c4 <HAL_Init>:
{
 80104c4:	b508      	push	{r3, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80104c6:	2003      	movs	r0, #3
 80104c8:	f000 f82a 	bl	8010520 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 80104cc:	200f      	movs	r0, #15
 80104ce:	f7ff ffe3 	bl	8010498 <HAL_InitTick>
  HAL_MspInit();
 80104d2:	f7ff ffdf 	bl	8010494 <HAL_MspInit>
}
 80104d6:	2000      	movs	r0, #0
 80104d8:	bd08      	pop	{r3, pc}
 80104da:	bf00      	nop

080104dc <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 80104dc:	4a02      	ldr	r2, [pc, #8]	; (80104e8 <HAL_IncTick+0xc>)
 80104de:	6813      	ldr	r3, [r2, #0]
 80104e0:	3301      	adds	r3, #1
 80104e2:	6013      	str	r3, [r2, #0]
}
 80104e4:	4770      	bx	lr
 80104e6:	bf00      	nop
 80104e8:	200113e8 	.word	0x200113e8

080104ec <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80104ec:	4b01      	ldr	r3, [pc, #4]	; (80104f4 <HAL_GetTick+0x8>)
 80104ee:	6818      	ldr	r0, [r3, #0]
}
 80104f0:	4770      	bx	lr
 80104f2:	bf00      	nop
 80104f4:	200113e8 	.word	0x200113e8

080104f8 <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
 80104f8:	4a02      	ldr	r2, [pc, #8]	; (8010504 <HAL_SuspendTick+0xc>)
 80104fa:	6813      	ldr	r3, [r2, #0]
 80104fc:	f023 0302 	bic.w	r3, r3, #2
 8010500:	6013      	str	r3, [r2, #0]
}
 8010502:	4770      	bx	lr
 8010504:	e000e010 	.word	0xe000e010

08010508 <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
 8010508:	4a02      	ldr	r2, [pc, #8]	; (8010514 <HAL_ResumeTick+0xc>)
 801050a:	6813      	ldr	r3, [r2, #0]
 801050c:	f043 0302 	orr.w	r3, r3, #2
 8010510:	6013      	str	r3, [r2, #0]
}
 8010512:	4770      	bx	lr
 8010514:	e000e010 	.word	0xe000e010

08010518 <HAL_GetHalVersion>:
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
 return __STM32L4xx_HAL_VERSION;
}
 8010518:	4800      	ldr	r0, [pc, #0]	; (801051c <HAL_GetHalVersion+0x4>)
 801051a:	4770      	bx	lr
 801051c:	01080200 	.word	0x01080200

08010520 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8010520:	4a07      	ldr	r2, [pc, #28]	; (8010540 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8010522:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8010524:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 8010528:	400b      	ands	r3, r1
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 801052a:	0200      	lsls	r0, r0, #8
 801052c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8010530:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 8010534:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
 8010538:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 801053a:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 801053c:	4770      	bx	lr
 801053e:	bf00      	nop
 8010540:	e000ed00 	.word	0xe000ed00

08010544 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8010544:	4b18      	ldr	r3, [pc, #96]	; (80105a8 <HAL_NVIC_SetPriority+0x64>)
 8010546:	68db      	ldr	r3, [r3, #12]
 8010548:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 801054c:	b430      	push	{r4, r5}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 801054e:	f1c3 0507 	rsb	r5, r3, #7
 8010552:	2d04      	cmp	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8010554:	f103 0404 	add.w	r4, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8010558:	bf28      	it	cs
 801055a:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 801055c:	2c06      	cmp	r4, #6
 801055e:	d919      	bls.n	8010594 <HAL_NVIC_SetPriority+0x50>
 8010560:	3b03      	subs	r3, #3
 8010562:	f04f 34ff 	mov.w	r4, #4294967295
 8010566:	409c      	lsls	r4, r3
 8010568:	ea22 0404 	bic.w	r4, r2, r4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 801056c:	f04f 32ff 	mov.w	r2, #4294967295
 8010570:	40aa      	lsls	r2, r5
 8010572:	ea21 0102 	bic.w	r1, r1, r2
 8010576:	fa01 f203 	lsl.w	r2, r1, r3
 801057a:	4322      	orrs	r2, r4
 801057c:	0112      	lsls	r2, r2, #4
  if ((int32_t)(IRQn) < 0)
 801057e:	2800      	cmp	r0, #0
 8010580:	b2d2      	uxtb	r2, r2
 8010582:	db0a      	blt.n	801059a <HAL_NVIC_SetPriority+0x56>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8010584:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8010588:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 801058c:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8010590:	bc30      	pop	{r4, r5}
 8010592:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8010594:	2400      	movs	r4, #0
 8010596:	4623      	mov	r3, r4
 8010598:	e7e8      	b.n	801056c <HAL_NVIC_SetPriority+0x28>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 801059a:	4b04      	ldr	r3, [pc, #16]	; (80105ac <HAL_NVIC_SetPriority+0x68>)
 801059c:	f000 000f 	and.w	r0, r0, #15
 80105a0:	4403      	add	r3, r0
 80105a2:	761a      	strb	r2, [r3, #24]
 80105a4:	bc30      	pop	{r4, r5}
 80105a6:	4770      	bx	lr
 80105a8:	e000ed00 	.word	0xe000ed00
 80105ac:	e000ecfc 	.word	0xe000ecfc

080105b0 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80105b0:	f000 011f 	and.w	r1, r0, #31
 80105b4:	2301      	movs	r3, #1
 80105b6:	0940      	lsrs	r0, r0, #5
 80105b8:	4a02      	ldr	r2, [pc, #8]	; (80105c4 <HAL_NVIC_EnableIRQ+0x14>)
 80105ba:	408b      	lsls	r3, r1
 80105bc:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80105c0:	4770      	bx	lr
 80105c2:	bf00      	nop
 80105c4:	e000e100 	.word	0xe000e100

080105c8 <HAL_NVIC_DisableIRQ>:
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80105c8:	0943      	lsrs	r3, r0, #5
 80105ca:	3320      	adds	r3, #32
 80105cc:	f000 001f 	and.w	r0, r0, #31
 80105d0:	2201      	movs	r2, #1
 80105d2:	4903      	ldr	r1, [pc, #12]	; (80105e0 <HAL_NVIC_DisableIRQ+0x18>)
 80105d4:	fa02 f000 	lsl.w	r0, r2, r0
 80105d8:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 80105dc:	4770      	bx	lr
 80105de:	bf00      	nop
 80105e0:	e000e100 	.word	0xe000e100

080105e4 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80105e4:	3801      	subs	r0, #1
 80105e6:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80105ea:	d20e      	bcs.n	801060a <HAL_SYSTICK_Config+0x26>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80105ec:	4b08      	ldr	r3, [pc, #32]	; (8010610 <HAL_SYSTICK_Config+0x2c>)
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80105ee:	b410      	push	{r4}
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80105f0:	4c08      	ldr	r4, [pc, #32]	; (8010614 <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80105f2:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80105f4:	20f0      	movs	r0, #240	; 0xf0
 80105f6:	f884 0023 	strb.w	r0, [r4, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80105fa:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80105fc:	2107      	movs	r1, #7
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80105fe:	4610      	mov	r0, r2
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8010600:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8010602:	6019      	str	r1, [r3, #0]
   return SysTick_Config(TicksNumb);
}
 8010604:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010608:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 801060a:	2001      	movs	r0, #1
 801060c:	4770      	bx	lr
 801060e:	bf00      	nop
 8010610:	e000e010 	.word	0xe000e010
 8010614:	e000ed00 	.word	0xe000ed00

08010618 <DFSDM_RegConvStart>:
  * @retval None
  */
static void DFSDM_RegConvStart(DFSDM_Filter_HandleTypeDef* hdfsdm_filter)
{
  /* Check regular trigger */
  if(hdfsdm_filter->RegularTrigger == DFSDM_FILTER_SW_TRIGGER)
 8010618:	6b41      	ldr	r1, [r0, #52]	; 0x34
 801061a:	6803      	ldr	r3, [r0, #0]
 801061c:	f890 204c 	ldrb.w	r2, [r0, #76]	; 0x4c
 8010620:	b951      	cbnz	r1, 8010638 <DFSDM_RegConvStart+0x20>
  {
    /* Software start of regular conversion */
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_RSWSTART;
 8010622:	6819      	ldr	r1, [r3, #0]
 8010624:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
 8010628:	6019      	str	r1, [r3, #0]
                                         hdfsdm_filter->InjectedChannelsNbr : 1;
    }
  }
  /* Update DFSDM filter state */
  hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_READY) ? \
                          HAL_DFSDM_FILTER_STATE_REG : HAL_DFSDM_FILTER_STATE_REG_INJ;
 801062a:	2a01      	cmp	r2, #1
 801062c:	bf14      	ite	ne
 801062e:	2304      	movne	r3, #4
 8010630:	2302      	moveq	r3, #2
  hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_READY) ? \
 8010632:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
}
 8010636:	4770      	bx	lr
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_DFEN);
 8010638:	6819      	ldr	r1, [r3, #0]
 801063a:	f021 0101 	bic.w	r1, r1, #1
 801063e:	6019      	str	r1, [r3, #0]
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_RSYNC;
 8010640:	6819      	ldr	r1, [r3, #0]
 8010642:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
 8010646:	6019      	str	r1, [r3, #0]
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 8010648:	6819      	ldr	r1, [r3, #0]
    if(hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_INJ)
 801064a:	2a03      	cmp	r2, #3
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 801064c:	f041 0101 	orr.w	r1, r1, #1
 8010650:	6019      	str	r1, [r3, #0]
    if(hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_INJ)
 8010652:	d1ea      	bne.n	801062a <DFSDM_RegConvStart+0x12>
      if(hdfsdm_filter->InjectedTrigger == DFSDM_FILTER_SW_TRIGGER)
 8010654:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8010656:	b91a      	cbnz	r2, 8010660 <DFSDM_RegConvStart+0x48>
        hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_JSWSTART;
 8010658:	681a      	ldr	r2, [r3, #0]
 801065a:	f042 0202 	orr.w	r2, r2, #2
 801065e:	601a      	str	r2, [r3, #0]
                                         hdfsdm_filter->InjectedChannelsNbr : 1;
 8010660:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8010664:	2b01      	cmp	r3, #1
 8010666:	bf0c      	ite	eq
 8010668:	6c43      	ldreq	r3, [r0, #68]	; 0x44
 801066a:	2301      	movne	r3, #1
      hdfsdm_filter->InjConvRemaining = (hdfsdm_filter->InjectedScanMode == ENABLE) ? \
 801066c:	6483      	str	r3, [r0, #72]	; 0x48
                          HAL_DFSDM_FILTER_STATE_REG : HAL_DFSDM_FILTER_STATE_REG_INJ;
 801066e:	2304      	movs	r3, #4
  hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_READY) ? \
 8010670:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
}
 8010674:	4770      	bx	lr
 8010676:	bf00      	nop

08010678 <DFSDM_RegConvStop>:
  * @retval None
  */
static void DFSDM_RegConvStop(DFSDM_Filter_HandleTypeDef* hdfsdm_filter)
{
  /* Disable DFSDM filter */
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_DFEN);
 8010678:	6803      	ldr	r3, [r0, #0]

  /* If regular trigger was synchronous, reset RSYNC bit in DFSDM_FLTCR1 register */
  if(hdfsdm_filter->RegularTrigger == DFSDM_FILTER_SYNC_TRIGGER)
 801067a:	6b41      	ldr	r1, [r0, #52]	; 0x34
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_DFEN);
 801067c:	681a      	ldr	r2, [r3, #0]
  if(hdfsdm_filter->RegularTrigger == DFSDM_FILTER_SYNC_TRIGGER)
 801067e:	2901      	cmp	r1, #1
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_DFEN);
 8010680:	f022 0201 	bic.w	r2, r2, #1
 8010684:	601a      	str	r2, [r3, #0]
  if(hdfsdm_filter->RegularTrigger == DFSDM_FILTER_SYNC_TRIGGER)
 8010686:	d103      	bne.n	8010690 <DFSDM_RegConvStop+0x18>
  {
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RSYNC);
 8010688:	681a      	ldr	r2, [r3, #0]
 801068a:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 801068e:	601a      	str	r2, [r3, #0]
  }

  /* Enable DFSDM filter */
  hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 8010690:	681a      	ldr	r2, [r3, #0]
  
  /* If injected conversion was in progress, restart it */
  if(hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_REG_INJ)
 8010692:	f890 104c 	ldrb.w	r1, [r0, #76]	; 0x4c
  hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 8010696:	f042 0201 	orr.w	r2, r2, #1
  if(hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_REG_INJ)
 801069a:	2904      	cmp	r1, #4
  hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 801069c:	601a      	str	r2, [r3, #0]
  if(hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_REG_INJ)
 801069e:	d006      	beq.n	80106ae <DFSDM_RegConvStop+0x36>
                                       hdfsdm_filter->InjectedChannelsNbr : 1;
  }
  
  /* Update DFSDM filter state */
  hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_REG) ? \
                          HAL_DFSDM_FILTER_STATE_READY : HAL_DFSDM_FILTER_STATE_INJ;
 80106a0:	2902      	cmp	r1, #2
 80106a2:	bf0c      	ite	eq
 80106a4:	2301      	moveq	r3, #1
 80106a6:	2303      	movne	r3, #3
  hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_REG) ? \
 80106a8:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
}
 80106ac:	4770      	bx	lr
    if(hdfsdm_filter->InjectedTrigger == DFSDM_FILTER_SW_TRIGGER)
 80106ae:	6b82      	ldr	r2, [r0, #56]	; 0x38
 80106b0:	b91a      	cbnz	r2, 80106ba <DFSDM_RegConvStop+0x42>
      hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_JSWSTART;
 80106b2:	681a      	ldr	r2, [r3, #0]
 80106b4:	f042 0202 	orr.w	r2, r2, #2
 80106b8:	601a      	str	r2, [r3, #0]
                                       hdfsdm_filter->InjectedChannelsNbr : 1;
 80106ba:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 80106be:	2b01      	cmp	r3, #1
 80106c0:	bf0c      	ite	eq
 80106c2:	6c43      	ldreq	r3, [r0, #68]	; 0x44
 80106c4:	2301      	movne	r3, #1
    hdfsdm_filter->InjConvRemaining = (hdfsdm_filter->InjectedScanMode == ENABLE) ? \
 80106c6:	6483      	str	r3, [r0, #72]	; 0x48
                          HAL_DFSDM_FILTER_STATE_READY : HAL_DFSDM_FILTER_STATE_INJ;
 80106c8:	2303      	movs	r3, #3
  hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_REG) ? \
 80106ca:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
}
 80106ce:	4770      	bx	lr

080106d0 <DFSDM_GetChannelFromInstance>:
  if(Instance == DFSDM1_Channel0)
 80106d0:	4b14      	ldr	r3, [pc, #80]	; (8010724 <DFSDM_GetChannelFromInstance+0x54>)
 80106d2:	4298      	cmp	r0, r3
 80106d4:	d017      	beq.n	8010706 <DFSDM_GetChannelFromInstance+0x36>
  else if(Instance == DFSDM1_Channel1)
 80106d6:	3320      	adds	r3, #32
 80106d8:	4298      	cmp	r0, r3
 80106da:	d018      	beq.n	801070e <DFSDM_GetChannelFromInstance+0x3e>
  else if(Instance == DFSDM1_Channel2)
 80106dc:	3320      	adds	r3, #32
 80106de:	4298      	cmp	r0, r3
 80106e0:	d013      	beq.n	801070a <DFSDM_GetChannelFromInstance+0x3a>
  else if(Instance == DFSDM1_Channel3)
 80106e2:	3320      	adds	r3, #32
 80106e4:	4298      	cmp	r0, r3
 80106e6:	d014      	beq.n	8010712 <DFSDM_GetChannelFromInstance+0x42>
  else if(Instance == DFSDM1_Channel4)
 80106e8:	3320      	adds	r3, #32
 80106ea:	4298      	cmp	r0, r3
 80106ec:	d013      	beq.n	8010716 <DFSDM_GetChannelFromInstance+0x46>
  else if(Instance == DFSDM1_Channel5)
 80106ee:	3320      	adds	r3, #32
 80106f0:	4298      	cmp	r0, r3
 80106f2:	d012      	beq.n	801071a <DFSDM_GetChannelFromInstance+0x4a>
  else if(Instance == DFSDM1_Channel6)
 80106f4:	3320      	adds	r3, #32
 80106f6:	4298      	cmp	r0, r3
 80106f8:	d011      	beq.n	801071e <DFSDM_GetChannelFromInstance+0x4e>
  else if(Instance == DFSDM1_Channel7)
 80106fa:	3320      	adds	r3, #32
    channel = 7;
 80106fc:	4298      	cmp	r0, r3
 80106fe:	bf14      	ite	ne
 8010700:	20ff      	movne	r0, #255	; 0xff
 8010702:	2007      	moveq	r0, #7
 8010704:	4770      	bx	lr
    channel = 0;
 8010706:	2000      	movs	r0, #0
 8010708:	4770      	bx	lr
    channel = 2;
 801070a:	2002      	movs	r0, #2
 801070c:	4770      	bx	lr
    channel = 1;
 801070e:	2001      	movs	r0, #1
 8010710:	4770      	bx	lr
    channel = 3;
 8010712:	2003      	movs	r0, #3
 8010714:	4770      	bx	lr
    channel = 4;
 8010716:	2004      	movs	r0, #4
 8010718:	4770      	bx	lr
    channel = 5;
 801071a:	2005      	movs	r0, #5
 801071c:	4770      	bx	lr
    channel = 6;
 801071e:	2006      	movs	r0, #6
}
 8010720:	4770      	bx	lr
 8010722:	bf00      	nop
 8010724:	40016000 	.word	0x40016000

08010728 <HAL_DFSDM_ChannelMspInit>:
}
 8010728:	4770      	bx	lr
 801072a:	bf00      	nop

0801072c <HAL_DFSDM_ChannelInit>:
{
 801072c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(hdfsdm_channel == NULL)
 801072e:	b138      	cbz	r0, 8010740 <HAL_DFSDM_ChannelInit+0x14>
 8010730:	4604      	mov	r4, r0
  if(a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] != NULL)
 8010732:	6800      	ldr	r0, [r0, #0]
 8010734:	4d36      	ldr	r5, [pc, #216]	; (8010810 <HAL_DFSDM_ChannelInit+0xe4>)
 8010736:	f7ff ffcb 	bl	80106d0 <DFSDM_GetChannelFromInstance>
 801073a:	f855 3020 	ldr.w	r3, [r5, r0, lsl #2]
 801073e:	b113      	cbz	r3, 8010746 <HAL_DFSDM_ChannelInit+0x1a>
    return HAL_ERROR;
 8010740:	2301      	movs	r3, #1
}
 8010742:	4618      	mov	r0, r3
 8010744:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  HAL_DFSDM_ChannelMspInit(hdfsdm_channel);
 8010746:	4620      	mov	r0, r4
 8010748:	f7ff ffee 	bl	8010728 <HAL_DFSDM_ChannelMspInit>
  v_dfsdm1ChannelCounter++;
 801074c:	6a2b      	ldr	r3, [r5, #32]
 801074e:	3301      	adds	r3, #1
 8010750:	622b      	str	r3, [r5, #32]
  if(v_dfsdm1ChannelCounter == 1)
 8010752:	6a2b      	ldr	r3, [r5, #32]
 8010754:	2b01      	cmp	r3, #1
 8010756:	d03e      	beq.n	80107d6 <HAL_DFSDM_ChannelInit+0xaa>
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_DATPACK | DFSDM_CHCFGR1_DATMPX | 
 8010758:	6820      	ldr	r0, [r4, #0]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer | 
 801075a:	6923      	ldr	r3, [r4, #16]
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_DATPACK | DFSDM_CHCFGR1_DATMPX | 
 801075c:	6802      	ldr	r2, [r0, #0]
  hdfsdm_channel->Instance->CHAWSCDR |= (hdfsdm_channel->Init.Awd.FilterOrder | 
 801075e:	f8d4 c024 	ldr.w	ip, [r4, #36]	; 0x24
                                        (hdfsdm_channel->Init.RightBitShift << DFSDM_CHCFGR2_DTRBS_Pos));
 8010762:	6b27      	ldr	r7, [r4, #48]	; 0x30
                                        hdfsdm_channel->Init.Input.DataPacking | 
 8010764:	e9d4 6105 	ldrd	r6, r1, [r4, #20]
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_DATPACK | DFSDM_CHCFGR1_DATMPX | 
 8010768:	f422 4271 	bic.w	r2, r2, #61696	; 0xf100
 801076c:	6002      	str	r2, [r0, #0]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer | 
 801076e:	6802      	ldr	r2, [r0, #0]
 8010770:	4333      	orrs	r3, r6
                                        hdfsdm_channel->Init.Input.DataPacking | 
 8010772:	430b      	orrs	r3, r1
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer | 
 8010774:	4313      	orrs	r3, r2
 8010776:	6003      	str	r3, [r0, #0]
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_SITP | DFSDM_CHCFGR1_SPICKSEL);
 8010778:	6801      	ldr	r1, [r0, #0]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.SerialInterface.Type | 
 801077a:	e9d4 3607 	ldrd	r3, r6, [r4, #28]
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_SITP | DFSDM_CHCFGR1_SPICKSEL);
 801077e:	f021 010f 	bic.w	r1, r1, #15
 8010782:	6001      	str	r1, [r0, #0]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.SerialInterface.Type | 
 8010784:	6802      	ldr	r2, [r0, #0]
                                       ((hdfsdm_channel->Init.Awd.Oversampling - 1) << DFSDM_CHAWSCDR_AWFOSR_Pos));
 8010786:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.SerialInterface.Type | 
 8010788:	4333      	orrs	r3, r6
 801078a:	4313      	orrs	r3, r2
 801078c:	6003      	str	r3, [r0, #0]
  hdfsdm_channel->Instance->CHAWSCDR &= ~(DFSDM_CHAWSCDR_AWFORD | DFSDM_CHAWSCDR_AWFOSR);
 801078e:	6886      	ldr	r6, [r0, #8]
 8010790:	f426 065f 	bic.w	r6, r6, #14614528	; 0xdf0000
 8010794:	6086      	str	r6, [r0, #8]
  hdfsdm_channel->Instance->CHAWSCDR |= (hdfsdm_channel->Init.Awd.FilterOrder | 
 8010796:	6882      	ldr	r2, [r0, #8]
                                       ((hdfsdm_channel->Init.Awd.Oversampling - 1) << DFSDM_CHAWSCDR_AWFOSR_Pos));
 8010798:	3901      	subs	r1, #1
  hdfsdm_channel->Instance->CHAWSCDR |= (hdfsdm_channel->Init.Awd.FilterOrder | 
 801079a:	ea42 020c 	orr.w	r2, r2, ip
 801079e:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 80107a2:	6082      	str	r2, [r0, #8]
  hdfsdm_channel->Instance->CHCFGR2 &= ~(DFSDM_CHCFGR2_OFFSET | DFSDM_CHCFGR2_DTRBS);
 80107a4:	6842      	ldr	r2, [r0, #4]
  hdfsdm_channel->Instance->CHCFGR2 |= (((uint32_t) hdfsdm_channel->Init.Offset << DFSDM_CHCFGR2_OFFSET_Pos) | 
 80107a6:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  hdfsdm_channel->Instance->CHCFGR2 &= ~(DFSDM_CHCFGR2_OFFSET | DFSDM_CHCFGR2_DTRBS);
 80107a8:	f002 0207 	and.w	r2, r2, #7
 80107ac:	6042      	str	r2, [r0, #4]
  hdfsdm_channel->Instance->CHCFGR2 |= (((uint32_t) hdfsdm_channel->Init.Offset << DFSDM_CHCFGR2_OFFSET_Pos) | 
 80107ae:	6843      	ldr	r3, [r0, #4]
 80107b0:	ea43 03c7 	orr.w	r3, r3, r7, lsl #3
 80107b4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80107b8:	6043      	str	r3, [r0, #4]
  hdfsdm_channel->Instance->CHCFGR1 |= DFSDM_CHCFGR1_CHEN;
 80107ba:	6803      	ldr	r3, [r0, #0]
  hdfsdm_channel->State = HAL_DFSDM_CHANNEL_STATE_READY;
 80107bc:	2201      	movs	r2, #1
  hdfsdm_channel->Instance->CHCFGR1 |= DFSDM_CHCFGR1_CHEN;
 80107be:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80107c2:	6003      	str	r3, [r0, #0]
  hdfsdm_channel->State = HAL_DFSDM_CHANNEL_STATE_READY;
 80107c4:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] = hdfsdm_channel;
 80107c8:	f7ff ff82 	bl	80106d0 <DFSDM_GetChannelFromInstance>
  return HAL_OK;
 80107cc:	2300      	movs	r3, #0
  a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] = hdfsdm_channel;
 80107ce:	f845 4020 	str.w	r4, [r5, r0, lsl #2]
}
 80107d2:	4618      	mov	r0, r3
 80107d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_CKOUTSRC);
 80107d6:	4b0f      	ldr	r3, [pc, #60]	; (8010814 <HAL_DFSDM_ChannelInit+0xe8>)
    if(hdfsdm_channel->Init.OutputClock.Activation == ENABLE)
 80107d8:	7921      	ldrb	r1, [r4, #4]
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_CKOUTSRC);
 80107da:	681a      	ldr	r2, [r3, #0]
 80107dc:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 80107e0:	601a      	str	r2, [r3, #0]
    DFSDM1_Channel0->CHCFGR1 |= hdfsdm_channel->Init.OutputClock.Selection;
 80107e2:	681a      	ldr	r2, [r3, #0]
 80107e4:	68a0      	ldr	r0, [r4, #8]
 80107e6:	4302      	orrs	r2, r0
 80107e8:	601a      	str	r2, [r3, #0]
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_CKOUTDIV);
 80107ea:	681a      	ldr	r2, [r3, #0]
    if(hdfsdm_channel->Init.OutputClock.Activation == ENABLE)
 80107ec:	2901      	cmp	r1, #1
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_CKOUTDIV);
 80107ee:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 80107f2:	601a      	str	r2, [r3, #0]
    if(hdfsdm_channel->Init.OutputClock.Activation == ENABLE)
 80107f4:	d105      	bne.n	8010802 <HAL_DFSDM_ChannelInit+0xd6>
      DFSDM1_Channel0->CHCFGR1 |= (uint32_t) ((hdfsdm_channel->Init.OutputClock.Divider - 1) << 
 80107f6:	68e1      	ldr	r1, [r4, #12]
 80107f8:	681a      	ldr	r2, [r3, #0]
 80107fa:	3901      	subs	r1, #1
 80107fc:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8010800:	601a      	str	r2, [r3, #0]
    DFSDM1_Channel0->CHCFGR1 |= DFSDM_CHCFGR1_DFSDMEN;
 8010802:	4a04      	ldr	r2, [pc, #16]	; (8010814 <HAL_DFSDM_ChannelInit+0xe8>)
 8010804:	6813      	ldr	r3, [r2, #0]
 8010806:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 801080a:	6013      	str	r3, [r2, #0]
 801080c:	e7a4      	b.n	8010758 <HAL_DFSDM_ChannelInit+0x2c>
 801080e:	bf00      	nop
 8010810:	20001954 	.word	0x20001954
 8010814:	40016000 	.word	0x40016000

08010818 <HAL_DFSDM_ChannelMspDeInit>:
 8010818:	4770      	bx	lr
 801081a:	bf00      	nop

0801081c <HAL_DFSDM_ChannelDeInit>:
  if(hdfsdm_channel == NULL)
 801081c:	b328      	cbz	r0, 801086a <HAL_DFSDM_ChannelDeInit+0x4e>
  if(a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] == NULL)
 801081e:	6802      	ldr	r2, [r0, #0]
{
 8010820:	b570      	push	{r4, r5, r6, lr}
 8010822:	4604      	mov	r4, r0
  if(a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] == NULL)
 8010824:	4610      	mov	r0, r2
 8010826:	f7ff ff53 	bl	80106d0 <DFSDM_GetChannelFromInstance>
 801082a:	4d12      	ldr	r5, [pc, #72]	; (8010874 <HAL_DFSDM_ChannelDeInit+0x58>)
 801082c:	f855 3020 	ldr.w	r3, [r5, r0, lsl #2]
 8010830:	b1eb      	cbz	r3, 801086e <HAL_DFSDM_ChannelDeInit+0x52>
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_CHEN);
 8010832:	6813      	ldr	r3, [r2, #0]
 8010834:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8010838:	6013      	str	r3, [r2, #0]
  v_dfsdm1ChannelCounter--;
 801083a:	6a2b      	ldr	r3, [r5, #32]
 801083c:	3b01      	subs	r3, #1
 801083e:	622b      	str	r3, [r5, #32]
  if(v_dfsdm1ChannelCounter == 0)
 8010840:	6a2b      	ldr	r3, [r5, #32]
 8010842:	b923      	cbnz	r3, 801084e <HAL_DFSDM_ChannelDeInit+0x32>
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_DFSDMEN);
 8010844:	4a0c      	ldr	r2, [pc, #48]	; (8010878 <HAL_DFSDM_ChannelDeInit+0x5c>)
 8010846:	6813      	ldr	r3, [r2, #0]
 8010848:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 801084c:	6013      	str	r3, [r2, #0]
  hdfsdm_channel->State = HAL_DFSDM_CHANNEL_STATE_RESET;
 801084e:	2600      	movs	r6, #0
  HAL_DFSDM_ChannelMspDeInit(hdfsdm_channel);
 8010850:	4620      	mov	r0, r4
 8010852:	f7ff ffe1 	bl	8010818 <HAL_DFSDM_ChannelMspDeInit>
  a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] = (DFSDM_Channel_HandleTypeDef *) NULL;
 8010856:	6820      	ldr	r0, [r4, #0]
  hdfsdm_channel->State = HAL_DFSDM_CHANNEL_STATE_RESET;
 8010858:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
  a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] = (DFSDM_Channel_HandleTypeDef *) NULL;
 801085c:	f7ff ff38 	bl	80106d0 <DFSDM_GetChannelFromInstance>
 8010860:	4603      	mov	r3, r0
  return HAL_OK;
 8010862:	4630      	mov	r0, r6
  a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] = (DFSDM_Channel_HandleTypeDef *) NULL;
 8010864:	f845 6023 	str.w	r6, [r5, r3, lsl #2]
}
 8010868:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 801086a:	2001      	movs	r0, #1
}
 801086c:	4770      	bx	lr
    return HAL_ERROR;
 801086e:	2001      	movs	r0, #1
}
 8010870:	bd70      	pop	{r4, r5, r6, pc}
 8010872:	bf00      	nop
 8010874:	20001954 	.word	0x20001954
 8010878:	40016000 	.word	0x40016000

0801087c <HAL_DFSDM_ChannelGetState>:
}
 801087c:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
 8010880:	4770      	bx	lr
 8010882:	bf00      	nop

08010884 <HAL_DFSDM_FilterMspInit>:
 8010884:	4770      	bx	lr
 8010886:	bf00      	nop

08010888 <HAL_DFSDM_FilterInit>:
  if(hdfsdm_filter == NULL)
 8010888:	2800      	cmp	r0, #0
 801088a:	d068      	beq.n	801095e <HAL_DFSDM_FilterInit+0xd6>
{
 801088c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if((hdfsdm_filter->Instance == DFSDM1_Filter0) && 
 801088e:	6802      	ldr	r2, [r0, #0]
 8010890:	4b36      	ldr	r3, [pc, #216]	; (801096c <HAL_DFSDM_FilterInit+0xe4>)
 8010892:	429a      	cmp	r2, r3
 8010894:	d05b      	beq.n	801094e <HAL_DFSDM_FilterInit+0xc6>
 8010896:	4604      	mov	r4, r0
  hdfsdm_filter->RegularContMode     = DFSDM_CONTINUOUS_CONV_OFF;
 8010898:	2200      	movs	r2, #0
  hdfsdm_filter->InjectedChannelsNbr = 1;
 801089a:	2301      	movs	r3, #1
  hdfsdm_filter->RegularContMode     = DFSDM_CONTINUOUS_CONV_OFF;
 801089c:	6302      	str	r2, [r0, #48]	; 0x30
  hdfsdm_filter->ErrorCode           = DFSDM_FILTER_ERROR_NONE;
 801089e:	6502      	str	r2, [r0, #80]	; 0x50
  hdfsdm_filter->InjConvRemaining    = 1;
 80108a0:	e9c0 3311 	strd	r3, r3, [r0, #68]	; 0x44
  HAL_DFSDM_FilterMspInit(hdfsdm_filter);
 80108a4:	f7ff ffee 	bl	8010884 <HAL_DFSDM_FilterMspInit>
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RSYNC);
 80108a8:	6823      	ldr	r3, [r4, #0]
  if(hdfsdm_filter->Init.RegularParam.FastMode == ENABLE)
 80108aa:	7a21      	ldrb	r1, [r4, #8]
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RSYNC);
 80108ac:	681a      	ldr	r2, [r3, #0]
 80108ae:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 80108b2:	601a      	str	r2, [r3, #0]
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_FAST;
 80108b4:	681a      	ldr	r2, [r3, #0]
  if(hdfsdm_filter->Init.RegularParam.FastMode == ENABLE)
 80108b6:	2901      	cmp	r1, #1
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_FAST;
 80108b8:	bf0c      	ite	eq
 80108ba:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_FAST);
 80108be:	f022 5200 	bicne.w	r2, r2, #536870912	; 0x20000000
 80108c2:	601a      	str	r2, [r3, #0]
  if(hdfsdm_filter->Init.RegularParam.DmaMode == ENABLE)
 80108c4:	7a62      	ldrb	r2, [r4, #9]
 80108c6:	2a01      	cmp	r2, #1
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_RDMAEN;
 80108c8:	681a      	ldr	r2, [r3, #0]
 80108ca:	bf0c      	ite	eq
 80108cc:	f442 1200 	orreq.w	r2, r2, #2097152	; 0x200000
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RDMAEN);
 80108d0:	f422 1200 	bicne.w	r2, r2, #2097152	; 0x200000
 80108d4:	601a      	str	r2, [r3, #0]
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JSYNC | DFSDM_FLTCR1_JEXTEN | DFSDM_FLTCR1_JEXTSEL);
 80108d6:	681a      	ldr	r2, [r3, #0]
  if(hdfsdm_filter->Init.InjectedParam.Trigger == DFSDM_FILTER_EXT_TRIGGER)
 80108d8:	68e0      	ldr	r0, [r4, #12]
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JSYNC | DFSDM_FLTCR1_JEXTEN | DFSDM_FLTCR1_JEXTSEL);
 80108da:	f422 42ce 	bic.w	r2, r2, #26368	; 0x6700
 80108de:	f022 0208 	bic.w	r2, r2, #8
  if(hdfsdm_filter->Init.InjectedParam.Trigger == DFSDM_FILTER_EXT_TRIGGER)
 80108e2:	2802      	cmp	r0, #2
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JSYNC | DFSDM_FLTCR1_JEXTEN | DFSDM_FLTCR1_JEXTSEL);
 80108e4:	601a      	str	r2, [r3, #0]
  if(hdfsdm_filter->Init.InjectedParam.Trigger == DFSDM_FILTER_EXT_TRIGGER)
 80108e6:	d03c      	beq.n	8010962 <HAL_DFSDM_FilterInit+0xda>
  if(hdfsdm_filter->Init.InjectedParam.ScanMode == ENABLE)
 80108e8:	7c25      	ldrb	r5, [r4, #16]
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_JSCAN;
 80108ea:	681a      	ldr	r2, [r3, #0]
  if(hdfsdm_filter->Init.InjectedParam.ScanMode == ENABLE)
 80108ec:	2d01      	cmp	r5, #1
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_JSCAN;
 80108ee:	bf0c      	ite	eq
 80108f0:	f042 0210 	orreq.w	r2, r2, #16
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JSCAN);
 80108f4:	f022 0210 	bicne.w	r2, r2, #16
 80108f8:	601a      	str	r2, [r3, #0]
  if(hdfsdm_filter->Init.InjectedParam.DmaMode == ENABLE)
 80108fa:	7c62      	ldrb	r2, [r4, #17]
 80108fc:	2a01      	cmp	r2, #1
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_JDMAEN;
 80108fe:	681a      	ldr	r2, [r3, #0]
 8010900:	bf0c      	ite	eq
 8010902:	f042 0220 	orreq.w	r2, r2, #32
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JDMAEN);
 8010906:	f022 0220 	bicne.w	r2, r2, #32
 801090a:	601a      	str	r2, [r3, #0]
  hdfsdm_filter->Instance->FLTFCR &= ~(DFSDM_FLTFCR_FORD | DFSDM_FLTFCR_FOSR | DFSDM_FLTFCR_IOSR);
 801090c:	6959      	ldr	r1, [r3, #20]
  hdfsdm_filter->Instance->FLTFCR |= (hdfsdm_filter->Init.FilterParam.SincOrder |
 801090e:	69e6      	ldr	r6, [r4, #28]
                                  (hdfsdm_filter->Init.FilterParam.IntOversampling - 1));
 8010910:	6a62      	ldr	r2, [r4, #36]	; 0x24
  hdfsdm_filter->Instance->FLTFCR &= ~(DFSDM_FLTFCR_FORD | DFSDM_FLTFCR_FOSR | DFSDM_FLTFCR_IOSR);
 8010912:	f021 4163 	bic.w	r1, r1, #3808428032	; 0xe3000000
 8010916:	f001 21ff 	and.w	r1, r1, #4278255360	; 0xff00ff00
 801091a:	6159      	str	r1, [r3, #20]
  hdfsdm_filter->Instance->FLTFCR |= (hdfsdm_filter->Init.FilterParam.SincOrder |
 801091c:	695f      	ldr	r7, [r3, #20]
                                    ((hdfsdm_filter->Init.FilterParam.Oversampling - 1) << DFSDM_FLTFCR_FOSR_Pos) |
 801091e:	6a21      	ldr	r1, [r4, #32]
                                  (hdfsdm_filter->Init.FilterParam.IntOversampling - 1));
 8010920:	3a01      	subs	r2, #1
  hdfsdm_filter->Instance->FLTFCR |= (hdfsdm_filter->Init.FilterParam.SincOrder |
 8010922:	433a      	orrs	r2, r7
 8010924:	4332      	orrs	r2, r6
                                    ((hdfsdm_filter->Init.FilterParam.Oversampling - 1) << DFSDM_FLTFCR_FOSR_Pos) |
 8010926:	3901      	subs	r1, #1
  hdfsdm_filter->Instance->FLTFCR |= (hdfsdm_filter->Init.FilterParam.SincOrder |
 8010928:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 801092c:	615a      	str	r2, [r3, #20]
  hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 801092e:	681a      	ldr	r2, [r3, #0]
  hdfsdm_filter->RegularTrigger   = hdfsdm_filter->Init.RegularParam.Trigger;
 8010930:	6866      	ldr	r6, [r4, #4]
  hdfsdm_filter->ExtTriggerEdge   = hdfsdm_filter->Init.InjectedParam.ExtTriggerEdge;
 8010932:	69a1      	ldr	r1, [r4, #24]
  hdfsdm_filter->InjectedTrigger  = hdfsdm_filter->Init.InjectedParam.Trigger;
 8010934:	63a0      	str	r0, [r4, #56]	; 0x38
  hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 8010936:	f042 0201 	orr.w	r2, r2, #1
  hdfsdm_filter->State = HAL_DFSDM_FILTER_STATE_READY;
 801093a:	2701      	movs	r7, #1
  hdfsdm_filter->InjectedScanMode = hdfsdm_filter->Init.InjectedParam.ScanMode;
 801093c:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
  hdfsdm_filter->RegularTrigger   = hdfsdm_filter->Init.RegularParam.Trigger;
 8010940:	6366      	str	r6, [r4, #52]	; 0x34
  hdfsdm_filter->ExtTriggerEdge   = hdfsdm_filter->Init.InjectedParam.ExtTriggerEdge;
 8010942:	63e1      	str	r1, [r4, #60]	; 0x3c
  return HAL_OK;
 8010944:	2000      	movs	r0, #0
  hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 8010946:	601a      	str	r2, [r3, #0]
  hdfsdm_filter->State = HAL_DFSDM_FILTER_STATE_READY;
 8010948:	f884 704c 	strb.w	r7, [r4, #76]	; 0x4c
}
 801094c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if((hdfsdm_filter->Instance == DFSDM1_Filter0) && 
 801094e:	6843      	ldr	r3, [r0, #4]
 8010950:	2b01      	cmp	r3, #1
 8010952:	d002      	beq.n	801095a <HAL_DFSDM_FilterInit+0xd2>
    ((hdfsdm_filter->Init.RegularParam.Trigger  == DFSDM_FILTER_SYNC_TRIGGER) || 
 8010954:	68c3      	ldr	r3, [r0, #12]
 8010956:	2b01      	cmp	r3, #1
 8010958:	d19d      	bne.n	8010896 <HAL_DFSDM_FilterInit+0xe>
    return HAL_ERROR;
 801095a:	4618      	mov	r0, r3
}
 801095c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 801095e:	2001      	movs	r0, #1
}
 8010960:	4770      	bx	lr
    hdfsdm_filter->Instance->FLTCR1 |= (hdfsdm_filter->Init.InjectedParam.ExtTrigger);
 8010962:	681a      	ldr	r2, [r3, #0]
 8010964:	6961      	ldr	r1, [r4, #20]
 8010966:	430a      	orrs	r2, r1
 8010968:	601a      	str	r2, [r3, #0]
 801096a:	e7bd      	b.n	80108e8 <HAL_DFSDM_FilterInit+0x60>
 801096c:	40016100 	.word	0x40016100

08010970 <HAL_DFSDM_FilterMspDeInit>:
 8010970:	4770      	bx	lr
 8010972:	bf00      	nop

08010974 <HAL_DFSDM_FilterDeInit>:
  if(hdfsdm_filter == NULL)
 8010974:	b160      	cbz	r0, 8010990 <HAL_DFSDM_FilterDeInit+0x1c>
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_DFEN);
 8010976:	6802      	ldr	r2, [r0, #0]
{
 8010978:	b510      	push	{r4, lr}
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_DFEN);
 801097a:	6813      	ldr	r3, [r2, #0]
 801097c:	f023 0301 	bic.w	r3, r3, #1
 8010980:	4604      	mov	r4, r0
 8010982:	6013      	str	r3, [r2, #0]
  HAL_DFSDM_FilterMspDeInit(hdfsdm_filter);
 8010984:	f7ff fff4 	bl	8010970 <HAL_DFSDM_FilterMspDeInit>
  hdfsdm_filter->State = HAL_DFSDM_FILTER_STATE_RESET;
 8010988:	2000      	movs	r0, #0
 801098a:	f884 004c 	strb.w	r0, [r4, #76]	; 0x4c
}
 801098e:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8010990:	2001      	movs	r0, #1
}
 8010992:	4770      	bx	lr

08010994 <HAL_DFSDM_FilterConfigRegChannel>:
  if((hdfsdm_filter->State != HAL_DFSDM_FILTER_STATE_RESET) && 
 8010994:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
 8010998:	3b01      	subs	r3, #1
 801099a:	b2db      	uxtb	r3, r3
 801099c:	2bfd      	cmp	r3, #253	; 0xfd
 801099e:	d816      	bhi.n	80109ce <HAL_DFSDM_FilterConfigRegChannel+0x3a>
{
 80109a0:	b410      	push	{r4}
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RCH | DFSDM_FLTCR1_RCONT);
 80109a2:	6804      	ldr	r4, [r0, #0]
 80109a4:	6823      	ldr	r3, [r4, #0]
 80109a6:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 80109aa:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80109ae:	6023      	str	r3, [r4, #0]
 80109b0:	0209      	lsls	r1, r1, #8
      hdfsdm_filter->Instance->FLTCR1 |= (uint32_t) (((Channel & DFSDM_MSB_MASK) << DFSDM_FLTCR1_MSB_RCH_OFFSET) |
 80109b2:	6823      	ldr	r3, [r4, #0]
 80109b4:	f001 417f 	and.w	r1, r1, #4278190080	; 0xff000000
    if(ContinuousMode == DFSDM_CONTINUOUS_CONV_ON)
 80109b8:	2a01      	cmp	r2, #1
      hdfsdm_filter->Instance->FLTCR1 |= (uint32_t) (((Channel & DFSDM_MSB_MASK) << DFSDM_FLTCR1_MSB_RCH_OFFSET) |
 80109ba:	bf08      	it	eq
 80109bc:	f441 2180 	orreq.w	r1, r1, #262144	; 0x40000
      hdfsdm_filter->Instance->FLTCR1 |= (uint32_t) ((Channel & DFSDM_MSB_MASK) << DFSDM_FLTCR1_MSB_RCH_OFFSET);
 80109c0:	4319      	orrs	r1, r3
 80109c2:	6021      	str	r1, [r4, #0]
    hdfsdm_filter->RegularContMode = ContinuousMode;
 80109c4:	6302      	str	r2, [r0, #48]	; 0x30
}
 80109c6:	f85d 4b04 	ldr.w	r4, [sp], #4
  HAL_StatusTypeDef status = HAL_OK;
 80109ca:	2000      	movs	r0, #0
}
 80109cc:	4770      	bx	lr
    status = HAL_ERROR;
 80109ce:	2001      	movs	r0, #1
}
 80109d0:	4770      	bx	lr
 80109d2:	bf00      	nop

080109d4 <HAL_DFSDM_FilterRegularStart_DMA>:
{
 80109d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if((pData == NULL) || (Length == 0))
 80109d6:	b309      	cbz	r1, 8010a1c <HAL_DFSDM_FilterRegularStart_DMA+0x48>
 80109d8:	b302      	cbz	r2, 8010a1c <HAL_DFSDM_FilterRegularStart_DMA+0x48>
  else if((hdfsdm_filter->Instance->FLTCR1 & DFSDM_FLTCR1_RDMAEN) != DFSDM_FLTCR1_RDMAEN)
 80109da:	6806      	ldr	r6, [r0, #0]
 80109dc:	6834      	ldr	r4, [r6, #0]
 80109de:	02a3      	lsls	r3, r4, #10
 80109e0:	d51c      	bpl.n	8010a1c <HAL_DFSDM_FilterRegularStart_DMA+0x48>
  else if((hdfsdm_filter->RegularTrigger == DFSDM_FILTER_SW_TRIGGER) && \
 80109e2:	6b44      	ldr	r4, [r0, #52]	; 0x34
 80109e4:	b9a4      	cbnz	r4, 8010a10 <HAL_DFSDM_FilterRegularStart_DMA+0x3c>
 80109e6:	6b03      	ldr	r3, [r0, #48]	; 0x30
 80109e8:	b993      	cbnz	r3, 8010a10 <HAL_DFSDM_FilterRegularStart_DMA+0x3c>
          (hdfsdm_filter->hdmaReg->Init.Mode == DMA_NORMAL) && \
 80109ea:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80109ec:	69dc      	ldr	r4, [r3, #28]
 80109ee:	461d      	mov	r5, r3
          (hdfsdm_filter->RegularContMode == DFSDM_CONTINUOUS_CONV_OFF) && \
 80109f0:	b38c      	cbz	r4, 8010a56 <HAL_DFSDM_FilterRegularStart_DMA+0x82>
          (hdfsdm_filter->RegularContMode == DFSDM_CONTINUOUS_CONV_OFF) && \
 80109f2:	2c20      	cmp	r4, #32
 80109f4:	d012      	beq.n	8010a1c <HAL_DFSDM_FilterRegularStart_DMA+0x48>
  else if((hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_READY) || \
 80109f6:	f890 404c 	ldrb.w	r4, [r0, #76]	; 0x4c
 80109fa:	2c01      	cmp	r4, #1
 80109fc:	d032      	beq.n	8010a64 <HAL_DFSDM_FilterRegularStart_DMA+0x90>
 80109fe:	2c03      	cmp	r4, #3
 8010a00:	d10c      	bne.n	8010a1c <HAL_DFSDM_FilterRegularStart_DMA+0x48>
    hdfsdm_filter->hdmaReg->XferCpltCallback = DFSDM_DMARegularConvCplt;
 8010a02:	461d      	mov	r5, r3
 8010a04:	4c1a      	ldr	r4, [pc, #104]	; (8010a70 <HAL_DFSDM_FilterRegularStart_DMA+0x9c>)
    hdfsdm_filter->hdmaReg->XferErrorCallback = DFSDM_DMAError;
 8010a06:	4b1b      	ldr	r3, [pc, #108]	; (8010a74 <HAL_DFSDM_FilterRegularStart_DMA+0xa0>)
    hdfsdm_filter->hdmaReg->XferCpltCallback = DFSDM_DMARegularConvCplt;
 8010a08:	62ec      	str	r4, [r5, #44]	; 0x2c
    hdfsdm_filter->hdmaReg->XferErrorCallback = DFSDM_DMAError;
 8010a0a:	636b      	str	r3, [r5, #52]	; 0x34
                                                   DFSDM_DMARegularHalfConvCplt : NULL;
 8010a0c:	2400      	movs	r4, #0
 8010a0e:	e012      	b.n	8010a36 <HAL_DFSDM_FilterRegularStart_DMA+0x62>
  else if((hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_READY) || \
 8010a10:	f890 404c 	ldrb.w	r4, [r0, #76]	; 0x4c
 8010a14:	2c01      	cmp	r4, #1
 8010a16:	d004      	beq.n	8010a22 <HAL_DFSDM_FilterRegularStart_DMA+0x4e>
 8010a18:	2c03      	cmp	r4, #3
 8010a1a:	d002      	beq.n	8010a22 <HAL_DFSDM_FilterRegularStart_DMA+0x4e>
    status = HAL_ERROR;
 8010a1c:	2401      	movs	r4, #1
}
 8010a1e:	4620      	mov	r0, r4
 8010a20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hdfsdm_filter->hdmaReg->XferCpltCallback = DFSDM_DMARegularConvCplt;
 8010a22:	6a85      	ldr	r5, [r0, #40]	; 0x28
 8010a24:	4f12      	ldr	r7, [pc, #72]	; (8010a70 <HAL_DFSDM_FilterRegularStart_DMA+0x9c>)
                                                   DFSDM_DMARegularHalfConvCplt : NULL;
 8010a26:	69eb      	ldr	r3, [r5, #28]
    hdfsdm_filter->hdmaReg->XferCpltCallback = DFSDM_DMARegularConvCplt;
 8010a28:	62ef      	str	r7, [r5, #44]	; 0x2c
                                                   DFSDM_DMARegularHalfConvCplt : NULL;
 8010a2a:	2b20      	cmp	r3, #32
    hdfsdm_filter->hdmaReg->XferErrorCallback = DFSDM_DMAError;
 8010a2c:	4f11      	ldr	r7, [pc, #68]	; (8010a74 <HAL_DFSDM_FilterRegularStart_DMA+0xa0>)
                                                   DFSDM_DMARegularHalfConvCplt : NULL;
 8010a2e:	4c12      	ldr	r4, [pc, #72]	; (8010a78 <HAL_DFSDM_FilterRegularStart_DMA+0xa4>)
    hdfsdm_filter->hdmaReg->XferErrorCallback = DFSDM_DMAError;
 8010a30:	636f      	str	r7, [r5, #52]	; 0x34
                                                   DFSDM_DMARegularHalfConvCplt : NULL;
 8010a32:	bf18      	it	ne
 8010a34:	2400      	movne	r4, #0
 8010a36:	4613      	mov	r3, r2
    hdfsdm_filter->hdmaReg->XferHalfCpltCallback = (hdfsdm_filter->hdmaReg->Init.Mode == DMA_CIRCULAR) ?\
 8010a38:	632c      	str	r4, [r5, #48]	; 0x30
    if(HAL_DMA_Start_IT(hdfsdm_filter->hdmaReg, (uint32_t)&hdfsdm_filter->Instance->FLTRDATAR, \
 8010a3a:	460a      	mov	r2, r1
 8010a3c:	4607      	mov	r7, r0
 8010a3e:	f106 011c 	add.w	r1, r6, #28
 8010a42:	4628      	mov	r0, r5
 8010a44:	f000 f900 	bl	8010c48 <HAL_DMA_Start_IT>
 8010a48:	4604      	mov	r4, r0
 8010a4a:	b138      	cbz	r0, 8010a5c <HAL_DFSDM_FilterRegularStart_DMA+0x88>
      hdfsdm_filter->State = HAL_DFSDM_FILTER_STATE_ERROR;
 8010a4c:	23ff      	movs	r3, #255	; 0xff
 8010a4e:	f887 304c 	strb.w	r3, [r7, #76]	; 0x4c
      status = HAL_ERROR;
 8010a52:	2401      	movs	r4, #1
 8010a54:	e7e3      	b.n	8010a1e <HAL_DFSDM_FilterRegularStart_DMA+0x4a>
          (hdfsdm_filter->hdmaReg->Init.Mode == DMA_NORMAL) && \
 8010a56:	2a01      	cmp	r2, #1
 8010a58:	d1e0      	bne.n	8010a1c <HAL_DFSDM_FilterRegularStart_DMA+0x48>
 8010a5a:	e7cc      	b.n	80109f6 <HAL_DFSDM_FilterRegularStart_DMA+0x22>
      DFSDM_RegConvStart(hdfsdm_filter);
 8010a5c:	4638      	mov	r0, r7
 8010a5e:	f7ff fddb 	bl	8010618 <DFSDM_RegConvStart>
 8010a62:	e7dc      	b.n	8010a1e <HAL_DFSDM_FilterRegularStart_DMA+0x4a>
    hdfsdm_filter->hdmaReg->XferErrorCallback = DFSDM_DMAError;
 8010a64:	4c03      	ldr	r4, [pc, #12]	; (8010a74 <HAL_DFSDM_FilterRegularStart_DMA+0xa0>)
    hdfsdm_filter->hdmaReg->XferCpltCallback = DFSDM_DMARegularConvCplt;
 8010a66:	4f02      	ldr	r7, [pc, #8]	; (8010a70 <HAL_DFSDM_FilterRegularStart_DMA+0x9c>)
    hdfsdm_filter->hdmaReg->XferErrorCallback = DFSDM_DMAError;
 8010a68:	635c      	str	r4, [r3, #52]	; 0x34
    hdfsdm_filter->hdmaReg->XferCpltCallback = DFSDM_DMARegularConvCplt;
 8010a6a:	62df      	str	r7, [r3, #44]	; 0x2c
                                                   DFSDM_DMARegularHalfConvCplt : NULL;
 8010a6c:	2400      	movs	r4, #0
 8010a6e:	e7e2      	b.n	8010a36 <HAL_DFSDM_FilterRegularStart_DMA+0x62>
 8010a70:	08010ab5 	.word	0x08010ab5
 8010a74:	08010ad1 	.word	0x08010ad1
 8010a78:	08010ac1 	.word	0x08010ac1

08010a7c <HAL_DFSDM_FilterRegularStop_DMA>:
{
 8010a7c:	b538      	push	{r3, r4, r5, lr}
  if((hdfsdm_filter->State != HAL_DFSDM_FILTER_STATE_REG) && \
 8010a7e:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
 8010a82:	2b02      	cmp	r3, #2
 8010a84:	d004      	beq.n	8010a90 <HAL_DFSDM_FilterRegularStop_DMA+0x14>
 8010a86:	2b04      	cmp	r3, #4
 8010a88:	d002      	beq.n	8010a90 <HAL_DFSDM_FilterRegularStop_DMA+0x14>
    status = HAL_ERROR;
 8010a8a:	2501      	movs	r5, #1
}
 8010a8c:	4628      	mov	r0, r5
 8010a8e:	bd38      	pop	{r3, r4, r5, pc}
 8010a90:	4604      	mov	r4, r0
    if(HAL_DMA_Abort(hdfsdm_filter->hdmaReg) != HAL_OK)
 8010a92:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8010a94:	f000 f91c 	bl	8010cd0 <HAL_DMA_Abort>
 8010a98:	4605      	mov	r5, r0
 8010a9a:	b128      	cbz	r0, 8010aa8 <HAL_DFSDM_FilterRegularStop_DMA+0x2c>
      hdfsdm_filter->State = HAL_DFSDM_FILTER_STATE_ERROR;
 8010a9c:	23ff      	movs	r3, #255	; 0xff
      status = HAL_ERROR;
 8010a9e:	2501      	movs	r5, #1
      hdfsdm_filter->State = HAL_DFSDM_FILTER_STATE_ERROR;
 8010aa0:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
}
 8010aa4:	4628      	mov	r0, r5
 8010aa6:	bd38      	pop	{r3, r4, r5, pc}
      DFSDM_RegConvStop(hdfsdm_filter);
 8010aa8:	4620      	mov	r0, r4
 8010aaa:	f7ff fde5 	bl	8010678 <DFSDM_RegConvStop>
}
 8010aae:	4628      	mov	r0, r5
 8010ab0:	bd38      	pop	{r3, r4, r5, pc}
 8010ab2:	bf00      	nop

08010ab4 <DFSDM_DMARegularConvCplt>:
{
 8010ab4:	b508      	push	{r3, lr}
  HAL_DFSDM_FilterRegConvCpltCallback(hdfsdm_filter);
 8010ab6:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8010ab8:	f7fe ff80 	bl	800f9bc <HAL_DFSDM_FilterRegConvCpltCallback>
}
 8010abc:	bd08      	pop	{r3, pc}
 8010abe:	bf00      	nop

08010ac0 <DFSDM_DMARegularHalfConvCplt>:
{
 8010ac0:	b508      	push	{r3, lr}
  HAL_DFSDM_FilterRegConvHalfCpltCallback(hdfsdm_filter);
 8010ac2:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8010ac4:	f7fe ffe8 	bl	800fa98 <HAL_DFSDM_FilterRegConvHalfCpltCallback>
}
 8010ac8:	bd08      	pop	{r3, pc}
 8010aca:	bf00      	nop

08010acc <HAL_DFSDM_FilterErrorCallback>:
 8010acc:	4770      	bx	lr
 8010ace:	bf00      	nop

08010ad0 <DFSDM_DMAError>:
{
 8010ad0:	b508      	push	{r3, lr}
  DFSDM_Filter_HandleTypeDef* hdfsdm_filter = (DFSDM_Filter_HandleTypeDef*) ((DMA_HandleTypeDef*)hdma)->Parent;
 8010ad2:	6a80      	ldr	r0, [r0, #40]	; 0x28
  hdfsdm_filter->ErrorCode = DFSDM_FILTER_ERROR_DMA;
 8010ad4:	2303      	movs	r3, #3
 8010ad6:	6503      	str	r3, [r0, #80]	; 0x50
  HAL_DFSDM_FilterErrorCallback(hdfsdm_filter);
 8010ad8:	f7ff fff8 	bl	8010acc <HAL_DFSDM_FilterErrorCallback>
}
 8010adc:	bd08      	pop	{r3, pc}
 8010ade:	bf00      	nop

08010ae0 <HAL_DFSDM_FilterGetState>:
}
 8010ae0:	f890 004c 	ldrb.w	r0, [r0, #76]	; 0x4c
 8010ae4:	4770      	bx	lr
 8010ae6:	bf00      	nop

08010ae8 <HAL_DMA_Init>:
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
  uint32_t tmp = 0;

  /* Check the DMA handle allocation */
  if(hdma == NULL)
 8010ae8:	2800      	cmp	r0, #0
 8010aea:	d04f      	beq.n	8010b8c <HAL_DMA_Init+0xa4>
 8010aec:	4603      	mov	r3, r0
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));

  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8010aee:	4a28      	ldr	r2, [pc, #160]	; (8010b90 <HAL_DMA_Init+0xa8>)
 8010af0:	6800      	ldr	r0, [r0, #0]
 8010af2:	4290      	cmp	r0, r2
{
 8010af4:	b470      	push	{r4, r5, r6}
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8010af6:	d945      	bls.n	8010b84 <HAL_DMA_Init+0x9c>
    hdma->DmaBaseAddress = DMA1;
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 8010af8:	4a26      	ldr	r2, [pc, #152]	; (8010b94 <HAL_DMA_Init+0xac>)
 8010afa:	4927      	ldr	r1, [pc, #156]	; (8010b98 <HAL_DMA_Init+0xb0>)
    hdma->DmaBaseAddress = DMA2;
 8010afc:	4c27      	ldr	r4, [pc, #156]	; (8010b9c <HAL_DMA_Init+0xb4>)
 8010afe:	641c      	str	r4, [r3, #64]	; 0x40
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 8010b00:	4402      	add	r2, r0
 8010b02:	fba1 1202 	umull	r1, r2, r1, r2
 8010b06:	0912      	lsrs	r2, r2, #4
 8010b08:	0092      	lsls	r2, r2, #2
 8010b0a:	645a      	str	r2, [r3, #68]	; 0x44
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
                      DMA_CCR_DIR   | DMA_CCR_MEM2MEM));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8010b0c:	e9d3 4202 	ldrd	r4, r2, [r3, #8]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8010b10:	e9d3 5104 	ldrd	r5, r1, [r3, #16]
  tmp |=  hdma->Init.Direction        |
 8010b14:	4322      	orrs	r2, r4
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8010b16:	432a      	orrs	r2, r5
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8010b18:	699e      	ldr	r6, [r3, #24]
  hdma->State = HAL_DMA_STATE_BUSY;
 8010b1a:	2502      	movs	r5, #2
 8010b1c:	f883 5025 	strb.w	r5, [r3, #37]	; 0x25
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8010b20:	430a      	orrs	r2, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8010b22:	69dd      	ldr	r5, [r3, #28]
  tmp = hdma->Instance->CCR;
 8010b24:	6801      	ldr	r1, [r0, #0]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8010b26:	4332      	orrs	r2, r6
 8010b28:	432a      	orrs	r2, r5
          hdma->Init.Mode                | hdma->Init.Priority;
 8010b2a:	6a1d      	ldr	r5, [r3, #32]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 8010b2c:	f421 41ff 	bic.w	r1, r1, #32640	; 0x7f80
          hdma->Init.Mode                | hdma->Init.Priority;
 8010b30:	432a      	orrs	r2, r5
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 8010b32:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmp |=  hdma->Init.Direction        |
 8010b36:	430a      	orrs	r2, r1
#endif /* DMAMUX1 */

#if !defined (DMAMUX1)

  /* Set request selection */
  if(hdma->Init.Direction != DMA_MEMORY_TO_MEMORY)
 8010b38:	f5b4 4f80 	cmp.w	r4, #16384	; 0x4000
  hdma->Instance->CCR = tmp;
 8010b3c:	6002      	str	r2, [r0, #0]
  if(hdma->Init.Direction != DMA_MEMORY_TO_MEMORY)
 8010b3e:	d014      	beq.n	8010b6a <HAL_DMA_Init+0x82>
  {
    /* Write to DMA channel selection register */
    if (DMA1 == hdma->DmaBaseAddress)
 8010b40:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 8010b42:	4d17      	ldr	r5, [pc, #92]	; (8010ba0 <HAL_DMA_Init+0xb8>)
 8010b44:	6c58      	ldr	r0, [r3, #68]	; 0x44
 8010b46:	6859      	ldr	r1, [r3, #4]
 8010b48:	42ac      	cmp	r4, r5
 8010b4a:	f04f 020f 	mov.w	r2, #15
 8010b4e:	fa02 f200 	lsl.w	r2, r2, r0
 8010b52:	fa01 f100 	lsl.w	r1, r1, r0
    {
      /* Reset request selection for DMA1 Channelx */
      DMA1_CSELR->CSELR &= ~(DMA_CSELR_C1S << hdma->ChannelIndex);
 8010b56:	bf0c      	ite	eq
 8010b58:	4812      	ldreq	r0, [pc, #72]	; (8010ba4 <HAL_DMA_Init+0xbc>)
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << (hdma->ChannelIndex));
    }
    else /* DMA2 */
    {
      /* Reset request selection for DMA2 Channelx */
      DMA2_CSELR->CSELR &= ~(DMA_CSELR_C1S << hdma->ChannelIndex);
 8010b5a:	4813      	ldrne	r0, [pc, #76]	; (8010ba8 <HAL_DMA_Init+0xc0>)
 8010b5c:	6804      	ldr	r4, [r0, #0]
 8010b5e:	43d2      	mvns	r2, r2
 8010b60:	4022      	ands	r2, r4
 8010b62:	6002      	str	r2, [r0, #0]

      /* Configure request selection for DMA2 Channelx */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << (hdma->ChannelIndex));
 8010b64:	6802      	ldr	r2, [r0, #0]
 8010b66:	4311      	orrs	r1, r2
 8010b68:	6001      	str	r1, [r0, #0]
#endif /* STM32L431xx || STM32L432xx || STM32L433xx || STM32L442xx || STM32L443xx */
       /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L442xx || STM32L486xx */
       /* STM32L496xx || STM32L4A6xx                                              */

  /* Clean callbacks */
  hdma->XferCpltCallback = NULL;
 8010b6a:	2000      	movs	r0, #0

  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;

  /* Initialize the DMA state*/
  hdma->State  = HAL_DMA_STATE_READY;
 8010b6c:	2201      	movs	r2, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8010b6e:	63d8      	str	r0, [r3, #60]	; 0x3c
  hdma->XferHalfCpltCallback = NULL;
 8010b70:	e9c3 000b 	strd	r0, r0, [r3, #44]	; 0x2c
  hdma->XferAbortCallback = NULL;
 8010b74:	e9c3 000d 	strd	r0, r0, [r3, #52]	; 0x34

  /* Allocate lock resource and initialize it */
  hdma->Lock = HAL_UNLOCKED;
 8010b78:	f883 0024 	strb.w	r0, [r3, #36]	; 0x24
  hdma->State  = HAL_DMA_STATE_READY;
 8010b7c:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  return HAL_OK;
}
 8010b80:	bc70      	pop	{r4, r5, r6}
 8010b82:	4770      	bx	lr
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8010b84:	4a09      	ldr	r2, [pc, #36]	; (8010bac <HAL_DMA_Init+0xc4>)
 8010b86:	4904      	ldr	r1, [pc, #16]	; (8010b98 <HAL_DMA_Init+0xb0>)
    hdma->DmaBaseAddress = DMA1;
 8010b88:	4c05      	ldr	r4, [pc, #20]	; (8010ba0 <HAL_DMA_Init+0xb8>)
 8010b8a:	e7b8      	b.n	8010afe <HAL_DMA_Init+0x16>
    return HAL_ERROR;
 8010b8c:	2001      	movs	r0, #1
}
 8010b8e:	4770      	bx	lr
 8010b90:	40020407 	.word	0x40020407
 8010b94:	bffdfbf8 	.word	0xbffdfbf8
 8010b98:	cccccccd 	.word	0xcccccccd
 8010b9c:	40020400 	.word	0x40020400
 8010ba0:	40020000 	.word	0x40020000
 8010ba4:	400200a8 	.word	0x400200a8
 8010ba8:	400204a8 	.word	0x400204a8
 8010bac:	bffdfff8 	.word	0xbffdfff8

08010bb0 <HAL_DMA_DeInit>:
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{

  /* Check the DMA handle allocation */
  if (NULL == hdma )
 8010bb0:	2800      	cmp	r0, #0
 8010bb2:	d036      	beq.n	8010c22 <HAL_DMA_DeInit+0x72>

  /* Check the parameters */
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Disable the selected DMA Channelx */
  __HAL_DMA_DISABLE(hdma);
 8010bb4:	6802      	ldr	r2, [r0, #0]

  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8010bb6:	491c      	ldr	r1, [pc, #112]	; (8010c28 <HAL_DMA_DeInit+0x78>)
  __HAL_DMA_DISABLE(hdma);
 8010bb8:	6813      	ldr	r3, [r2, #0]
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8010bba:	428a      	cmp	r2, r1
  __HAL_DMA_DISABLE(hdma);
 8010bbc:	f023 0301 	bic.w	r3, r3, #1
{
 8010bc0:	b470      	push	{r4, r5, r6}
  __HAL_DMA_DISABLE(hdma);
 8010bc2:	6013      	str	r3, [r2, #0]
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8010bc4:	d91f      	bls.n	8010c06 <HAL_DMA_DeInit+0x56>
    hdma->DmaBaseAddress = DMA1;
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 8010bc6:	4b19      	ldr	r3, [pc, #100]	; (8010c2c <HAL_DMA_DeInit+0x7c>)
 8010bc8:	4919      	ldr	r1, [pc, #100]	; (8010c30 <HAL_DMA_DeInit+0x80>)
    hdma->DmaBaseAddress = DMA2;
 8010bca:	4d1a      	ldr	r5, [pc, #104]	; (8010c34 <HAL_DMA_DeInit+0x84>)
    DMA1_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex));
  }
  else
  {
    /* DMA2 */
    DMA2_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex));
 8010bcc:	4c1a      	ldr	r4, [pc, #104]	; (8010c38 <HAL_DMA_DeInit+0x88>)
    hdma->DmaBaseAddress = DMA2;
 8010bce:	6405      	str	r5, [r0, #64]	; 0x40
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 8010bd0:	4413      	add	r3, r2
 8010bd2:	fba1 1303 	umull	r1, r3, r1, r3
 8010bd6:	091b      	lsrs	r3, r3, #4
 8010bd8:	009b      	lsls	r3, r3, #2
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex));
 8010bda:	2101      	movs	r1, #1
 8010bdc:	4099      	lsls	r1, r3
  hdma->Instance->CCR  = 0;
 8010bde:	2600      	movs	r6, #0
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 8010be0:	6443      	str	r3, [r0, #68]	; 0x44
  hdma->Instance->CCR  = 0;
 8010be2:	6016      	str	r6, [r2, #0]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex));
 8010be4:	6069      	str	r1, [r5, #4]
    DMA2_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex));
 8010be6:	6822      	ldr	r2, [r4, #0]
 8010be8:	210f      	movs	r1, #15
 8010bea:	fa01 f303 	lsl.w	r3, r1, r3
 8010bee:	ea22 0303 	bic.w	r3, r2, r3
 8010bf2:	6023      	str	r3, [r4, #0]
  hdma->DMAmuxRequestGenStatusMask = 0U;

#endif /* DMAMUX1 */

  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8010bf4:	2300      	movs	r3, #0
 8010bf6:	63c3      	str	r3, [r0, #60]	; 0x3c

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hdma);
 8010bf8:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  hdma->State = HAL_DMA_STATE_RESET;
 8010bfc:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25

  return HAL_OK;
}
 8010c00:	bc70      	pop	{r4, r5, r6}
  return HAL_OK;
 8010c02:	4618      	mov	r0, r3
}
 8010c04:	4770      	bx	lr
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8010c06:	4b0d      	ldr	r3, [pc, #52]	; (8010c3c <HAL_DMA_DeInit+0x8c>)
 8010c08:	4909      	ldr	r1, [pc, #36]	; (8010c30 <HAL_DMA_DeInit+0x80>)
    hdma->DmaBaseAddress = DMA1;
 8010c0a:	4d0d      	ldr	r5, [pc, #52]	; (8010c40 <HAL_DMA_DeInit+0x90>)
 8010c0c:	6405      	str	r5, [r0, #64]	; 0x40
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8010c0e:	4413      	add	r3, r2
 8010c10:	fba1 1303 	umull	r1, r3, r1, r3
 8010c14:	091b      	lsrs	r3, r3, #4
 8010c16:	009b      	lsls	r3, r3, #2
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex));
 8010c18:	2101      	movs	r1, #1
 8010c1a:	4099      	lsls	r1, r3
  hdma->Instance->CCR  = 0;
 8010c1c:	2600      	movs	r6, #0
    DMA1_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex));
 8010c1e:	4c09      	ldr	r4, [pc, #36]	; (8010c44 <HAL_DMA_DeInit+0x94>)
 8010c20:	e7de      	b.n	8010be0 <HAL_DMA_DeInit+0x30>
    return HAL_ERROR;
 8010c22:	2001      	movs	r0, #1
}
 8010c24:	4770      	bx	lr
 8010c26:	bf00      	nop
 8010c28:	40020407 	.word	0x40020407
 8010c2c:	bffdfbf8 	.word	0xbffdfbf8
 8010c30:	cccccccd 	.word	0xcccccccd
 8010c34:	40020400 	.word	0x40020400
 8010c38:	400204a8 	.word	0x400204a8
 8010c3c:	bffdfff8 	.word	0xbffdfff8
 8010c40:	40020000 	.word	0x40020000
 8010c44:	400200a8 	.word	0x400200a8

08010c48 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8010c48:	b4f0      	push	{r4, r5, r6, r7}

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Process locked */
  __HAL_LOCK(hdma);
 8010c4a:	f890 4024 	ldrb.w	r4, [r0, #36]	; 0x24
 8010c4e:	2c01      	cmp	r4, #1
 8010c50:	d031      	beq.n	8010cb6 <HAL_DMA_Start_IT+0x6e>

  if(HAL_DMA_STATE_READY == hdma->State)
 8010c52:	f890 5025 	ldrb.w	r5, [r0, #37]	; 0x25
  __HAL_LOCK(hdma);
 8010c56:	2401      	movs	r4, #1
  if(HAL_DMA_STATE_READY == hdma->State)
 8010c58:	b2ed      	uxtb	r5, r5
 8010c5a:	42a5      	cmp	r5, r4
  __HAL_LOCK(hdma);
 8010c5c:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
  if(HAL_DMA_STATE_READY == hdma->State)
 8010c60:	d123      	bne.n	8010caa <HAL_DMA_Start_IT+0x62>
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
 8010c62:	6804      	ldr	r4, [r0, #0]
    hdma->State = HAL_DMA_STATE_BUSY;
 8010c64:	2702      	movs	r7, #2
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8010c66:	2600      	movs	r6, #0
    hdma->State = HAL_DMA_STATE_BUSY;
 8010c68:	f880 7025 	strb.w	r7, [r0, #37]	; 0x25
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8010c6c:	63c6      	str	r6, [r0, #60]	; 0x3c
    __HAL_DMA_DISABLE(hdma);
 8010c6e:	6826      	ldr	r6, [r4, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
  }
#endif

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8010c70:	6c07      	ldr	r7, [r0, #64]	; 0x40
    __HAL_DMA_DISABLE(hdma);
 8010c72:	f026 0c01 	bic.w	ip, r6, #1
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8010c76:	6c46      	ldr	r6, [r0, #68]	; 0x44
    __HAL_DMA_DISABLE(hdma);
 8010c78:	f8c4 c000 	str.w	ip, [r4]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8010c7c:	40b5      	lsls	r5, r6

  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;

  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8010c7e:	6886      	ldr	r6, [r0, #8]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8010c80:	607d      	str	r5, [r7, #4]
  hdma->Instance->CNDTR = DataLength;
 8010c82:	6063      	str	r3, [r4, #4]
    if(NULL != hdma->XferHalfCpltCallback )
 8010c84:	6b03      	ldr	r3, [r0, #48]	; 0x30
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8010c86:	2e10      	cmp	r6, #16
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 8010c88:	bf0b      	itete	eq
 8010c8a:	60a2      	streq	r2, [r4, #8]
  }
  /* Memory to Peripheral */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
 8010c8c:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 8010c8e:	60e1      	streq	r1, [r4, #12]

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
 8010c90:	60e2      	strne	r2, [r4, #12]
    if(NULL != hdma->XferHalfCpltCallback )
 8010c92:	b19b      	cbz	r3, 8010cbc <HAL_DMA_Start_IT+0x74>
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8010c94:	6823      	ldr	r3, [r4, #0]
 8010c96:	f043 030e 	orr.w	r3, r3, #14
 8010c9a:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 8010c9c:	6823      	ldr	r3, [r4, #0]
 8010c9e:	f043 0301 	orr.w	r3, r3, #1
 8010ca2:	6023      	str	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8010ca4:	2000      	movs	r0, #0
}
 8010ca6:	bcf0      	pop	{r4, r5, r6, r7}
 8010ca8:	4770      	bx	lr
    __HAL_UNLOCK(hdma);
 8010caa:	2300      	movs	r3, #0
 8010cac:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
}
 8010cb0:	bcf0      	pop	{r4, r5, r6, r7}
    status = HAL_BUSY;
 8010cb2:	2002      	movs	r0, #2
}
 8010cb4:	4770      	bx	lr
  __HAL_LOCK(hdma);
 8010cb6:	2002      	movs	r0, #2
}
 8010cb8:	bcf0      	pop	{r4, r5, r6, r7}
 8010cba:	4770      	bx	lr
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8010cbc:	6823      	ldr	r3, [r4, #0]
 8010cbe:	f023 0304 	bic.w	r3, r3, #4
 8010cc2:	6023      	str	r3, [r4, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 8010cc4:	6823      	ldr	r3, [r4, #0]
 8010cc6:	f043 030a 	orr.w	r3, r3, #10
 8010cca:	6023      	str	r3, [r4, #0]
 8010ccc:	e7e6      	b.n	8010c9c <HAL_DMA_Start_IT+0x54>
 8010cce:	bf00      	nop

08010cd0 <HAL_DMA_Abort>:
  if(NULL == hdma)
 8010cd0:	b1c0      	cbz	r0, 8010d04 <HAL_DMA_Abort+0x34>
  __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8010cd2:	6802      	ldr	r2, [r0, #0]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8010cd4:	6c41      	ldr	r1, [r0, #68]	; 0x44
 8010cd6:	4603      	mov	r3, r0
  __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8010cd8:	6810      	ldr	r0, [r2, #0]
 8010cda:	f020 000e 	bic.w	r0, r0, #14
{
 8010cde:	b430      	push	{r4, r5}
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8010ce0:	6c1d      	ldr	r5, [r3, #64]	; 0x40
  __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8010ce2:	6010      	str	r0, [r2, #0]
  __HAL_DMA_DISABLE(hdma);
 8010ce4:	6810      	ldr	r0, [r2, #0]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8010ce6:	2401      	movs	r4, #1
  __HAL_DMA_DISABLE(hdma);
 8010ce8:	f020 0001 	bic.w	r0, r0, #1
 8010cec:	6010      	str	r0, [r2, #0]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8010cee:	fa04 f101 	lsl.w	r1, r4, r1
  __HAL_UNLOCK(hdma);
 8010cf2:	2200      	movs	r2, #0
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8010cf4:	6069      	str	r1, [r5, #4]
  return status;
 8010cf6:	4610      	mov	r0, r2
  hdma->State = HAL_DMA_STATE_READY;
 8010cf8:	f883 4025 	strb.w	r4, [r3, #37]	; 0x25
  __HAL_UNLOCK(hdma);
 8010cfc:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
}
 8010d00:	bc30      	pop	{r4, r5}
 8010d02:	4770      	bx	lr
    return HAL_ERROR;
 8010d04:	2001      	movs	r0, #1
}
 8010d06:	4770      	bx	lr

08010d08 <HAL_DMA_IRQHandler>:
{
 8010d08:	b470      	push	{r4, r5, r6}
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 8010d0a:	e9d0 5210 	ldrd	r5, r2, [r0, #64]	; 0x40
 8010d0e:	2304      	movs	r3, #4
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8010d10:	6829      	ldr	r1, [r5, #0]
  uint32_t source_it = hdma->Instance->CCR;
 8010d12:	6804      	ldr	r4, [r0, #0]
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 8010d14:	4093      	lsls	r3, r2
 8010d16:	420b      	tst	r3, r1
  uint32_t source_it = hdma->Instance->CCR;
 8010d18:	6826      	ldr	r6, [r4, #0]
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 8010d1a:	d00a      	beq.n	8010d32 <HAL_DMA_IRQHandler+0x2a>
 8010d1c:	f016 0f04 	tst.w	r6, #4
 8010d20:	d007      	beq.n	8010d32 <HAL_DMA_IRQHandler+0x2a>
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
 8010d22:	6822      	ldr	r2, [r4, #0]
 8010d24:	0692      	lsls	r2, r2, #26
 8010d26:	d537      	bpl.n	8010d98 <HAL_DMA_IRQHandler+0x90>
     if(hdma->XferHalfCpltCallback != NULL)
 8010d28:	6b02      	ldr	r2, [r0, #48]	; 0x30
      hdma->DmaBaseAddress->IFCR = (DMA_ISR_HTIF1 << hdma->ChannelIndex);
 8010d2a:	606b      	str	r3, [r5, #4]
     if(hdma->XferHalfCpltCallback != NULL)
 8010d2c:	b1ca      	cbz	r2, 8010d62 <HAL_DMA_IRQHandler+0x5a>
}
 8010d2e:	bc70      	pop	{r4, r5, r6}
      hdma->XferCpltCallback(hdma);
 8010d30:	4710      	bx	r2
  else if ((RESET != (flag_it & (DMA_FLAG_TC1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TC)))
 8010d32:	2302      	movs	r3, #2
 8010d34:	4093      	lsls	r3, r2
 8010d36:	420b      	tst	r3, r1
 8010d38:	d015      	beq.n	8010d66 <HAL_DMA_IRQHandler+0x5e>
 8010d3a:	f016 0f02 	tst.w	r6, #2
 8010d3e:	d012      	beq.n	8010d66 <HAL_DMA_IRQHandler+0x5e>
    if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
 8010d40:	6822      	ldr	r2, [r4, #0]
 8010d42:	0692      	lsls	r2, r2, #26
 8010d44:	d406      	bmi.n	8010d54 <HAL_DMA_IRQHandler+0x4c>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 8010d46:	6822      	ldr	r2, [r4, #0]
      hdma->State = HAL_DMA_STATE_READY;
 8010d48:	2101      	movs	r1, #1
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 8010d4a:	f022 020a 	bic.w	r2, r2, #10
 8010d4e:	6022      	str	r2, [r4, #0]
      hdma->State = HAL_DMA_STATE_READY;
 8010d50:	f880 1025 	strb.w	r1, [r0, #37]	; 0x25
    if(hdma->XferCpltCallback != NULL)
 8010d54:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_TCIF1 << hdma->ChannelIndex);
 8010d56:	606b      	str	r3, [r5, #4]
    __HAL_UNLOCK(hdma);
 8010d58:	2300      	movs	r3, #0
 8010d5a:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    if(hdma->XferCpltCallback != NULL)
 8010d5e:	2a00      	cmp	r2, #0
 8010d60:	d1e5      	bne.n	8010d2e <HAL_DMA_IRQHandler+0x26>
}
 8010d62:	bc70      	pop	{r4, r5, r6}
 8010d64:	4770      	bx	lr
  else if (( RESET != (flag_it & (DMA_FLAG_TE1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TE)))
 8010d66:	2308      	movs	r3, #8
 8010d68:	4093      	lsls	r3, r2
 8010d6a:	420b      	tst	r3, r1
 8010d6c:	d0f9      	beq.n	8010d62 <HAL_DMA_IRQHandler+0x5a>
 8010d6e:	0733      	lsls	r3, r6, #28
 8010d70:	d5f7      	bpl.n	8010d62 <HAL_DMA_IRQHandler+0x5a>
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8010d72:	6823      	ldr	r3, [r4, #0]
    if (hdma->XferErrorCallback != NULL)
 8010d74:	6b41      	ldr	r1, [r0, #52]	; 0x34
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8010d76:	f023 030e 	bic.w	r3, r3, #14
 8010d7a:	6023      	str	r3, [r4, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8010d7c:	2301      	movs	r3, #1
 8010d7e:	fa03 f202 	lsl.w	r2, r3, r2
    __HAL_UNLOCK(hdma);
 8010d82:	2400      	movs	r4, #0
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8010d84:	606a      	str	r2, [r5, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8010d86:	63c3      	str	r3, [r0, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
 8010d88:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
    hdma->State = HAL_DMA_STATE_READY;
 8010d8c:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    if (hdma->XferErrorCallback != NULL)
 8010d90:	2900      	cmp	r1, #0
 8010d92:	d0e6      	beq.n	8010d62 <HAL_DMA_IRQHandler+0x5a>
}
 8010d94:	bc70      	pop	{r4, r5, r6}
      hdma->XferErrorCallback(hdma);
 8010d96:	4708      	bx	r1
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8010d98:	6822      	ldr	r2, [r4, #0]
 8010d9a:	f022 0204 	bic.w	r2, r2, #4
 8010d9e:	6022      	str	r2, [r4, #0]
 8010da0:	e7c2      	b.n	8010d28 <HAL_DMA_IRQHandler+0x20>
 8010da2:	bf00      	nop

08010da4 <FLASH_SetErrorCode>:
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR))
 8010da4:	4b35      	ldr	r3, [pc, #212]	; (8010e7c <FLASH_SetErrorCode+0xd8>)
 8010da6:	691b      	ldr	r3, [r3, #16]
 8010da8:	079a      	lsls	r2, r3, #30
 8010daa:	d504      	bpl.n	8010db6 <FLASH_SetErrorCode+0x12>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OP;
 8010dac:	4a34      	ldr	r2, [pc, #208]	; (8010e80 <FLASH_SetErrorCode+0xdc>)
 8010dae:	6853      	ldr	r3, [r2, #4]
 8010db0:	f043 0301 	orr.w	r3, r3, #1
 8010db4:	6053      	str	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PROGERR))
 8010db6:	4b31      	ldr	r3, [pc, #196]	; (8010e7c <FLASH_SetErrorCode+0xd8>)
 8010db8:	691b      	ldr	r3, [r3, #16]
 8010dba:	071b      	lsls	r3, r3, #28
 8010dbc:	d504      	bpl.n	8010dc8 <FLASH_SetErrorCode+0x24>
  { 
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 8010dbe:	4a30      	ldr	r2, [pc, #192]	; (8010e80 <FLASH_SetErrorCode+0xdc>)
 8010dc0:	6853      	ldr	r3, [r2, #4]
 8010dc2:	f043 0302 	orr.w	r3, r3, #2
 8010dc6:	6053      	str	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8010dc8:	4b2c      	ldr	r3, [pc, #176]	; (8010e7c <FLASH_SetErrorCode+0xd8>)
 8010dca:	691b      	ldr	r3, [r3, #16]
 8010dcc:	06d8      	lsls	r0, r3, #27
 8010dce:	d504      	bpl.n	8010dda <FLASH_SetErrorCode+0x36>
  { 
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8010dd0:	4a2b      	ldr	r2, [pc, #172]	; (8010e80 <FLASH_SetErrorCode+0xdc>)
 8010dd2:	6853      	ldr	r3, [r2, #4]
 8010dd4:	f043 0304 	orr.w	r3, r3, #4
 8010dd8:	6053      	str	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))
 8010dda:	4b28      	ldr	r3, [pc, #160]	; (8010e7c <FLASH_SetErrorCode+0xd8>)
 8010ddc:	691b      	ldr	r3, [r3, #16]
 8010dde:	0699      	lsls	r1, r3, #26
 8010de0:	d504      	bpl.n	8010dec <FLASH_SetErrorCode+0x48>
  { 
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 8010de2:	4a27      	ldr	r2, [pc, #156]	; (8010e80 <FLASH_SetErrorCode+0xdc>)
 8010de4:	6853      	ldr	r3, [r2, #4]
 8010de6:	f043 0308 	orr.w	r3, r3, #8
 8010dea:	6053      	str	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR))
 8010dec:	4b23      	ldr	r3, [pc, #140]	; (8010e7c <FLASH_SetErrorCode+0xd8>)
 8010dee:	691b      	ldr	r3, [r3, #16]
 8010df0:	065a      	lsls	r2, r3, #25
 8010df2:	d504      	bpl.n	8010dfe <FLASH_SetErrorCode+0x5a>
  { 
    pFlash.ErrorCode |= HAL_FLASH_ERROR_SIZ;
 8010df4:	4a22      	ldr	r2, [pc, #136]	; (8010e80 <FLASH_SetErrorCode+0xdc>)
 8010df6:	6853      	ldr	r3, [r2, #4]
 8010df8:	f043 0310 	orr.w	r3, r3, #16
 8010dfc:	6053      	str	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR))
 8010dfe:	4b1f      	ldr	r3, [pc, #124]	; (8010e7c <FLASH_SetErrorCode+0xd8>)
 8010e00:	691b      	ldr	r3, [r3, #16]
 8010e02:	061b      	lsls	r3, r3, #24
 8010e04:	d504      	bpl.n	8010e10 <FLASH_SetErrorCode+0x6c>
  { 
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;
 8010e06:	4a1e      	ldr	r2, [pc, #120]	; (8010e80 <FLASH_SetErrorCode+0xdc>)
 8010e08:	6853      	ldr	r3, [r2, #4]
 8010e0a:	f043 0320 	orr.w	r3, r3, #32
 8010e0e:	6053      	str	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_MISERR))
 8010e10:	4b1a      	ldr	r3, [pc, #104]	; (8010e7c <FLASH_SetErrorCode+0xd8>)
 8010e12:	691b      	ldr	r3, [r3, #16]
 8010e14:	05d8      	lsls	r0, r3, #23
 8010e16:	d504      	bpl.n	8010e22 <FLASH_SetErrorCode+0x7e>
  { 
   pFlash.ErrorCode |= HAL_FLASH_ERROR_MIS;
 8010e18:	4a19      	ldr	r2, [pc, #100]	; (8010e80 <FLASH_SetErrorCode+0xdc>)
 8010e1a:	6853      	ldr	r3, [r2, #4]
 8010e1c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8010e20:	6053      	str	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_FASTERR))
 8010e22:	4b16      	ldr	r3, [pc, #88]	; (8010e7c <FLASH_SetErrorCode+0xd8>)
 8010e24:	691b      	ldr	r3, [r3, #16]
 8010e26:	0599      	lsls	r1, r3, #22
 8010e28:	d504      	bpl.n	8010e34 <FLASH_SetErrorCode+0x90>
  { 
   pFlash.ErrorCode |= HAL_FLASH_ERROR_FAST;
 8010e2a:	4a15      	ldr	r2, [pc, #84]	; (8010e80 <FLASH_SetErrorCode+0xdc>)
 8010e2c:	6853      	ldr	r3, [r2, #4]
 8010e2e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8010e32:	6053      	str	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR))
 8010e34:	4b11      	ldr	r3, [pc, #68]	; (8010e7c <FLASH_SetErrorCode+0xd8>)
 8010e36:	691b      	ldr	r3, [r3, #16]
 8010e38:	045a      	lsls	r2, r3, #17
 8010e3a:	d504      	bpl.n	8010e46 <FLASH_SetErrorCode+0xa2>
  { 
   pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
 8010e3c:	4a10      	ldr	r2, [pc, #64]	; (8010e80 <FLASH_SetErrorCode+0xdc>)
 8010e3e:	6853      	ldr	r3, [r2, #4]
 8010e40:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8010e44:	6053      	str	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
 8010e46:	4b0d      	ldr	r3, [pc, #52]	; (8010e7c <FLASH_SetErrorCode+0xd8>)
 8010e48:	691b      	ldr	r3, [r3, #16]
 8010e4a:	041b      	lsls	r3, r3, #16
 8010e4c:	d504      	bpl.n	8010e58 <FLASH_SetErrorCode+0xb4>
  { 
   pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
 8010e4e:	4a0c      	ldr	r2, [pc, #48]	; (8010e80 <FLASH_SetErrorCode+0xdc>)
 8010e50:	6853      	ldr	r3, [r2, #4]
 8010e52:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8010e56:	6053      	str	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ECCD))
 8010e58:	4b08      	ldr	r3, [pc, #32]	; (8010e7c <FLASH_SetErrorCode+0xd8>)
 8010e5a:	699b      	ldr	r3, [r3, #24]
 8010e5c:	2b00      	cmp	r3, #0
 8010e5e:	da04      	bge.n	8010e6a <FLASH_SetErrorCode+0xc6>
  { 
   pFlash.ErrorCode |= HAL_FLASH_ERROR_ECCD;
 8010e60:	4a07      	ldr	r2, [pc, #28]	; (8010e80 <FLASH_SetErrorCode+0xdc>)
 8010e62:	6853      	ldr	r3, [r2, #4]
 8010e64:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8010e68:	6053      	str	r3, [r2, #4]
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PEMPTY);
  }
#endif
  
  /* Clear error programming flags */
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 8010e6a:	4b04      	ldr	r3, [pc, #16]	; (8010e7c <FLASH_SetErrorCode+0xd8>)
 8010e6c:	699a      	ldr	r2, [r3, #24]
 8010e6e:	f24c 31fa 	movw	r1, #50170	; 0xc3fa
 8010e72:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8010e76:	619a      	str	r2, [r3, #24]
 8010e78:	6119      	str	r1, [r3, #16]
} 
 8010e7a:	4770      	bx	lr
 8010e7c:	40022000 	.word	0x40022000
 8010e80:	200113ec 	.word	0x200113ec

08010e84 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8010e84:	4b06      	ldr	r3, [pc, #24]	; (8010ea0 <HAL_FLASH_Unlock+0x1c>)
 8010e86:	695a      	ldr	r2, [r3, #20]
 8010e88:	2a00      	cmp	r2, #0
 8010e8a:	db01      	blt.n	8010e90 <HAL_FLASH_Unlock+0xc>
  HAL_StatusTypeDef status = HAL_OK;
 8010e8c:	2000      	movs	r0, #0
}
 8010e8e:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8010e90:	4904      	ldr	r1, [pc, #16]	; (8010ea4 <HAL_FLASH_Unlock+0x20>)
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8010e92:	4a05      	ldr	r2, [pc, #20]	; (8010ea8 <HAL_FLASH_Unlock+0x24>)
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8010e94:	6099      	str	r1, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8010e96:	609a      	str	r2, [r3, #8]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8010e98:	6958      	ldr	r0, [r3, #20]
  HAL_StatusTypeDef status = HAL_OK;
 8010e9a:	0fc0      	lsrs	r0, r0, #31
 8010e9c:	4770      	bx	lr
 8010e9e:	bf00      	nop
 8010ea0:	40022000 	.word	0x40022000
 8010ea4:	45670123 	.word	0x45670123
 8010ea8:	cdef89ab 	.word	0xcdef89ab

08010eac <HAL_FLASH_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8010eac:	4a03      	ldr	r2, [pc, #12]	; (8010ebc <HAL_FLASH_Lock+0x10>)
 8010eae:	6953      	ldr	r3, [r2, #20]
 8010eb0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8010eb4:	6153      	str	r3, [r2, #20]
}
 8010eb6:	2000      	movs	r0, #0
 8010eb8:	4770      	bx	lr
 8010eba:	bf00      	nop
 8010ebc:	40022000 	.word	0x40022000

08010ec0 <FLASH_WaitForLastOperation>:
{
 8010ec0:	b570      	push	{r4, r5, r6, lr}
 8010ec2:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
 8010ec4:	f7ff fb12 	bl	80104ec <HAL_GetTick>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8010ec8:	4c1f      	ldr	r4, [pc, #124]	; (8010f48 <FLASH_WaitForLastOperation+0x88>)
  uint32_t tickstart = HAL_GetTick();
 8010eca:	4606      	mov	r6, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8010ecc:	e001      	b.n	8010ed2 <FLASH_WaitForLastOperation+0x12>
    if(Timeout != HAL_MAX_DELAY)
 8010ece:	1c6b      	adds	r3, r5, #1
 8010ed0:	d130      	bne.n	8010f34 <FLASH_WaitForLastOperation+0x74>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8010ed2:	6923      	ldr	r3, [r4, #16]
 8010ed4:	03d8      	lsls	r0, r3, #15
 8010ed6:	d4fa      	bmi.n	8010ece <FLASH_WaitForLastOperation+0xe>
  if((__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR))  || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PROGERR)) || 
 8010ed8:	6923      	ldr	r3, [r4, #16]
 8010eda:	0799      	lsls	r1, r3, #30
 8010edc:	d426      	bmi.n	8010f2c <FLASH_WaitForLastOperation+0x6c>
 8010ede:	6923      	ldr	r3, [r4, #16]
 8010ee0:	071a      	lsls	r2, r3, #28
 8010ee2:	d423      	bmi.n	8010f2c <FLASH_WaitForLastOperation+0x6c>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))  || 
 8010ee4:	6923      	ldr	r3, [r4, #16]
  if((__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR))  || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PROGERR)) || 
 8010ee6:	06db      	lsls	r3, r3, #27
 8010ee8:	d420      	bmi.n	8010f2c <FLASH_WaitForLastOperation+0x6c>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))  || 
 8010eea:	6923      	ldr	r3, [r4, #16]
 8010eec:	069e      	lsls	r6, r3, #26
 8010eee:	d41d      	bmi.n	8010f2c <FLASH_WaitForLastOperation+0x6c>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR))  ||
 8010ef0:	6923      	ldr	r3, [r4, #16]
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))  || 
 8010ef2:	065d      	lsls	r5, r3, #25
 8010ef4:	d41a      	bmi.n	8010f2c <FLASH_WaitForLastOperation+0x6c>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR))  ||
 8010ef6:	6923      	ldr	r3, [r4, #16]
 8010ef8:	0618      	lsls	r0, r3, #24
 8010efa:	d417      	bmi.n	8010f2c <FLASH_WaitForLastOperation+0x6c>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_MISERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_FASTERR)) || 
 8010efc:	6923      	ldr	r3, [r4, #16]
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR))  ||
 8010efe:	05d9      	lsls	r1, r3, #23
 8010f00:	d414      	bmi.n	8010f2c <FLASH_WaitForLastOperation+0x6c>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_MISERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_FASTERR)) || 
 8010f02:	6923      	ldr	r3, [r4, #16]
 8010f04:	059a      	lsls	r2, r3, #22
 8010f06:	d411      	bmi.n	8010f2c <FLASH_WaitForLastOperation+0x6c>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR))  || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR)) ||
 8010f08:	6923      	ldr	r3, [r4, #16]
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_MISERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_FASTERR)) || 
 8010f0a:	045b      	lsls	r3, r3, #17
 8010f0c:	d40e      	bmi.n	8010f2c <FLASH_WaitForLastOperation+0x6c>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR))  || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR)) ||
 8010f0e:	4a0e      	ldr	r2, [pc, #56]	; (8010f48 <FLASH_WaitForLastOperation+0x88>)
 8010f10:	6910      	ldr	r0, [r2, #16]
 8010f12:	f410 4000 	ands.w	r0, r0, #32768	; 0x8000
 8010f16:	d109      	bne.n	8010f2c <FLASH_WaitForLastOperation+0x6c>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_ECCD)))
 8010f18:	6993      	ldr	r3, [r2, #24]
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR))  || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR)) ||
 8010f1a:	2b00      	cmp	r3, #0
 8010f1c:	db06      	blt.n	8010f2c <FLASH_WaitForLastOperation+0x6c>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8010f1e:	6913      	ldr	r3, [r2, #16]
 8010f20:	f013 0301 	ands.w	r3, r3, #1
 8010f24:	d00d      	beq.n	8010f42 <FLASH_WaitForLastOperation+0x82>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8010f26:	2301      	movs	r3, #1
 8010f28:	6113      	str	r3, [r2, #16]
}
 8010f2a:	bd70      	pop	{r4, r5, r6, pc}
    FLASH_SetErrorCode();
 8010f2c:	f7ff ff3a 	bl	8010da4 <FLASH_SetErrorCode>
    return HAL_ERROR;
 8010f30:	2001      	movs	r0, #1
}
 8010f32:	bd70      	pop	{r4, r5, r6, pc}
      if((HAL_GetTick() - tickstart) >= Timeout)
 8010f34:	f7ff fada 	bl	80104ec <HAL_GetTick>
 8010f38:	1b80      	subs	r0, r0, r6
 8010f3a:	42a8      	cmp	r0, r5
 8010f3c:	d3c9      	bcc.n	8010ed2 <FLASH_WaitForLastOperation+0x12>
        return HAL_TIMEOUT;
 8010f3e:	2003      	movs	r0, #3
}
 8010f40:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_OK;  
 8010f42:	4618      	mov	r0, r3
}
 8010f44:	bd70      	pop	{r4, r5, r6, pc}
 8010f46:	bf00      	nop
 8010f48:	40022000 	.word	0x40022000

08010f4c <HAL_FLASH_Program>:
{
 8010f4c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  __HAL_LOCK(&pFlash);
 8010f50:	4e32      	ldr	r6, [pc, #200]	; (801101c <HAL_FLASH_Program+0xd0>)
 8010f52:	f896 c000 	ldrb.w	ip, [r6]
 8010f56:	f1bc 0f01 	cmp.w	ip, #1
 8010f5a:	d033      	beq.n	8010fc4 <HAL_FLASH_Program+0x78>
 8010f5c:	4698      	mov	r8, r3
 8010f5e:	4607      	mov	r7, r0
 8010f60:	2301      	movs	r3, #1
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8010f62:	f24c 3050 	movw	r0, #50000	; 0xc350
 8010f66:	4614      	mov	r4, r2
 8010f68:	460d      	mov	r5, r1
  __HAL_LOCK(&pFlash);
 8010f6a:	7033      	strb	r3, [r6, #0]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8010f6c:	f7ff ffa8 	bl	8010ec0 <FLASH_WaitForLastOperation>
 8010f70:	4681      	mov	r9, r0
  if(status == HAL_OK)
 8010f72:	b120      	cbz	r0, 8010f7e <HAL_FLASH_Program+0x32>
  __HAL_UNLOCK(&pFlash);
 8010f74:	2300      	movs	r3, #0
 8010f76:	7033      	strb	r3, [r6, #0]
}
 8010f78:	4648      	mov	r0, r9
 8010f7a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
 8010f7e:	4a28      	ldr	r2, [pc, #160]	; (8011020 <HAL_FLASH_Program+0xd4>)
    pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8010f80:	6070      	str	r0, [r6, #4]
    if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
 8010f82:	6813      	ldr	r3, [r2, #0]
 8010f84:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
 8010f88:	d021      	beq.n	8010fce <HAL_FLASH_Program+0x82>
      __HAL_FLASH_DATA_CACHE_DISABLE();
 8010f8a:	6813      	ldr	r3, [r2, #0]
      pFlash.CacheToReactivate = FLASH_CACHE_DCACHE_ENABLED;
 8010f8c:	2102      	movs	r1, #2
      __HAL_FLASH_DATA_CACHE_DISABLE();
 8010f8e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8010f92:	6013      	str	r3, [r2, #0]
      pFlash.CacheToReactivate = FLASH_CACHE_DCACHE_ENABLED;
 8010f94:	7731      	strb	r1, [r6, #28]
    if(TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
 8010f96:	b9ef      	cbnz	r7, 8010fd4 <HAL_FLASH_Program+0x88>
{
  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));

  /* Set PG bit */
  SET_BIT(FLASH->CR, FLASH_CR_PG);
 8010f98:	4a21      	ldr	r2, [pc, #132]	; (8011020 <HAL_FLASH_Program+0xd4>)
 8010f9a:	6953      	ldr	r3, [r2, #20]
 8010f9c:	f043 0301 	orr.w	r3, r3, #1
 8010fa0:	6153      	str	r3, [r2, #20]
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8010fa2:	f24c 3050 	movw	r0, #50000	; 0xc350
  
  /* Program the double word */
  *(__IO uint32_t*)Address = (uint32_t)Data;
 8010fa6:	602c      	str	r4, [r5, #0]
  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
 8010fa8:	f8c5 8004 	str.w	r8, [r5, #4]
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8010fac:	f7ff ff88 	bl	8010ec0 <FLASH_WaitForLastOperation>
 8010fb0:	f06f 0101 	mvn.w	r1, #1
 8010fb4:	4681      	mov	r9, r0
      CLEAR_BIT(FLASH->CR, prog_bit);
 8010fb6:	4a1a      	ldr	r2, [pc, #104]	; (8011020 <HAL_FLASH_Program+0xd4>)
 8010fb8:	6953      	ldr	r3, [r2, #20]
 8010fba:	400b      	ands	r3, r1
 8010fbc:	6153      	str	r3, [r2, #20]
    FLASH_FlushCaches();
 8010fbe:	f000 f853 	bl	8011068 <FLASH_FlushCaches>
 8010fc2:	e7d7      	b.n	8010f74 <HAL_FLASH_Program+0x28>
  __HAL_LOCK(&pFlash);
 8010fc4:	f04f 0902 	mov.w	r9, #2
}
 8010fc8:	4648      	mov	r0, r9
 8010fca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
 8010fce:	7733      	strb	r3, [r6, #28]
    if(TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
 8010fd0:	2f00      	cmp	r7, #0
 8010fd2:	d0e1      	beq.n	8010f98 <HAL_FLASH_Program+0x4c>
    else if((TypeProgram == FLASH_TYPEPROGRAM_FAST) || (TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST))
 8010fd4:	1e7b      	subs	r3, r7, #1
 8010fd6:	2b01      	cmp	r3, #1
 8010fd8:	d905      	bls.n	8010fe6 <HAL_FLASH_Program+0x9a>
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8010fda:	f24c 3050 	movw	r0, #50000	; 0xc350
 8010fde:	f7ff ff6f 	bl	8010ec0 <FLASH_WaitForLastOperation>
 8010fe2:	4681      	mov	r9, r0
 8010fe4:	e7eb      	b.n	8010fbe <HAL_FLASH_Program+0x72>

  /* Check the parameters */
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(Address));

  /* Set FSTPG bit */
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 8010fe6:	490e      	ldr	r1, [pc, #56]	; (8011020 <HAL_FLASH_Program+0xd4>)
 8010fe8:	694b      	ldr	r3, [r1, #20]
 8010fea:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
  __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;
 8010fee:	4622      	mov	r2, r4
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 8010ff0:	614b      	str	r3, [r1, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 8010ff2:	b672      	cpsid	i
 8010ff4:	1b29      	subs	r1, r5, r4
 8010ff6:	f504 7480 	add.w	r4, r4, #256	; 0x100
  __disable_irq();
  
  /* Program the double word of the row */
  do
  {
    *dest_addr++ = *src_addr++;
 8010ffa:	6813      	ldr	r3, [r2, #0]
 8010ffc:	5053      	str	r3, [r2, r1]
 8010ffe:	3204      	adds	r2, #4
  } while (--row_index != 0);
 8011000:	4294      	cmp	r4, r2
 8011002:	d1fa      	bne.n	8010ffa <HAL_FLASH_Program+0xae>
  __ASM volatile ("cpsie i" : : : "memory");
 8011004:	b662      	cpsie	i
      if(TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST)
 8011006:	2f02      	cmp	r7, #2
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8011008:	f24c 3050 	movw	r0, #50000	; 0xc350
      if(TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST)
 801100c:	d1e7      	bne.n	8010fde <HAL_FLASH_Program+0x92>
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 801100e:	f7ff ff57 	bl	8010ec0 <FLASH_WaitForLastOperation>
 8011012:	f46f 2180 	mvn.w	r1, #262144	; 0x40000
 8011016:	4681      	mov	r9, r0
 8011018:	e7cd      	b.n	8010fb6 <HAL_FLASH_Program+0x6a>
 801101a:	bf00      	nop
 801101c:	200113ec 	.word	0x200113ec
 8011020:	40022000 	.word	0x40022000

08011024 <FLASH_PageErase>:
  {
    assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));

    if((Banks & FLASH_BANK_1) != RESET)
    {
      CLEAR_BIT(FLASH->CR, FLASH_CR_BKER);
 8011024:	4a0f      	ldr	r2, [pc, #60]	; (8011064 <FLASH_PageErase+0x40>)
 8011026:	6953      	ldr	r3, [r2, #20]
    if((Banks & FLASH_BANK_1) != RESET)
 8011028:	07c9      	lsls	r1, r1, #31
      CLEAR_BIT(FLASH->CR, FLASH_CR_BKER);
 801102a:	bf4c      	ite	mi
 801102c:	f423 6300 	bicmi.w	r3, r3, #2048	; 0x800
    }
    else
    {
      SET_BIT(FLASH->CR, FLASH_CR_BKER);
 8011030:	f443 6300 	orrpl.w	r3, r3, #2048	; 0x800
 8011034:	6153      	str	r3, [r2, #20]
    }
  }
#endif

  /* Proceed to erase the page */
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, (Page << POSITION_VAL(FLASH_CR_PNB)));
 8011036:	4b0b      	ldr	r3, [pc, #44]	; (8011064 <FLASH_PageErase+0x40>)
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8011038:	f44f 61ff 	mov.w	r1, #2040	; 0x7f8
 801103c:	695a      	ldr	r2, [r3, #20]
 801103e:	fa91 f1a1 	rbit	r1, r1
 8011042:	fab1 f181 	clz	r1, r1
 8011046:	fa00 f101 	lsl.w	r1, r0, r1
 801104a:	f422 60ff 	bic.w	r0, r2, #2040	; 0x7f8
 801104e:	4308      	orrs	r0, r1
 8011050:	6158      	str	r0, [r3, #20]
  SET_BIT(FLASH->CR, FLASH_CR_PER);
 8011052:	695a      	ldr	r2, [r3, #20]
 8011054:	f042 0202 	orr.w	r2, r2, #2
 8011058:	615a      	str	r2, [r3, #20]
  SET_BIT(FLASH->CR, FLASH_CR_STRT);
 801105a:	695a      	ldr	r2, [r3, #20]
 801105c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8011060:	615a      	str	r2, [r3, #20]
}
 8011062:	4770      	bx	lr
 8011064:	40022000 	.word	0x40022000

08011068 <FLASH_FlushCaches>:
  * @retval None
  */
void FLASH_FlushCaches(void)
{
  /* Flush instruction cache  */
  if((pFlash.CacheToReactivate == FLASH_CACHE_ICACHE_ENABLED) || 
 8011068:	4b16      	ldr	r3, [pc, #88]	; (80110c4 <FLASH_FlushCaches+0x5c>)
 801106a:	7f1a      	ldrb	r2, [r3, #28]
 801106c:	2a01      	cmp	r2, #1
 801106e:	d01b      	beq.n	80110a8 <FLASH_FlushCaches+0x40>
     (pFlash.CacheToReactivate == FLASH_CACHE_ICACHE_DCACHE_ENABLED))
 8011070:	7f1a      	ldrb	r2, [r3, #28]
  if((pFlash.CacheToReactivate == FLASH_CACHE_ICACHE_ENABLED) || 
 8011072:	2a03      	cmp	r2, #3
 8011074:	d018      	beq.n	80110a8 <FLASH_FlushCaches+0x40>
    /* Enable instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
  }
  
  /* Flush data cache */
  if((pFlash.CacheToReactivate == FLASH_CACHE_DCACHE_ENABLED) || 
 8011076:	7f1a      	ldrb	r2, [r3, #28]
 8011078:	2a02      	cmp	r2, #2
 801107a:	d005      	beq.n	8011088 <FLASH_FlushCaches+0x20>
     (pFlash.CacheToReactivate == FLASH_CACHE_ICACHE_DCACHE_ENABLED))
 801107c:	7f1a      	ldrb	r2, [r3, #28]
  if((pFlash.CacheToReactivate == FLASH_CACHE_DCACHE_ENABLED) || 
 801107e:	2a03      	cmp	r2, #3
 8011080:	d002      	beq.n	8011088 <FLASH_FlushCaches+0x20>
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
  }
  
  /* Reset internal variable */
  pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
 8011082:	2200      	movs	r2, #0
 8011084:	771a      	strb	r2, [r3, #28]
}
 8011086:	4770      	bx	lr
    __HAL_FLASH_DATA_CACHE_RESET();
 8011088:	4a0f      	ldr	r2, [pc, #60]	; (80110c8 <FLASH_FlushCaches+0x60>)
 801108a:	6811      	ldr	r1, [r2, #0]
 801108c:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 8011090:	6011      	str	r1, [r2, #0]
 8011092:	6811      	ldr	r1, [r2, #0]
 8011094:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
 8011098:	6011      	str	r1, [r2, #0]
    __HAL_FLASH_DATA_CACHE_ENABLE();
 801109a:	6811      	ldr	r1, [r2, #0]
 801109c:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 80110a0:	6011      	str	r1, [r2, #0]
  pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
 80110a2:	2200      	movs	r2, #0
 80110a4:	771a      	strb	r2, [r3, #28]
}
 80110a6:	4770      	bx	lr
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 80110a8:	4a07      	ldr	r2, [pc, #28]	; (80110c8 <FLASH_FlushCaches+0x60>)
 80110aa:	6811      	ldr	r1, [r2, #0]
 80110ac:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 80110b0:	6011      	str	r1, [r2, #0]
 80110b2:	6811      	ldr	r1, [r2, #0]
 80110b4:	f421 6100 	bic.w	r1, r1, #2048	; 0x800
 80110b8:	6011      	str	r1, [r2, #0]
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 80110ba:	6811      	ldr	r1, [r2, #0]
 80110bc:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 80110c0:	6011      	str	r1, [r2, #0]
 80110c2:	e7d8      	b.n	8011076 <FLASH_FlushCaches+0xe>
 80110c4:	200113ec 	.word	0x200113ec
 80110c8:	40022000 	.word	0x40022000

080110cc <HAL_FLASHEx_Erase>:
{
 80110cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __HAL_LOCK(&pFlash);
 80110d0:	4e41      	ldr	r6, [pc, #260]	; (80111d8 <HAL_FLASHEx_Erase+0x10c>)
 80110d2:	7833      	ldrb	r3, [r6, #0]
 80110d4:	2b01      	cmp	r3, #1
 80110d6:	d04a      	beq.n	801116e <HAL_FLASHEx_Erase+0xa2>
 80110d8:	4604      	mov	r4, r0
 80110da:	2501      	movs	r5, #1
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80110dc:	f24c 3050 	movw	r0, #50000	; 0xc350
 80110e0:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 80110e2:	7035      	strb	r5, [r6, #0]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80110e4:	f7ff feec 	bl	8010ec0 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 80110e8:	4607      	mov	r7, r0
 80110ea:	b120      	cbz	r0, 80110f6 <HAL_FLASHEx_Erase+0x2a>
  __HAL_UNLOCK(&pFlash);
 80110ec:	2300      	movs	r3, #0
 80110ee:	7033      	strb	r3, [r6, #0]
}
 80110f0:	4638      	mov	r0, r7
 80110f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != RESET)
 80110f6:	4b39      	ldr	r3, [pc, #228]	; (80111dc <HAL_FLASHEx_Erase+0x110>)
    pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 80110f8:	6070      	str	r0, [r6, #4]
    if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != RESET)
 80110fa:	681a      	ldr	r2, [r3, #0]
 80110fc:	f412 7f00 	tst.w	r2, #512	; 0x200
      __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 8011100:	681a      	ldr	r2, [r3, #0]
    if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != RESET)
 8011102:	d138      	bne.n	8011176 <HAL_FLASHEx_Erase+0xaa>
    else if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
 8011104:	0551      	lsls	r1, r2, #21
 8011106:	d565      	bpl.n	80111d4 <HAL_FLASHEx_Erase+0x108>
      __HAL_FLASH_DATA_CACHE_DISABLE();
 8011108:	681a      	ldr	r2, [r3, #0]
      pFlash.CacheToReactivate = FLASH_CACHE_DCACHE_ENABLED;
 801110a:	2102      	movs	r1, #2
      __HAL_FLASH_DATA_CACHE_DISABLE();
 801110c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8011110:	601a      	str	r2, [r3, #0]
      pFlash.CacheToReactivate = FLASH_CACHE_DCACHE_ENABLED;
 8011112:	7731      	strb	r1, [r6, #28]
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8011114:	6823      	ldr	r3, [r4, #0]
 8011116:	2b01      	cmp	r3, #1
 8011118:	d03a      	beq.n	8011190 <HAL_FLASHEx_Erase+0xc4>
      *PageError = 0xFFFFFFFF;
 801111a:	f04f 33ff 	mov.w	r3, #4294967295
 801111e:	f8c8 3000 	str.w	r3, [r8]
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 8011122:	e9d4 5302 	ldrd	r5, r3, [r4, #8]
 8011126:	442b      	add	r3, r5
 8011128:	429d      	cmp	r5, r3
 801112a:	d21d      	bcs.n	8011168 <HAL_FLASHEx_Erase+0x9c>
        CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
 801112c:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 80111dc <HAL_FLASHEx_Erase+0x110>
 8011130:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 80111e0 <HAL_FLASHEx_Erase+0x114>
 8011134:	e005      	b.n	8011142 <HAL_FLASHEx_Erase+0x76>
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 8011136:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 801113a:	3501      	adds	r5, #1
 801113c:	4413      	add	r3, r2
 801113e:	42ab      	cmp	r3, r5
 8011140:	d912      	bls.n	8011168 <HAL_FLASHEx_Erase+0x9c>
        FLASH_PageErase(page_index, pEraseInit->Banks);
 8011142:	6861      	ldr	r1, [r4, #4]
 8011144:	4628      	mov	r0, r5
 8011146:	f7ff ff6d 	bl	8011024 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 801114a:	f24c 3050 	movw	r0, #50000	; 0xc350
 801114e:	f7ff feb7 	bl	8010ec0 <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
 8011152:	f8da 3014 	ldr.w	r3, [sl, #20]
 8011156:	ea03 0309 	and.w	r3, r3, r9
 801115a:	f8ca 3014 	str.w	r3, [sl, #20]
        if (status != HAL_OK)
 801115e:	2800      	cmp	r0, #0
 8011160:	d0e9      	beq.n	8011136 <HAL_FLASHEx_Erase+0x6a>
          *PageError = page_index;
 8011162:	f8c8 5000 	str.w	r5, [r8]
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8011166:	4607      	mov	r7, r0
    FLASH_FlushCaches();
 8011168:	f7ff ff7e 	bl	8011068 <FLASH_FlushCaches>
 801116c:	e7be      	b.n	80110ec <HAL_FLASHEx_Erase+0x20>
  __HAL_LOCK(&pFlash);
 801116e:	2702      	movs	r7, #2
}
 8011170:	4638      	mov	r0, r7
 8011172:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 8011176:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 801117a:	601a      	str	r2, [r3, #0]
      if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
 801117c:	681a      	ldr	r2, [r3, #0]
 801117e:	0550      	lsls	r0, r2, #21
 8011180:	d526      	bpl.n	80111d0 <HAL_FLASHEx_Erase+0x104>
        __HAL_FLASH_DATA_CACHE_DISABLE();
 8011182:	681a      	ldr	r2, [r3, #0]
        pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_DCACHE_ENABLED;
 8011184:	2103      	movs	r1, #3
        __HAL_FLASH_DATA_CACHE_DISABLE();
 8011186:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 801118a:	601a      	str	r2, [r3, #0]
        pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_DCACHE_ENABLED;
 801118c:	7731      	strb	r1, [r6, #28]
 801118e:	e7c1      	b.n	8011114 <HAL_FLASHEx_Erase+0x48>
      FLASH_MassErase(pEraseInit->Banks);
 8011190:	6863      	ldr	r3, [r4, #4]
    if((Banks & FLASH_BANK_1) != RESET)
 8011192:	07da      	lsls	r2, r3, #31
 8011194:	d504      	bpl.n	80111a0 <HAL_FLASHEx_Erase+0xd4>
      SET_BIT(FLASH->CR, FLASH_CR_MER1);
 8011196:	4911      	ldr	r1, [pc, #68]	; (80111dc <HAL_FLASHEx_Erase+0x110>)
 8011198:	694a      	ldr	r2, [r1, #20]
 801119a:	f042 0204 	orr.w	r2, r2, #4
 801119e:	614a      	str	r2, [r1, #20]
    if((Banks & FLASH_BANK_2) != RESET)
 80111a0:	079b      	lsls	r3, r3, #30
 80111a2:	d504      	bpl.n	80111ae <HAL_FLASHEx_Erase+0xe2>
      SET_BIT(FLASH->CR, FLASH_CR_MER2);
 80111a4:	4a0d      	ldr	r2, [pc, #52]	; (80111dc <HAL_FLASHEx_Erase+0x110>)
 80111a6:	6953      	ldr	r3, [r2, #20]
 80111a8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80111ac:	6153      	str	r3, [r2, #20]
  SET_BIT(FLASH->CR, FLASH_CR_STRT);
 80111ae:	4c0b      	ldr	r4, [pc, #44]	; (80111dc <HAL_FLASHEx_Erase+0x110>)
 80111b0:	6963      	ldr	r3, [r4, #20]
 80111b2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80111b6:	6163      	str	r3, [r4, #20]
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80111b8:	f24c 3050 	movw	r0, #50000	; 0xc350
 80111bc:	f7ff fe80 	bl	8010ec0 <FLASH_WaitForLastOperation>
      CLEAR_BIT(FLASH->CR, (FLASH_CR_MER1 | FLASH_CR_MER2));
 80111c0:	6963      	ldr	r3, [r4, #20]
 80111c2:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80111c6:	f023 0304 	bic.w	r3, r3, #4
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80111ca:	4607      	mov	r7, r0
      CLEAR_BIT(FLASH->CR, (FLASH_CR_MER1 | FLASH_CR_MER2));
 80111cc:	6163      	str	r3, [r4, #20]
 80111ce:	e7cb      	b.n	8011168 <HAL_FLASHEx_Erase+0x9c>
        pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_ENABLED;
 80111d0:	7735      	strb	r5, [r6, #28]
 80111d2:	e79f      	b.n	8011114 <HAL_FLASHEx_Erase+0x48>
      pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
 80111d4:	7730      	strb	r0, [r6, #28]
 80111d6:	e79d      	b.n	8011114 <HAL_FLASHEx_Erase+0x48>
 80111d8:	200113ec 	.word	0x200113ec
 80111dc:	40022000 	.word	0x40022000
 80111e0:	fffff805 	.word	0xfffff805

080111e4 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80111e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80111e8:	4688      	mov	r8, r1
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 80111ea:	6809      	ldr	r1, [r1, #0]
{
 80111ec:	b083      	sub	sp, #12
  while (((GPIO_Init->Pin) >> position) != RESET)
 80111ee:	2900      	cmp	r1, #0
 80111f0:	f000 80a0 	beq.w	8011334 <HAL_GPIO_Init+0x150>
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 80111f4:	f8df e210 	ldr.w	lr, [pc, #528]	; 8011408 <HAL_GPIO_Init+0x224>
  uint32_t position = 0x00;
 80111f8:	2500      	movs	r5, #0
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 80111fa:	2301      	movs	r3, #1
 80111fc:	fa03 f205 	lsl.w	r2, r3, r5
    if(iocurrent)
 8011200:	ea12 0701 	ands.w	r7, r2, r1
 8011204:	f000 8091 	beq.w	801132a <HAL_GPIO_Init+0x146>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8011208:	f8d8 4004 	ldr.w	r4, [r8, #4]
 801120c:	f024 0610 	bic.w	r6, r4, #16
 8011210:	2e02      	cmp	r6, #2
 8011212:	f000 8092 	beq.w	801133a <HAL_GPIO_Init+0x156>
 8011216:	ea4f 0c45 	mov.w	ip, r5, lsl #1
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 801121a:	2303      	movs	r3, #3
      temp = GPIOx->MODER;
 801121c:	f8d0 b000 	ldr.w	fp, [r0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8011220:	fa03 f30c 	lsl.w	r3, r3, ip
 8011224:	43db      	mvns	r3, r3
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8011226:	f004 0903 	and.w	r9, r4, #3
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 801122a:	ea03 0b0b 	and.w	fp, r3, fp
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 801122e:	fa09 fa0c 	lsl.w	sl, r9, ip
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8011232:	3e01      	subs	r6, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8011234:	ea4a 0a0b 	orr.w	sl, sl, fp
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8011238:	2e01      	cmp	r6, #1
      GPIOx->MODER = temp;
 801123a:	f8c0 a000 	str.w	sl, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 801123e:	f240 80a2 	bls.w	8011386 <HAL_GPIO_Init+0x1a2>
      if((GPIO_Init->Mode & GPIO_MODE_ANALOG) == GPIO_MODE_ANALOG)
 8011242:	f1b9 0f03 	cmp.w	r9, #3
 8011246:	d10a      	bne.n	801125e <HAL_GPIO_Init+0x7a>
        temp = GPIOx->ASCR;
 8011248:	f8d0 902c 	ldr.w	r9, [r0, #44]	; 0x2c
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
 801124c:	f3c4 06c0 	ubfx	r6, r4, #3, #1
        temp &= ~(GPIO_ASCR_ASC0 << position) ;
 8011250:	ea29 0902 	bic.w	r9, r9, r2
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
 8011254:	4632      	mov	r2, r6
 8011256:	40aa      	lsls	r2, r5
 8011258:	ea42 0209 	orr.w	r2, r2, r9
        GPIOx->ASCR = temp;
 801125c:	62c2      	str	r2, [r0, #44]	; 0x2c
      temp = GPIOx->PUPDR;
 801125e:	68c6      	ldr	r6, [r0, #12]
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8011260:	f8d8 2008 	ldr.w	r2, [r8, #8]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2));
 8011264:	4033      	ands	r3, r6
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8011266:	fa02 f20c 	lsl.w	r2, r2, ip
 801126a:	431a      	orrs	r2, r3
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 801126c:	00e3      	lsls	r3, r4, #3
      GPIOx->PUPDR = temp;
 801126e:	60c2      	str	r2, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8011270:	d55b      	bpl.n	801132a <HAL_GPIO_Init+0x146>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8011272:	4a5e      	ldr	r2, [pc, #376]	; (80113ec <HAL_GPIO_Init+0x208>)
 8011274:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8011276:	f043 0301 	orr.w	r3, r3, #1
 801127a:	6613      	str	r3, [r2, #96]	; 0x60
 801127c:	6e13      	ldr	r3, [r2, #96]	; 0x60
 801127e:	f025 0603 	bic.w	r6, r5, #3
 8011282:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 8011286:	f003 0301 	and.w	r3, r3, #1
 801128a:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
 801128e:	9301      	str	r3, [sp, #4]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8011290:	f005 0303 	and.w	r3, r5, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8011294:	9a01      	ldr	r2, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2];
 8011296:	f8d6 c008 	ldr.w	ip, [r6, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 801129a:	ea4f 0983 	mov.w	r9, r3, lsl #2
 801129e:	220f      	movs	r2, #15
 80112a0:	fa02 f209 	lsl.w	r2, r2, r9
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 80112a4:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80112a8:	ea2c 0202 	bic.w	r2, ip, r2
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 80112ac:	d01b      	beq.n	80112e6 <HAL_GPIO_Init+0x102>
 80112ae:	4b50      	ldr	r3, [pc, #320]	; (80113f0 <HAL_GPIO_Init+0x20c>)
 80112b0:	4298      	cmp	r0, r3
 80112b2:	f000 8083 	beq.w	80113bc <HAL_GPIO_Init+0x1d8>
 80112b6:	4b4f      	ldr	r3, [pc, #316]	; (80113f4 <HAL_GPIO_Init+0x210>)
 80112b8:	4298      	cmp	r0, r3
 80112ba:	d079      	beq.n	80113b0 <HAL_GPIO_Init+0x1cc>
 80112bc:	4b4e      	ldr	r3, [pc, #312]	; (80113f8 <HAL_GPIO_Init+0x214>)
 80112be:	4298      	cmp	r0, r3
 80112c0:	f000 8087 	beq.w	80113d2 <HAL_GPIO_Init+0x1ee>
 80112c4:	4b4d      	ldr	r3, [pc, #308]	; (80113fc <HAL_GPIO_Init+0x218>)
 80112c6:	4298      	cmp	r0, r3
 80112c8:	f000 8089 	beq.w	80113de <HAL_GPIO_Init+0x1fa>
 80112cc:	4b4c      	ldr	r3, [pc, #304]	; (8011400 <HAL_GPIO_Init+0x21c>)
 80112ce:	4298      	cmp	r0, r3
 80112d0:	d079      	beq.n	80113c6 <HAL_GPIO_Init+0x1e2>
 80112d2:	4b4c      	ldr	r3, [pc, #304]	; (8011404 <HAL_GPIO_Init+0x220>)
 80112d4:	4298      	cmp	r0, r3
 80112d6:	bf0c      	ite	eq
 80112d8:	f04f 0c06 	moveq.w	ip, #6
 80112dc:	f04f 0c07 	movne.w	ip, #7
 80112e0:	fa0c f309 	lsl.w	r3, ip, r9
 80112e4:	431a      	orrs	r2, r3
        SYSCFG->EXTICR[position >> 2] = temp;
 80112e6:	60b2      	str	r2, [r6, #8]
        temp = EXTI->IMR1;
 80112e8:	f8de 3000 	ldr.w	r3, [lr]
        temp &= ~((uint32_t)iocurrent);
 80112ec:	43fa      	mvns	r2, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80112ee:	03e6      	lsls	r6, r4, #15
        temp &= ~((uint32_t)iocurrent);
 80112f0:	bf54      	ite	pl
 80112f2:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 80112f4:	433b      	orrmi	r3, r7
        }
        EXTI->IMR1 = temp;
 80112f6:	f8ce 3000 	str.w	r3, [lr]

        temp = EXTI->EMR1;
 80112fa:	f8de 3004 	ldr.w	r3, [lr, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80112fe:	03a6      	lsls	r6, r4, #14
        temp &= ~((uint32_t)iocurrent);
 8011300:	bf54      	ite	pl
 8011302:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8011304:	433b      	orrmi	r3, r7
        }
        EXTI->EMR1 = temp;
 8011306:	f8ce 3004 	str.w	r3, [lr, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 801130a:	f8de 3008 	ldr.w	r3, [lr, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 801130e:	02e6      	lsls	r6, r4, #11
        temp &= ~((uint32_t)iocurrent);
 8011310:	bf54      	ite	pl
 8011312:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8011314:	433b      	orrmi	r3, r7
        }
        EXTI->RTSR1 = temp;
 8011316:	f8ce 3008 	str.w	r3, [lr, #8]

        temp = EXTI->FTSR1;
 801131a:	f8de 300c 	ldr.w	r3, [lr, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 801131e:	02a4      	lsls	r4, r4, #10
        temp &= ~((uint32_t)iocurrent);
 8011320:	bf54      	ite	pl
 8011322:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8011324:	433b      	orrmi	r3, r7
        }
        EXTI->FTSR1 = temp;
 8011326:	f8ce 300c 	str.w	r3, [lr, #12]
      }
    }
    
    position++;
 801132a:	3501      	adds	r5, #1
  while (((GPIO_Init->Pin) >> position) != RESET)
 801132c:	fa31 f305 	lsrs.w	r3, r1, r5
 8011330:	f47f af63 	bne.w	80111fa <HAL_GPIO_Init+0x16>
  }
}
 8011334:	b003      	add	sp, #12
 8011336:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->AFR[position >> 3];
 801133a:	ea4f 0cd5 	mov.w	ip, r5, lsr #3
 801133e:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8011342:	f005 0607 	and.w	r6, r5, #7
        temp = GPIOx->AFR[position >> 3];
 8011346:	f8dc 3020 	ldr.w	r3, [ip, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 801134a:	00b6      	lsls	r6, r6, #2
 801134c:	f04f 0a0f 	mov.w	sl, #15
 8011350:	fa0a fa06 	lsl.w	sl, sl, r6
 8011354:	ea23 090a 	bic.w	r9, r3, sl
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8011358:	f8d8 3010 	ldr.w	r3, [r8, #16]
 801135c:	40b3      	lsls	r3, r6
 801135e:	ea43 0309 	orr.w	r3, r3, r9
        GPIOx->AFR[position >> 3] = temp;
 8011362:	f8cc 3020 	str.w	r3, [ip, #32]
 8011366:	ea4f 0c45 	mov.w	ip, r5, lsl #1
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 801136a:	2303      	movs	r3, #3
      temp = GPIOx->MODER;
 801136c:	6806      	ldr	r6, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 801136e:	fa03 f30c 	lsl.w	r3, r3, ip
 8011372:	43db      	mvns	r3, r3
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8011374:	f004 0903 	and.w	r9, r4, #3
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8011378:	ea06 0a03 	and.w	sl, r6, r3
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 801137c:	fa09 f60c 	lsl.w	r6, r9, ip
 8011380:	ea46 060a 	orr.w	r6, r6, sl
      GPIOx->MODER = temp;
 8011384:	6006      	str	r6, [r0, #0]
        temp = GPIOx->OSPEEDR;
 8011386:	6886      	ldr	r6, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2));
 8011388:	ea06 0a03 	and.w	sl, r6, r3
        temp |= (GPIO_Init->Speed << (position * 2));
 801138c:	f8d8 600c 	ldr.w	r6, [r8, #12]
 8011390:	fa06 f60c 	lsl.w	r6, r6, ip
 8011394:	ea46 060a 	orr.w	r6, r6, sl
        GPIOx->OSPEEDR = temp;
 8011398:	6086      	str	r6, [r0, #8]
        temp = GPIOx->OTYPER;
 801139a:	f8d0 a004 	ldr.w	sl, [r0, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 801139e:	f3c4 1600 	ubfx	r6, r4, #4, #1
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 80113a2:	ea2a 0a02 	bic.w	sl, sl, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 80113a6:	40ae      	lsls	r6, r5
 80113a8:	ea46 060a 	orr.w	r6, r6, sl
        GPIOx->OTYPER = temp;
 80113ac:	6046      	str	r6, [r0, #4]
 80113ae:	e748      	b.n	8011242 <HAL_GPIO_Init+0x5e>
 80113b0:	f04f 0c02 	mov.w	ip, #2
 80113b4:	fa0c f309 	lsl.w	r3, ip, r9
 80113b8:	431a      	orrs	r2, r3
 80113ba:	e794      	b.n	80112e6 <HAL_GPIO_Init+0x102>
 80113bc:	2301      	movs	r3, #1
 80113be:	fa03 f309 	lsl.w	r3, r3, r9
 80113c2:	431a      	orrs	r2, r3
 80113c4:	e78f      	b.n	80112e6 <HAL_GPIO_Init+0x102>
 80113c6:	f04f 0c05 	mov.w	ip, #5
 80113ca:	fa0c f309 	lsl.w	r3, ip, r9
 80113ce:	431a      	orrs	r2, r3
 80113d0:	e789      	b.n	80112e6 <HAL_GPIO_Init+0x102>
 80113d2:	f04f 0c03 	mov.w	ip, #3
 80113d6:	fa0c f309 	lsl.w	r3, ip, r9
 80113da:	431a      	orrs	r2, r3
 80113dc:	e783      	b.n	80112e6 <HAL_GPIO_Init+0x102>
 80113de:	f04f 0c04 	mov.w	ip, #4
 80113e2:	fa0c f309 	lsl.w	r3, ip, r9
 80113e6:	431a      	orrs	r2, r3
 80113e8:	e77d      	b.n	80112e6 <HAL_GPIO_Init+0x102>
 80113ea:	bf00      	nop
 80113ec:	40021000 	.word	0x40021000
 80113f0:	48000400 	.word	0x48000400
 80113f4:	48000800 	.word	0x48000800
 80113f8:	48000c00 	.word	0x48000c00
 80113fc:	48001000 	.word	0x48001000
 8011400:	48001400 	.word	0x48001400
 8011404:	48001800 	.word	0x48001800
 8011408:	40010400 	.word	0x40010400

0801140c <HAL_GPIO_DeInit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 801140c:	2900      	cmp	r1, #0
 801140e:	f000 8093 	beq.w	8011538 <HAL_GPIO_DeInit+0x12c>
{
 8011412:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
 8011416:	f8df 8140 	ldr.w	r8, [pc, #320]	; 8011558 <HAL_GPIO_DeInit+0x14c>
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 801141a:	f8df b140 	ldr.w	fp, [pc, #320]	; 801155c <HAL_GPIO_DeInit+0x150>
  uint32_t position = 0x00;
 801141e:	2200      	movs	r2, #0
    iocurrent = (GPIO_Pin) & (1U << position);
 8011420:	f04f 0901 	mov.w	r9, #1
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2));
 8011424:	f04f 0a03 	mov.w	sl, #3
    iocurrent = (GPIO_Pin) & (1U << position);
 8011428:	fa09 f302 	lsl.w	r3, r9, r2
    if (iocurrent)
 801142c:	ea13 0c01 	ands.w	ip, r3, r1
 8011430:	d048      	beq.n	80114c4 <HAL_GPIO_DeInit+0xb8>
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2));
 8011432:	6805      	ldr	r5, [r0, #0]
 8011434:	0054      	lsls	r4, r2, #1
 8011436:	fa0a f404 	lsl.w	r4, sl, r4
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 801143a:	08d6      	lsrs	r6, r2, #3
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2));
 801143c:	4325      	orrs	r5, r4
 801143e:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 8011442:	6005      	str	r5, [r0, #0]
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8011444:	f002 0507 	and.w	r5, r2, #7
 8011448:	f8d6 e020 	ldr.w	lr, [r6, #32]
 801144c:	270f      	movs	r7, #15
 801144e:	00ad      	lsls	r5, r5, #2
 8011450:	fa07 f505 	lsl.w	r5, r7, r5
 8011454:	ea2e 0505 	bic.w	r5, lr, r5
 8011458:	6235      	str	r5, [r6, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2));
 801145a:	6885      	ldr	r5, [r0, #8]
 801145c:	43e4      	mvns	r4, r4
 801145e:	4025      	ands	r5, r4
 8011460:	6085      	str	r5, [r0, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 8011462:	6845      	ldr	r5, [r0, #4]
 8011464:	43db      	mvns	r3, r3
 8011466:	401d      	ands	r5, r3
 8011468:	6045      	str	r5, [r0, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2));
 801146a:	68c5      	ldr	r5, [r0, #12]
 801146c:	402c      	ands	r4, r5
 801146e:	60c4      	str	r4, [r0, #12]
      GPIOx->ASCR &= ~(GPIO_ASCR_ASC0<< position);
 8011470:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 8011472:	f022 0403 	bic.w	r4, r2, #3
 8011476:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 801147a:	402b      	ands	r3, r5
 801147c:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
 8011480:	62c3      	str	r3, [r0, #44]	; 0x2c
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8011482:	f002 0303 	and.w	r3, r2, #3
      tmp = SYSCFG->EXTICR[position >> 2];
 8011486:	68a5      	ldr	r5, [r4, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8011488:	009b      	lsls	r3, r3, #2
 801148a:	409f      	lsls	r7, r3
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 801148c:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8011490:	ea05 0507 	and.w	r5, r5, r7
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8011494:	d01c      	beq.n	80114d0 <HAL_GPIO_DeInit+0xc4>
 8011496:	4558      	cmp	r0, fp
 8011498:	d040      	beq.n	801151c <HAL_GPIO_DeInit+0x110>
 801149a:	4e2a      	ldr	r6, [pc, #168]	; (8011544 <HAL_GPIO_DeInit+0x138>)
 801149c:	42b0      	cmp	r0, r6
 801149e:	d044      	beq.n	801152a <HAL_GPIO_DeInit+0x11e>
 80114a0:	4e29      	ldr	r6, [pc, #164]	; (8011548 <HAL_GPIO_DeInit+0x13c>)
 80114a2:	42b0      	cmp	r0, r6
 80114a4:	d045      	beq.n	8011532 <HAL_GPIO_DeInit+0x126>
 80114a6:	4e29      	ldr	r6, [pc, #164]	; (801154c <HAL_GPIO_DeInit+0x140>)
 80114a8:	42b0      	cmp	r0, r6
 80114aa:	d03a      	beq.n	8011522 <HAL_GPIO_DeInit+0x116>
 80114ac:	4e28      	ldr	r6, [pc, #160]	; (8011550 <HAL_GPIO_DeInit+0x144>)
 80114ae:	42b0      	cmp	r0, r6
 80114b0:	d043      	beq.n	801153a <HAL_GPIO_DeInit+0x12e>
 80114b2:	4e28      	ldr	r6, [pc, #160]	; (8011554 <HAL_GPIO_DeInit+0x148>)
 80114b4:	42b0      	cmp	r0, r6
 80114b6:	bf0c      	ite	eq
 80114b8:	2606      	moveq	r6, #6
 80114ba:	2607      	movne	r6, #7
 80114bc:	fa06 f303 	lsl.w	r3, r6, r3
 80114c0:	429d      	cmp	r5, r3
 80114c2:	d008      	beq.n	80114d6 <HAL_GPIO_DeInit+0xca>
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
      }
    }
    
    position++;
 80114c4:	3201      	adds	r2, #1
  while ((GPIO_Pin >> position) != RESET)
 80114c6:	fa31 f302 	lsrs.w	r3, r1, r2
 80114ca:	d1ad      	bne.n	8011428 <HAL_GPIO_DeInit+0x1c>
  }
}
 80114cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80114d0:	2300      	movs	r3, #0
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 80114d2:	429d      	cmp	r5, r3
 80114d4:	d1f6      	bne.n	80114c4 <HAL_GPIO_DeInit+0xb8>
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
 80114d6:	68a3      	ldr	r3, [r4, #8]
 80114d8:	ea23 0707 	bic.w	r7, r3, r7
 80114dc:	60a7      	str	r7, [r4, #8]
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
 80114de:	f8d8 3000 	ldr.w	r3, [r8]
 80114e2:	ea6f 0c0c 	mvn.w	ip, ip
 80114e6:	ea03 030c 	and.w	r3, r3, ip
 80114ea:	f8c8 3000 	str.w	r3, [r8]
        EXTI->EMR1 &= ~((uint32_t)iocurrent);
 80114ee:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80114f2:	ea0c 0303 	and.w	r3, ip, r3
 80114f6:	f8c8 3004 	str.w	r3, [r8, #4]
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
 80114fa:	f8d8 3008 	ldr.w	r3, [r8, #8]
 80114fe:	ea0c 0303 	and.w	r3, ip, r3
 8011502:	f8c8 3008 	str.w	r3, [r8, #8]
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
 8011506:	f8d8 300c 	ldr.w	r3, [r8, #12]
    position++;
 801150a:	3201      	adds	r2, #1
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
 801150c:	ea0c 0303 	and.w	r3, ip, r3
 8011510:	f8c8 300c 	str.w	r3, [r8, #12]
  while ((GPIO_Pin >> position) != RESET)
 8011514:	fa31 f302 	lsrs.w	r3, r1, r2
 8011518:	d186      	bne.n	8011428 <HAL_GPIO_DeInit+0x1c>
 801151a:	e7d7      	b.n	80114cc <HAL_GPIO_DeInit+0xc0>
 801151c:	fa09 f303 	lsl.w	r3, r9, r3
 8011520:	e7d7      	b.n	80114d2 <HAL_GPIO_DeInit+0xc6>
 8011522:	2604      	movs	r6, #4
 8011524:	fa06 f303 	lsl.w	r3, r6, r3
 8011528:	e7d3      	b.n	80114d2 <HAL_GPIO_DeInit+0xc6>
 801152a:	2602      	movs	r6, #2
 801152c:	fa06 f303 	lsl.w	r3, r6, r3
 8011530:	e7cf      	b.n	80114d2 <HAL_GPIO_DeInit+0xc6>
 8011532:	fa0a f303 	lsl.w	r3, sl, r3
 8011536:	e7cc      	b.n	80114d2 <HAL_GPIO_DeInit+0xc6>
 8011538:	4770      	bx	lr
 801153a:	2605      	movs	r6, #5
 801153c:	fa06 f303 	lsl.w	r3, r6, r3
 8011540:	e7c7      	b.n	80114d2 <HAL_GPIO_DeInit+0xc6>
 8011542:	bf00      	nop
 8011544:	48000800 	.word	0x48000800
 8011548:	48000c00 	.word	0x48000c00
 801154c:	48001000 	.word	0x48001000
 8011550:	48001400 	.word	0x48001400
 8011554:	48001800 	.word	0x48001800
 8011558:	40010400 	.word	0x40010400
 801155c:	48000400 	.word	0x48000400

08011560 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8011560:	6903      	ldr	r3, [r0, #16]
 8011562:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 8011564:	bf14      	ite	ne
 8011566:	2001      	movne	r0, #1
 8011568:	2000      	moveq	r0, #0
 801156a:	4770      	bx	lr

0801156c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 801156c:	b90a      	cbnz	r2, 8011572 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 801156e:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 8011570:	4770      	bx	lr
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8011572:	6181      	str	r1, [r0, #24]
 8011574:	4770      	bx	lr
 8011576:	bf00      	nop

08011578 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8011578:	6943      	ldr	r3, [r0, #20]
 801157a:	4059      	eors	r1, r3
 801157c:	6141      	str	r1, [r0, #20]
}
 801157e:	4770      	bx	lr

08011580 <HAL_GPIO_EXTI_IRQHandler>:
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 8011580:	4a04      	ldr	r2, [pc, #16]	; (8011594 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 8011582:	6951      	ldr	r1, [r2, #20]
 8011584:	4201      	tst	r1, r0
 8011586:	d100      	bne.n	801158a <HAL_GPIO_EXTI_IRQHandler+0xa>
 8011588:	4770      	bx	lr
{
 801158a:	b508      	push	{r3, lr}
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 801158c:	6150      	str	r0, [r2, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 801158e:	f00a f8eb 	bl	801b768 <HAL_GPIO_EXTI_Callback>
  }
}
 8011592:	bd08      	pop	{r3, pc}
 8011594:	40010400 	.word	0x40010400

08011598 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
{
 8011598:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801159c:	4680      	mov	r8, r0
 801159e:	460f      	mov	r7, r1
 80115a0:	4616      	mov	r6, r2
 80115a2:	461d      	mov	r5, r3
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80115a4:	f8d8 4000 	ldr.w	r4, [r8]
 80115a8:	e001      	b.n	80115ae <I2C_WaitOnFlagUntilTimeout+0x16>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 80115aa:	1c6b      	adds	r3, r5, #1
 80115ac:	d10a      	bne.n	80115c4 <I2C_WaitOnFlagUntilTimeout+0x2c>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80115ae:	69a0      	ldr	r0, [r4, #24]
 80115b0:	ea37 0300 	bics.w	r3, r7, r0
 80115b4:	bf0c      	ite	eq
 80115b6:	2001      	moveq	r0, #1
 80115b8:	2000      	movne	r0, #0
 80115ba:	42b0      	cmp	r0, r6
 80115bc:	d0f5      	beq.n	80115aa <I2C_WaitOnFlagUntilTimeout+0x12>
        __HAL_UNLOCK(hi2c);
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 80115be:	2000      	movs	r0, #0
}
 80115c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 80115c4:	b12d      	cbz	r5, 80115d2 <I2C_WaitOnFlagUntilTimeout+0x3a>
 80115c6:	f7fe ff91 	bl	80104ec <HAL_GetTick>
 80115ca:	9b06      	ldr	r3, [sp, #24]
 80115cc:	1ac0      	subs	r0, r0, r3
 80115ce:	42a8      	cmp	r0, r5
 80115d0:	d9e8      	bls.n	80115a4 <I2C_WaitOnFlagUntilTimeout+0xc>
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80115d2:	2300      	movs	r3, #0
        hi2c->State = HAL_I2C_STATE_READY;
 80115d4:	2220      	movs	r2, #32
 80115d6:	f888 2041 	strb.w	r2, [r8, #65]	; 0x41
        __HAL_UNLOCK(hi2c);
 80115da:	f888 3040 	strb.w	r3, [r8, #64]	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80115de:	f888 3042 	strb.w	r3, [r8, #66]	; 0x42
        return HAL_TIMEOUT;
 80115e2:	2003      	movs	r0, #3
 80115e4:	e7ec      	b.n	80115c0 <I2C_WaitOnFlagUntilTimeout+0x28>
 80115e6:	bf00      	nop

080115e8 <I2C_IsAcknowledgeFailed.part.0>:
  *                the configuration information for the specified I2C.
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
 80115e8:	b570      	push	{r4, r5, r6, lr}
 80115ea:	4605      	mov	r5, r0
 80115ec:	460c      	mov	r4, r1
 80115ee:	4616      	mov	r6, r2
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80115f0:	6828      	ldr	r0, [r5, #0]
 80115f2:	e001      	b.n	80115f8 <I2C_IsAcknowledgeFailed.part.0+0x10>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 80115f4:	1c63      	adds	r3, r4, #1
 80115f6:	d122      	bne.n	801163e <I2C_IsAcknowledgeFailed.part.0+0x56>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80115f8:	6983      	ldr	r3, [r0, #24]
 80115fa:	0699      	lsls	r1, r3, #26
 80115fc:	d5fa      	bpl.n	80115f4 <I2C_IsAcknowledgeFailed.part.0+0xc>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80115fe:	2210      	movs	r2, #16

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8011600:	2320      	movs	r3, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8011602:	61c2      	str	r2, [r0, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8011604:	61c3      	str	r3, [r0, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8011606:	6983      	ldr	r3, [r0, #24]
 8011608:	079a      	lsls	r2, r3, #30
    hi2c->Instance->TXDR = 0x00U;
 801160a:	bf44      	itt	mi
 801160c:	2300      	movmi	r3, #0
 801160e:	6283      	strmi	r3, [r0, #40]	; 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8011610:	6983      	ldr	r3, [r0, #24]
 8011612:	07db      	lsls	r3, r3, #31
 8011614:	d403      	bmi.n	801161e <I2C_IsAcknowledgeFailed.part.0+0x36>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8011616:	6983      	ldr	r3, [r0, #24]
 8011618:	f043 0301 	orr.w	r3, r3, #1
 801161c:	6183      	str	r3, [r0, #24]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 801161e:	6843      	ldr	r3, [r0, #4]
 8011620:	4a0f      	ldr	r2, [pc, #60]	; (8011660 <I2C_IsAcknowledgeFailed.part.0+0x78>)

    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8011622:	2404      	movs	r4, #4
    I2C_RESET_CR2(hi2c);
 8011624:	4013      	ands	r3, r2
    hi2c->State = HAL_I2C_STATE_READY;
 8011626:	2120      	movs	r1, #32
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8011628:	2200      	movs	r2, #0
    I2C_RESET_CR2(hi2c);
 801162a:	6043      	str	r3, [r0, #4]
    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 801162c:	646c      	str	r4, [r5, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    return HAL_ERROR;
 801162e:	2001      	movs	r0, #1
    hi2c->State = HAL_I2C_STATE_READY;
 8011630:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8011634:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8011638:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
  }
  return HAL_OK;
}
 801163c:	bd70      	pop	{r4, r5, r6, pc}
        if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 801163e:	b124      	cbz	r4, 801164a <I2C_IsAcknowledgeFailed.part.0+0x62>
 8011640:	f7fe ff54 	bl	80104ec <HAL_GetTick>
 8011644:	1b80      	subs	r0, r0, r6
 8011646:	4284      	cmp	r4, r0
 8011648:	d2d2      	bcs.n	80115f0 <I2C_IsAcknowledgeFailed.part.0+0x8>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 801164a:	2300      	movs	r3, #0
          hi2c->State = HAL_I2C_STATE_READY;
 801164c:	2220      	movs	r2, #32
 801164e:	f885 2041 	strb.w	r2, [r5, #65]	; 0x41
          __HAL_UNLOCK(hi2c);
 8011652:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8011656:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
          return HAL_TIMEOUT;
 801165a:	2003      	movs	r0, #3
}
 801165c:	bd70      	pop	{r4, r5, r6, pc}
 801165e:	bf00      	nop
 8011660:	fe00e800 	.word	0xfe00e800

08011664 <I2C_WaitOnTXISFlagUntilTimeout>:
{
 8011664:	b570      	push	{r4, r5, r6, lr}
 8011666:	4605      	mov	r5, r0
 8011668:	460c      	mov	r4, r1
 801166a:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 801166c:	e001      	b.n	8011672 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
    if (Timeout != HAL_MAX_DELAY)
 801166e:	1c61      	adds	r1, r4, #1
 8011670:	d111      	bne.n	8011696 <I2C_WaitOnTXISFlagUntilTimeout+0x32>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8011672:	682b      	ldr	r3, [r5, #0]
 8011674:	699a      	ldr	r2, [r3, #24]
 8011676:	0792      	lsls	r2, r2, #30
 8011678:	d40b      	bmi.n	8011692 <I2C_WaitOnTXISFlagUntilTimeout+0x2e>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 801167a:	699b      	ldr	r3, [r3, #24]
 801167c:	06d8      	lsls	r0, r3, #27
 801167e:	d5f6      	bpl.n	801166e <I2C_WaitOnTXISFlagUntilTimeout+0xa>
 8011680:	4632      	mov	r2, r6
 8011682:	4621      	mov	r1, r4
 8011684:	4628      	mov	r0, r5
 8011686:	f7ff ffaf 	bl	80115e8 <I2C_IsAcknowledgeFailed.part.0>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 801168a:	2800      	cmp	r0, #0
 801168c:	d0ef      	beq.n	801166e <I2C_WaitOnTXISFlagUntilTimeout+0xa>
      return HAL_ERROR;
 801168e:	2001      	movs	r0, #1
}
 8011690:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_OK;
 8011692:	2000      	movs	r0, #0
}
 8011694:	bd70      	pop	{r4, r5, r6, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 8011696:	b124      	cbz	r4, 80116a2 <I2C_WaitOnTXISFlagUntilTimeout+0x3e>
 8011698:	f7fe ff28 	bl	80104ec <HAL_GetTick>
 801169c:	1b80      	subs	r0, r0, r6
 801169e:	42a0      	cmp	r0, r4
 80116a0:	d9e7      	bls.n	8011672 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80116a2:	6c6b      	ldr	r3, [r5, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80116a4:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80116a6:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80116a8:	430b      	orrs	r3, r1
 80116aa:	646b      	str	r3, [r5, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 80116ac:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
        hi2c->State = HAL_I2C_STATE_READY;
 80116b0:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
        __HAL_UNLOCK(hi2c);
 80116b4:	2003      	movs	r0, #3
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80116b6:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
}
 80116ba:	bd70      	pop	{r4, r5, r6, pc}

080116bc <I2C_RequestMemoryWrite>:
{
 80116bc:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80116be:	6806      	ldr	r6, [r0, #0]
 80116c0:	f8df c070 	ldr.w	ip, [pc, #112]	; 8011734 <I2C_RequestMemoryWrite+0x78>
 80116c4:	6874      	ldr	r4, [r6, #4]
 80116c6:	f3c1 0109 	ubfx	r1, r1, #0, #10
 80116ca:	f041 4101 	orr.w	r1, r1, #2164260864	; 0x81000000
 80116ce:	ea04 040c 	and.w	r4, r4, ip
 80116d2:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 80116d6:	4321      	orrs	r1, r4
{
 80116d8:	461f      	mov	r7, r3
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80116da:	b2db      	uxtb	r3, r3
{
 80116dc:	b083      	sub	sp, #12
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80116de:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
{
 80116e2:	4614      	mov	r4, r2
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80116e4:	6071      	str	r1, [r6, #4]
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80116e6:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
{
 80116ea:	4605      	mov	r5, r0
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80116ec:	f7ff ffba 	bl	8011664 <I2C_WaitOnTXISFlagUntilTimeout>
 80116f0:	b9c0      	cbnz	r0, 8011724 <I2C_RequestMemoryWrite+0x68>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 80116f2:	2f01      	cmp	r7, #1
 80116f4:	682b      	ldr	r3, [r5, #0]
 80116f6:	d10d      	bne.n	8011714 <I2C_RequestMemoryWrite+0x58>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 80116f8:	b2e4      	uxtb	r4, r4
 80116fa:	629c      	str	r4, [r3, #40]	; 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 80116fc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80116fe:	9300      	str	r3, [sp, #0]
 8011700:	4628      	mov	r0, r5
 8011702:	9b08      	ldr	r3, [sp, #32]
 8011704:	2200      	movs	r2, #0
 8011706:	2180      	movs	r1, #128	; 0x80
 8011708:	f7ff ff46 	bl	8011598 <I2C_WaitOnFlagUntilTimeout>
 801170c:	b170      	cbz	r0, 801172c <I2C_RequestMemoryWrite+0x70>
      return HAL_TIMEOUT;
 801170e:	2003      	movs	r0, #3
}
 8011710:	b003      	add	sp, #12
 8011712:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8011714:	0a22      	lsrs	r2, r4, #8
 8011716:	629a      	str	r2, [r3, #40]	; 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8011718:	4628      	mov	r0, r5
 801171a:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
 801171e:	f7ff ffa1 	bl	8011664 <I2C_WaitOnTXISFlagUntilTimeout>
 8011722:	b128      	cbz	r0, 8011730 <I2C_RequestMemoryWrite+0x74>
    if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8011724:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8011726:	2b04      	cmp	r3, #4
 8011728:	d1f1      	bne.n	801170e <I2C_RequestMemoryWrite+0x52>
      return HAL_ERROR;
 801172a:	2001      	movs	r0, #1
}
 801172c:	b003      	add	sp, #12
 801172e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8011730:	682b      	ldr	r3, [r5, #0]
 8011732:	e7e1      	b.n	80116f8 <I2C_RequestMemoryWrite+0x3c>
 8011734:	fc009800 	.word	0xfc009800

08011738 <I2C_RequestMemoryRead>:
{
 8011738:	b5f0      	push	{r4, r5, r6, r7, lr}
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 801173a:	6806      	ldr	r6, [r0, #0]
 801173c:	f8df c070 	ldr.w	ip, [pc, #112]	; 80117b0 <I2C_RequestMemoryRead+0x78>
 8011740:	6874      	ldr	r4, [r6, #4]
 8011742:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8011746:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 801174a:	ea04 040c 	and.w	r4, r4, ip
 801174e:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8011752:	4321      	orrs	r1, r4
{
 8011754:	461f      	mov	r7, r3
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011756:	b2db      	uxtb	r3, r3
{
 8011758:	b083      	sub	sp, #12
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 801175a:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
{
 801175e:	4614      	mov	r4, r2
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011760:	6071      	str	r1, [r6, #4]
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8011762:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
{
 8011766:	4605      	mov	r5, r0
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8011768:	f7ff ff7c 	bl	8011664 <I2C_WaitOnTXISFlagUntilTimeout>
 801176c:	b9c0      	cbnz	r0, 80117a0 <I2C_RequestMemoryRead+0x68>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 801176e:	2f01      	cmp	r7, #1
 8011770:	682b      	ldr	r3, [r5, #0]
 8011772:	d10d      	bne.n	8011790 <I2C_RequestMemoryRead+0x58>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8011774:	b2e4      	uxtb	r4, r4
 8011776:	629c      	str	r4, [r3, #40]	; 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 8011778:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801177a:	9300      	str	r3, [sp, #0]
 801177c:	4628      	mov	r0, r5
 801177e:	9b08      	ldr	r3, [sp, #32]
 8011780:	2200      	movs	r2, #0
 8011782:	2140      	movs	r1, #64	; 0x40
 8011784:	f7ff ff08 	bl	8011598 <I2C_WaitOnFlagUntilTimeout>
 8011788:	b170      	cbz	r0, 80117a8 <I2C_RequestMemoryRead+0x70>
      return HAL_TIMEOUT;
 801178a:	2003      	movs	r0, #3
}
 801178c:	b003      	add	sp, #12
 801178e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8011790:	0a22      	lsrs	r2, r4, #8
 8011792:	629a      	str	r2, [r3, #40]	; 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8011794:	4628      	mov	r0, r5
 8011796:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
 801179a:	f7ff ff63 	bl	8011664 <I2C_WaitOnTXISFlagUntilTimeout>
 801179e:	b128      	cbz	r0, 80117ac <I2C_RequestMemoryRead+0x74>
    if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80117a0:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80117a2:	2b04      	cmp	r3, #4
 80117a4:	d1f1      	bne.n	801178a <I2C_RequestMemoryRead+0x52>
      return HAL_ERROR;
 80117a6:	2001      	movs	r0, #1
}
 80117a8:	b003      	add	sp, #12
 80117aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 80117ac:	682b      	ldr	r3, [r5, #0]
 80117ae:	e7e1      	b.n	8011774 <I2C_RequestMemoryRead+0x3c>
 80117b0:	fc009800 	.word	0xfc009800

080117b4 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 80117b4:	b570      	push	{r4, r5, r6, lr}
 80117b6:	4605      	mov	r5, r0
 80117b8:	460c      	mov	r4, r1
 80117ba:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80117bc:	682b      	ldr	r3, [r5, #0]
 80117be:	699a      	ldr	r2, [r3, #24]
 80117c0:	0692      	lsls	r2, r2, #26
 80117c2:	d41e      	bmi.n	8011802 <I2C_WaitOnSTOPFlagUntilTimeout+0x4e>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 80117c4:	699b      	ldr	r3, [r3, #24]
 80117c6:	06d9      	lsls	r1, r3, #27
 80117c8:	d412      	bmi.n	80117f0 <I2C_WaitOnSTOPFlagUntilTimeout+0x3c>
    if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 80117ca:	b124      	cbz	r4, 80117d6 <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
 80117cc:	f7fe fe8e 	bl	80104ec <HAL_GetTick>
 80117d0:	1b80      	subs	r0, r0, r6
 80117d2:	42a0      	cmp	r0, r4
 80117d4:	d9f2      	bls.n	80117bc <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80117d6:	6c6b      	ldr	r3, [r5, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80117d8:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80117da:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80117dc:	430b      	orrs	r3, r1
 80117de:	646b      	str	r3, [r5, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 80117e0:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
        hi2c->State = HAL_I2C_STATE_READY;
 80117e4:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
        __HAL_UNLOCK(hi2c);
 80117e8:	2003      	movs	r0, #3
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80117ea:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
}
 80117ee:	bd70      	pop	{r4, r5, r6, pc}
 80117f0:	4632      	mov	r2, r6
 80117f2:	4621      	mov	r1, r4
 80117f4:	4628      	mov	r0, r5
 80117f6:	f7ff fef7 	bl	80115e8 <I2C_IsAcknowledgeFailed.part.0>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 80117fa:	2800      	cmp	r0, #0
 80117fc:	d0e5      	beq.n	80117ca <I2C_WaitOnSTOPFlagUntilTimeout+0x16>
      return HAL_ERROR;
 80117fe:	2001      	movs	r0, #1
}
 8011800:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_OK;
 8011802:	2000      	movs	r0, #0
}
 8011804:	bd70      	pop	{r4, r5, r6, pc}
 8011806:	bf00      	nop

08011808 <HAL_I2C_MspInit>:
}
 8011808:	4770      	bx	lr
 801180a:	bf00      	nop

0801180c <HAL_I2C_Init>:
  if (hi2c == NULL)
 801180c:	2800      	cmp	r0, #0
 801180e:	d04e      	beq.n	80118ae <HAL_I2C_Init+0xa2>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 8011810:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
{
 8011814:	b570      	push	{r4, r5, r6, lr}
  if (hi2c->State == HAL_I2C_STATE_RESET)
 8011816:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 801181a:	4604      	mov	r4, r0
 801181c:	2b00      	cmp	r3, #0
 801181e:	d041      	beq.n	80118a4 <HAL_I2C_Init+0x98>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8011820:	2224      	movs	r2, #36	; 0x24
 8011822:	1d21      	adds	r1, r4, #4
 8011824:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 8011828:	6823      	ldr	r3, [r4, #0]
 801182a:	c926      	ldmia	r1, {r1, r2, r5}
 801182c:	6818      	ldr	r0, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 801182e:	f021 6170 	bic.w	r1, r1, #251658240	; 0xf000000
  __HAL_I2C_DISABLE(hi2c);
 8011832:	f020 0001 	bic.w	r0, r0, #1
 8011836:	6018      	str	r0, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8011838:	6119      	str	r1, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 801183a:	6899      	ldr	r1, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 801183c:	2d01      	cmp	r5, #1
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 801183e:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
 8011842:	6099      	str	r1, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8011844:	d02a      	beq.n	801189c <HAL_I2C_Init+0x90>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8011846:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 801184a:	2d02      	cmp	r5, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 801184c:	609a      	str	r2, [r3, #8]
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 801184e:	bf04      	itt	eq
 8011850:	f44f 6200 	moveq.w	r2, #2048	; 0x800
 8011854:	605a      	streq	r2, [r3, #4]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8011856:	6859      	ldr	r1, [r3, #4]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8011858:	69a5      	ldr	r5, [r4, #24]
 801185a:	e9d4 2604 	ldrd	r2, r6, [r4, #16]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 801185e:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 8011862:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 8011866:	6059      	str	r1, [r3, #4]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8011868:	4332      	orrs	r2, r6
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 801186a:	68d8      	ldr	r0, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 801186c:	69e1      	ldr	r1, [r4, #28]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 801186e:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8011872:	6a25      	ldr	r5, [r4, #32]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8011874:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8011878:	4329      	orrs	r1, r5
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 801187a:	60d8      	str	r0, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 801187c:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 801187e:	6019      	str	r1, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 8011880:	6819      	ldr	r1, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8011882:	2200      	movs	r2, #0
  __HAL_I2C_ENABLE(hi2c);
 8011884:	f041 0101 	orr.w	r1, r1, #1
  hi2c->State = HAL_I2C_STATE_READY;
 8011888:	2520      	movs	r5, #32
  __HAL_I2C_ENABLE(hi2c);
 801188a:	6019      	str	r1, [r3, #0]
  return HAL_OK;
 801188c:	4610      	mov	r0, r2
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 801188e:	6462      	str	r2, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8011890:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8011894:	6322      	str	r2, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8011896:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 801189a:	bd70      	pop	{r4, r5, r6, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 801189c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80118a0:	609a      	str	r2, [r3, #8]
 80118a2:	e7d8      	b.n	8011856 <HAL_I2C_Init+0x4a>
    hi2c->Lock = HAL_UNLOCKED;
 80118a4:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
 80118a8:	f7ff ffae 	bl	8011808 <HAL_I2C_MspInit>
 80118ac:	e7b8      	b.n	8011820 <HAL_I2C_Init+0x14>
    return HAL_ERROR;
 80118ae:	2001      	movs	r0, #1
}
 80118b0:	4770      	bx	lr
 80118b2:	bf00      	nop

080118b4 <HAL_I2C_MspDeInit>:
 80118b4:	4770      	bx	lr
 80118b6:	bf00      	nop

080118b8 <HAL_I2C_DeInit>:
  if (hi2c == NULL)
 80118b8:	b1b0      	cbz	r0, 80118e8 <HAL_I2C_DeInit+0x30>
  __HAL_I2C_DISABLE(hi2c);
 80118ba:	6802      	ldr	r2, [r0, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 80118bc:	2324      	movs	r3, #36	; 0x24
{
 80118be:	b510      	push	{r4, lr}
  hi2c->State = HAL_I2C_STATE_BUSY;
 80118c0:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 80118c4:	6813      	ldr	r3, [r2, #0]
 80118c6:	f023 0301 	bic.w	r3, r3, #1
 80118ca:	4604      	mov	r4, r0
 80118cc:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
 80118ce:	f7ff fff1 	bl	80118b4 <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80118d2:	2300      	movs	r3, #0
 80118d4:	6463      	str	r3, [r4, #68]	; 0x44
  __HAL_UNLOCK(hi2c);
 80118d6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_RESET;
 80118da:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  return HAL_OK;
 80118de:	4618      	mov	r0, r3
  hi2c->PreviousState = I2C_STATE_NONE;
 80118e0:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80118e2:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
}
 80118e6:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 80118e8:	2001      	movs	r0, #1
}
 80118ea:	4770      	bx	lr

080118ec <HAL_I2C_Mem_Write>:
{
 80118ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
 80118f0:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
{
 80118f4:	b082      	sub	sp, #8
  if (hi2c->State == HAL_I2C_STATE_READY)
 80118f6:	2c20      	cmp	r4, #32
{
 80118f8:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
  if (hi2c->State == HAL_I2C_STATE_READY)
 80118fc:	f040 8086 	bne.w	8011a0c <HAL_I2C_Mem_Write+0x120>
    if ((pData == NULL) || (Size == 0U))
 8011900:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8011902:	2c00      	cmp	r4, #0
 8011904:	f000 8089 	beq.w	8011a1a <HAL_I2C_Mem_Write+0x12e>
 8011908:	f1b8 0f00 	cmp.w	r8, #0
 801190c:	f000 8085 	beq.w	8011a1a <HAL_I2C_Mem_Write+0x12e>
    __HAL_LOCK(hi2c);
 8011910:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
 8011914:	2c01      	cmp	r4, #1
 8011916:	d079      	beq.n	8011a0c <HAL_I2C_Mem_Write+0x120>
 8011918:	469a      	mov	sl, r3
 801191a:	2301      	movs	r3, #1
 801191c:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
 8011920:	4691      	mov	r9, r2
 8011922:	460f      	mov	r7, r1
 8011924:	4604      	mov	r4, r0
    tickstart = HAL_GetTick();
 8011926:	f7fe fde1 	bl	80104ec <HAL_GetTick>
 801192a:	4606      	mov	r6, r0
 801192c:	e004      	b.n	8011938 <HAL_I2C_Mem_Write+0x4c>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 801192e:	f7fe fddd 	bl	80104ec <HAL_GetTick>
 8011932:	1b80      	subs	r0, r0, r6
 8011934:	2819      	cmp	r0, #25
 8011936:	d874      	bhi.n	8011a22 <HAL_I2C_Mem_Write+0x136>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8011938:	6823      	ldr	r3, [r4, #0]
 801193a:	699d      	ldr	r5, [r3, #24]
 801193c:	f415 4500 	ands.w	r5, r5, #32768	; 0x8000
 8011940:	d1f5      	bne.n	801192e <HAL_I2C_Mem_Write+0x42>
    hi2c->pBuffPtr  = pData;
 8011942:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011944:	6263      	str	r3, [r4, #36]	; 0x24
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8011946:	2021      	movs	r0, #33	; 0x21
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8011948:	2140      	movs	r1, #64	; 0x40
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 801194a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    hi2c->XferISR   = NULL;
 801194c:	6365      	str	r5, [r4, #52]	; 0x34
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 801194e:	464a      	mov	r2, r9
 8011950:	9300      	str	r3, [sp, #0]
 8011952:	9601      	str	r6, [sp, #4]
 8011954:	4653      	mov	r3, sl
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8011956:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 801195a:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 801195e:	4620      	mov	r0, r4
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8011960:	6465      	str	r5, [r4, #68]	; 0x44
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8011962:	4639      	mov	r1, r7
    hi2c->XferCount = Size;
 8011964:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8011968:	f7ff fea8 	bl	80116bc <I2C_RequestMemoryWrite>
 801196c:	2800      	cmp	r0, #0
 801196e:	d162      	bne.n	8011a36 <HAL_I2C_Mem_Write+0x14a>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8011970:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8011972:	6822      	ldr	r2, [r4, #0]
 8011974:	2bff      	cmp	r3, #255	; 0xff
 8011976:	f3c7 0709 	ubfx	r7, r7, #0, #10
 801197a:	d970      	bls.n	8011a5e <HAL_I2C_Mem_Write+0x172>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 801197c:	6853      	ldr	r3, [r2, #4]
 801197e:	4849      	ldr	r0, [pc, #292]	; (8011aa4 <HAL_I2C_Mem_Write+0x1b8>)
 8011980:	f047 71ff 	orr.w	r1, r7, #33423360	; 0x1fe0000
 8011984:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 8011988:	4003      	ands	r3, r0
 801198a:	430b      	orrs	r3, r1
      hi2c->XferSize = MAX_NBYTE_SIZE;
 801198c:	21ff      	movs	r1, #255	; 0xff
 801198e:	8521      	strh	r1, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011990:	6053      	str	r3, [r2, #4]
 8011992:	f047 75ff 	orr.w	r5, r7, #33423360	; 0x1fe0000
 8011996:	f445 3580 	orr.w	r5, r5, #65536	; 0x10000
 801199a:	f8df 8108 	ldr.w	r8, [pc, #264]	; 8011aa4 <HAL_I2C_Mem_Write+0x1b8>
 801199e:	e003      	b.n	80119a8 <HAL_I2C_Mem_Write+0xbc>
    while (hi2c->XferCount > 0U);
 80119a0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80119a2:	b29b      	uxth	r3, r3
 80119a4:	2b00      	cmp	r3, #0
 80119a6:	d068      	beq.n	8011a7a <HAL_I2C_Mem_Write+0x18e>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 80119a8:	4632      	mov	r2, r6
 80119aa:	990c      	ldr	r1, [sp, #48]	; 0x30
 80119ac:	4620      	mov	r0, r4
 80119ae:	f7ff fe59 	bl	8011664 <I2C_WaitOnTXISFlagUntilTimeout>
 80119b2:	2800      	cmp	r0, #0
 80119b4:	d12e      	bne.n	8011a14 <HAL_I2C_Mem_Write+0x128>
      hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
 80119b6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80119b8:	6822      	ldr	r2, [r4, #0]
 80119ba:	1c59      	adds	r1, r3, #1
 80119bc:	6261      	str	r1, [r4, #36]	; 0x24
 80119be:	781b      	ldrb	r3, [r3, #0]
 80119c0:	6293      	str	r3, [r2, #40]	; 0x28
      hi2c->XferCount--;
 80119c2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 80119c4:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 80119c6:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 80119c8:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 80119ca:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 80119cc:	b292      	uxth	r2, r2
      hi2c->XferCount--;
 80119ce:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 80119d0:	8522      	strh	r2, [r4, #40]	; 0x28
      if ((hi2c->XferSize == 0U) && (hi2c->XferCount != 0U))
 80119d2:	2a00      	cmp	r2, #0
 80119d4:	d1e4      	bne.n	80119a0 <HAL_I2C_Mem_Write+0xb4>
 80119d6:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80119d8:	b29b      	uxth	r3, r3
 80119da:	2b00      	cmp	r3, #0
 80119dc:	d0e0      	beq.n	80119a0 <HAL_I2C_Mem_Write+0xb4>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 80119de:	9600      	str	r6, [sp, #0]
 80119e0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80119e2:	2180      	movs	r1, #128	; 0x80
 80119e4:	4620      	mov	r0, r4
 80119e6:	f7ff fdd7 	bl	8011598 <I2C_WaitOnFlagUntilTimeout>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80119ea:	f04f 0eff 	mov.w	lr, #255	; 0xff
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80119ee:	f047 7c00 	orr.w	ip, r7, #33554432	; 0x2000000
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 80119f2:	bb28      	cbnz	r0, 8011a40 <HAL_I2C_Mem_Write+0x154>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80119f4:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
 80119f6:	6822      	ldr	r2, [r4, #0]
 80119f8:	4571      	cmp	r1, lr
 80119fa:	d923      	bls.n	8011a44 <HAL_I2C_Mem_Write+0x158>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80119fc:	6853      	ldr	r3, [r2, #4]
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80119fe:	f8a4 e028 	strh.w	lr, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011a02:	ea03 0308 	and.w	r3, r3, r8
 8011a06:	432b      	orrs	r3, r5
 8011a08:	6053      	str	r3, [r2, #4]
 8011a0a:	e7c9      	b.n	80119a0 <HAL_I2C_Mem_Write+0xb4>
    return HAL_BUSY;
 8011a0c:	2002      	movs	r0, #2
}
 8011a0e:	b002      	add	sp, #8
 8011a10:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8011a14:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8011a16:	2b04      	cmp	r3, #4
 8011a18:	d112      	bne.n	8011a40 <HAL_I2C_Mem_Write+0x154>
        return HAL_ERROR;
 8011a1a:	2001      	movs	r0, #1
}
 8011a1c:	b002      	add	sp, #8
 8011a1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8011a22:	2300      	movs	r3, #0
        hi2c->State = HAL_I2C_STATE_READY;
 8011a24:	2220      	movs	r2, #32
 8011a26:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
        __HAL_UNLOCK(hi2c);
 8011a2a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8011a2e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      return HAL_TIMEOUT;
 8011a32:	2003      	movs	r0, #3
 8011a34:	e7eb      	b.n	8011a0e <HAL_I2C_Mem_Write+0x122>
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8011a36:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8011a38:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8011a3c:	2b04      	cmp	r3, #4
 8011a3e:	d0ec      	beq.n	8011a1a <HAL_I2C_Mem_Write+0x12e>
          return HAL_TIMEOUT;
 8011a40:	2003      	movs	r0, #3
 8011a42:	e7e4      	b.n	8011a0e <HAL_I2C_Mem_Write+0x122>
          hi2c->XferSize = hi2c->XferCount;
 8011a44:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011a46:	6853      	ldr	r3, [r2, #4]
          hi2c->XferSize = hi2c->XferCount;
 8011a48:	b289      	uxth	r1, r1
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011a4a:	ea03 0308 	and.w	r3, r3, r8
 8011a4e:	ea43 030c 	orr.w	r3, r3, ip
 8011a52:	b2c8      	uxtb	r0, r1
 8011a54:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
          hi2c->XferSize = hi2c->XferCount;
 8011a58:	8521      	strh	r1, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011a5a:	6053      	str	r3, [r2, #4]
 8011a5c:	e7a0      	b.n	80119a0 <HAL_I2C_Mem_Write+0xb4>
      hi2c->XferSize = hi2c->XferCount;
 8011a5e:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011a60:	4810      	ldr	r0, [pc, #64]	; (8011aa4 <HAL_I2C_Mem_Write+0x1b8>)
 8011a62:	6853      	ldr	r3, [r2, #4]
      hi2c->XferSize = hi2c->XferCount;
 8011a64:	b289      	uxth	r1, r1
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011a66:	4003      	ands	r3, r0
 8011a68:	f047 7000 	orr.w	r0, r7, #33554432	; 0x2000000
 8011a6c:	4303      	orrs	r3, r0
 8011a6e:	b2c8      	uxtb	r0, r1
 8011a70:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
      hi2c->XferSize = hi2c->XferCount;
 8011a74:	8521      	strh	r1, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011a76:	6053      	str	r3, [r2, #4]
 8011a78:	e78b      	b.n	8011992 <HAL_I2C_Mem_Write+0xa6>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8011a7a:	4632      	mov	r2, r6
 8011a7c:	990c      	ldr	r1, [sp, #48]	; 0x30
 8011a7e:	4620      	mov	r0, r4
 8011a80:	f7ff fe98 	bl	80117b4 <I2C_WaitOnSTOPFlagUntilTimeout>
 8011a84:	2800      	cmp	r0, #0
 8011a86:	d1c5      	bne.n	8011a14 <HAL_I2C_Mem_Write+0x128>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8011a88:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 8011a8a:	4d07      	ldr	r5, [pc, #28]	; (8011aa8 <HAL_I2C_Mem_Write+0x1bc>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8011a8c:	2120      	movs	r1, #32
 8011a8e:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8011a90:	685a      	ldr	r2, [r3, #4]
 8011a92:	402a      	ands	r2, r5
 8011a94:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8011a96:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8011a9a:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8011a9e:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 8011aa2:	e7b4      	b.n	8011a0e <HAL_I2C_Mem_Write+0x122>
 8011aa4:	fc009c00 	.word	0xfc009c00
 8011aa8:	fe00e800 	.word	0xfe00e800

08011aac <HAL_I2C_Mem_Read>:
{
 8011aac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
 8011ab0:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
{
 8011ab4:	b082      	sub	sp, #8
  if (hi2c->State == HAL_I2C_STATE_READY)
 8011ab6:	2c20      	cmp	r4, #32
{
 8011ab8:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
  if (hi2c->State == HAL_I2C_STATE_READY)
 8011abc:	f040 8086 	bne.w	8011bcc <HAL_I2C_Mem_Read+0x120>
    if ((pData == NULL) || (Size == 0U))
 8011ac0:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8011ac2:	2c00      	cmp	r4, #0
 8011ac4:	f000 8090 	beq.w	8011be8 <HAL_I2C_Mem_Read+0x13c>
 8011ac8:	f1b8 0f00 	cmp.w	r8, #0
 8011acc:	f000 808c 	beq.w	8011be8 <HAL_I2C_Mem_Read+0x13c>
    __HAL_LOCK(hi2c);
 8011ad0:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
 8011ad4:	2c01      	cmp	r4, #1
 8011ad6:	d079      	beq.n	8011bcc <HAL_I2C_Mem_Read+0x120>
 8011ad8:	469a      	mov	sl, r3
 8011ada:	2301      	movs	r3, #1
 8011adc:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
 8011ae0:	4691      	mov	r9, r2
 8011ae2:	460f      	mov	r7, r1
 8011ae4:	4604      	mov	r4, r0
    tickstart = HAL_GetTick();
 8011ae6:	f7fe fd01 	bl	80104ec <HAL_GetTick>
 8011aea:	4606      	mov	r6, r0
 8011aec:	e004      	b.n	8011af8 <HAL_I2C_Mem_Read+0x4c>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 8011aee:	f7fe fcfd 	bl	80104ec <HAL_GetTick>
 8011af2:	1b80      	subs	r0, r0, r6
 8011af4:	2819      	cmp	r0, #25
 8011af6:	d87b      	bhi.n	8011bf0 <HAL_I2C_Mem_Read+0x144>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8011af8:	6823      	ldr	r3, [r4, #0]
 8011afa:	699d      	ldr	r5, [r3, #24]
 8011afc:	f415 4500 	ands.w	r5, r5, #32768	; 0x8000
 8011b00:	d1f5      	bne.n	8011aee <HAL_I2C_Mem_Read+0x42>
    hi2c->pBuffPtr  = pData;
 8011b02:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011b04:	6263      	str	r3, [r4, #36]	; 0x24
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8011b06:	2022      	movs	r0, #34	; 0x22
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8011b08:	2140      	movs	r1, #64	; 0x40
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8011b0a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    hi2c->XferISR   = NULL;
 8011b0c:	6365      	str	r5, [r4, #52]	; 0x34
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8011b0e:	464a      	mov	r2, r9
 8011b10:	9300      	str	r3, [sp, #0]
 8011b12:	9601      	str	r6, [sp, #4]
 8011b14:	4653      	mov	r3, sl
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8011b16:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8011b1a:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8011b1e:	4620      	mov	r0, r4
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8011b20:	6465      	str	r5, [r4, #68]	; 0x44
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8011b22:	4639      	mov	r1, r7
    hi2c->XferCount = Size;
 8011b24:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8011b28:	f7ff fe06 	bl	8011738 <I2C_RequestMemoryRead>
 8011b2c:	2800      	cmp	r0, #0
 8011b2e:	d169      	bne.n	8011c04 <HAL_I2C_Mem_Read+0x158>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8011b30:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8011b32:	6822      	ldr	r2, [r4, #0]
 8011b34:	2bff      	cmp	r3, #255	; 0xff
 8011b36:	f3c7 0709 	ubfx	r7, r7, #0, #10
 8011b3a:	d976      	bls.n	8011c2a <HAL_I2C_Mem_Read+0x17e>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011b3c:	6853      	ldr	r3, [r2, #4]
 8011b3e:	484a      	ldr	r0, [pc, #296]	; (8011c68 <HAL_I2C_Mem_Read+0x1bc>)
 8011b40:	494a      	ldr	r1, [pc, #296]	; (8011c6c <HAL_I2C_Mem_Read+0x1c0>)
 8011b42:	4003      	ands	r3, r0
 8011b44:	4339      	orrs	r1, r7
 8011b46:	430b      	orrs	r3, r1
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8011b48:	21ff      	movs	r1, #255	; 0xff
 8011b4a:	8521      	strh	r1, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011b4c:	6053      	str	r3, [r2, #4]
 8011b4e:	f047 75ff 	orr.w	r5, r7, #33423360	; 0x1fe0000
 8011b52:	f445 3580 	orr.w	r5, r5, #65536	; 0x10000
 8011b56:	f8df 811c 	ldr.w	r8, [pc, #284]	; 8011c74 <HAL_I2C_Mem_Read+0x1c8>
 8011b5a:	e003      	b.n	8011b64 <HAL_I2C_Mem_Read+0xb8>
    while (hi2c->XferCount > 0U);
 8011b5c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8011b5e:	b29b      	uxth	r3, r3
 8011b60:	2b00      	cmp	r3, #0
 8011b62:	d037      	beq.n	8011bd4 <HAL_I2C_Mem_Read+0x128>
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 8011b64:	9600      	str	r6, [sp, #0]
 8011b66:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011b68:	2200      	movs	r2, #0
 8011b6a:	2104      	movs	r1, #4
 8011b6c:	4620      	mov	r0, r4
 8011b6e:	f7ff fd13 	bl	8011598 <I2C_WaitOnFlagUntilTimeout>
 8011b72:	2800      	cmp	r0, #0
 8011b74:	d14b      	bne.n	8011c0e <HAL_I2C_Mem_Read+0x162>
      (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
 8011b76:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8011b78:	6822      	ldr	r2, [r4, #0]
 8011b7a:	1c59      	adds	r1, r3, #1
 8011b7c:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8011b7e:	6261      	str	r1, [r4, #36]	; 0x24
 8011b80:	701a      	strb	r2, [r3, #0]
      hi2c->XferSize--;
 8011b82:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8011b84:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8011b86:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 8011b88:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 8011b8a:	b292      	uxth	r2, r2
      hi2c->XferCount--;
 8011b8c:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8011b8e:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8011b90:	8563      	strh	r3, [r4, #42]	; 0x2a
      if ((hi2c->XferSize == 0U) && (hi2c->XferCount != 0U))
 8011b92:	2a00      	cmp	r2, #0
 8011b94:	d1e2      	bne.n	8011b5c <HAL_I2C_Mem_Read+0xb0>
 8011b96:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8011b98:	b29b      	uxth	r3, r3
 8011b9a:	2b00      	cmp	r3, #0
 8011b9c:	d0de      	beq.n	8011b5c <HAL_I2C_Mem_Read+0xb0>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8011b9e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011ba0:	9600      	str	r6, [sp, #0]
 8011ba2:	2180      	movs	r1, #128	; 0x80
 8011ba4:	4620      	mov	r0, r4
 8011ba6:	f7ff fcf7 	bl	8011598 <I2C_WaitOnFlagUntilTimeout>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8011baa:	f04f 0cff 	mov.w	ip, #255	; 0xff
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011bae:	f047 7300 	orr.w	r3, r7, #33554432	; 0x2000000
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8011bb2:	bb60      	cbnz	r0, 8011c0e <HAL_I2C_Mem_Read+0x162>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8011bb4:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
 8011bb6:	6822      	ldr	r2, [r4, #0]
 8011bb8:	4561      	cmp	r1, ip
 8011bba:	d92a      	bls.n	8011c12 <HAL_I2C_Mem_Read+0x166>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011bbc:	6853      	ldr	r3, [r2, #4]
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8011bbe:	f8a4 c028 	strh.w	ip, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011bc2:	ea03 0308 	and.w	r3, r3, r8
 8011bc6:	432b      	orrs	r3, r5
 8011bc8:	6053      	str	r3, [r2, #4]
 8011bca:	e7c7      	b.n	8011b5c <HAL_I2C_Mem_Read+0xb0>
    return HAL_BUSY;
 8011bcc:	2002      	movs	r0, #2
}
 8011bce:	b002      	add	sp, #8
 8011bd0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8011bd4:	4632      	mov	r2, r6
 8011bd6:	990c      	ldr	r1, [sp, #48]	; 0x30
 8011bd8:	4620      	mov	r0, r4
 8011bda:	f7ff fdeb 	bl	80117b4 <I2C_WaitOnSTOPFlagUntilTimeout>
 8011bde:	2800      	cmp	r0, #0
 8011be0:	d033      	beq.n	8011c4a <HAL_I2C_Mem_Read+0x19e>
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8011be2:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8011be4:	2b04      	cmp	r3, #4
 8011be6:	d112      	bne.n	8011c0e <HAL_I2C_Mem_Read+0x162>
        return HAL_ERROR;
 8011be8:	2001      	movs	r0, #1
}
 8011bea:	b002      	add	sp, #8
 8011bec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8011bf0:	2300      	movs	r3, #0
        hi2c->State = HAL_I2C_STATE_READY;
 8011bf2:	2220      	movs	r2, #32
 8011bf4:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
        __HAL_UNLOCK(hi2c);
 8011bf8:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8011bfc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      return HAL_TIMEOUT;
 8011c00:	2003      	movs	r0, #3
 8011c02:	e7e4      	b.n	8011bce <HAL_I2C_Mem_Read+0x122>
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8011c04:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8011c06:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8011c0a:	2b04      	cmp	r3, #4
 8011c0c:	d0ec      	beq.n	8011be8 <HAL_I2C_Mem_Read+0x13c>
        return HAL_TIMEOUT;
 8011c0e:	2003      	movs	r0, #3
 8011c10:	e7dd      	b.n	8011bce <HAL_I2C_Mem_Read+0x122>
          hi2c->XferSize = hi2c->XferCount;
 8011c12:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011c14:	6850      	ldr	r0, [r2, #4]
          hi2c->XferSize = hi2c->XferCount;
 8011c16:	b289      	uxth	r1, r1
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011c18:	ea00 0008 	and.w	r0, r0, r8
 8011c1c:	4303      	orrs	r3, r0
 8011c1e:	b2c8      	uxtb	r0, r1
 8011c20:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
          hi2c->XferSize = hi2c->XferCount;
 8011c24:	8521      	strh	r1, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011c26:	6053      	str	r3, [r2, #4]
 8011c28:	e798      	b.n	8011b5c <HAL_I2C_Mem_Read+0xb0>
      hi2c->XferSize = hi2c->XferCount;
 8011c2a:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011c2c:	4d0e      	ldr	r5, [pc, #56]	; (8011c68 <HAL_I2C_Mem_Read+0x1bc>)
 8011c2e:	6853      	ldr	r3, [r2, #4]
 8011c30:	f047 4002 	orr.w	r0, r7, #2181038080	; 0x82000000
      hi2c->XferSize = hi2c->XferCount;
 8011c34:	b289      	uxth	r1, r1
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011c36:	f440 5010 	orr.w	r0, r0, #9216	; 0x2400
 8011c3a:	402b      	ands	r3, r5
 8011c3c:	4303      	orrs	r3, r0
 8011c3e:	b2c8      	uxtb	r0, r1
 8011c40:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
      hi2c->XferSize = hi2c->XferCount;
 8011c44:	8521      	strh	r1, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011c46:	6053      	str	r3, [r2, #4]
 8011c48:	e781      	b.n	8011b4e <HAL_I2C_Mem_Read+0xa2>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8011c4a:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 8011c4c:	4d08      	ldr	r5, [pc, #32]	; (8011c70 <HAL_I2C_Mem_Read+0x1c4>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8011c4e:	2120      	movs	r1, #32
 8011c50:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8011c52:	685a      	ldr	r2, [r3, #4]
 8011c54:	402a      	ands	r2, r5
 8011c56:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8011c58:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8011c5c:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8011c60:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 8011c64:	e7b3      	b.n	8011bce <HAL_I2C_Mem_Read+0x122>
 8011c66:	bf00      	nop
 8011c68:	fc009800 	.word	0xfc009800
 8011c6c:	81ff2400 	.word	0x81ff2400
 8011c70:	fe00e800 	.word	0xfe00e800
 8011c74:	fc009c00 	.word	0xfc009c00

08011c78 <HAL_I2C_GetState>:
  return hi2c->State;
 8011c78:	f890 0041 	ldrb.w	r0, [r0, #65]	; 0x41
}
 8011c7c:	4770      	bx	lr
 8011c7e:	bf00      	nop

08011c80 <HAL_PWR_EnableBkUpAccess>:
  *        back-up domain.                
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);    
 8011c80:	4a02      	ldr	r2, [pc, #8]	; (8011c8c <HAL_PWR_EnableBkUpAccess+0xc>)
 8011c82:	6813      	ldr	r3, [r2, #0]
 8011c84:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8011c88:	6013      	str	r3, [r2, #0]
}
 8011c8a:	4770      	bx	lr
 8011c8c:	40007000 	.word	0x40007000

08011c90 <HAL_PWR_DisableBkUpAccess>:
  *        (RTC registers, RTC backup data registers).    
  * @retval None
  */
void HAL_PWR_DisableBkUpAccess(void)
{
  CLEAR_BIT(PWR->CR1, PWR_CR1_DBP);   
 8011c90:	4a02      	ldr	r2, [pc, #8]	; (8011c9c <HAL_PWR_DisableBkUpAccess+0xc>)
 8011c92:	6813      	ldr	r3, [r2, #0]
 8011c94:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8011c98:	6013      	str	r3, [r2, #0]
}
 8011c9a:	4770      	bx	lr
 8011c9c:	40007000 	.word	0x40007000

08011ca0 <HAL_PWREx_GetVoltageRange>:
    else
    {
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
 8011ca0:	4b02      	ldr	r3, [pc, #8]	; (8011cac <HAL_PWREx_GetVoltageRange+0xc>)
 8011ca2:	6818      	ldr	r0, [r3, #0]
#endif  
}
 8011ca4:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8011ca8:	4770      	bx	lr
 8011caa:	bf00      	nop
 8011cac:	40007000 	.word	0x40007000

08011cb0 <HAL_PWREx_EnableVddIO2>:
  * @note  Remove VDDIO2 electrical and logical isolation, once VDDIO2 supply is present. 
  * @retval None
  */
void HAL_PWREx_EnableVddIO2(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_IOSV);
 8011cb0:	4a02      	ldr	r2, [pc, #8]	; (8011cbc <HAL_PWREx_EnableVddIO2+0xc>)
 8011cb2:	6853      	ldr	r3, [r2, #4]
 8011cb4:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8011cb8:	6053      	str	r3, [r2, #4]
}
 8011cba:	4770      	bx	lr
 8011cbc:	40007000 	.word	0x40007000

08011cc0 <HAL_PWREx_EnterSTOP2Mode>:
{
  /* Check the parameter */
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP2);
 8011cc0:	490c      	ldr	r1, [pc, #48]	; (8011cf4 <HAL_PWREx_EnterSTOP2Mode+0x34>)

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8011cc2:	4a0d      	ldr	r2, [pc, #52]	; (8011cf8 <HAL_PWREx_EnterSTOP2Mode+0x38>)
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP2);
 8011cc4:	680b      	ldr	r3, [r1, #0]
 8011cc6:	f023 0307 	bic.w	r3, r3, #7
 8011cca:	f043 0302 	orr.w	r3, r3, #2
 8011cce:	600b      	str	r3, [r1, #0]
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8011cd0:	6913      	ldr	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
 8011cd2:	2801      	cmp	r0, #1
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8011cd4:	f043 0304 	orr.w	r3, r3, #4
 8011cd8:	6113      	str	r3, [r2, #16]
  if(STOPEntry == PWR_STOPENTRY_WFI)
 8011cda:	d008      	beq.n	8011cee <HAL_PWREx_EnterSTOP2Mode+0x2e>
  __ASM volatile ("sev");
 8011cdc:	bf40      	sev
  __ASM volatile ("wfe");
 8011cde:	bf20      	wfe
 8011ce0:	bf20      	wfe
    __WFE();
    __WFE();
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8011ce2:	4a05      	ldr	r2, [pc, #20]	; (8011cf8 <HAL_PWREx_EnterSTOP2Mode+0x38>)
 8011ce4:	6913      	ldr	r3, [r2, #16]
 8011ce6:	f023 0304 	bic.w	r3, r3, #4
 8011cea:	6113      	str	r3, [r2, #16]
}
 8011cec:	4770      	bx	lr
  __ASM volatile ("wfi");
 8011cee:	bf30      	wfi
 8011cf0:	e7f7      	b.n	8011ce2 <HAL_PWREx_EnterSTOP2Mode+0x22>
 8011cf2:	bf00      	nop
 8011cf4:	40007000 	.word	0x40007000
 8011cf8:	e000ed00 	.word	0xe000ed00

08011cfc <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8011cfc:	b530      	push	{r4, r5, lr}
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8011cfe:	4d20      	ldr	r5, [pc, #128]	; (8011d80 <RCC_SetFlashLatencyFromMSIRange+0x84>)
 8011d00:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8011d02:	00db      	lsls	r3, r3, #3
{
 8011d04:	b083      	sub	sp, #12
 8011d06:	4604      	mov	r4, r0
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8011d08:	d51a      	bpl.n	8011d40 <RCC_SetFlashLatencyFromMSIRange+0x44>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8011d0a:	f7ff ffc9 	bl	8011ca0 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8011d0e:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8011d12:	d027      	beq.n	8011d64 <RCC_SetFlashLatencyFromMSIRange+0x68>
        latency = FLASH_LATENCY_1; /* 1WS */
      }
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#else
    if(msirange > RCC_MSIRANGE_8)
 8011d14:	2c80      	cmp	r4, #128	; 0x80
 8011d16:	d82c      	bhi.n	8011d72 <RCC_SetFlashLatencyFromMSIRange+0x76>
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
    }
    else
    {
      if(msirange == RCC_MSIRANGE_8)
 8011d18:	d02f      	beq.n	8011d7a <RCC_SetFlashLatencyFromMSIRange+0x7e>
      {
        /* MSI 16Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else if(msirange == RCC_MSIRANGE_7)
 8011d1a:	f1a4 0470 	sub.w	r4, r4, #112	; 0x70
 8011d1e:	fab4 f484 	clz	r4, r4
 8011d22:	0964      	lsrs	r4, r4, #5
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8011d24:	4917      	ldr	r1, [pc, #92]	; (8011d84 <RCC_SetFlashLatencyFromMSIRange+0x88>)
 8011d26:	680b      	ldr	r3, [r1, #0]
 8011d28:	f023 0307 	bic.w	r3, r3, #7
 8011d2c:	4323      	orrs	r3, r4
 8011d2e:	600b      	str	r3, [r1, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY) != latency)
 8011d30:	6808      	ldr	r0, [r1, #0]
 8011d32:	f000 0007 	and.w	r0, r0, #7
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 8011d36:	1b00      	subs	r0, r0, r4
 8011d38:	bf18      	it	ne
 8011d3a:	2001      	movne	r0, #1
 8011d3c:	b003      	add	sp, #12
 8011d3e:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 8011d40:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8011d42:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8011d46:	65ab      	str	r3, [r5, #88]	; 0x58
 8011d48:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8011d4a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8011d4e:	9301      	str	r3, [sp, #4]
 8011d50:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 8011d52:	f7ff ffa5 	bl	8011ca0 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 8011d56:	6dab      	ldr	r3, [r5, #88]	; 0x58
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8011d58:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    __HAL_RCC_PWR_CLK_DISABLE();
 8011d5c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8011d60:	65ab      	str	r3, [r5, #88]	; 0x58
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8011d62:	d1d7      	bne.n	8011d14 <RCC_SetFlashLatencyFromMSIRange+0x18>
    if(msirange > RCC_MSIRANGE_8)
 8011d64:	2c80      	cmp	r4, #128	; 0x80
 8011d66:	d906      	bls.n	8011d76 <RCC_SetFlashLatencyFromMSIRange+0x7a>
      if(msirange > RCC_MSIRANGE_10)
 8011d68:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_1; /* 1WS */
 8011d6a:	bf8c      	ite	hi
 8011d6c:	2402      	movhi	r4, #2
 8011d6e:	2401      	movls	r4, #1
 8011d70:	e7d8      	b.n	8011d24 <RCC_SetFlashLatencyFromMSIRange+0x28>
      latency = FLASH_LATENCY_3; /* 3WS */
 8011d72:	2403      	movs	r4, #3
 8011d74:	e7d6      	b.n	8011d24 <RCC_SetFlashLatencyFromMSIRange+0x28>
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8011d76:	2400      	movs	r4, #0
 8011d78:	e7d4      	b.n	8011d24 <RCC_SetFlashLatencyFromMSIRange+0x28>
        latency = FLASH_LATENCY_2; /* 2WS */
 8011d7a:	2402      	movs	r4, #2
 8011d7c:	e7d2      	b.n	8011d24 <RCC_SetFlashLatencyFromMSIRange+0x28>
 8011d7e:	bf00      	nop
 8011d80:	40021000 	.word	0x40021000
 8011d84:	40022000 	.word	0x40022000

08011d88 <HAL_RCC_GetSysClockFreq>:
  if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 8011d88:	4b3a      	ldr	r3, [pc, #232]	; (8011e74 <HAL_RCC_GetSysClockFreq+0xec>)
 8011d8a:	689a      	ldr	r2, [r3, #8]
 8011d8c:	f012 0f0c 	tst.w	r2, #12
 8011d90:	d03b      	beq.n	8011e0a <HAL_RCC_GetSysClockFreq+0x82>
     ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 8011d92:	689a      	ldr	r2, [r3, #8]
 8011d94:	f002 020c 	and.w	r2, r2, #12
  if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 8011d98:	2a0c      	cmp	r2, #12
 8011d9a:	d031      	beq.n	8011e00 <HAL_RCC_GetSysClockFreq+0x78>
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 8011d9c:	4a35      	ldr	r2, [pc, #212]	; (8011e74 <HAL_RCC_GetSysClockFreq+0xec>)
 8011d9e:	6893      	ldr	r3, [r2, #8]
 8011da0:	f003 030c 	and.w	r3, r3, #12
 8011da4:	2b04      	cmp	r3, #4
 8011da6:	d059      	beq.n	8011e5c <HAL_RCC_GetSysClockFreq+0xd4>
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 8011da8:	6893      	ldr	r3, [r2, #8]
 8011daa:	f003 030c 	and.w	r3, r3, #12
 8011dae:	2b08      	cmp	r3, #8
 8011db0:	d051      	beq.n	8011e56 <HAL_RCC_GetSysClockFreq+0xce>
  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8011db2:	4a30      	ldr	r2, [pc, #192]	; (8011e74 <HAL_RCC_GetSysClockFreq+0xec>)
 8011db4:	6893      	ldr	r3, [r2, #8]
 8011db6:	f003 030c 	and.w	r3, r3, #12
  uint32_t sysclockfreq = 0U;
 8011dba:	2000      	movs	r0, #0
  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8011dbc:	2b0c      	cmp	r3, #12
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
 8011dbe:	4601      	mov	r1, r0
  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8011dc0:	d13f      	bne.n	8011e42 <HAL_RCC_GetSysClockFreq+0xba>
{
 8011dc2:	b410      	push	{r4}
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8011dc4:	68d4      	ldr	r4, [r2, #12]
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8011dc6:	68d0      	ldr	r0, [r2, #12]
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8011dc8:	f004 0403 	and.w	r4, r4, #3
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8011dcc:	f3c0 1002 	ubfx	r0, r0, #4, #3
    switch (pllsource)
 8011dd0:	2c02      	cmp	r4, #2
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8011dd2:	f100 0301 	add.w	r3, r0, #1
    switch (pllsource)
 8011dd6:	d044      	beq.n	8011e62 <HAL_RCC_GetSysClockFreq+0xda>
 8011dd8:	2c03      	cmp	r4, #3
 8011dda:	d033      	beq.n	8011e44 <HAL_RCC_GetSysClockFreq+0xbc>
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8011ddc:	fbb1 f3f3 	udiv	r3, r1, r3
 8011de0:	68d0      	ldr	r0, [r2, #12]
 8011de2:	f3c0 2006 	ubfx	r0, r0, #8, #7
 8011de6:	fb03 f000 	mul.w	r0, r3, r0
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8011dea:	4b22      	ldr	r3, [pc, #136]	; (8011e74 <HAL_RCC_GetSysClockFreq+0xec>)
}
 8011dec:	f85d 4b04 	ldr.w	r4, [sp], #4
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8011df0:	68db      	ldr	r3, [r3, #12]
 8011df2:	f3c3 6341 	ubfx	r3, r3, #25, #2
 8011df6:	3301      	adds	r3, #1
 8011df8:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco/pllr;
 8011dfa:	fbb0 f0f3 	udiv	r0, r0, r3
}
 8011dfe:	4770      	bx	lr
     ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 8011e00:	68db      	ldr	r3, [r3, #12]
 8011e02:	f003 0303 	and.w	r3, r3, #3
 8011e06:	2b01      	cmp	r3, #1
 8011e08:	d1c8      	bne.n	8011d9c <HAL_RCC_GetSysClockFreq+0x14>
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
 8011e0a:	4b1a      	ldr	r3, [pc, #104]	; (8011e74 <HAL_RCC_GetSysClockFreq+0xec>)
    msirange = MSIRangeTable[msirange];
 8011e0c:	491a      	ldr	r1, [pc, #104]	; (8011e78 <HAL_RCC_GetSysClockFreq+0xf0>)
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
 8011e0e:	681a      	ldr	r2, [r3, #0]
 8011e10:	0712      	lsls	r2, r2, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8011e12:	bf54      	ite	pl
 8011e14:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8011e18:	681b      	ldrmi	r3, [r3, #0]
    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
 8011e1a:	4a16      	ldr	r2, [pc, #88]	; (8011e74 <HAL_RCC_GetSysClockFreq+0xec>)
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8011e1c:	bf54      	ite	pl
 8011e1e:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8011e22:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
 8011e26:	6892      	ldr	r2, [r2, #8]
    msirange = MSIRangeTable[msirange];
 8011e28:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
      sysclockfreq = msirange;
 8011e2c:	f012 0f0c 	tst.w	r2, #12
 8011e30:	bf0c      	ite	eq
 8011e32:	4608      	moveq	r0, r1
 8011e34:	2000      	movne	r0, #0
  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8011e36:	4a0f      	ldr	r2, [pc, #60]	; (8011e74 <HAL_RCC_GetSysClockFreq+0xec>)
 8011e38:	6893      	ldr	r3, [r2, #8]
 8011e3a:	f003 030c 	and.w	r3, r3, #12
 8011e3e:	2b0c      	cmp	r3, #12
 8011e40:	d0bf      	beq.n	8011dc2 <HAL_RCC_GetSysClockFreq+0x3a>
}
 8011e42:	4770      	bx	lr
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8011e44:	68d2      	ldr	r2, [r2, #12]
 8011e46:	480d      	ldr	r0, [pc, #52]	; (8011e7c <HAL_RCC_GetSysClockFreq+0xf4>)
 8011e48:	fbb0 f0f3 	udiv	r0, r0, r3
 8011e4c:	f3c2 2306 	ubfx	r3, r2, #8, #7
 8011e50:	fb00 f003 	mul.w	r0, r0, r3
      break;
 8011e54:	e7c9      	b.n	8011dea <HAL_RCC_GetSysClockFreq+0x62>
    sysclockfreq = HSE_VALUE;
 8011e56:	4809      	ldr	r0, [pc, #36]	; (8011e7c <HAL_RCC_GetSysClockFreq+0xf4>)
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
 8011e58:	2100      	movs	r1, #0
 8011e5a:	e7ec      	b.n	8011e36 <HAL_RCC_GetSysClockFreq+0xae>
    sysclockfreq = HSI_VALUE;
 8011e5c:	4808      	ldr	r0, [pc, #32]	; (8011e80 <HAL_RCC_GetSysClockFreq+0xf8>)
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
 8011e5e:	2100      	movs	r1, #0
 8011e60:	e7e9      	b.n	8011e36 <HAL_RCC_GetSysClockFreq+0xae>
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8011e62:	68d2      	ldr	r2, [r2, #12]
 8011e64:	4806      	ldr	r0, [pc, #24]	; (8011e80 <HAL_RCC_GetSysClockFreq+0xf8>)
 8011e66:	fbb0 f0f3 	udiv	r0, r0, r3
 8011e6a:	f3c2 2306 	ubfx	r3, r2, #8, #7
 8011e6e:	fb00 f003 	mul.w	r0, r0, r3
      break;
 8011e72:	e7ba      	b.n	8011dea <HAL_RCC_GetSysClockFreq+0x62>
 8011e74:	40021000 	.word	0x40021000
 8011e78:	08022ab4 	.word	0x08022ab4
 8011e7c:	007a1200 	.word	0x007a1200
 8011e80:	00f42400 	.word	0x00f42400

08011e84 <HAL_RCC_OscConfig>:
{
 8011e84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8011e88:	6803      	ldr	r3, [r0, #0]
{
 8011e8a:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8011e8c:	06d8      	lsls	r0, r3, #27
{
 8011e8e:	b082      	sub	sp, #8
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8011e90:	d53e      	bpl.n	8011f10 <HAL_RCC_OscConfig+0x8c>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
 8011e92:	4db3      	ldr	r5, [pc, #716]	; (8012160 <HAL_RCC_OscConfig+0x2dc>)
 8011e94:	68aa      	ldr	r2, [r5, #8]
 8011e96:	f012 0f0c 	tst.w	r2, #12
 8011e9a:	f040 8121 	bne.w	80120e0 <HAL_RCC_OscConfig+0x25c>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8011e9e:	682b      	ldr	r3, [r5, #0]
 8011ea0:	0799      	lsls	r1, r3, #30
 8011ea2:	f100 8143 	bmi.w	801212c <HAL_RCC_OscConfig+0x2a8>
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8011ea6:	4bae      	ldr	r3, [pc, #696]	; (8012160 <HAL_RCC_OscConfig+0x2dc>)
 8011ea8:	6a20      	ldr	r0, [r4, #32]
 8011eaa:	681a      	ldr	r2, [r3, #0]
 8011eac:	0712      	lsls	r2, r2, #28
 8011eae:	bf56      	itet	pl
 8011eb0:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 8011eb4:	681b      	ldrmi	r3, [r3, #0]
 8011eb6:	091b      	lsrpl	r3, r3, #4
 8011eb8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8011ebc:	4298      	cmp	r0, r3
 8011ebe:	f240 81b8 	bls.w	8012232 <HAL_RCC_OscConfig+0x3ae>
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8011ec2:	f7ff ff1b 	bl	8011cfc <RCC_SetFlashLatencyFromMSIRange>
 8011ec6:	2800      	cmp	r0, #0
 8011ec8:	f040 8134 	bne.w	8012134 <HAL_RCC_OscConfig+0x2b0>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8011ecc:	4ba4      	ldr	r3, [pc, #656]	; (8012160 <HAL_RCC_OscConfig+0x2dc>)
 8011ece:	681a      	ldr	r2, [r3, #0]
 8011ed0:	f042 0208 	orr.w	r2, r2, #8
 8011ed4:	601a      	str	r2, [r3, #0]
 8011ed6:	681a      	ldr	r2, [r3, #0]
 8011ed8:	6a21      	ldr	r1, [r4, #32]
 8011eda:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8011ede:	430a      	orrs	r2, r1
 8011ee0:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8011ee2:	685a      	ldr	r2, [r3, #4]
 8011ee4:	69e1      	ldr	r1, [r4, #28]
 8011ee6:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8011eea:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8011eee:	605a      	str	r2, [r3, #4]
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8011ef0:	f7ff ff4a 	bl	8011d88 <HAL_RCC_GetSysClockFreq>
 8011ef4:	4b9a      	ldr	r3, [pc, #616]	; (8012160 <HAL_RCC_OscConfig+0x2dc>)
 8011ef6:	499b      	ldr	r1, [pc, #620]	; (8012164 <HAL_RCC_OscConfig+0x2e0>)
 8011ef8:	689b      	ldr	r3, [r3, #8]
 8011efa:	4a9b      	ldr	r2, [pc, #620]	; (8012168 <HAL_RCC_OscConfig+0x2e4>)
 8011efc:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8011f00:	5ccb      	ldrb	r3, [r1, r3]
 8011f02:	fa20 f303 	lsr.w	r3, r0, r3
        HAL_InitTick (TICK_INT_PRIORITY);
 8011f06:	200f      	movs	r0, #15
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8011f08:	6013      	str	r3, [r2, #0]
        HAL_InitTick (TICK_INT_PRIORITY);
 8011f0a:	f7fe fac5 	bl	8010498 <HAL_InitTick>
 8011f0e:	6823      	ldr	r3, [r4, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8011f10:	07d9      	lsls	r1, r3, #31
 8011f12:	d52f      	bpl.n	8011f74 <HAL_RCC_OscConfig+0xf0>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||
 8011f14:	4992      	ldr	r1, [pc, #584]	; (8012160 <HAL_RCC_OscConfig+0x2dc>)
 8011f16:	688a      	ldr	r2, [r1, #8]
 8011f18:	f002 020c 	and.w	r2, r2, #12
 8011f1c:	2a08      	cmp	r2, #8
 8011f1e:	f000 8157 	beq.w	80121d0 <HAL_RCC_OscConfig+0x34c>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8011f22:	688a      	ldr	r2, [r1, #8]
 8011f24:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||
 8011f28:	2a0c      	cmp	r2, #12
 8011f2a:	f000 814b 	beq.w	80121c4 <HAL_RCC_OscConfig+0x340>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8011f2e:	6863      	ldr	r3, [r4, #4]
 8011f30:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8011f34:	f000 8156 	beq.w	80121e4 <HAL_RCC_OscConfig+0x360>
 8011f38:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8011f3c:	f000 81cf 	beq.w	80122de <HAL_RCC_OscConfig+0x45a>
 8011f40:	4d87      	ldr	r5, [pc, #540]	; (8012160 <HAL_RCC_OscConfig+0x2dc>)
 8011f42:	682a      	ldr	r2, [r5, #0]
 8011f44:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8011f48:	602a      	str	r2, [r5, #0]
 8011f4a:	682a      	ldr	r2, [r5, #0]
 8011f4c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8011f50:	602a      	str	r2, [r5, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8011f52:	2b00      	cmp	r3, #0
 8011f54:	f040 814b 	bne.w	80121ee <HAL_RCC_OscConfig+0x36a>
        tickstart = HAL_GetTick();
 8011f58:	f7fe fac8 	bl	80104ec <HAL_GetTick>
 8011f5c:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
 8011f5e:	e005      	b.n	8011f6c <HAL_RCC_OscConfig+0xe8>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8011f60:	f7fe fac4 	bl	80104ec <HAL_GetTick>
 8011f64:	1b80      	subs	r0, r0, r6
 8011f66:	2864      	cmp	r0, #100	; 0x64
 8011f68:	f200 815f 	bhi.w	801222a <HAL_RCC_OscConfig+0x3a6>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
 8011f6c:	682b      	ldr	r3, [r5, #0]
 8011f6e:	039f      	lsls	r7, r3, #14
 8011f70:	d4f6      	bmi.n	8011f60 <HAL_RCC_OscConfig+0xdc>
 8011f72:	6823      	ldr	r3, [r4, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8011f74:	079e      	lsls	r6, r3, #30
 8011f76:	f100 8088 	bmi.w	801208a <HAL_RCC_OscConfig+0x206>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8011f7a:	071a      	lsls	r2, r3, #28
 8011f7c:	d519      	bpl.n	8011fb2 <HAL_RCC_OscConfig+0x12e>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8011f7e:	6963      	ldr	r3, [r4, #20]
      __HAL_RCC_LSI_ENABLE();
 8011f80:	4d77      	ldr	r5, [pc, #476]	; (8012160 <HAL_RCC_OscConfig+0x2dc>)
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8011f82:	2b00      	cmp	r3, #0
 8011f84:	f000 80f4 	beq.w	8012170 <HAL_RCC_OscConfig+0x2ec>
      __HAL_RCC_LSI_ENABLE();
 8011f88:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8011f8c:	f043 0301 	orr.w	r3, r3, #1
 8011f90:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 8011f94:	f7fe faaa 	bl	80104ec <HAL_GetTick>
 8011f98:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == RESET)
 8011f9a:	e005      	b.n	8011fa8 <HAL_RCC_OscConfig+0x124>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8011f9c:	f7fe faa6 	bl	80104ec <HAL_GetTick>
 8011fa0:	1b80      	subs	r0, r0, r6
 8011fa2:	2802      	cmp	r0, #2
 8011fa4:	f200 8141 	bhi.w	801222a <HAL_RCC_OscConfig+0x3a6>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == RESET)
 8011fa8:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8011fac:	079b      	lsls	r3, r3, #30
 8011fae:	d5f5      	bpl.n	8011f9c <HAL_RCC_OscConfig+0x118>
 8011fb0:	6823      	ldr	r3, [r4, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8011fb2:	075e      	lsls	r6, r3, #29
 8011fb4:	d53e      	bpl.n	8012034 <HAL_RCC_OscConfig+0x1b0>
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 8011fb6:	4b6a      	ldr	r3, [pc, #424]	; (8012160 <HAL_RCC_OscConfig+0x2dc>)
 8011fb8:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8011fba:	00d5      	lsls	r5, r2, #3
 8011fbc:	f100 8150 	bmi.w	8012260 <HAL_RCC_OscConfig+0x3dc>
      __HAL_RCC_PWR_CLK_ENABLE();
 8011fc0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8011fc2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8011fc6:	659a      	str	r2, [r3, #88]	; 0x58
 8011fc8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8011fca:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8011fce:	9301      	str	r3, [sp, #4]
 8011fd0:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8011fd2:	2601      	movs	r6, #1
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8011fd4:	4d65      	ldr	r5, [pc, #404]	; (801216c <HAL_RCC_OscConfig+0x2e8>)
 8011fd6:	682a      	ldr	r2, [r5, #0]
 8011fd8:	05d0      	lsls	r0, r2, #23
 8011fda:	f140 8116 	bpl.w	801220a <HAL_RCC_OscConfig+0x386>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8011fde:	68a3      	ldr	r3, [r4, #8]
 8011fe0:	2b01      	cmp	r3, #1
 8011fe2:	f000 813f 	beq.w	8012264 <HAL_RCC_OscConfig+0x3e0>
 8011fe6:	2b05      	cmp	r3, #5
 8011fe8:	f000 8186 	beq.w	80122f8 <HAL_RCC_OscConfig+0x474>
 8011fec:	4d5c      	ldr	r5, [pc, #368]	; (8012160 <HAL_RCC_OscConfig+0x2dc>)
 8011fee:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 8011ff2:	f022 0201 	bic.w	r2, r2, #1
 8011ff6:	f8c5 2090 	str.w	r2, [r5, #144]	; 0x90
 8011ffa:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 8011ffe:	f022 0204 	bic.w	r2, r2, #4
 8012002:	f8c5 2090 	str.w	r2, [r5, #144]	; 0x90
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8012006:	2b00      	cmp	r3, #0
 8012008:	f040 8133 	bne.w	8012272 <HAL_RCC_OscConfig+0x3ee>
      tickstart = HAL_GetTick();
 801200c:	f7fe fa6e 	bl	80104ec <HAL_GetTick>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8012010:	f241 3788 	movw	r7, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8012014:	4680      	mov	r8, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != RESET)
 8012016:	e006      	b.n	8012026 <HAL_RCC_OscConfig+0x1a2>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8012018:	f7fe fa68 	bl	80104ec <HAL_GetTick>
 801201c:	eba0 0008 	sub.w	r0, r0, r8
 8012020:	42b8      	cmp	r0, r7
 8012022:	f200 8102 	bhi.w	801222a <HAL_RCC_OscConfig+0x3a6>
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != RESET)
 8012026:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 801202a:	079b      	lsls	r3, r3, #30
 801202c:	d4f4      	bmi.n	8012018 <HAL_RCC_OscConfig+0x194>
    if(pwrclkchanged == SET)
 801202e:	2e00      	cmp	r6, #0
 8012030:	f040 814f 	bne.w	80122d2 <HAL_RCC_OscConfig+0x44e>
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8012034:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8012036:	b322      	cbz	r2, 8012082 <HAL_RCC_OscConfig+0x1fe>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8012038:	4d49      	ldr	r5, [pc, #292]	; (8012160 <HAL_RCC_OscConfig+0x2dc>)
 801203a:	68a9      	ldr	r1, [r5, #8]
 801203c:	f001 010c 	and.w	r1, r1, #12
 8012040:	290c      	cmp	r1, #12
 8012042:	d077      	beq.n	8012134 <HAL_RCC_OscConfig+0x2b0>
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8012044:	2a02      	cmp	r2, #2
        __HAL_RCC_PLL_DISABLE();
 8012046:	682a      	ldr	r2, [r5, #0]
 8012048:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 801204c:	602a      	str	r2, [r5, #0]
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 801204e:	f000 8161 	beq.w	8012314 <HAL_RCC_OscConfig+0x490>
        if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == RESET)
 8012052:	682a      	ldr	r2, [r5, #0]
 8012054:	0111      	lsls	r1, r2, #4
 8012056:	f140 8133 	bpl.w	80122c0 <HAL_RCC_OscConfig+0x43c>
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 801205a:	4c41      	ldr	r4, [pc, #260]	; (8012160 <HAL_RCC_OscConfig+0x2dc>)
 801205c:	68e3      	ldr	r3, [r4, #12]
 801205e:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8012062:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8012066:	60e3      	str	r3, [r4, #12]
        tickstart = HAL_GetTick();
 8012068:	f7fe fa40 	bl	80104ec <HAL_GetTick>
 801206c:	4605      	mov	r5, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 801206e:	e005      	b.n	801207c <HAL_RCC_OscConfig+0x1f8>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8012070:	f7fe fa3c 	bl	80104ec <HAL_GetTick>
 8012074:	1b40      	subs	r0, r0, r5
 8012076:	2802      	cmp	r0, #2
 8012078:	f200 80d7 	bhi.w	801222a <HAL_RCC_OscConfig+0x3a6>
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 801207c:	6823      	ldr	r3, [r4, #0]
 801207e:	019b      	lsls	r3, r3, #6
 8012080:	d4f6      	bmi.n	8012070 <HAL_RCC_OscConfig+0x1ec>
  return HAL_OK;
 8012082:	2000      	movs	r0, #0
}
 8012084:	b002      	add	sp, #8
 8012086:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 801208a:	4935      	ldr	r1, [pc, #212]	; (8012160 <HAL_RCC_OscConfig+0x2dc>)
 801208c:	688a      	ldr	r2, [r1, #8]
 801208e:	f002 020c 	and.w	r2, r2, #12
 8012092:	2a04      	cmp	r2, #4
 8012094:	f000 8086 	beq.w	80121a4 <HAL_RCC_OscConfig+0x320>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8012098:	688a      	ldr	r2, [r1, #8]
 801209a:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 801209e:	2a0c      	cmp	r2, #12
 80120a0:	d07a      	beq.n	8012198 <HAL_RCC_OscConfig+0x314>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80120a2:	68e3      	ldr	r3, [r4, #12]
        __HAL_RCC_HSI_ENABLE();
 80120a4:	4d2e      	ldr	r5, [pc, #184]	; (8012160 <HAL_RCC_OscConfig+0x2dc>)
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80120a6:	2b00      	cmp	r3, #0
 80120a8:	f000 80f8 	beq.w	801229c <HAL_RCC_OscConfig+0x418>
        __HAL_RCC_HSI_ENABLE();
 80120ac:	682b      	ldr	r3, [r5, #0]
 80120ae:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80120b2:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80120b4:	f7fe fa1a 	bl	80104ec <HAL_GetTick>
 80120b8:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 80120ba:	e005      	b.n	80120c8 <HAL_RCC_OscConfig+0x244>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80120bc:	f7fe fa16 	bl	80104ec <HAL_GetTick>
 80120c0:	1b80      	subs	r0, r0, r6
 80120c2:	2802      	cmp	r0, #2
 80120c4:	f200 80b1 	bhi.w	801222a <HAL_RCC_OscConfig+0x3a6>
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 80120c8:	682b      	ldr	r3, [r5, #0]
 80120ca:	0558      	lsls	r0, r3, #21
 80120cc:	d5f6      	bpl.n	80120bc <HAL_RCC_OscConfig+0x238>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80120ce:	686b      	ldr	r3, [r5, #4]
 80120d0:	6922      	ldr	r2, [r4, #16]
 80120d2:	f023 53f8 	bic.w	r3, r3, #520093696	; 0x1f000000
 80120d6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80120da:	606b      	str	r3, [r5, #4]
 80120dc:	6823      	ldr	r3, [r4, #0]
 80120de:	e74c      	b.n	8011f7a <HAL_RCC_OscConfig+0xf6>
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 80120e0:	69a2      	ldr	r2, [r4, #24]
 80120e2:	b35a      	cbz	r2, 801213c <HAL_RCC_OscConfig+0x2b8>
        __HAL_RCC_MSI_ENABLE();
 80120e4:	682a      	ldr	r2, [r5, #0]
 80120e6:	f042 0201 	orr.w	r2, r2, #1
 80120ea:	602a      	str	r2, [r5, #0]
        tickstart = HAL_GetTick();
 80120ec:	f7fe f9fe 	bl	80104ec <HAL_GetTick>
 80120f0:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET)
 80120f2:	e005      	b.n	8012100 <HAL_RCC_OscConfig+0x27c>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80120f4:	f7fe f9fa 	bl	80104ec <HAL_GetTick>
 80120f8:	1b80      	subs	r0, r0, r6
 80120fa:	2802      	cmp	r0, #2
 80120fc:	f200 8095 	bhi.w	801222a <HAL_RCC_OscConfig+0x3a6>
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET)
 8012100:	682b      	ldr	r3, [r5, #0]
 8012102:	079f      	lsls	r7, r3, #30
 8012104:	d5f6      	bpl.n	80120f4 <HAL_RCC_OscConfig+0x270>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8012106:	682b      	ldr	r3, [r5, #0]
 8012108:	f043 0308 	orr.w	r3, r3, #8
 801210c:	602b      	str	r3, [r5, #0]
 801210e:	682b      	ldr	r3, [r5, #0]
 8012110:	6a22      	ldr	r2, [r4, #32]
 8012112:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8012116:	4313      	orrs	r3, r2
 8012118:	602b      	str	r3, [r5, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 801211a:	686b      	ldr	r3, [r5, #4]
 801211c:	69e2      	ldr	r2, [r4, #28]
 801211e:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8012122:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8012126:	606b      	str	r3, [r5, #4]
 8012128:	6823      	ldr	r3, [r4, #0]
 801212a:	e6f1      	b.n	8011f10 <HAL_RCC_OscConfig+0x8c>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 801212c:	69a3      	ldr	r3, [r4, #24]
 801212e:	2b00      	cmp	r3, #0
 8012130:	f47f aeb9 	bne.w	8011ea6 <HAL_RCC_OscConfig+0x22>
        return HAL_ERROR;
 8012134:	2001      	movs	r0, #1
}
 8012136:	b002      	add	sp, #8
 8012138:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        __HAL_RCC_MSI_DISABLE();
 801213c:	682a      	ldr	r2, [r5, #0]
 801213e:	f022 0201 	bic.w	r2, r2, #1
 8012142:	602a      	str	r2, [r5, #0]
        tickstart = HAL_GetTick();
 8012144:	f7fe f9d2 	bl	80104ec <HAL_GetTick>
 8012148:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != RESET)
 801214a:	e004      	b.n	8012156 <HAL_RCC_OscConfig+0x2d2>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 801214c:	f7fe f9ce 	bl	80104ec <HAL_GetTick>
 8012150:	1b80      	subs	r0, r0, r6
 8012152:	2802      	cmp	r0, #2
 8012154:	d869      	bhi.n	801222a <HAL_RCC_OscConfig+0x3a6>
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != RESET)
 8012156:	682b      	ldr	r3, [r5, #0]
 8012158:	0798      	lsls	r0, r3, #30
 801215a:	d4f7      	bmi.n	801214c <HAL_RCC_OscConfig+0x2c8>
 801215c:	6823      	ldr	r3, [r4, #0]
 801215e:	e6d7      	b.n	8011f10 <HAL_RCC_OscConfig+0x8c>
 8012160:	40021000 	.word	0x40021000
 8012164:	08022ae4 	.word	0x08022ae4
 8012168:	20000400 	.word	0x20000400
 801216c:	40007000 	.word	0x40007000
      __HAL_RCC_LSI_DISABLE();
 8012170:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8012174:	f023 0301 	bic.w	r3, r3, #1
 8012178:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 801217c:	f7fe f9b6 	bl	80104ec <HAL_GetTick>
 8012180:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != RESET)
 8012182:	e004      	b.n	801218e <HAL_RCC_OscConfig+0x30a>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8012184:	f7fe f9b2 	bl	80104ec <HAL_GetTick>
 8012188:	1b80      	subs	r0, r0, r6
 801218a:	2802      	cmp	r0, #2
 801218c:	d84d      	bhi.n	801222a <HAL_RCC_OscConfig+0x3a6>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != RESET)
 801218e:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8012192:	079f      	lsls	r7, r3, #30
 8012194:	d4f6      	bmi.n	8012184 <HAL_RCC_OscConfig+0x300>
 8012196:	e70b      	b.n	8011fb0 <HAL_RCC_OscConfig+0x12c>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8012198:	68ca      	ldr	r2, [r1, #12]
 801219a:	f002 0203 	and.w	r2, r2, #3
 801219e:	2a02      	cmp	r2, #2
 80121a0:	f47f af7f 	bne.w	80120a2 <HAL_RCC_OscConfig+0x21e>
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80121a4:	4a78      	ldr	r2, [pc, #480]	; (8012388 <HAL_RCC_OscConfig+0x504>)
 80121a6:	6812      	ldr	r2, [r2, #0]
 80121a8:	0555      	lsls	r5, r2, #21
 80121aa:	d502      	bpl.n	80121b2 <HAL_RCC_OscConfig+0x32e>
 80121ac:	68e2      	ldr	r2, [r4, #12]
 80121ae:	2a00      	cmp	r2, #0
 80121b0:	d0c0      	beq.n	8012134 <HAL_RCC_OscConfig+0x2b0>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80121b2:	4975      	ldr	r1, [pc, #468]	; (8012388 <HAL_RCC_OscConfig+0x504>)
 80121b4:	6920      	ldr	r0, [r4, #16]
 80121b6:	684a      	ldr	r2, [r1, #4]
 80121b8:	f022 52f8 	bic.w	r2, r2, #520093696	; 0x1f000000
 80121bc:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 80121c0:	604a      	str	r2, [r1, #4]
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80121c2:	e6da      	b.n	8011f7a <HAL_RCC_OscConfig+0xf6>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80121c4:	68ca      	ldr	r2, [r1, #12]
 80121c6:	f002 0203 	and.w	r2, r2, #3
 80121ca:	2a03      	cmp	r2, #3
 80121cc:	f47f aeaf 	bne.w	8011f2e <HAL_RCC_OscConfig+0xaa>
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80121d0:	4a6d      	ldr	r2, [pc, #436]	; (8012388 <HAL_RCC_OscConfig+0x504>)
 80121d2:	6812      	ldr	r2, [r2, #0]
 80121d4:	0392      	lsls	r2, r2, #14
 80121d6:	f57f aecd 	bpl.w	8011f74 <HAL_RCC_OscConfig+0xf0>
 80121da:	6862      	ldr	r2, [r4, #4]
 80121dc:	2a00      	cmp	r2, #0
 80121de:	f47f aec9 	bne.w	8011f74 <HAL_RCC_OscConfig+0xf0>
 80121e2:	e7a7      	b.n	8012134 <HAL_RCC_OscConfig+0x2b0>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80121e4:	4a68      	ldr	r2, [pc, #416]	; (8012388 <HAL_RCC_OscConfig+0x504>)
 80121e6:	6813      	ldr	r3, [r2, #0]
 80121e8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80121ec:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 80121ee:	f7fe f97d 	bl	80104ec <HAL_GetTick>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 80121f2:	4d65      	ldr	r5, [pc, #404]	; (8012388 <HAL_RCC_OscConfig+0x504>)
        tickstart = HAL_GetTick();
 80121f4:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 80121f6:	e004      	b.n	8012202 <HAL_RCC_OscConfig+0x37e>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80121f8:	f7fe f978 	bl	80104ec <HAL_GetTick>
 80121fc:	1b80      	subs	r0, r0, r6
 80121fe:	2864      	cmp	r0, #100	; 0x64
 8012200:	d813      	bhi.n	801222a <HAL_RCC_OscConfig+0x3a6>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 8012202:	682b      	ldr	r3, [r5, #0]
 8012204:	039b      	lsls	r3, r3, #14
 8012206:	d5f7      	bpl.n	80121f8 <HAL_RCC_OscConfig+0x374>
 8012208:	e6b3      	b.n	8011f72 <HAL_RCC_OscConfig+0xee>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 801220a:	682a      	ldr	r2, [r5, #0]
 801220c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8012210:	602a      	str	r2, [r5, #0]
      tickstart = HAL_GetTick();
 8012212:	f7fe f96b 	bl	80104ec <HAL_GetTick>
 8012216:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8012218:	682b      	ldr	r3, [r5, #0]
 801221a:	05d9      	lsls	r1, r3, #23
 801221c:	f53f aedf 	bmi.w	8011fde <HAL_RCC_OscConfig+0x15a>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8012220:	f7fe f964 	bl	80104ec <HAL_GetTick>
 8012224:	1bc0      	subs	r0, r0, r7
 8012226:	2802      	cmp	r0, #2
 8012228:	d9f6      	bls.n	8012218 <HAL_RCC_OscConfig+0x394>
            return HAL_TIMEOUT;
 801222a:	2003      	movs	r0, #3
}
 801222c:	b002      	add	sp, #8
 801222e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8012232:	4b55      	ldr	r3, [pc, #340]	; (8012388 <HAL_RCC_OscConfig+0x504>)
 8012234:	681a      	ldr	r2, [r3, #0]
 8012236:	f042 0208 	orr.w	r2, r2, #8
 801223a:	601a      	str	r2, [r3, #0]
 801223c:	681a      	ldr	r2, [r3, #0]
 801223e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8012242:	4302      	orrs	r2, r0
 8012244:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8012246:	685a      	ldr	r2, [r3, #4]
 8012248:	69e1      	ldr	r1, [r4, #28]
 801224a:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 801224e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8012252:	605a      	str	r2, [r3, #4]
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8012254:	f7ff fd52 	bl	8011cfc <RCC_SetFlashLatencyFromMSIRange>
 8012258:	2800      	cmp	r0, #0
 801225a:	f43f ae49 	beq.w	8011ef0 <HAL_RCC_OscConfig+0x6c>
 801225e:	e769      	b.n	8012134 <HAL_RCC_OscConfig+0x2b0>
    FlagStatus       pwrclkchanged = RESET;
 8012260:	2600      	movs	r6, #0
 8012262:	e6b7      	b.n	8011fd4 <HAL_RCC_OscConfig+0x150>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8012264:	4a48      	ldr	r2, [pc, #288]	; (8012388 <HAL_RCC_OscConfig+0x504>)
 8012266:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 801226a:	f043 0301 	orr.w	r3, r3, #1
 801226e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      tickstart = HAL_GetTick();
 8012272:	f7fe f93b 	bl	80104ec <HAL_GetTick>
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 8012276:	4d44      	ldr	r5, [pc, #272]	; (8012388 <HAL_RCC_OscConfig+0x504>)
      tickstart = HAL_GetTick();
 8012278:	4680      	mov	r8, r0
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 801227a:	f241 3788 	movw	r7, #5000	; 0x1388
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 801227e:	e005      	b.n	801228c <HAL_RCC_OscConfig+0x408>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8012280:	f7fe f934 	bl	80104ec <HAL_GetTick>
 8012284:	eba0 0008 	sub.w	r0, r0, r8
 8012288:	42b8      	cmp	r0, r7
 801228a:	d8ce      	bhi.n	801222a <HAL_RCC_OscConfig+0x3a6>
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 801228c:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8012290:	079a      	lsls	r2, r3, #30
 8012292:	d5f5      	bpl.n	8012280 <HAL_RCC_OscConfig+0x3fc>
    if(pwrclkchanged == SET)
 8012294:	2e00      	cmp	r6, #0
 8012296:	f43f aecd 	beq.w	8012034 <HAL_RCC_OscConfig+0x1b0>
 801229a:	e01a      	b.n	80122d2 <HAL_RCC_OscConfig+0x44e>
        __HAL_RCC_HSI_DISABLE();
 801229c:	682b      	ldr	r3, [r5, #0]
 801229e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80122a2:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80122a4:	f7fe f922 	bl	80104ec <HAL_GetTick>
 80122a8:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET)
 80122aa:	e004      	b.n	80122b6 <HAL_RCC_OscConfig+0x432>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80122ac:	f7fe f91e 	bl	80104ec <HAL_GetTick>
 80122b0:	1b80      	subs	r0, r0, r6
 80122b2:	2802      	cmp	r0, #2
 80122b4:	d8b9      	bhi.n	801222a <HAL_RCC_OscConfig+0x3a6>
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET)
 80122b6:	682b      	ldr	r3, [r5, #0]
 80122b8:	0559      	lsls	r1, r3, #21
 80122ba:	d4f7      	bmi.n	80122ac <HAL_RCC_OscConfig+0x428>
 80122bc:	6823      	ldr	r3, [r4, #0]
 80122be:	e65c      	b.n	8011f7a <HAL_RCC_OscConfig+0xf6>
           (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == RESET)
 80122c0:	682a      	ldr	r2, [r5, #0]
           &&
 80122c2:	0092      	lsls	r2, r2, #2
 80122c4:	f53f aec9 	bmi.w	801205a <HAL_RCC_OscConfig+0x1d6>
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 80122c8:	68ea      	ldr	r2, [r5, #12]
 80122ca:	f022 0203 	bic.w	r2, r2, #3
 80122ce:	60ea      	str	r2, [r5, #12]
 80122d0:	e6c3      	b.n	801205a <HAL_RCC_OscConfig+0x1d6>
      __HAL_RCC_PWR_CLK_DISABLE();
 80122d2:	4a2d      	ldr	r2, [pc, #180]	; (8012388 <HAL_RCC_OscConfig+0x504>)
 80122d4:	6d93      	ldr	r3, [r2, #88]	; 0x58
 80122d6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80122da:	6593      	str	r3, [r2, #88]	; 0x58
 80122dc:	e6aa      	b.n	8012034 <HAL_RCC_OscConfig+0x1b0>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80122de:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80122e2:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 80122e6:	681a      	ldr	r2, [r3, #0]
 80122e8:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80122ec:	601a      	str	r2, [r3, #0]
 80122ee:	681a      	ldr	r2, [r3, #0]
 80122f0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80122f4:	601a      	str	r2, [r3, #0]
 80122f6:	e77a      	b.n	80121ee <HAL_RCC_OscConfig+0x36a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80122f8:	4b23      	ldr	r3, [pc, #140]	; (8012388 <HAL_RCC_OscConfig+0x504>)
 80122fa:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80122fe:	f042 0204 	orr.w	r2, r2, #4
 8012302:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8012306:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 801230a:	f042 0201 	orr.w	r2, r2, #1
 801230e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8012312:	e7ae      	b.n	8012272 <HAL_RCC_OscConfig+0x3ee>
        tickstart = HAL_GetTick();
 8012314:	f7fe f8ea 	bl	80104ec <HAL_GetTick>
 8012318:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 801231a:	e004      	b.n	8012326 <HAL_RCC_OscConfig+0x4a2>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 801231c:	f7fe f8e6 	bl	80104ec <HAL_GetTick>
 8012320:	1b80      	subs	r0, r0, r6
 8012322:	2802      	cmp	r0, #2
 8012324:	d881      	bhi.n	801222a <HAL_RCC_OscConfig+0x3a6>
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 8012326:	682b      	ldr	r3, [r5, #0]
 8012328:	019f      	lsls	r7, r3, #6
 801232a:	d4f7      	bmi.n	801231c <HAL_RCC_OscConfig+0x498>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 801232c:	f104 032c 	add.w	r3, r4, #44	; 0x2c
 8012330:	cbc8      	ldmia	r3, {r3, r6, r7}
 8012332:	e9d4 010e 	ldrd	r0, r1, [r4, #56]	; 0x38
 8012336:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8012338:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
 801233c:	1e74      	subs	r4, r6, #1
 801233e:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
 8012342:	0900      	lsrs	r0, r0, #4
 8012344:	0849      	lsrs	r1, r1, #1
 8012346:	ea43 4340 	orr.w	r3, r3, r0, lsl #17
 801234a:	3901      	subs	r1, #1
 801234c:	0852      	lsrs	r2, r2, #1
 801234e:	ea43 5341 	orr.w	r3, r3, r1, lsl #21
 8012352:	3a01      	subs	r2, #1
 8012354:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8012358:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLL_ENABLE();
 801235a:	682b      	ldr	r3, [r5, #0]
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 801235c:	4c0a      	ldr	r4, [pc, #40]	; (8012388 <HAL_RCC_OscConfig+0x504>)
        __HAL_RCC_PLL_ENABLE();
 801235e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8012362:	602b      	str	r3, [r5, #0]
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8012364:	68eb      	ldr	r3, [r5, #12]
 8012366:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 801236a:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
 801236c:	f7fe f8be 	bl	80104ec <HAL_GetTick>
 8012370:	4605      	mov	r5, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 8012372:	e005      	b.n	8012380 <HAL_RCC_OscConfig+0x4fc>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8012374:	f7fe f8ba 	bl	80104ec <HAL_GetTick>
 8012378:	1b40      	subs	r0, r0, r5
 801237a:	2802      	cmp	r0, #2
 801237c:	f63f af55 	bhi.w	801222a <HAL_RCC_OscConfig+0x3a6>
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 8012380:	6823      	ldr	r3, [r4, #0]
 8012382:	0198      	lsls	r0, r3, #6
 8012384:	d5f6      	bpl.n	8012374 <HAL_RCC_OscConfig+0x4f0>
 8012386:	e67c      	b.n	8012082 <HAL_RCC_OscConfig+0x1fe>
 8012388:	40021000 	.word	0x40021000

0801238c <HAL_RCC_ClockConfig>:
  if(FLatency > READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY))
 801238c:	4a57      	ldr	r2, [pc, #348]	; (80124ec <HAL_RCC_ClockConfig+0x160>)
 801238e:	6813      	ldr	r3, [r2, #0]
 8012390:	f003 0307 	and.w	r3, r3, #7
 8012394:	428b      	cmp	r3, r1
 8012396:	d20b      	bcs.n	80123b0 <HAL_RCC_ClockConfig+0x24>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8012398:	6813      	ldr	r3, [r2, #0]
 801239a:	f023 0307 	bic.w	r3, r3, #7
 801239e:	430b      	orrs	r3, r1
 80123a0:	6013      	str	r3, [r2, #0]
    if(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY) != FLatency)
 80123a2:	6813      	ldr	r3, [r2, #0]
 80123a4:	f003 0307 	and.w	r3, r3, #7
 80123a8:	428b      	cmp	r3, r1
 80123aa:	d001      	beq.n	80123b0 <HAL_RCC_ClockConfig+0x24>
      return HAL_ERROR;
 80123ac:	2001      	movs	r0, #1
}
 80123ae:	4770      	bx	lr
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80123b0:	6803      	ldr	r3, [r0, #0]
{
 80123b2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80123b6:	460d      	mov	r5, r1
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80123b8:	07d9      	lsls	r1, r3, #31
 80123ba:	4604      	mov	r4, r0
 80123bc:	d41b      	bmi.n	80123f6 <HAL_RCC_ClockConfig+0x6a>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80123be:	0799      	lsls	r1, r3, #30
 80123c0:	d506      	bpl.n	80123d0 <HAL_RCC_ClockConfig+0x44>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80123c2:	494b      	ldr	r1, [pc, #300]	; (80124f0 <HAL_RCC_ClockConfig+0x164>)
 80123c4:	68a0      	ldr	r0, [r4, #8]
 80123c6:	688a      	ldr	r2, [r1, #8]
 80123c8:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80123cc:	4302      	orrs	r2, r0
 80123ce:	608a      	str	r2, [r1, #8]
  if(FLatency < READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY))
 80123d0:	4946      	ldr	r1, [pc, #280]	; (80124ec <HAL_RCC_ClockConfig+0x160>)
 80123d2:	680a      	ldr	r2, [r1, #0]
 80123d4:	f002 0207 	and.w	r2, r2, #7
 80123d8:	42aa      	cmp	r2, r5
 80123da:	d92a      	bls.n	8012432 <HAL_RCC_ClockConfig+0xa6>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80123dc:	680a      	ldr	r2, [r1, #0]
 80123de:	f022 0207 	bic.w	r2, r2, #7
 80123e2:	432a      	orrs	r2, r5
 80123e4:	600a      	str	r2, [r1, #0]
    if(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY) != FLatency)
 80123e6:	680a      	ldr	r2, [r1, #0]
 80123e8:	f002 0207 	and.w	r2, r2, #7
 80123ec:	42aa      	cmp	r2, r5
 80123ee:	d020      	beq.n	8012432 <HAL_RCC_ClockConfig+0xa6>
      return HAL_ERROR;
 80123f0:	2001      	movs	r0, #1
}
 80123f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80123f6:	6843      	ldr	r3, [r0, #4]
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 80123f8:	4a3d      	ldr	r2, [pc, #244]	; (80124f0 <HAL_RCC_ClockConfig+0x164>)
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80123fa:	2b03      	cmp	r3, #3
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 80123fc:	6812      	ldr	r2, [r2, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80123fe:	d06c      	beq.n	80124da <HAL_RCC_ClockConfig+0x14e>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8012400:	2b02      	cmp	r3, #2
 8012402:	d03b      	beq.n	801247c <HAL_RCC_ClockConfig+0xf0>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8012404:	2b00      	cmp	r3, #0
 8012406:	d16d      	bne.n	80124e4 <HAL_RCC_ClockConfig+0x158>
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET)
 8012408:	0796      	lsls	r6, r2, #30
 801240a:	d5f1      	bpl.n	80123f0 <HAL_RCC_ClockConfig+0x64>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 801240c:	4e38      	ldr	r6, [pc, #224]	; (80124f0 <HAL_RCC_ClockConfig+0x164>)
 801240e:	68b2      	ldr	r2, [r6, #8]
 8012410:	f022 0203 	bic.w	r2, r2, #3
 8012414:	4313      	orrs	r3, r2
 8012416:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 8012418:	f7fe f868 	bl	80104ec <HAL_GetTick>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 801241c:	6863      	ldr	r3, [r4, #4]
 801241e:	2b03      	cmp	r3, #3
    tickstart = HAL_GetTick();
 8012420:	4607      	mov	r7, r0
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8012422:	f241 3888 	movw	r8, #5000	; 0x1388
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8012426:	d031      	beq.n	801248c <HAL_RCC_ClockConfig+0x100>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8012428:	2b02      	cmp	r3, #2
 801242a:	d03b      	beq.n	80124a4 <HAL_RCC_ClockConfig+0x118>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 801242c:	2b00      	cmp	r3, #0
 801242e:	d144      	bne.n	80124ba <HAL_RCC_ClockConfig+0x12e>
 8012430:	e04e      	b.n	80124d0 <HAL_RCC_ClockConfig+0x144>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8012432:	075a      	lsls	r2, r3, #29
 8012434:	d506      	bpl.n	8012444 <HAL_RCC_ClockConfig+0xb8>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8012436:	492e      	ldr	r1, [pc, #184]	; (80124f0 <HAL_RCC_ClockConfig+0x164>)
 8012438:	68e0      	ldr	r0, [r4, #12]
 801243a:	688a      	ldr	r2, [r1, #8]
 801243c:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8012440:	4302      	orrs	r2, r0
 8012442:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8012444:	071b      	lsls	r3, r3, #28
 8012446:	d507      	bpl.n	8012458 <HAL_RCC_ClockConfig+0xcc>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8012448:	4a29      	ldr	r2, [pc, #164]	; (80124f0 <HAL_RCC_ClockConfig+0x164>)
 801244a:	6921      	ldr	r1, [r4, #16]
 801244c:	6893      	ldr	r3, [r2, #8]
 801244e:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8012452:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8012456:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8012458:	f7ff fc96 	bl	8011d88 <HAL_RCC_GetSysClockFreq>
 801245c:	4b24      	ldr	r3, [pc, #144]	; (80124f0 <HAL_RCC_ClockConfig+0x164>)
 801245e:	4925      	ldr	r1, [pc, #148]	; (80124f4 <HAL_RCC_ClockConfig+0x168>)
 8012460:	689b      	ldr	r3, [r3, #8]
 8012462:	4a25      	ldr	r2, [pc, #148]	; (80124f8 <HAL_RCC_ClockConfig+0x16c>)
 8012464:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8012468:	5ccb      	ldrb	r3, [r1, r3]
 801246a:	fa20 f303 	lsr.w	r3, r0, r3
  HAL_InitTick (TICK_INT_PRIORITY);
 801246e:	200f      	movs	r0, #15
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8012470:	6013      	str	r3, [r2, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 8012472:	f7fe f811 	bl	8010498 <HAL_InitTick>
  return HAL_OK;
 8012476:	2000      	movs	r0, #0
}
 8012478:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 801247c:	0397      	lsls	r7, r2, #14
 801247e:	d4c5      	bmi.n	801240c <HAL_RCC_ClockConfig+0x80>
 8012480:	e7b6      	b.n	80123f0 <HAL_RCC_ClockConfig+0x64>
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8012482:	f7fe f833 	bl	80104ec <HAL_GetTick>
 8012486:	1bc0      	subs	r0, r0, r7
 8012488:	4540      	cmp	r0, r8
 801248a:	d829      	bhi.n	80124e0 <HAL_RCC_ClockConfig+0x154>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 801248c:	68b3      	ldr	r3, [r6, #8]
 801248e:	f003 030c 	and.w	r3, r3, #12
 8012492:	2b0c      	cmp	r3, #12
 8012494:	d1f5      	bne.n	8012482 <HAL_RCC_ClockConfig+0xf6>
 8012496:	6823      	ldr	r3, [r4, #0]
 8012498:	e791      	b.n	80123be <HAL_RCC_ClockConfig+0x32>
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 801249a:	f7fe f827 	bl	80104ec <HAL_GetTick>
 801249e:	1bc0      	subs	r0, r0, r7
 80124a0:	4540      	cmp	r0, r8
 80124a2:	d81d      	bhi.n	80124e0 <HAL_RCC_ClockConfig+0x154>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 80124a4:	68b3      	ldr	r3, [r6, #8]
 80124a6:	f003 030c 	and.w	r3, r3, #12
 80124aa:	2b08      	cmp	r3, #8
 80124ac:	d1f5      	bne.n	801249a <HAL_RCC_ClockConfig+0x10e>
 80124ae:	e7f2      	b.n	8012496 <HAL_RCC_ClockConfig+0x10a>
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80124b0:	f7fe f81c 	bl	80104ec <HAL_GetTick>
 80124b4:	1bc0      	subs	r0, r0, r7
 80124b6:	4540      	cmp	r0, r8
 80124b8:	d812      	bhi.n	80124e0 <HAL_RCC_ClockConfig+0x154>
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80124ba:	68b3      	ldr	r3, [r6, #8]
 80124bc:	f003 030c 	and.w	r3, r3, #12
 80124c0:	2b04      	cmp	r3, #4
 80124c2:	d1f5      	bne.n	80124b0 <HAL_RCC_ClockConfig+0x124>
 80124c4:	e7e7      	b.n	8012496 <HAL_RCC_ClockConfig+0x10a>
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80124c6:	f7fe f811 	bl	80104ec <HAL_GetTick>
 80124ca:	1bc0      	subs	r0, r0, r7
 80124cc:	4540      	cmp	r0, r8
 80124ce:	d807      	bhi.n	80124e0 <HAL_RCC_ClockConfig+0x154>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
 80124d0:	68b3      	ldr	r3, [r6, #8]
 80124d2:	f013 0f0c 	tst.w	r3, #12
 80124d6:	d1f6      	bne.n	80124c6 <HAL_RCC_ClockConfig+0x13a>
 80124d8:	e7dd      	b.n	8012496 <HAL_RCC_ClockConfig+0x10a>
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 80124da:	0192      	lsls	r2, r2, #6
 80124dc:	d496      	bmi.n	801240c <HAL_RCC_ClockConfig+0x80>
 80124de:	e787      	b.n	80123f0 <HAL_RCC_ClockConfig+0x64>
          return HAL_TIMEOUT;
 80124e0:	2003      	movs	r0, #3
 80124e2:	e786      	b.n	80123f2 <HAL_RCC_ClockConfig+0x66>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 80124e4:	0550      	lsls	r0, r2, #21
 80124e6:	d583      	bpl.n	80123f0 <HAL_RCC_ClockConfig+0x64>
 80124e8:	e790      	b.n	801240c <HAL_RCC_ClockConfig+0x80>
 80124ea:	bf00      	nop
 80124ec:	40022000 	.word	0x40022000
 80124f0:	40021000 	.word	0x40021000
 80124f4:	08022ae4 	.word	0x08022ae4
 80124f8:	20000400 	.word	0x20000400

080124fc <RCCEx_PLLSAI1_Config>:
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 80124fc:	4a45      	ldr	r2, [pc, #276]	; (8012614 <RCCEx_PLLSAI1_Config+0x118>)
{
 80124fe:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8012500:	68d4      	ldr	r4, [r2, #12]
 8012502:	6803      	ldr	r3, [r0, #0]
 8012504:	07a4      	lsls	r4, r4, #30
 8012506:	d006      	beq.n	8012516 <RCCEx_PLLSAI1_Config+0x1a>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 8012508:	68d4      	ldr	r4, [r2, #12]
 801250a:	f004 0403 	and.w	r4, r4, #3
 801250e:	429c      	cmp	r4, r3
 8012510:	d00b      	beq.n	801252a <RCCEx_PLLSAI1_Config+0x2e>
 8012512:	2001      	movs	r0, #1
      }
    }
  }

  return status;
}
 8012514:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch(PllSai1->PLLSAI1Source)
 8012516:	2b02      	cmp	r3, #2
 8012518:	d011      	beq.n	801253e <RCCEx_PLLSAI1_Config+0x42>
 801251a:	2b03      	cmp	r3, #3
 801251c:	d056      	beq.n	80125cc <RCCEx_PLLSAI1_Config+0xd0>
 801251e:	2b01      	cmp	r3, #1
 8012520:	d1f7      	bne.n	8012512 <RCCEx_PLLSAI1_Config+0x16>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8012522:	6812      	ldr	r2, [r2, #0]
 8012524:	0797      	lsls	r7, r2, #30
 8012526:	d5f4      	bpl.n	8012512 <RCCEx_PLLSAI1_Config+0x16>
 8012528:	e00c      	b.n	8012544 <RCCEx_PLLSAI1_Config+0x48>
       ||
 801252a:	2c00      	cmp	r4, #0
 801252c:	d0f1      	beq.n	8012512 <RCCEx_PLLSAI1_Config+0x16>
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
 801252e:	68d3      	ldr	r3, [r2, #12]
       ||
 8012530:	6842      	ldr	r2, [r0, #4]
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
 8012532:	f3c3 1302 	ubfx	r3, r3, #4, #3
 8012536:	3301      	adds	r3, #1
       ||
 8012538:	4293      	cmp	r3, r2
 801253a:	d1ea      	bne.n	8012512 <RCCEx_PLLSAI1_Config+0x16>
 801253c:	e00c      	b.n	8012558 <RCCEx_PLLSAI1_Config+0x5c>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 801253e:	6812      	ldr	r2, [r2, #0]
 8012540:	0556      	lsls	r6, r2, #21
 8012542:	d5e6      	bpl.n	8012512 <RCCEx_PLLSAI1_Config+0x16>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai1->PLLSAI1Source | (PllSai1->PLLSAI1M - 1U) << RCC_PLLCFGR_PLLM_Pos);
 8012544:	4d33      	ldr	r5, [pc, #204]	; (8012614 <RCCEx_PLLSAI1_Config+0x118>)
 8012546:	6844      	ldr	r4, [r0, #4]
 8012548:	68ea      	ldr	r2, [r5, #12]
 801254a:	f022 0273 	bic.w	r2, r2, #115	; 0x73
 801254e:	4313      	orrs	r3, r2
 8012550:	3c01      	subs	r4, #1
 8012552:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
 8012556:	60eb      	str	r3, [r5, #12]
    __HAL_RCC_PLLSAI1_DISABLE();
 8012558:	4c2e      	ldr	r4, [pc, #184]	; (8012614 <RCCEx_PLLSAI1_Config+0x118>)
 801255a:	6823      	ldr	r3, [r4, #0]
 801255c:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8012560:	6023      	str	r3, [r4, #0]
 8012562:	460f      	mov	r7, r1
 8012564:	4605      	mov	r5, r0
    tickstart = HAL_GetTick();
 8012566:	f7fd ffc1 	bl	80104ec <HAL_GetTick>
 801256a:	4606      	mov	r6, r0
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != RESET)
 801256c:	e004      	b.n	8012578 <RCCEx_PLLSAI1_Config+0x7c>
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 801256e:	f7fd ffbd 	bl	80104ec <HAL_GetTick>
 8012572:	1b80      	subs	r0, r0, r6
 8012574:	2802      	cmp	r0, #2
 8012576:	d827      	bhi.n	80125c8 <RCCEx_PLLSAI1_Config+0xcc>
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != RESET)
 8012578:	6823      	ldr	r3, [r4, #0]
 801257a:	011a      	lsls	r2, r3, #4
 801257c:	d4f7      	bmi.n	801256e <RCCEx_PLLSAI1_Config+0x72>
 801257e:	68ab      	ldr	r3, [r5, #8]
 8012580:	0219      	lsls	r1, r3, #8
      if(Divider == DIVIDER_P_UPDATE)
 8012582:	bb57      	cbnz	r7, 80125da <RCCEx_PLLSAI1_Config+0xde>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8012584:	6923      	ldr	r3, [r4, #16]
 8012586:	68ea      	ldr	r2, [r5, #12]
 8012588:	f423 331f 	bic.w	r3, r3, #162816	; 0x27c00
 801258c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8012590:	430b      	orrs	r3, r1
 8012592:	0912      	lsrs	r2, r2, #4
 8012594:	ea43 4342 	orr.w	r3, r3, r2, lsl #17
 8012598:	6123      	str	r3, [r4, #16]
      __HAL_RCC_PLLSAI1_ENABLE();
 801259a:	4c1e      	ldr	r4, [pc, #120]	; (8012614 <RCCEx_PLLSAI1_Config+0x118>)
 801259c:	6823      	ldr	r3, [r4, #0]
 801259e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80125a2:	6023      	str	r3, [r4, #0]
      tickstart = HAL_GetTick();
 80125a4:	f7fd ffa2 	bl	80104ec <HAL_GetTick>
 80125a8:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == RESET)
 80125aa:	e004      	b.n	80125b6 <RCCEx_PLLSAI1_Config+0xba>
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80125ac:	f7fd ff9e 	bl	80104ec <HAL_GetTick>
 80125b0:	1b80      	subs	r0, r0, r6
 80125b2:	2802      	cmp	r0, #2
 80125b4:	d808      	bhi.n	80125c8 <RCCEx_PLLSAI1_Config+0xcc>
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == RESET)
 80125b6:	6823      	ldr	r3, [r4, #0]
 80125b8:	011b      	lsls	r3, r3, #4
 80125ba:	d5f7      	bpl.n	80125ac <RCCEx_PLLSAI1_Config+0xb0>
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 80125bc:	69aa      	ldr	r2, [r5, #24]
 80125be:	6923      	ldr	r3, [r4, #16]
 80125c0:	4313      	orrs	r3, r2
 80125c2:	6123      	str	r3, [r4, #16]
 80125c4:	2000      	movs	r0, #0
}
 80125c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        status = HAL_TIMEOUT;
 80125c8:	2003      	movs	r0, #3
}
 80125ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY) && HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 80125cc:	6814      	ldr	r4, [r2, #0]
 80125ce:	03a5      	lsls	r5, r4, #14
 80125d0:	d4b8      	bmi.n	8012544 <RCCEx_PLLSAI1_Config+0x48>
 80125d2:	6812      	ldr	r2, [r2, #0]
 80125d4:	0354      	lsls	r4, r2, #13
 80125d6:	d59c      	bpl.n	8012512 <RCCEx_PLLSAI1_Config+0x16>
 80125d8:	e7b4      	b.n	8012544 <RCCEx_PLLSAI1_Config+0x48>
      else if(Divider == DIVIDER_Q_UPDATE)
 80125da:	2f01      	cmp	r7, #1
 80125dc:	d00c      	beq.n	80125f8 <RCCEx_PLLSAI1_Config+0xfc>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80125de:	6922      	ldr	r2, [r4, #16]
 80125e0:	696b      	ldr	r3, [r5, #20]
 80125e2:	f022 62c0 	bic.w	r2, r2, #100663296	; 0x6000000
 80125e6:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 80125ea:	085b      	lsrs	r3, r3, #1
 80125ec:	430a      	orrs	r2, r1
 80125ee:	3b01      	subs	r3, #1
 80125f0:	ea42 6243 	orr.w	r2, r2, r3, lsl #25
 80125f4:	6122      	str	r2, [r4, #16]
 80125f6:	e7d0      	b.n	801259a <RCCEx_PLLSAI1_Config+0x9e>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80125f8:	6923      	ldr	r3, [r4, #16]
 80125fa:	692a      	ldr	r2, [r5, #16]
 80125fc:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
 8012600:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 8012604:	0852      	lsrs	r2, r2, #1
 8012606:	430b      	orrs	r3, r1
 8012608:	3a01      	subs	r2, #1
 801260a:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 801260e:	6123      	str	r3, [r4, #16]
 8012610:	e7c3      	b.n	801259a <RCCEx_PLLSAI1_Config+0x9e>
 8012612:	bf00      	nop
 8012614:	40021000 	.word	0x40021000

08012618 <RCCEx_PLLSAI2_Config>:
  assert_param(IS_RCC_PLLSAI2M_VALUE(PllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Check that PLLSAI2 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8012618:	4a3d      	ldr	r2, [pc, #244]	; (8012710 <RCCEx_PLLSAI2_Config+0xf8>)
{
 801261a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 801261c:	68d4      	ldr	r4, [r2, #12]
 801261e:	6803      	ldr	r3, [r0, #0]
 8012620:	07a4      	lsls	r4, r4, #30
 8012622:	d006      	beq.n	8012632 <RCCEx_PLLSAI2_Config+0x1a>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai2->PLLSAI2Source)
 8012624:	68d4      	ldr	r4, [r2, #12]
 8012626:	f004 0403 	and.w	r4, r4, #3
 801262a:	429c      	cmp	r4, r3
 801262c:	d00b      	beq.n	8012646 <RCCEx_PLLSAI2_Config+0x2e>
 801262e:	2001      	movs	r0, #1
      }
    }
  }

  return status;
}
 8012630:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch(PllSai2->PLLSAI2Source)
 8012632:	2b02      	cmp	r3, #2
 8012634:	d011      	beq.n	801265a <RCCEx_PLLSAI2_Config+0x42>
 8012636:	2b03      	cmp	r3, #3
 8012638:	d056      	beq.n	80126e8 <RCCEx_PLLSAI2_Config+0xd0>
 801263a:	2b01      	cmp	r3, #1
 801263c:	d1f7      	bne.n	801262e <RCCEx_PLLSAI2_Config+0x16>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 801263e:	6812      	ldr	r2, [r2, #0]
 8012640:	0797      	lsls	r7, r2, #30
 8012642:	d5f4      	bpl.n	801262e <RCCEx_PLLSAI2_Config+0x16>
 8012644:	e00c      	b.n	8012660 <RCCEx_PLLSAI2_Config+0x48>
       ||
 8012646:	2c00      	cmp	r4, #0
 8012648:	d0f1      	beq.n	801262e <RCCEx_PLLSAI2_Config+0x16>
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai2->PLLSAI2M)
 801264a:	68d3      	ldr	r3, [r2, #12]
       ||
 801264c:	6842      	ldr	r2, [r0, #4]
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai2->PLLSAI2M)
 801264e:	f3c3 1302 	ubfx	r3, r3, #4, #3
 8012652:	3301      	adds	r3, #1
       ||
 8012654:	4293      	cmp	r3, r2
 8012656:	d1ea      	bne.n	801262e <RCCEx_PLLSAI2_Config+0x16>
 8012658:	e00c      	b.n	8012674 <RCCEx_PLLSAI2_Config+0x5c>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 801265a:	6812      	ldr	r2, [r2, #0]
 801265c:	0556      	lsls	r6, r2, #21
 801265e:	d5e6      	bpl.n	801262e <RCCEx_PLLSAI2_Config+0x16>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai2->PLLSAI2Source | (PllSai2->PLLSAI2M - 1U) << RCC_PLLCFGR_PLLM_Pos);
 8012660:	4d2b      	ldr	r5, [pc, #172]	; (8012710 <RCCEx_PLLSAI2_Config+0xf8>)
 8012662:	6844      	ldr	r4, [r0, #4]
 8012664:	68ea      	ldr	r2, [r5, #12]
 8012666:	f022 0273 	bic.w	r2, r2, #115	; 0x73
 801266a:	4313      	orrs	r3, r2
 801266c:	3c01      	subs	r4, #1
 801266e:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
 8012672:	60eb      	str	r3, [r5, #12]
    __HAL_RCC_PLLSAI2_DISABLE();
 8012674:	4c26      	ldr	r4, [pc, #152]	; (8012710 <RCCEx_PLLSAI2_Config+0xf8>)
 8012676:	6823      	ldr	r3, [r4, #0]
 8012678:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 801267c:	6023      	str	r3, [r4, #0]
 801267e:	460f      	mov	r7, r1
 8012680:	4605      	mov	r5, r0
    tickstart = HAL_GetTick();
 8012682:	f7fd ff33 	bl	80104ec <HAL_GetTick>
 8012686:	4606      	mov	r6, r0
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != RESET)
 8012688:	e004      	b.n	8012694 <RCCEx_PLLSAI2_Config+0x7c>
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 801268a:	f7fd ff2f 	bl	80104ec <HAL_GetTick>
 801268e:	1b80      	subs	r0, r0, r6
 8012690:	2802      	cmp	r0, #2
 8012692:	d827      	bhi.n	80126e4 <RCCEx_PLLSAI2_Config+0xcc>
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != RESET)
 8012694:	6823      	ldr	r3, [r4, #0]
 8012696:	009a      	lsls	r2, r3, #2
 8012698:	d4f7      	bmi.n	801268a <RCCEx_PLLSAI2_Config+0x72>
 801269a:	68ab      	ldr	r3, [r5, #8]
 801269c:	0219      	lsls	r1, r3, #8
      if(Divider == DIVIDER_P_UPDATE)
 801269e:	bb57      	cbnz	r7, 80126f6 <RCCEx_PLLSAI2_Config+0xde>
        MODIFY_REG(RCC->PLLSAI2CFGR,
 80126a0:	6962      	ldr	r2, [r4, #20]
 80126a2:	68eb      	ldr	r3, [r5, #12]
 80126a4:	f422 321f 	bic.w	r2, r2, #162816	; 0x27c00
 80126a8:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80126ac:	430a      	orrs	r2, r1
 80126ae:	091b      	lsrs	r3, r3, #4
 80126b0:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
 80126b4:	6162      	str	r2, [r4, #20]
      __HAL_RCC_PLLSAI2_ENABLE();
 80126b6:	4c16      	ldr	r4, [pc, #88]	; (8012710 <RCCEx_PLLSAI2_Config+0xf8>)
 80126b8:	6823      	ldr	r3, [r4, #0]
 80126ba:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80126be:	6023      	str	r3, [r4, #0]
      tickstart = HAL_GetTick();
 80126c0:	f7fd ff14 	bl	80104ec <HAL_GetTick>
 80126c4:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == RESET)
 80126c6:	e004      	b.n	80126d2 <RCCEx_PLLSAI2_Config+0xba>
        if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 80126c8:	f7fd ff10 	bl	80104ec <HAL_GetTick>
 80126cc:	1b80      	subs	r0, r0, r6
 80126ce:	2802      	cmp	r0, #2
 80126d0:	d808      	bhi.n	80126e4 <RCCEx_PLLSAI2_Config+0xcc>
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == RESET)
 80126d2:	6823      	ldr	r3, [r4, #0]
 80126d4:	009b      	lsls	r3, r3, #2
 80126d6:	d5f7      	bpl.n	80126c8 <RCCEx_PLLSAI2_Config+0xb0>
        __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
 80126d8:	696a      	ldr	r2, [r5, #20]
 80126da:	6963      	ldr	r3, [r4, #20]
 80126dc:	4313      	orrs	r3, r2
 80126de:	6163      	str	r3, [r4, #20]
 80126e0:	2000      	movs	r0, #0
}
 80126e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        status = HAL_TIMEOUT;
 80126e4:	2003      	movs	r0, #3
}
 80126e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY) && HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 80126e8:	6814      	ldr	r4, [r2, #0]
 80126ea:	03a5      	lsls	r5, r4, #14
 80126ec:	d4b8      	bmi.n	8012660 <RCCEx_PLLSAI2_Config+0x48>
 80126ee:	6812      	ldr	r2, [r2, #0]
 80126f0:	0354      	lsls	r4, r2, #13
 80126f2:	d59c      	bpl.n	801262e <RCCEx_PLLSAI2_Config+0x16>
 80126f4:	e7b4      	b.n	8012660 <RCCEx_PLLSAI2_Config+0x48>
        MODIFY_REG(RCC->PLLSAI2CFGR,
 80126f6:	6963      	ldr	r3, [r4, #20]
 80126f8:	692a      	ldr	r2, [r5, #16]
 80126fa:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
 80126fe:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 8012702:	0852      	lsrs	r2, r2, #1
 8012704:	430b      	orrs	r3, r1
 8012706:	3a01      	subs	r2, #1
 8012708:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 801270c:	6163      	str	r3, [r4, #20]
 801270e:	e7d2      	b.n	80126b6 <RCCEx_PLLSAI2_Config+0x9e>
 8012710:	40021000 	.word	0x40021000

08012714 <HAL_RCCEx_PeriphCLKConfig>:
{
 8012714:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8012718:	6803      	ldr	r3, [r0, #0]
 801271a:	f413 6600 	ands.w	r6, r3, #2048	; 0x800
{
 801271e:	b083      	sub	sp, #12
 8012720:	4604      	mov	r4, r0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8012722:	d017      	beq.n	8012754 <HAL_RCCEx_PeriphCLKConfig+0x40>
    switch(PeriphClkInit->Sai1ClockSelection)
 8012724:	6e41      	ldr	r1, [r0, #100]	; 0x64
 8012726:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
 801272a:	f000 81bb 	beq.w	8012aa4 <HAL_RCCEx_PeriphCLKConfig+0x390>
 801272e:	f240 81ee 	bls.w	8012b0e <HAL_RCCEx_PeriphCLKConfig+0x3fa>
 8012732:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8012736:	f000 81af 	beq.w	8012a98 <HAL_RCCEx_PeriphCLKConfig+0x384>
 801273a:	f5b1 0f40 	cmp.w	r1, #12582912	; 0xc00000
 801273e:	f040 81ec 	bne.w	8012b1a <HAL_RCCEx_PeriphCLKConfig+0x406>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8012742:	48c3      	ldr	r0, [pc, #780]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 8012744:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8012748:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 801274c:	4311      	orrs	r1, r2
 801274e:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88
 8012752:	2600      	movs	r6, #0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 8012754:	04d8      	lsls	r0, r3, #19
 8012756:	f140 8100 	bpl.w	801295a <HAL_RCCEx_PeriphCLKConfig+0x246>
    switch(PeriphClkInit->Sai2ClockSelection)
 801275a:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 801275c:	f1b1 7f80 	cmp.w	r1, #16777216	; 0x1000000
 8012760:	f000 8187 	beq.w	8012a72 <HAL_RCCEx_PeriphCLKConfig+0x35e>
 8012764:	f240 81ca 	bls.w	8012afc <HAL_RCCEx_PeriphCLKConfig+0x3e8>
 8012768:	f1b1 7f00 	cmp.w	r1, #33554432	; 0x2000000
 801276c:	f000 818d 	beq.w	8012a8a <HAL_RCCEx_PeriphCLKConfig+0x376>
 8012770:	f1b1 7f40 	cmp.w	r1, #50331648	; 0x3000000
 8012774:	f040 80f0 	bne.w	8012958 <HAL_RCCEx_PeriphCLKConfig+0x244>
 8012778:	4637      	mov	r7, r6
    if(ret == HAL_OK)
 801277a:	2f00      	cmp	r7, #0
 801277c:	f040 8183 	bne.w	8012a86 <HAL_RCCEx_PeriphCLKConfig+0x372>
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8012780:	49b3      	ldr	r1, [pc, #716]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 8012782:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8012784:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8012788:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 801278c:	4302      	orrs	r2, r0
 801278e:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8012792:	0399      	lsls	r1, r3, #14
 8012794:	f100 80e5 	bmi.w	8012962 <HAL_RCCEx_PeriphCLKConfig+0x24e>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8012798:	07da      	lsls	r2, r3, #31
 801279a:	d508      	bpl.n	80127ae <HAL_RCCEx_PeriphCLKConfig+0x9a>
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 801279c:	49ac      	ldr	r1, [pc, #688]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 801279e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80127a0:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80127a4:	f022 0203 	bic.w	r2, r2, #3
 80127a8:	4302      	orrs	r2, r0
 80127aa:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 80127ae:	079f      	lsls	r7, r3, #30
 80127b0:	d508      	bpl.n	80127c4 <HAL_RCCEx_PeriphCLKConfig+0xb0>
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 80127b2:	49a7      	ldr	r1, [pc, #668]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 80127b4:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80127b6:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80127ba:	f022 020c 	bic.w	r2, r2, #12
 80127be:	4302      	orrs	r2, r0
 80127c0:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 80127c4:	075d      	lsls	r5, r3, #29
 80127c6:	d508      	bpl.n	80127da <HAL_RCCEx_PeriphCLKConfig+0xc6>
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 80127c8:	49a1      	ldr	r1, [pc, #644]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 80127ca:	6c20      	ldr	r0, [r4, #64]	; 0x40
 80127cc:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80127d0:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 80127d4:	4302      	orrs	r2, r0
 80127d6:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 80127da:	0718      	lsls	r0, r3, #28
 80127dc:	d508      	bpl.n	80127f0 <HAL_RCCEx_PeriphCLKConfig+0xdc>
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 80127de:	499c      	ldr	r1, [pc, #624]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 80127e0:	6c60      	ldr	r0, [r4, #68]	; 0x44
 80127e2:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80127e6:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 80127ea:	4302      	orrs	r2, r0
 80127ec:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 80127f0:	06d9      	lsls	r1, r3, #27
 80127f2:	d508      	bpl.n	8012806 <HAL_RCCEx_PeriphCLKConfig+0xf2>
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 80127f4:	4996      	ldr	r1, [pc, #600]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 80127f6:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80127f8:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80127fc:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8012800:	4302      	orrs	r2, r0
 8012802:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8012806:	069a      	lsls	r2, r3, #26
 8012808:	d508      	bpl.n	801281c <HAL_RCCEx_PeriphCLKConfig+0x108>
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 801280a:	4991      	ldr	r1, [pc, #580]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 801280c:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 801280e:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8012812:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8012816:	4302      	orrs	r2, r0
 8012818:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 801281c:	059f      	lsls	r7, r3, #22
 801281e:	d508      	bpl.n	8012832 <HAL_RCCEx_PeriphCLKConfig+0x11e>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8012820:	498b      	ldr	r1, [pc, #556]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 8012822:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8012824:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8012828:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 801282c:	4302      	orrs	r2, r0
 801282e:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8012832:	055d      	lsls	r5, r3, #21
 8012834:	d508      	bpl.n	8012848 <HAL_RCCEx_PeriphCLKConfig+0x134>
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8012836:	4986      	ldr	r1, [pc, #536]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 8012838:	6e20      	ldr	r0, [r4, #96]	; 0x60
 801283a:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 801283e:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8012842:	4302      	orrs	r2, r0
 8012844:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8012848:	0658      	lsls	r0, r3, #25
 801284a:	d508      	bpl.n	801285e <HAL_RCCEx_PeriphCLKConfig+0x14a>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 801284c:	4980      	ldr	r1, [pc, #512]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 801284e:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8012850:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8012854:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8012858:	4302      	orrs	r2, r0
 801285a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 801285e:	0619      	lsls	r1, r3, #24
 8012860:	d508      	bpl.n	8012874 <HAL_RCCEx_PeriphCLKConfig+0x160>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8012862:	497b      	ldr	r1, [pc, #492]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 8012864:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8012866:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 801286a:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 801286e:	4302      	orrs	r2, r0
 8012870:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8012874:	05da      	lsls	r2, r3, #23
 8012876:	d508      	bpl.n	801288a <HAL_RCCEx_PeriphCLKConfig+0x176>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8012878:	4975      	ldr	r1, [pc, #468]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 801287a:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801287c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8012880:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8012884:	4302      	orrs	r2, r0
 8012886:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 801288a:	049f      	lsls	r7, r3, #18
 801288c:	d510      	bpl.n	80128b0 <HAL_RCCEx_PeriphCLKConfig+0x19c>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 801288e:	4970      	ldr	r1, [pc, #448]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 8012890:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8012892:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8012896:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 801289a:	4302      	orrs	r2, r0
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 801289c:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 80128a0:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 80128a4:	f000 80ce 	beq.w	8012a44 <HAL_RCCEx_PeriphCLKConfig+0x330>
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 80128a8:	f1b0 6f80 	cmp.w	r0, #67108864	; 0x4000000
 80128ac:	f000 8116 	beq.w	8012adc <HAL_RCCEx_PeriphCLKConfig+0x3c8>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 80128b0:	031d      	lsls	r5, r3, #12
 80128b2:	d510      	bpl.n	80128d6 <HAL_RCCEx_PeriphCLKConfig+0x1c2>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80128b4:	4966      	ldr	r1, [pc, #408]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 80128b6:	6f20      	ldr	r0, [r4, #112]	; 0x70
 80128b8:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80128bc:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 80128c0:	4302      	orrs	r2, r0
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 80128c2:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80128c6:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 80128ca:	f000 80c5 	beq.w	8012a58 <HAL_RCCEx_PeriphCLKConfig+0x344>
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 80128ce:	f1b0 6f80 	cmp.w	r0, #67108864	; 0x4000000
 80128d2:	f000 810b 	beq.w	8012aec <HAL_RCCEx_PeriphCLKConfig+0x3d8>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 80128d6:	0358      	lsls	r0, r3, #13
 80128d8:	d510      	bpl.n	80128fc <HAL_RCCEx_PeriphCLKConfig+0x1e8>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 80128da:	495d      	ldr	r1, [pc, #372]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 80128dc:	6f60      	ldr	r0, [r4, #116]	; 0x74
 80128de:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80128e2:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 80128e6:	4302      	orrs	r2, r0
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 80128e8:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 80128ec:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 80128f0:	f000 80a3 	beq.w	8012a3a <HAL_RCCEx_PeriphCLKConfig+0x326>
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 80128f4:	f1b0 6f80 	cmp.w	r0, #67108864	; 0x4000000
 80128f8:	f000 80e8 	beq.w	8012acc <HAL_RCCEx_PeriphCLKConfig+0x3b8>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 80128fc:	0459      	lsls	r1, r3, #17
 80128fe:	d510      	bpl.n	8012922 <HAL_RCCEx_PeriphCLKConfig+0x20e>
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8012900:	4853      	ldr	r0, [pc, #332]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 8012902:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 8012904:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8012908:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 801290c:	430a      	orrs	r2, r1
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 801290e:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8012912:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8012916:	f000 80a4 	beq.w	8012a62 <HAL_RCCEx_PeriphCLKConfig+0x34e>
    else if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI2)
 801291a:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
 801291e:	f000 80cc 	beq.w	8012aba <HAL_RCCEx_PeriphCLKConfig+0x3a6>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 8012922:	041a      	lsls	r2, r3, #16
 8012924:	d508      	bpl.n	8012938 <HAL_RCCEx_PeriphCLKConfig+0x224>
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 8012926:	494a      	ldr	r1, [pc, #296]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 8012928:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 801292a:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 801292e:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8012932:	4302      	orrs	r2, r0
 8012934:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8012938:	03db      	lsls	r3, r3, #15
 801293a:	d509      	bpl.n	8012950 <HAL_RCCEx_PeriphCLKConfig+0x23c>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 801293c:	4a44      	ldr	r2, [pc, #272]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 801293e:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
 8012942:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8012946:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 801294a:	430b      	orrs	r3, r1
 801294c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
}
 8012950:	4630      	mov	r0, r6
 8012952:	b003      	add	sp, #12
 8012954:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      ret = HAL_ERROR;
 8012958:	2601      	movs	r6, #1
 801295a:	4637      	mov	r7, r6
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 801295c:	0399      	lsls	r1, r3, #14
 801295e:	f57f af1b 	bpl.w	8012798 <HAL_RCCEx_PeriphCLKConfig+0x84>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8012962:	4b3b      	ldr	r3, [pc, #236]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 8012964:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8012966:	00d2      	lsls	r2, r2, #3
 8012968:	d559      	bpl.n	8012a1e <HAL_RCCEx_PeriphCLKConfig+0x30a>
    FlagStatus       pwrclkchanged = RESET;
 801296a:	f04f 0800 	mov.w	r8, #0
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 801296e:	4d39      	ldr	r5, [pc, #228]	; (8012a54 <HAL_RCCEx_PeriphCLKConfig+0x340>)
 8012970:	682b      	ldr	r3, [r5, #0]
 8012972:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8012976:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 8012978:	f7fd fdb8 	bl	80104ec <HAL_GetTick>
 801297c:	4681      	mov	r9, r0
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == RESET)
 801297e:	e005      	b.n	801298c <HAL_RCCEx_PeriphCLKConfig+0x278>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8012980:	f7fd fdb4 	bl	80104ec <HAL_GetTick>
 8012984:	eba0 0009 	sub.w	r0, r0, r9
 8012988:	2802      	cmp	r0, #2
 801298a:	d854      	bhi.n	8012a36 <HAL_RCCEx_PeriphCLKConfig+0x322>
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == RESET)
 801298c:	682b      	ldr	r3, [r5, #0]
 801298e:	05db      	lsls	r3, r3, #23
 8012990:	d5f6      	bpl.n	8012980 <HAL_RCCEx_PeriphCLKConfig+0x26c>
    if(ret == HAL_OK)
 8012992:	2f00      	cmp	r7, #0
 8012994:	f040 80c9 	bne.w	8012b2a <HAL_RCCEx_PeriphCLKConfig+0x416>
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8012998:	4b2d      	ldr	r3, [pc, #180]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 801299a:	f8d4 1084 	ldr.w	r1, [r4, #132]	; 0x84
 801299e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 80129a2:	f412 7240 	ands.w	r2, r2, #768	; 0x300
 80129a6:	d028      	beq.n	80129fa <HAL_RCCEx_PeriphCLKConfig+0x2e6>
 80129a8:	428a      	cmp	r2, r1
 80129aa:	d026      	beq.n	80129fa <HAL_RCCEx_PeriphCLKConfig+0x2e6>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 80129ac:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_FORCE();
 80129b0:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80129b4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80129b8:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 80129bc:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 80129c0:	f420 7540 	bic.w	r5, r0, #768	; 0x300
        __HAL_RCC_BACKUPRESET_RELEASE();
 80129c4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 80129c8:	07c0      	lsls	r0, r0, #31
        __HAL_RCC_BACKUPRESET_RELEASE();
 80129ca:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        RCC->BDCR = tmpregister;
 80129ce:	f8c3 5090 	str.w	r5, [r3, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 80129d2:	d512      	bpl.n	80129fa <HAL_RCCEx_PeriphCLKConfig+0x2e6>
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 80129d4:	461d      	mov	r5, r3
        tickstart = HAL_GetTick();
 80129d6:	f7fd fd89 	bl	80104ec <HAL_GetTick>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80129da:	f241 3788 	movw	r7, #5000	; 0x1388
        tickstart = HAL_GetTick();
 80129de:	4681      	mov	r9, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 80129e0:	e005      	b.n	80129ee <HAL_RCCEx_PeriphCLKConfig+0x2da>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80129e2:	f7fd fd83 	bl	80104ec <HAL_GetTick>
 80129e6:	eba0 0009 	sub.w	r0, r0, r9
 80129ea:	42b8      	cmp	r0, r7
 80129ec:	d823      	bhi.n	8012a36 <HAL_RCCEx_PeriphCLKConfig+0x322>
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 80129ee:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 80129f2:	0799      	lsls	r1, r3, #30
 80129f4:	d5f5      	bpl.n	80129e2 <HAL_RCCEx_PeriphCLKConfig+0x2ce>
 80129f6:	f8d4 1084 	ldr.w	r1, [r4, #132]	; 0x84
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80129fa:	4a15      	ldr	r2, [pc, #84]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 80129fc:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8012a00:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8012a04:	430b      	orrs	r3, r1
 8012a06:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
    if(pwrclkchanged == SET)
 8012a0a:	f1b8 0f00 	cmp.w	r8, #0
 8012a0e:	d004      	beq.n	8012a1a <HAL_RCCEx_PeriphCLKConfig+0x306>
      __HAL_RCC_PWR_CLK_DISABLE();
 8012a10:	4a0f      	ldr	r2, [pc, #60]	; (8012a50 <HAL_RCCEx_PeriphCLKConfig+0x33c>)
 8012a12:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8012a14:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8012a18:	6593      	str	r3, [r2, #88]	; 0x58
 8012a1a:	6823      	ldr	r3, [r4, #0]
 8012a1c:	e6bc      	b.n	8012798 <HAL_RCCEx_PeriphCLKConfig+0x84>
      __HAL_RCC_PWR_CLK_ENABLE();
 8012a1e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8012a20:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8012a24:	659a      	str	r2, [r3, #88]	; 0x58
 8012a26:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8012a28:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8012a2c:	9301      	str	r3, [sp, #4]
 8012a2e:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8012a30:	f04f 0801 	mov.w	r8, #1
 8012a34:	e79b      	b.n	801296e <HAL_RCCEx_PeriphCLKConfig+0x25a>
        ret = HAL_TIMEOUT;
 8012a36:	2603      	movs	r6, #3
 8012a38:	e7e7      	b.n	8012a0a <HAL_RCCEx_PeriphCLKConfig+0x2f6>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8012a3a:	68ca      	ldr	r2, [r1, #12]
 8012a3c:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8012a40:	60ca      	str	r2, [r1, #12]
 8012a42:	e75b      	b.n	80128fc <HAL_RCCEx_PeriphCLKConfig+0x1e8>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8012a44:	68ca      	ldr	r2, [r1, #12]
 8012a46:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8012a4a:	60ca      	str	r2, [r1, #12]
 8012a4c:	e730      	b.n	80128b0 <HAL_RCCEx_PeriphCLKConfig+0x19c>
 8012a4e:	bf00      	nop
 8012a50:	40021000 	.word	0x40021000
 8012a54:	40007000 	.word	0x40007000
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8012a58:	68ca      	ldr	r2, [r1, #12]
 8012a5a:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8012a5e:	60ca      	str	r2, [r1, #12]
 8012a60:	e739      	b.n	80128d6 <HAL_RCCEx_PeriphCLKConfig+0x1c2>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 8012a62:	2102      	movs	r1, #2
 8012a64:	1d20      	adds	r0, r4, #4
 8012a66:	f7ff fd49 	bl	80124fc <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 8012a6a:	b368      	cbz	r0, 8012ac8 <HAL_RCCEx_PeriphCLKConfig+0x3b4>
      if(ret != HAL_OK)
 8012a6c:	4606      	mov	r6, r0
 8012a6e:	6823      	ldr	r3, [r4, #0]
 8012a70:	e757      	b.n	8012922 <HAL_RCCEx_PeriphCLKConfig+0x20e>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8012a72:	2100      	movs	r1, #0
 8012a74:	f104 0020 	add.w	r0, r4, #32
 8012a78:	f7ff fdce 	bl	8012618 <RCCEx_PLLSAI2_Config>
 8012a7c:	4607      	mov	r7, r0
 8012a7e:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 8012a80:	2f00      	cmp	r7, #0
 8012a82:	f43f ae7d 	beq.w	8012780 <HAL_RCCEx_PeriphCLKConfig+0x6c>
 8012a86:	463e      	mov	r6, r7
 8012a88:	e768      	b.n	801295c <HAL_RCCEx_PeriphCLKConfig+0x248>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8012a8a:	4929      	ldr	r1, [pc, #164]	; (8012b30 <HAL_RCCEx_PeriphCLKConfig+0x41c>)
 8012a8c:	68ca      	ldr	r2, [r1, #12]
 8012a8e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8012a92:	60ca      	str	r2, [r1, #12]
      break;
 8012a94:	4637      	mov	r7, r6
 8012a96:	e670      	b.n	801277a <HAL_RCCEx_PeriphCLKConfig+0x66>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8012a98:	4825      	ldr	r0, [pc, #148]	; (8012b30 <HAL_RCCEx_PeriphCLKConfig+0x41c>)
 8012a9a:	68c2      	ldr	r2, [r0, #12]
 8012a9c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8012aa0:	60c2      	str	r2, [r0, #12]
 8012aa2:	e64e      	b.n	8012742 <HAL_RCCEx_PeriphCLKConfig+0x2e>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8012aa4:	2100      	movs	r1, #0
 8012aa6:	3020      	adds	r0, #32
 8012aa8:	f7ff fdb6 	bl	8012618 <RCCEx_PLLSAI2_Config>
 8012aac:	4606      	mov	r6, r0
 8012aae:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 8012ab0:	2e00      	cmp	r6, #0
 8012ab2:	f47f ae4f 	bne.w	8012754 <HAL_RCCEx_PeriphCLKConfig+0x40>
 8012ab6:	6e61      	ldr	r1, [r4, #100]	; 0x64
 8012ab8:	e643      	b.n	8012742 <HAL_RCCEx_PeriphCLKConfig+0x2e>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_R_UPDATE);
 8012aba:	2102      	movs	r1, #2
 8012abc:	f104 0020 	add.w	r0, r4, #32
 8012ac0:	f7ff fdaa 	bl	8012618 <RCCEx_PLLSAI2_Config>
      if(ret != HAL_OK)
 8012ac4:	2800      	cmp	r0, #0
 8012ac6:	d1d1      	bne.n	8012a6c <HAL_RCCEx_PeriphCLKConfig+0x358>
 8012ac8:	6823      	ldr	r3, [r4, #0]
 8012aca:	e72a      	b.n	8012922 <HAL_RCCEx_PeriphCLKConfig+0x20e>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8012acc:	2101      	movs	r1, #1
 8012ace:	1d20      	adds	r0, r4, #4
 8012ad0:	f7ff fd14 	bl	80124fc <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 8012ad4:	b338      	cbz	r0, 8012b26 <HAL_RCCEx_PeriphCLKConfig+0x412>
 8012ad6:	4606      	mov	r6, r0
 8012ad8:	6823      	ldr	r3, [r4, #0]
 8012ada:	e70f      	b.n	80128fc <HAL_RCCEx_PeriphCLKConfig+0x1e8>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8012adc:	2101      	movs	r1, #1
 8012ade:	1d20      	adds	r0, r4, #4
 8012ae0:	f7ff fd0c 	bl	80124fc <RCCEx_PLLSAI1_Config>
        if(ret != HAL_OK)
 8012ae4:	b1e8      	cbz	r0, 8012b22 <HAL_RCCEx_PeriphCLKConfig+0x40e>
 8012ae6:	4606      	mov	r6, r0
 8012ae8:	6823      	ldr	r3, [r4, #0]
 8012aea:	e6e1      	b.n	80128b0 <HAL_RCCEx_PeriphCLKConfig+0x19c>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8012aec:	2101      	movs	r1, #1
 8012aee:	1d20      	adds	r0, r4, #4
 8012af0:	f7ff fd04 	bl	80124fc <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 8012af4:	b198      	cbz	r0, 8012b1e <HAL_RCCEx_PeriphCLKConfig+0x40a>
 8012af6:	4606      	mov	r6, r0
 8012af8:	6823      	ldr	r3, [r4, #0]
 8012afa:	e6ec      	b.n	80128d6 <HAL_RCCEx_PeriphCLKConfig+0x1c2>
    switch(PeriphClkInit->Sai2ClockSelection)
 8012afc:	2900      	cmp	r1, #0
 8012afe:	f47f af2b 	bne.w	8012958 <HAL_RCCEx_PeriphCLKConfig+0x244>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8012b02:	1d20      	adds	r0, r4, #4
 8012b04:	f7ff fcfa 	bl	80124fc <RCCEx_PLLSAI1_Config>
 8012b08:	6823      	ldr	r3, [r4, #0]
 8012b0a:	4607      	mov	r7, r0
      break;
 8012b0c:	e635      	b.n	801277a <HAL_RCCEx_PeriphCLKConfig+0x66>
    switch(PeriphClkInit->Sai1ClockSelection)
 8012b0e:	b921      	cbnz	r1, 8012b1a <HAL_RCCEx_PeriphCLKConfig+0x406>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8012b10:	3004      	adds	r0, #4
 8012b12:	f7ff fcf3 	bl	80124fc <RCCEx_PLLSAI1_Config>
 8012b16:	4606      	mov	r6, r0
      break;
 8012b18:	e7c9      	b.n	8012aae <HAL_RCCEx_PeriphCLKConfig+0x39a>
      ret = HAL_ERROR;
 8012b1a:	2601      	movs	r6, #1
 8012b1c:	e61a      	b.n	8012754 <HAL_RCCEx_PeriphCLKConfig+0x40>
 8012b1e:	6823      	ldr	r3, [r4, #0]
 8012b20:	e6d9      	b.n	80128d6 <HAL_RCCEx_PeriphCLKConfig+0x1c2>
 8012b22:	6823      	ldr	r3, [r4, #0]
 8012b24:	e6c4      	b.n	80128b0 <HAL_RCCEx_PeriphCLKConfig+0x19c>
 8012b26:	6823      	ldr	r3, [r4, #0]
 8012b28:	e6e8      	b.n	80128fc <HAL_RCCEx_PeriphCLKConfig+0x1e8>
 8012b2a:	463e      	mov	r6, r7
 8012b2c:	e76d      	b.n	8012a0a <HAL_RCCEx_PeriphCLKConfig+0x2f6>
 8012b2e:	bf00      	nop
 8012b30:	40021000 	.word	0x40021000

08012b34 <HAL_RCCEx_DisableLSECSS>:
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
 8012b34:	4b05      	ldr	r3, [pc, #20]	; (8012b4c <HAL_RCCEx_DisableLSECSS+0x18>)
 8012b36:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8012b3a:	f022 0220 	bic.w	r2, r2, #32
 8012b3e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
 8012b42:	699a      	ldr	r2, [r3, #24]
 8012b44:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8012b48:	619a      	str	r2, [r3, #24]
}
 8012b4a:	4770      	bx	lr
 8012b4c:	40021000 	.word	0x40021000

08012b50 <HAL_RCCEx_EnableMSIPLLMode>:
  SET_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
 8012b50:	4a02      	ldr	r2, [pc, #8]	; (8012b5c <HAL_RCCEx_EnableMSIPLLMode+0xc>)
 8012b52:	6813      	ldr	r3, [r2, #0]
 8012b54:	f043 0304 	orr.w	r3, r3, #4
 8012b58:	6013      	str	r3, [r2, #0]
}
 8012b5a:	4770      	bx	lr
 8012b5c:	40021000 	.word	0x40021000

08012b60 <HAL_RTC_GetTime>:

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

  /* Get subseconds structure field from the corresponding register*/
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 8012b60:	6803      	ldr	r3, [r0, #0]
{
 8012b62:	b470      	push	{r4, r5, r6}
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 8012b64:	6a9d      	ldr	r5, [r3, #40]	; 0x28

  /* Get SecondFraction structure field from the corresponding register field*/
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 8012b66:	691c      	ldr	r4, [r3, #16]
  
  /* Get the TR register */
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);
 8012b68:	681b      	ldr	r3, [r3, #0]
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 8012b6a:	604d      	str	r5, [r1, #4]
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);
 8012b6c:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 8012b70:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000

  /* Fill the structure fields with the read parameters */
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8012b74:	0c18      	lsrs	r0, r3, #16
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 8012b76:	f3c4 040e 	ubfx	r4, r4, #0, #15
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);
 8012b7a:	f000 0640 	and.w	r6, r0, #64	; 0x40
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8012b7e:	f000 053f 	and.w	r5, r0, #63	; 0x3f
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 8012b82:	608c      	str	r4, [r1, #8]
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8012b84:	f3c3 2406 	ubfx	r4, r3, #8, #7
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8012b88:	b2db      	uxtb	r3, r3
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);
 8012b8a:	70ce      	strb	r6, [r1, #3]
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8012b8c:	700d      	strb	r5, [r1, #0]
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8012b8e:	704c      	strb	r4, [r1, #1]
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8012b90:	708b      	strb	r3, [r1, #2]

  /* Check the input parameters format */
  if(Format == RTC_FORMAT_BIN)
 8012b92:	b9ba      	cbnz	r2, 8012bc4 <HAL_RTC_GetTime+0x64>
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8012b94:	0922      	lsrs	r2, r4, #4
 8012b96:	eb02 0682 	add.w	r6, r2, r2, lsl #2
 8012b9a:	092d      	lsrs	r5, r5, #4
 8012b9c:	091a      	lsrs	r2, r3, #4
 8012b9e:	eb05 0585 	add.w	r5, r5, r5, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8012ba2:	f000 000f 	and.w	r0, r0, #15
 8012ba6:	f004 040f 	and.w	r4, r4, #15
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8012baa:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8012bae:	f003 030f 	and.w	r3, r3, #15
 8012bb2:	eb00 0045 	add.w	r0, r0, r5, lsl #1
 8012bb6:	eb04 0446 	add.w	r4, r4, r6, lsl #1
 8012bba:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
 8012bbe:	7008      	strb	r0, [r1, #0]
    sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
 8012bc0:	704c      	strb	r4, [r1, #1]
    sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
 8012bc2:	708b      	strb	r3, [r1, #2]
}
 8012bc4:	2000      	movs	r0, #0
 8012bc6:	bc70      	pop	{r4, r5, r6}
 8012bc8:	4770      	bx	lr
 8012bca:	bf00      	nop

08012bcc <HAL_RTC_GetDate>:
  datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);
 8012bcc:	6803      	ldr	r3, [r0, #0]
 8012bce:	685b      	ldr	r3, [r3, #4]
 8012bd0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8012bd4:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
{
 8012bd8:	b470      	push	{r4, r5, r6}
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8012bda:	f3c3 2407 	ubfx	r4, r3, #8, #8
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13); 
 8012bde:	f3c3 3642 	ubfx	r6, r3, #13, #3
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8012be2:	0c18      	lsrs	r0, r3, #16
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8012be4:	f004 051f 	and.w	r5, r4, #31
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
 8012be8:	b2db      	uxtb	r3, r3
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13); 
 8012bea:	700e      	strb	r6, [r1, #0]
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8012bec:	704d      	strb	r5, [r1, #1]
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8012bee:	70c8      	strb	r0, [r1, #3]
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
 8012bf0:	708b      	strb	r3, [r1, #2]
  if(Format == RTC_FORMAT_BIN)
 8012bf2:	b9ba      	cbnz	r2, 8012c24 <HAL_RTC_GetDate+0x58>
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8012bf4:	092d      	lsrs	r5, r5, #4
 8012bf6:	00aa      	lsls	r2, r5, #2
 8012bf8:	0906      	lsrs	r6, r0, #4
 8012bfa:	4415      	add	r5, r2
 8012bfc:	091a      	lsrs	r2, r3, #4
  return (tmp + (Value & (uint8_t)0x0F));
 8012bfe:	f004 040f 	and.w	r4, r4, #15
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8012c02:	eb06 0686 	add.w	r6, r6, r6, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8012c06:	f000 000f 	and.w	r0, r0, #15
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8012c0a:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8012c0e:	f003 030f 	and.w	r3, r3, #15
 8012c12:	eb04 0445 	add.w	r4, r4, r5, lsl #1
 8012c16:	eb00 0046 	add.w	r0, r0, r6, lsl #1
 8012c1a:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
 8012c1e:	704c      	strb	r4, [r1, #1]
    sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
 8012c20:	70c8      	strb	r0, [r1, #3]
    sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
 8012c22:	708b      	strb	r3, [r1, #2]
}
 8012c24:	2000      	movs	r0, #0
 8012c26:	bc70      	pop	{r4, r5, r6}
 8012c28:	4770      	bx	lr
 8012c2a:	bf00      	nop

08012c2c <HAL_RTC_AlarmIRQHandler>:
  __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
 8012c2c:	4a1b      	ldr	r2, [pc, #108]	; (8012c9c <HAL_RTC_AlarmIRQHandler+0x70>)
 8012c2e:	6803      	ldr	r3, [r0, #0]
 8012c30:	f44f 2180 	mov.w	r1, #262144	; 0x40000
{
 8012c34:	b510      	push	{r4, lr}
 8012c36:	4604      	mov	r4, r0
  __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
 8012c38:	6151      	str	r1, [r2, #20]
  while(((__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA) != RESET) && (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != RESET)) ||
 8012c3a:	689a      	ldr	r2, [r3, #8]
 8012c3c:	04d2      	lsls	r2, r2, #19
 8012c3e:	d502      	bpl.n	8012c46 <HAL_RTC_AlarmIRQHandler+0x1a>
 8012c40:	68da      	ldr	r2, [r3, #12]
 8012c42:	05d0      	lsls	r0, r2, #23
 8012c44:	d405      	bmi.n	8012c52 <HAL_RTC_AlarmIRQHandler+0x26>
        ((__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRB) != RESET) && (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) != RESET)))
 8012c46:	689a      	ldr	r2, [r3, #8]
  while(((__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA) != RESET) && (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != RESET)) ||
 8012c48:	0491      	lsls	r1, r2, #18
 8012c4a:	d522      	bpl.n	8012c92 <HAL_RTC_AlarmIRQHandler+0x66>
        ((__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRB) != RESET) && (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) != RESET)))
 8012c4c:	68da      	ldr	r2, [r3, #12]
 8012c4e:	0592      	lsls	r2, r2, #22
 8012c50:	d51f      	bpl.n	8012c92 <HAL_RTC_AlarmIRQHandler+0x66>
    if((__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA) != RESET) && (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != RESET))
 8012c52:	689a      	ldr	r2, [r3, #8]
 8012c54:	04d1      	lsls	r1, r2, #19
 8012c56:	d502      	bpl.n	8012c5e <HAL_RTC_AlarmIRQHandler+0x32>
 8012c58:	68da      	ldr	r2, [r3, #12]
 8012c5a:	05d2      	lsls	r2, r2, #23
 8012c5c:	d40f      	bmi.n	8012c7e <HAL_RTC_AlarmIRQHandler+0x52>
    if((__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRB) != RESET) && (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) != RESET))
 8012c5e:	689a      	ldr	r2, [r3, #8]
 8012c60:	0490      	lsls	r0, r2, #18
 8012c62:	d5ea      	bpl.n	8012c3a <HAL_RTC_AlarmIRQHandler+0xe>
 8012c64:	68da      	ldr	r2, [r3, #12]
 8012c66:	0591      	lsls	r1, r2, #22
 8012c68:	d5e7      	bpl.n	8012c3a <HAL_RTC_AlarmIRQHandler+0xe>
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
 8012c6a:	68da      	ldr	r2, [r3, #12]
 8012c6c:	b2d2      	uxtb	r2, r2
 8012c6e:	f462 7220 	orn	r2, r2, #640	; 0x280
 8012c72:	60da      	str	r2, [r3, #12]
      HAL_RTCEx_AlarmBEventCallback(hrtc);
 8012c74:	4620      	mov	r0, r4
 8012c76:	f000 fab7 	bl	80131e8 <HAL_RTCEx_AlarmBEventCallback>
 8012c7a:	6823      	ldr	r3, [r4, #0]
 8012c7c:	e7dd      	b.n	8012c3a <HAL_RTC_AlarmIRQHandler+0xe>
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
 8012c7e:	68da      	ldr	r2, [r3, #12]
 8012c80:	b2d2      	uxtb	r2, r2
 8012c82:	f462 72c0 	orn	r2, r2, #384	; 0x180
 8012c86:	60da      	str	r2, [r3, #12]
      HAL_RTC_AlarmAEventCallback(hrtc);
 8012c88:	4620      	mov	r0, r4
 8012c8a:	f008 fa19 	bl	801b0c0 <HAL_RTC_AlarmAEventCallback>
 8012c8e:	6823      	ldr	r3, [r4, #0]
 8012c90:	e7e5      	b.n	8012c5e <HAL_RTC_AlarmIRQHandler+0x32>
  hrtc->State = HAL_RTC_STATE_READY;
 8012c92:	2301      	movs	r3, #1
 8012c94:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
}
 8012c98:	bd10      	pop	{r4, pc}
 8012c9a:	bf00      	nop
 8012c9c:	40010400 	.word	0x40010400

08012ca0 <HAL_RTC_WaitForSynchro>:
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8012ca0:	6802      	ldr	r2, [r0, #0]
{
 8012ca2:	b538      	push	{r3, r4, r5, lr}
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8012ca4:	68d3      	ldr	r3, [r2, #12]
 8012ca6:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8012caa:	60d3      	str	r3, [r2, #12]
{
 8012cac:	4604      	mov	r4, r0
  tickstart = HAL_GetTick();
 8012cae:	f7fd fc1d 	bl	80104ec <HAL_GetTick>
 8012cb2:	4605      	mov	r5, r0
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8012cb4:	e005      	b.n	8012cc2 <HAL_RTC_WaitForSynchro+0x22>
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8012cb6:	f7fd fc19 	bl	80104ec <HAL_GetTick>
 8012cba:	1b40      	subs	r0, r0, r5
 8012cbc:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8012cc0:	d805      	bhi.n	8012cce <HAL_RTC_WaitForSynchro+0x2e>
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8012cc2:	6823      	ldr	r3, [r4, #0]
 8012cc4:	68db      	ldr	r3, [r3, #12]
 8012cc6:	069b      	lsls	r3, r3, #26
 8012cc8:	d5f5      	bpl.n	8012cb6 <HAL_RTC_WaitForSynchro+0x16>
  return HAL_OK;
 8012cca:	2000      	movs	r0, #0
}
 8012ccc:	bd38      	pop	{r3, r4, r5, pc}
      return HAL_TIMEOUT;
 8012cce:	2003      	movs	r0, #3
}
 8012cd0:	bd38      	pop	{r3, r4, r5, pc}
 8012cd2:	bf00      	nop

08012cd4 <RTC_EnterInitMode>:
{
 8012cd4:	b538      	push	{r3, r4, r5, lr}
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8012cd6:	6803      	ldr	r3, [r0, #0]
 8012cd8:	68da      	ldr	r2, [r3, #12]
 8012cda:	0652      	lsls	r2, r2, #25
 8012cdc:	d501      	bpl.n	8012ce2 <RTC_EnterInitMode+0xe>
  return HAL_OK;
 8012cde:	2000      	movs	r0, #0
}
 8012ce0:	bd38      	pop	{r3, r4, r5, pc}
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8012ce2:	f04f 32ff 	mov.w	r2, #4294967295
 8012ce6:	60da      	str	r2, [r3, #12]
 8012ce8:	4604      	mov	r4, r0
    tickstart = HAL_GetTick();
 8012cea:	f7fd fbff 	bl	80104ec <HAL_GetTick>
 8012cee:	4605      	mov	r5, r0
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8012cf0:	6823      	ldr	r3, [r4, #0]
 8012cf2:	68db      	ldr	r3, [r3, #12]
 8012cf4:	065b      	lsls	r3, r3, #25
 8012cf6:	d4f2      	bmi.n	8012cde <RTC_EnterInitMode+0xa>
      if((HAL_GetTick()  - tickstart ) > RTC_TIMEOUT_VALUE)
 8012cf8:	f7fd fbf8 	bl	80104ec <HAL_GetTick>
 8012cfc:	1b40      	subs	r0, r0, r5
 8012cfe:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8012d02:	d9f5      	bls.n	8012cf0 <RTC_EnterInitMode+0x1c>
        return HAL_TIMEOUT;
 8012d04:	2003      	movs	r0, #3
}
 8012d06:	bd38      	pop	{r3, r4, r5, pc}

08012d08 <HAL_RTC_Init>:
{
 8012d08:	b570      	push	{r4, r5, r6, lr}
  if(hrtc == NULL)
 8012d0a:	2800      	cmp	r0, #0
 8012d0c:	d050      	beq.n	8012db0 <HAL_RTC_Init+0xa8>
  if(hrtc->State == HAL_RTC_STATE_RESET)
 8012d0e:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8012d12:	4604      	mov	r4, r0
 8012d14:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8012d18:	2b00      	cmp	r3, #0
 8012d1a:	d044      	beq.n	8012da6 <HAL_RTC_Init+0x9e>
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012d1c:	6823      	ldr	r3, [r4, #0]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8012d1e:	2002      	movs	r0, #2
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012d20:	21ca      	movs	r1, #202	; 0xca
 8012d22:	2253      	movs	r2, #83	; 0x53
  hrtc->State = HAL_RTC_STATE_BUSY;
 8012d24:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012d28:	6259      	str	r1, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8012d2a:	4620      	mov	r0, r4
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012d2c:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8012d2e:	f7ff ffd1 	bl	8012cd4 <RTC_EnterInitMode>
 8012d32:	4605      	mov	r5, r0
 8012d34:	2800      	cmp	r0, #0
 8012d36:	d12d      	bne.n	8012d94 <HAL_RTC_Init+0x8c>
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8012d38:	e9d4 3200 	ldrd	r3, r2, [r4]
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8012d3c:	6899      	ldr	r1, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8012d3e:	6926      	ldr	r6, [r4, #16]
 8012d40:	69a0      	ldr	r0, [r4, #24]
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8012d42:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
 8012d46:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8012d4a:	6099      	str	r1, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8012d4c:	6899      	ldr	r1, [r3, #8]
 8012d4e:	4332      	orrs	r2, r6
 8012d50:	4302      	orrs	r2, r0
 8012d52:	430a      	orrs	r2, r1
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8012d54:	68e1      	ldr	r1, [r4, #12]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8012d56:	609a      	str	r2, [r3, #8]
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8012d58:	6119      	str	r1, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16);
 8012d5a:	691a      	ldr	r2, [r3, #16]
 8012d5c:	68a1      	ldr	r1, [r4, #8]
 8012d5e:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8012d62:	611a      	str	r2, [r3, #16]
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 8012d64:	68da      	ldr	r2, [r3, #12]
 8012d66:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8012d6a:	60da      	str	r2, [r3, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8012d6c:	689a      	ldr	r2, [r3, #8]
 8012d6e:	0692      	lsls	r2, r2, #26
 8012d70:	d521      	bpl.n	8012db6 <HAL_RTC_Init+0xae>
    hrtc->Instance->OR &= (uint32_t)~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 8012d72:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
    hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 8012d74:	6960      	ldr	r0, [r4, #20]
 8012d76:	69e2      	ldr	r2, [r4, #28]
    hrtc->Instance->OR &= (uint32_t)~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 8012d78:	f021 0103 	bic.w	r1, r1, #3
 8012d7c:	64d9      	str	r1, [r3, #76]	; 0x4c
    hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 8012d7e:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8012d80:	4302      	orrs	r2, r0
 8012d82:	430a      	orrs	r2, r1
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8012d84:	20ff      	movs	r0, #255	; 0xff
    hrtc->State = HAL_RTC_STATE_READY;
 8012d86:	2101      	movs	r1, #1
    hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 8012d88:	64da      	str	r2, [r3, #76]	; 0x4c
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8012d8a:	6258      	str	r0, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY;
 8012d8c:	f884 1021 	strb.w	r1, [r4, #33]	; 0x21
}
 8012d90:	4628      	mov	r0, r5
 8012d92:	bd70      	pop	{r4, r5, r6, pc}
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8012d94:	6822      	ldr	r2, [r4, #0]
 8012d96:	21ff      	movs	r1, #255	; 0xff
        hrtc->State = HAL_RTC_STATE_ERROR;
 8012d98:	2304      	movs	r3, #4
        return HAL_ERROR;
 8012d9a:	2501      	movs	r5, #1
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8012d9c:	6251      	str	r1, [r2, #36]	; 0x24
}
 8012d9e:	4628      	mov	r0, r5
        hrtc->State = HAL_RTC_STATE_ERROR;
 8012da0:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
}
 8012da4:	bd70      	pop	{r4, r5, r6, pc}
    hrtc->Lock = HAL_UNLOCKED;
 8012da6:	f880 2020 	strb.w	r2, [r0, #32]
    HAL_RTC_MspInit(hrtc);
 8012daa:	f00a fe7d 	bl	801daa8 <HAL_RTC_MspInit>
 8012dae:	e7b5      	b.n	8012d1c <HAL_RTC_Init+0x14>
     return HAL_ERROR;
 8012db0:	2501      	movs	r5, #1
}
 8012db2:	4628      	mov	r0, r5
 8012db4:	bd70      	pop	{r4, r5, r6, pc}
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8012db6:	4620      	mov	r0, r4
 8012db8:	f7ff ff72 	bl	8012ca0 <HAL_RTC_WaitForSynchro>
 8012dbc:	2800      	cmp	r0, #0
 8012dbe:	d1e9      	bne.n	8012d94 <HAL_RTC_Init+0x8c>
 8012dc0:	6823      	ldr	r3, [r4, #0]
 8012dc2:	e7d6      	b.n	8012d72 <HAL_RTC_Init+0x6a>

08012dc4 <HAL_RTC_SetTime>:
{
 8012dc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hrtc);
 8012dc6:	f890 3020 	ldrb.w	r3, [r0, #32]
 8012dca:	2b01      	cmp	r3, #1
 8012dcc:	f000 808b 	beq.w	8012ee6 <HAL_RTC_SetTime+0x122>
 8012dd0:	460d      	mov	r5, r1
  hrtc->State = HAL_RTC_STATE_BUSY;
 8012dd2:	2302      	movs	r3, #2
  __HAL_LOCK(hrtc);
 8012dd4:	2101      	movs	r1, #1
 8012dd6:	f880 1020 	strb.w	r1, [r0, #32]
 8012dda:	4604      	mov	r4, r0
  hrtc->State = HAL_RTC_STATE_BUSY;
 8012ddc:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
 8012de0:	6801      	ldr	r1, [r0, #0]
  if(Format == RTC_FORMAT_BIN)
 8012de2:	2a00      	cmp	r2, #0
 8012de4:	d03b      	beq.n	8012e5e <HAL_RTC_SetTime+0x9a>
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8012de6:	688e      	ldr	r6, [r1, #8]
              ((uint32_t)(sTime->Minutes) << 8) | \
 8012de8:	7868      	ldrb	r0, [r5, #1]
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
 8012dea:	782a      	ldrb	r2, [r5, #0]
              ((uint32_t)sTime->Seconds) | \
 8012dec:	78ab      	ldrb	r3, [r5, #2]
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8012dee:	f016 0640 	ands.w	r6, r6, #64	; 0x40
 8012df2:	bf14      	ite	ne
 8012df4:	78ee      	ldrbne	r6, [r5, #3]
      sTime->TimeFormat = 0x00;
 8012df6:	70ee      	strbeq	r6, [r5, #3]
              ((uint32_t)(sTime->Minutes) << 8) | \
 8012df8:	ea4f 2000 	mov.w	r0, r0, lsl #8
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
 8012dfc:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 8012e00:	bf18      	it	ne
 8012e02:	0436      	lslne	r6, r6, #16
              ((uint32_t)(sTime->Minutes) << 8) | \
 8012e04:	4318      	orrs	r0, r3
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
 8012e06:	4306      	orrs	r6, r0
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012e08:	22ca      	movs	r2, #202	; 0xca
 8012e0a:	2353      	movs	r3, #83	; 0x53
 8012e0c:	624a      	str	r2, [r1, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8012e0e:	4620      	mov	r0, r4
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012e10:	624b      	str	r3, [r1, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8012e12:	f7ff ff5f 	bl	8012cd4 <RTC_EnterInitMode>
 8012e16:	4607      	mov	r7, r0
 8012e18:	2800      	cmp	r0, #0
 8012e1a:	d158      	bne.n	8012ece <HAL_RTC_SetTime+0x10a>
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8012e1c:	6823      	ldr	r3, [r4, #0]
 8012e1e:	f006 367f 	and.w	r6, r6, #2139062143	; 0x7f7f7f7f
 8012e22:	f026 46fe 	bic.w	r6, r6, #2130706432	; 0x7f000000
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8012e26:	e9d5 2503 	ldrd	r2, r5, [r5, #12]
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8012e2a:	601e      	str	r6, [r3, #0]
    hrtc->Instance->CR &= ((uint32_t)~RTC_CR_BCK);
 8012e2c:	6899      	ldr	r1, [r3, #8]
 8012e2e:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 8012e32:	6099      	str	r1, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8012e34:	6899      	ldr	r1, [r3, #8]
 8012e36:	432a      	orrs	r2, r5
 8012e38:	430a      	orrs	r2, r1
 8012e3a:	609a      	str	r2, [r3, #8]
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 8012e3c:	68da      	ldr	r2, [r3, #12]
 8012e3e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8012e42:	60da      	str	r2, [r3, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8012e44:	689a      	ldr	r2, [r3, #8]
 8012e46:	0692      	lsls	r2, r2, #26
 8012e48:	d550      	bpl.n	8012eec <HAL_RTC_SetTime+0x128>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8012e4a:	20ff      	movs	r0, #255	; 0xff
   hrtc->State = HAL_RTC_STATE_READY;
 8012e4c:	2101      	movs	r1, #1
   __HAL_UNLOCK(hrtc); 
 8012e4e:	2200      	movs	r2, #0
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8012e50:	6258      	str	r0, [r3, #36]	; 0x24
   hrtc->State = HAL_RTC_STATE_READY;
 8012e52:	f884 1021 	strb.w	r1, [r4, #33]	; 0x21
   __HAL_UNLOCK(hrtc); 
 8012e56:	f884 2020 	strb.w	r2, [r4, #32]
}
 8012e5a:	4638      	mov	r0, r7
 8012e5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8012e5e:	688f      	ldr	r7, [r1, #8]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 8012e60:	7828      	ldrb	r0, [r5, #0]
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8012e62:	f017 0740 	ands.w	r7, r7, #64	; 0x40
 8012e66:	bf16      	itet	ne
 8012e68:	78ee      	ldrbne	r6, [r5, #3]
      sTime->TimeFormat = 0x00;
 8012e6a:	70ef      	strbeq	r7, [r5, #3]
 8012e6c:	0437      	lslne	r7, r6, #16
  while(Value >= 10)
 8012e6e:	2809      	cmp	r0, #9
 8012e70:	d94c      	bls.n	8012f0c <HAL_RTC_SetTime+0x148>
  uint32_t bcdhigh = 0;
 8012e72:	2300      	movs	r3, #0
    Value -= 10;
 8012e74:	380a      	subs	r0, #10
 8012e76:	b2c0      	uxtb	r0, r0
  while(Value >= 10)
 8012e78:	2809      	cmp	r0, #9
    bcdhigh++;
 8012e7a:	f103 0301 	add.w	r3, r3, #1
  while(Value >= 10)
 8012e7e:	d8f9      	bhi.n	8012e74 <HAL_RTC_SetTime+0xb0>
 8012e80:	011b      	lsls	r3, r3, #4
 8012e82:	b2de      	uxtb	r6, r3
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8) | \
 8012e84:	786b      	ldrb	r3, [r5, #1]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 8012e86:	4330      	orrs	r0, r6
  while(Value >= 10)
 8012e88:	2b09      	cmp	r3, #9
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 8012e8a:	ea4f 4600 	mov.w	r6, r0, lsl #16
  while(Value >= 10)
 8012e8e:	d941      	bls.n	8012f14 <HAL_RTC_SetTime+0x150>
  uint32_t bcdhigh = 0;
 8012e90:	2000      	movs	r0, #0
    Value -= 10;
 8012e92:	3b0a      	subs	r3, #10
 8012e94:	b2db      	uxtb	r3, r3
  while(Value >= 10)
 8012e96:	2b09      	cmp	r3, #9
    bcdhigh++;
 8012e98:	f100 0001 	add.w	r0, r0, #1
  while(Value >= 10)
 8012e9c:	d8f9      	bhi.n	8012e92 <HAL_RTC_SetTime+0xce>
 8012e9e:	0100      	lsls	r0, r0, #4
 8012ea0:	fa5f fc80 	uxtb.w	ip, r0
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 8012ea4:	78a8      	ldrb	r0, [r5, #2]
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8) | \
 8012ea6:	ea43 030c 	orr.w	r3, r3, ip
  while(Value >= 10)
 8012eaa:	2809      	cmp	r0, #9
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8) | \
 8012eac:	ea4f 2303 	mov.w	r3, r3, lsl #8
  while(Value >= 10)
 8012eb0:	d92e      	bls.n	8012f10 <HAL_RTC_SetTime+0x14c>
    Value -= 10;
 8012eb2:	380a      	subs	r0, #10
 8012eb4:	b2c0      	uxtb	r0, r0
  while(Value >= 10)
 8012eb6:	2809      	cmp	r0, #9
    bcdhigh++;
 8012eb8:	f102 0201 	add.w	r2, r2, #1
  while(Value >= 10)
 8012ebc:	d8f9      	bhi.n	8012eb2 <HAL_RTC_SetTime+0xee>
 8012ebe:	0112      	lsls	r2, r2, #4
 8012ec0:	b2d2      	uxtb	r2, r2
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 8012ec2:	433e      	orrs	r6, r7
 8012ec4:	4333      	orrs	r3, r6
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 8012ec6:	4310      	orrs	r0, r2
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 8012ec8:	ea43 0600 	orr.w	r6, r3, r0
 8012ecc:	e79c      	b.n	8012e08 <HAL_RTC_SetTime+0x44>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8012ece:	6821      	ldr	r1, [r4, #0]
 8012ed0:	20ff      	movs	r0, #255	; 0xff
    hrtc->State = HAL_RTC_STATE_ERROR;
 8012ed2:	2204      	movs	r2, #4
    __HAL_UNLOCK(hrtc);
 8012ed4:	2300      	movs	r3, #0
    return HAL_ERROR;
 8012ed6:	2701      	movs	r7, #1
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8012ed8:	6248      	str	r0, [r1, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 8012eda:	f884 2021 	strb.w	r2, [r4, #33]	; 0x21
    __HAL_UNLOCK(hrtc);
 8012ede:	f884 3020 	strb.w	r3, [r4, #32]
}
 8012ee2:	4638      	mov	r0, r7
 8012ee4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hrtc);
 8012ee6:	2702      	movs	r7, #2
}
 8012ee8:	4638      	mov	r0, r7
 8012eea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8012eec:	4620      	mov	r0, r4
 8012eee:	f7ff fed7 	bl	8012ca0 <HAL_RTC_WaitForSynchro>
 8012ef2:	b908      	cbnz	r0, 8012ef8 <HAL_RTC_SetTime+0x134>
 8012ef4:	6823      	ldr	r3, [r4, #0]
 8012ef6:	e7a8      	b.n	8012e4a <HAL_RTC_SetTime+0x86>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8012ef8:	6822      	ldr	r2, [r4, #0]
 8012efa:	21ff      	movs	r1, #255	; 0xff
        hrtc->State = HAL_RTC_STATE_ERROR;
 8012efc:	2304      	movs	r3, #4
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8012efe:	6251      	str	r1, [r2, #36]	; 0x24
        __HAL_UNLOCK(hrtc);
 8012f00:	f884 7020 	strb.w	r7, [r4, #32]
        hrtc->State = HAL_RTC_STATE_ERROR;
 8012f04:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
        return HAL_ERROR;
 8012f08:	2701      	movs	r7, #1
 8012f0a:	e7a6      	b.n	8012e5a <HAL_RTC_SetTime+0x96>
  while(Value >= 10)
 8012f0c:	2600      	movs	r6, #0
 8012f0e:	e7b9      	b.n	8012e84 <HAL_RTC_SetTime+0xc0>
 8012f10:	2200      	movs	r2, #0
 8012f12:	e7d6      	b.n	8012ec2 <HAL_RTC_SetTime+0xfe>
 8012f14:	f04f 0c00 	mov.w	ip, #0
 8012f18:	e7c4      	b.n	8012ea4 <HAL_RTC_SetTime+0xe0>
 8012f1a:	bf00      	nop

08012f1c <HAL_RTC_SetDate>:
 __HAL_LOCK(hrtc);
 8012f1c:	f890 3020 	ldrb.w	r3, [r0, #32]
 8012f20:	2b01      	cmp	r3, #1
{
 8012f22:	b570      	push	{r4, r5, r6, lr}
 __HAL_LOCK(hrtc);
 8012f24:	d075      	beq.n	8013012 <HAL_RTC_SetDate+0xf6>
 8012f26:	4605      	mov	r5, r0
  hrtc->State = HAL_RTC_STATE_BUSY;
 8012f28:	2302      	movs	r3, #2
 __HAL_LOCK(hrtc);
 8012f2a:	2001      	movs	r0, #1
 8012f2c:	f885 0020 	strb.w	r0, [r5, #32]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8012f30:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
 8012f34:	780e      	ldrb	r6, [r1, #0]
 8012f36:	7848      	ldrb	r0, [r1, #1]
 8012f38:	788c      	ldrb	r4, [r1, #2]
 8012f3a:	78cb      	ldrb	r3, [r1, #3]
 8012f3c:	0376      	lsls	r6, r6, #13
  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8012f3e:	b332      	cbz	r2, 8012f8e <HAL_RTC_SetDate+0x72>
    datetmpreg = ((((uint32_t)sDate->Year) << 16) | \
 8012f40:	ea46 4303 	orr.w	r3, r6, r3, lsl #16
 8012f44:	431c      	orrs	r4, r3
 8012f46:	ea44 2400 	orr.w	r4, r4, r0, lsl #8
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012f4a:	682b      	ldr	r3, [r5, #0]
 8012f4c:	21ca      	movs	r1, #202	; 0xca
 8012f4e:	2253      	movs	r2, #83	; 0x53
 8012f50:	6259      	str	r1, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8012f52:	4628      	mov	r0, r5
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012f54:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8012f56:	f7ff febd 	bl	8012cd4 <RTC_EnterInitMode>
 8012f5a:	4606      	mov	r6, r0
 8012f5c:	2800      	cmp	r0, #0
 8012f5e:	d14c      	bne.n	8012ffa <HAL_RTC_SetDate+0xde>
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 8012f60:	682b      	ldr	r3, [r5, #0]
 8012f62:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
 8012f66:	f024 04c0 	bic.w	r4, r4, #192	; 0xc0
 8012f6a:	605c      	str	r4, [r3, #4]
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 8012f6c:	68da      	ldr	r2, [r3, #12]
 8012f6e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8012f72:	60da      	str	r2, [r3, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8012f74:	689a      	ldr	r2, [r3, #8]
 8012f76:	0692      	lsls	r2, r2, #26
 8012f78:	d54e      	bpl.n	8013018 <HAL_RTC_SetDate+0xfc>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8012f7a:	20ff      	movs	r0, #255	; 0xff
    hrtc->State = HAL_RTC_STATE_READY ;
 8012f7c:	2101      	movs	r1, #1
    __HAL_UNLOCK(hrtc);
 8012f7e:	2200      	movs	r2, #0
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8012f80:	6258      	str	r0, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY ;
 8012f82:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21
    __HAL_UNLOCK(hrtc);
 8012f86:	f885 2020 	strb.w	r2, [r5, #32]
}
 8012f8a:	4630      	mov	r0, r6
 8012f8c:	bd70      	pop	{r4, r5, r6, pc}
  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8012f8e:	f010 0f10 	tst.w	r0, #16
 8012f92:	d004      	beq.n	8012f9e <HAL_RTC_SetDate+0x82>
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 8012f94:	f020 0010 	bic.w	r0, r0, #16
 8012f98:	300a      	adds	r0, #10
 8012f9a:	b2c0      	uxtb	r0, r0
 8012f9c:	7048      	strb	r0, [r1, #1]
  while(Value >= 10)
 8012f9e:	2b09      	cmp	r3, #9
  uint32_t bcdhigh = 0;
 8012fa0:	f04f 0100 	mov.w	r1, #0
  while(Value >= 10)
 8012fa4:	d907      	bls.n	8012fb6 <HAL_RTC_SetDate+0x9a>
    Value -= 10;
 8012fa6:	3b0a      	subs	r3, #10
 8012fa8:	b2db      	uxtb	r3, r3
  while(Value >= 10)
 8012faa:	2b09      	cmp	r3, #9
    bcdhigh++;
 8012fac:	f101 0101 	add.w	r1, r1, #1
  while(Value >= 10)
 8012fb0:	d8f9      	bhi.n	8012fa6 <HAL_RTC_SetDate+0x8a>
 8012fb2:	0109      	lsls	r1, r1, #4
 8012fb4:	b2c9      	uxtb	r1, r1
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 8012fb6:	430b      	orrs	r3, r1
  while(Value >= 10)
 8012fb8:	2809      	cmp	r0, #9
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 8012fba:	ea4f 4303 	mov.w	r3, r3, lsl #16
  uint32_t bcdhigh = 0;
 8012fbe:	f04f 0100 	mov.w	r1, #0
  while(Value >= 10)
 8012fc2:	d907      	bls.n	8012fd4 <HAL_RTC_SetDate+0xb8>
    Value -= 10;
 8012fc4:	380a      	subs	r0, #10
 8012fc6:	b2c0      	uxtb	r0, r0
  while(Value >= 10)
 8012fc8:	2809      	cmp	r0, #9
    bcdhigh++;
 8012fca:	f101 0101 	add.w	r1, r1, #1
  while(Value >= 10)
 8012fce:	d8f9      	bhi.n	8012fc4 <HAL_RTC_SetDate+0xa8>
 8012fd0:	0109      	lsls	r1, r1, #4
 8012fd2:	b2c9      	uxtb	r1, r1
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8) | \
 8012fd4:	4308      	orrs	r0, r1
  while(Value >= 10)
 8012fd6:	2c09      	cmp	r4, #9
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8) | \
 8012fd8:	ea4f 2100 	mov.w	r1, r0, lsl #8
  while(Value >= 10)
 8012fdc:	d92c      	bls.n	8013038 <HAL_RTC_SetDate+0x11c>
    Value -= 10;
 8012fde:	3c0a      	subs	r4, #10
 8012fe0:	b2e4      	uxtb	r4, r4
  while(Value >= 10)
 8012fe2:	2c09      	cmp	r4, #9
    bcdhigh++;
 8012fe4:	f102 0201 	add.w	r2, r2, #1
  while(Value >= 10)
 8012fe8:	d8f9      	bhi.n	8012fde <HAL_RTC_SetDate+0xc2>
 8012fea:	0112      	lsls	r2, r2, #4
 8012fec:	b2d2      	uxtb	r2, r2
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 8012fee:	ea43 0006 	orr.w	r0, r3, r6
 8012ff2:	4308      	orrs	r0, r1
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 8012ff4:	4314      	orrs	r4, r2
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 8012ff6:	4304      	orrs	r4, r0
 8012ff8:	e7a7      	b.n	8012f4a <HAL_RTC_SetDate+0x2e>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8012ffa:	6829      	ldr	r1, [r5, #0]
 8012ffc:	20ff      	movs	r0, #255	; 0xff
    hrtc->State = HAL_RTC_STATE_ERROR;
 8012ffe:	2204      	movs	r2, #4
    __HAL_UNLOCK(hrtc);
 8013000:	2300      	movs	r3, #0
    return HAL_ERROR;
 8013002:	2601      	movs	r6, #1
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013004:	6248      	str	r0, [r1, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 8013006:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21
    __HAL_UNLOCK(hrtc);
 801300a:	f885 3020 	strb.w	r3, [r5, #32]
}
 801300e:	4630      	mov	r0, r6
 8013010:	bd70      	pop	{r4, r5, r6, pc}
 __HAL_LOCK(hrtc);
 8013012:	2602      	movs	r6, #2
}
 8013014:	4630      	mov	r0, r6
 8013016:	bd70      	pop	{r4, r5, r6, pc}
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8013018:	4628      	mov	r0, r5
 801301a:	f7ff fe41 	bl	8012ca0 <HAL_RTC_WaitForSynchro>
 801301e:	b908      	cbnz	r0, 8013024 <HAL_RTC_SetDate+0x108>
 8013020:	682b      	ldr	r3, [r5, #0]
 8013022:	e7aa      	b.n	8012f7a <HAL_RTC_SetDate+0x5e>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 8013024:	682a      	ldr	r2, [r5, #0]
 8013026:	21ff      	movs	r1, #255	; 0xff
        hrtc->State = HAL_RTC_STATE_ERROR;
 8013028:	2304      	movs	r3, #4
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 801302a:	6251      	str	r1, [r2, #36]	; 0x24
        __HAL_UNLOCK(hrtc);
 801302c:	f885 6020 	strb.w	r6, [r5, #32]
        hrtc->State = HAL_RTC_STATE_ERROR;
 8013030:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
        return HAL_ERROR;
 8013034:	2601      	movs	r6, #1
 8013036:	e7a8      	b.n	8012f8a <HAL_RTC_SetDate+0x6e>
  while(Value >= 10)
 8013038:	2200      	movs	r2, #0
 801303a:	e7d8      	b.n	8012fee <HAL_RTC_SetDate+0xd2>

0801303c <HAL_RTCEx_SetWakeUpTimer_IT>:
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 801303c:	f890 3020 	ldrb.w	r3, [r0, #32]
 8013040:	2b01      	cmp	r3, #1
 8013042:	d074      	beq.n	801312e <HAL_RTCEx_SetWakeUpTimer_IT+0xf2>
{
 8013044:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8013048:	6803      	ldr	r3, [r0, #0]
 801304a:	4616      	mov	r6, r2
 801304c:	460f      	mov	r7, r1
  hrtc->State = HAL_RTC_STATE_BUSY;
 801304e:	2202      	movs	r2, #2
  __HAL_LOCK(hrtc);
 8013050:	2101      	movs	r1, #1
  hrtc->State = HAL_RTC_STATE_BUSY;
 8013052:	f880 2021 	strb.w	r2, [r0, #33]	; 0x21
  __HAL_LOCK(hrtc);
 8013056:	f880 1020 	strb.w	r1, [r0, #32]
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 801305a:	2253      	movs	r2, #83	; 0x53
 801305c:	21ca      	movs	r1, #202	; 0xca
 801305e:	6259      	str	r1, [r3, #36]	; 0x24
 8013060:	625a      	str	r2, [r3, #36]	; 0x24

  /*Check RTC WUTWF flag is reset only when wake up timer enabled*/
  if((hrtc->Instance->CR & RTC_CR_WUTE) != RESET)
 8013062:	689a      	ldr	r2, [r3, #8]
 8013064:	0551      	lsls	r1, r2, #21
 8013066:	4605      	mov	r5, r0
 8013068:	d50d      	bpl.n	8013086 <HAL_RTCEx_SetWakeUpTimer_IT+0x4a>
  {
    tickstart = HAL_GetTick();
 801306a:	f7fd fa3f 	bl	80104ec <HAL_GetTick>
 801306e:	4604      	mov	r4, r0

    /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
 8013070:	e005      	b.n	801307e <HAL_RTCEx_SetWakeUpTimer_IT+0x42>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8013072:	f7fd fa3b 	bl	80104ec <HAL_GetTick>
 8013076:	1b00      	subs	r0, r0, r4
 8013078:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 801307c:	d84b      	bhi.n	8013116 <HAL_RTCEx_SetWakeUpTimer_IT+0xda>
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
 801307e:	682b      	ldr	r3, [r5, #0]
 8013080:	68da      	ldr	r2, [r3, #12]
 8013082:	0752      	lsls	r2, r2, #29
 8013084:	d4f5      	bmi.n	8013072 <HAL_RTCEx_SetWakeUpTimer_IT+0x36>
        return HAL_TIMEOUT;
      }
    }
  }
  /* Disable the Wake-Up timer */
  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
 8013086:	689a      	ldr	r2, [r3, #8]
 8013088:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 801308c:	609a      	str	r2, [r3, #8]

  /* Clear flag Wake-Up */
  __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
 801308e:	68da      	ldr	r2, [r3, #12]
 8013090:	b2d2      	uxtb	r2, r2
 8013092:	f462 6290 	orn	r2, r2, #1152	; 0x480
 8013096:	60da      	str	r2, [r3, #12]

  tickstart = HAL_GetTick();
 8013098:	f7fd fa28 	bl	80104ec <HAL_GetTick>
 801309c:	4680      	mov	r8, r0

  /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 801309e:	e006      	b.n	80130ae <HAL_RTCEx_SetWakeUpTimer_IT+0x72>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 80130a0:	f7fd fa24 	bl	80104ec <HAL_GetTick>
 80130a4:	eba0 0008 	sub.w	r0, r0, r8
 80130a8:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80130ac:	d828      	bhi.n	8013100 <HAL_RTCEx_SetWakeUpTimer_IT+0xc4>
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 80130ae:	6828      	ldr	r0, [r5, #0]
 80130b0:	68c4      	ldr	r4, [r0, #12]
 80130b2:	f014 0404 	ands.w	r4, r4, #4
 80130b6:	d0f3      	beq.n	80130a0 <HAL_RTCEx_SetWakeUpTimer_IT+0x64>
      return HAL_TIMEOUT;
    }
  }

  /* Configure the Wakeup Timer counter */
  hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
 80130b8:	6147      	str	r7, [r0, #20]

  /* Clear the Wakeup Timer clock source bits in CR register */
  hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 80130ba:	6882      	ldr	r2, [r0, #8]

  /* Configure the clock source */
  hrtc->Instance->CR |= (uint32_t)WakeUpClock;

  /* RTC WakeUpTimer Interrupt Configuration: EXTI configuration */
  __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT();
 80130bc:	4b1d      	ldr	r3, [pc, #116]	; (8013134 <HAL_RTCEx_SetWakeUpTimer_IT+0xf8>)
  hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 80130be:	f022 0207 	bic.w	r2, r2, #7
 80130c2:	6082      	str	r2, [r0, #8]
  hrtc->Instance->CR |= (uint32_t)WakeUpClock;
 80130c4:	6882      	ldr	r2, [r0, #8]
 80130c6:	4316      	orrs	r6, r2
 80130c8:	6086      	str	r6, [r0, #8]
  __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT();
 80130ca:	681a      	ldr	r2, [r3, #0]
 80130cc:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80130d0:	601a      	str	r2, [r3, #0]

  __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE();
 80130d2:	689a      	ldr	r2, [r3, #8]
 80130d4:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80130d8:	609a      	str	r2, [r3, #8]

  /* Configure the Interrupt in the RTC_CR register */
  __HAL_RTC_WAKEUPTIMER_ENABLE_IT(hrtc,RTC_IT_WUT);
 80130da:	6883      	ldr	r3, [r0, #8]
 80130dc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80130e0:	6083      	str	r3, [r0, #8]
  
  /* Enable the Wakeup Timer */
  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
 80130e2:	6883      	ldr	r3, [r0, #8]
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

  hrtc->State = HAL_RTC_STATE_READY; 

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 80130e4:	2200      	movs	r2, #0
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80130e6:	24ff      	movs	r4, #255	; 0xff
  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
 80130e8:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  hrtc->State = HAL_RTC_STATE_READY; 
 80130ec:	2101      	movs	r1, #1
  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
 80130ee:	6083      	str	r3, [r0, #8]
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80130f0:	6244      	str	r4, [r0, #36]	; 0x24

  return HAL_OK;
 80130f2:	4610      	mov	r0, r2
  hrtc->State = HAL_RTC_STATE_READY; 
 80130f4:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21
  __HAL_UNLOCK(hrtc);
 80130f8:	f885 2020 	strb.w	r2, [r5, #32]
}
 80130fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013100:	682a      	ldr	r2, [r5, #0]
      hrtc->State = HAL_RTC_STATE_TIMEOUT; 
 8013102:	2303      	movs	r3, #3
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013104:	21ff      	movs	r1, #255	; 0xff
 8013106:	6251      	str	r1, [r2, #36]	; 0x24
      return HAL_TIMEOUT;
 8013108:	4618      	mov	r0, r3
      __HAL_UNLOCK(hrtc);
 801310a:	f885 4020 	strb.w	r4, [r5, #32]
      hrtc->State = HAL_RTC_STATE_TIMEOUT; 
 801310e:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
}
 8013112:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013116:	6829      	ldr	r1, [r5, #0]
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8013118:	2303      	movs	r3, #3
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 801311a:	20ff      	movs	r0, #255	; 0xff
        __HAL_UNLOCK(hrtc);
 801311c:	2200      	movs	r2, #0
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 801311e:	6248      	str	r0, [r1, #36]	; 0x24
        return HAL_TIMEOUT;
 8013120:	4618      	mov	r0, r3
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8013122:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
        __HAL_UNLOCK(hrtc);
 8013126:	f885 2020 	strb.w	r2, [r5, #32]
}
 801312a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  __HAL_LOCK(hrtc);
 801312e:	2002      	movs	r0, #2
}
 8013130:	4770      	bx	lr
 8013132:	bf00      	nop
 8013134:	40010400 	.word	0x40010400

08013138 <HAL_RTCEx_DeactivateWakeUpTimer>:
uint32_t HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc)
{
  uint32_t tickstart = 0;

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8013138:	f890 3020 	ldrb.w	r3, [r0, #32]
 801313c:	2b01      	cmp	r3, #1
 801313e:	d037      	beq.n	80131b0 <HAL_RTCEx_DeactivateWakeUpTimer+0x78>
{
 8013140:	b570      	push	{r4, r5, r6, lr}

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8013142:	6803      	ldr	r3, [r0, #0]
 8013144:	4605      	mov	r5, r0
 8013146:	21ca      	movs	r1, #202	; 0xca
  hrtc->State = HAL_RTC_STATE_BUSY;
 8013148:	2002      	movs	r0, #2
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 801314a:	2253      	movs	r2, #83	; 0x53
  __HAL_LOCK(hrtc);
 801314c:	2401      	movs	r4, #1
  hrtc->State = HAL_RTC_STATE_BUSY;
 801314e:	f885 0021 	strb.w	r0, [r5, #33]	; 0x21
  __HAL_LOCK(hrtc);
 8013152:	f885 4020 	strb.w	r4, [r5, #32]
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8013156:	6259      	str	r1, [r3, #36]	; 0x24
 8013158:	625a      	str	r2, [r3, #36]	; 0x24

  /* Disable the Wakeup Timer */
  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
 801315a:	689a      	ldr	r2, [r3, #8]
 801315c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8013160:	609a      	str	r2, [r3, #8]

  /* In case of interrupt mode is used, the interrupt source must disabled */
  __HAL_RTC_WAKEUPTIMER_DISABLE_IT(hrtc,RTC_IT_WUT);
 8013162:	689a      	ldr	r2, [r3, #8]
 8013164:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8013168:	609a      	str	r2, [r3, #8]

  tickstart = HAL_GetTick();
 801316a:	f7fd f9bf 	bl	80104ec <HAL_GetTick>
 801316e:	4606      	mov	r6, r0
  /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 8013170:	e005      	b.n	801317e <HAL_RTCEx_DeactivateWakeUpTimer+0x46>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8013172:	f7fd f9bb 	bl	80104ec <HAL_GetTick>
 8013176:	1b80      	subs	r0, r0, r6
 8013178:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 801317c:	d80e      	bhi.n	801319c <HAL_RTCEx_DeactivateWakeUpTimer+0x64>
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 801317e:	682a      	ldr	r2, [r5, #0]
 8013180:	68d4      	ldr	r4, [r2, #12]
 8013182:	f014 0404 	ands.w	r4, r4, #4
 8013186:	d0f4      	beq.n	8013172 <HAL_RTCEx_DeactivateWakeUpTimer+0x3a>
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8013188:	2300      	movs	r3, #0
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 801318a:	20ff      	movs	r0, #255	; 0xff
  hrtc->State = HAL_RTC_STATE_READY;
 801318c:	2101      	movs	r1, #1
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 801318e:	6250      	str	r0, [r2, #36]	; 0x24

  return HAL_OK;
 8013190:	4618      	mov	r0, r3
  hrtc->State = HAL_RTC_STATE_READY;
 8013192:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21
  __HAL_UNLOCK(hrtc);
 8013196:	f885 3020 	strb.w	r3, [r5, #32]
}
 801319a:	bd70      	pop	{r4, r5, r6, pc}
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 801319c:	682a      	ldr	r2, [r5, #0]
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 801319e:	2303      	movs	r3, #3
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80131a0:	21ff      	movs	r1, #255	; 0xff
 80131a2:	6251      	str	r1, [r2, #36]	; 0x24
      return HAL_TIMEOUT;
 80131a4:	4618      	mov	r0, r3
      __HAL_UNLOCK(hrtc);
 80131a6:	f885 4020 	strb.w	r4, [r5, #32]
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 80131aa:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
}
 80131ae:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hrtc);
 80131b0:	2002      	movs	r0, #2
}
 80131b2:	4770      	bx	lr

080131b4 <HAL_RTCEx_WakeUpTimerEventCallback>:
 80131b4:	4770      	bx	lr
 80131b6:	bf00      	nop

080131b8 <HAL_RTCEx_WakeUpTimerIRQHandler>:
  * @retval None
  */
void HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc)
{
  /* Clear the EXTI's line Flag for RTC WakeUpTimer */
  __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
 80131b8:	4a0a      	ldr	r2, [pc, #40]	; (80131e4 <HAL_RTCEx_WakeUpTimerIRQHandler+0x2c>)
  
  /* Get the pending status of the WAKEUPTIMER Interrupt */
  if(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) != RESET)
 80131ba:	6803      	ldr	r3, [r0, #0]
  __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
 80131bc:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
{
 80131c0:	b510      	push	{r4, lr}
  __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
 80131c2:	6151      	str	r1, [r2, #20]
  if(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) != RESET)
 80131c4:	68da      	ldr	r2, [r3, #12]
 80131c6:	0552      	lsls	r2, r2, #21
{
 80131c8:	4604      	mov	r4, r0
  if(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) != RESET)
 80131ca:	d506      	bpl.n	80131da <HAL_RTCEx_WakeUpTimerIRQHandler+0x22>
  {   
    /* Clear the WAKEUPTIMER interrupt pending bit */
    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
 80131cc:	68da      	ldr	r2, [r3, #12]
 80131ce:	b2d2      	uxtb	r2, r2
 80131d0:	f462 6290 	orn	r2, r2, #1152	; 0x480
 80131d4:	60da      	str	r2, [r3, #12]

    /* WAKEUPTIMER callback */ 
    HAL_RTCEx_WakeUpTimerEventCallback(hrtc);
 80131d6:	f7ff ffed 	bl	80131b4 <HAL_RTCEx_WakeUpTimerEventCallback>
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 80131da:	2301      	movs	r3, #1
 80131dc:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
}
 80131e0:	bd10      	pop	{r4, pc}
 80131e2:	bf00      	nop
 80131e4:	40010400 	.word	0x40010400

080131e8 <HAL_RTCEx_AlarmBEventCallback>:
 80131e8:	4770      	bx	lr
 80131ea:	bf00      	nop

080131ec <SPI_WaitFifoStateUntilTimeout.part.1>:
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80131ec:	e9d0 3100 	ldrd	r3, r1, [r0]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80131f0:	685a      	ldr	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80131f2:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80131f6:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 80131fa:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80131fc:	d013      	beq.n	8013226 <SPI_WaitFifoStateUntilTimeout.part.1+0x3a>
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80131fe:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8013200:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8013204:	d107      	bne.n	8013216 <SPI_WaitFifoStateUntilTimeout.part.1+0x2a>
        {
          SPI_RESET_CRC(hspi);
 8013206:	681a      	ldr	r2, [r3, #0]
 8013208:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 801320c:	601a      	str	r2, [r3, #0]
 801320e:	681a      	ldr	r2, [r3, #0]
 8013210:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8013214:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8013216:	2201      	movs	r2, #1

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8013218:	2300      	movs	r3, #0
        hspi->State = HAL_SPI_STATE_READY;
 801321a:	f880 205d 	strb.w	r2, [r0, #93]	; 0x5d
        __HAL_UNLOCK(hspi);
 801321e:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
      }
    }
  }

  return HAL_OK;
}
 8013222:	2003      	movs	r0, #3
 8013224:	4770      	bx	lr
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8013226:	6882      	ldr	r2, [r0, #8]
 8013228:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 801322c:	d002      	beq.n	8013234 <SPI_WaitFifoStateUntilTimeout.part.1+0x48>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 801322e:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8013232:	d1e4      	bne.n	80131fe <SPI_WaitFifoStateUntilTimeout.part.1+0x12>
          __HAL_SPI_DISABLE(hspi);
 8013234:	681a      	ldr	r2, [r3, #0]
 8013236:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 801323a:	601a      	str	r2, [r3, #0]
 801323c:	e7df      	b.n	80131fe <SPI_WaitFifoStateUntilTimeout.part.1+0x12>
 801323e:	bf00      	nop

08013240 <SPI_WaitFlagStateUntilTimeout>:
{
 8013240:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8013244:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8013248:	4680      	mov	r8, r0
 801324a:	460f      	mov	r7, r1
 801324c:	4616      	mov	r6, r2
 801324e:	461d      	mov	r5, r3
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8013250:	f8d8 4000 	ldr.w	r4, [r8]
 8013254:	e001      	b.n	801325a <SPI_WaitFlagStateUntilTimeout+0x1a>
    if (Timeout != HAL_MAX_DELAY)
 8013256:	1c6b      	adds	r3, r5, #1
 8013258:	d10a      	bne.n	8013270 <SPI_WaitFlagStateUntilTimeout+0x30>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 801325a:	68a0      	ldr	r0, [r4, #8]
 801325c:	ea37 0300 	bics.w	r3, r7, r0
 8013260:	bf0c      	ite	eq
 8013262:	2001      	moveq	r0, #1
 8013264:	2000      	movne	r0, #0
 8013266:	4286      	cmp	r6, r0
 8013268:	d1f5      	bne.n	8013256 <SPI_WaitFlagStateUntilTimeout+0x16>
}
 801326a:	2000      	movs	r0, #0
 801326c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 8013270:	b12d      	cbz	r5, 801327e <SPI_WaitFlagStateUntilTimeout+0x3e>
 8013272:	f7fd f93b 	bl	80104ec <HAL_GetTick>
 8013276:	eba0 0009 	sub.w	r0, r0, r9
 801327a:	42a8      	cmp	r0, r5
 801327c:	d3e8      	bcc.n	8013250 <SPI_WaitFlagStateUntilTimeout+0x10>
 801327e:	4640      	mov	r0, r8
}
 8013280:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8013284:	f7ff bfb2 	b.w	80131ec <SPI_WaitFifoStateUntilTimeout.part.1>

08013288 <SPI_WaitFifoStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8013288:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801328c:	b082      	sub	sp, #8
 801328e:	4607      	mov	r7, r0
 8013290:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8013294:	460c      	mov	r4, r1
 8013296:	4615      	mov	r5, r2
 8013298:	461e      	mov	r6, r3
  __IO uint8_t tmpreg;

  while ((hspi->Instance->SR & Fifo) != State)
 801329a:	683a      	ldr	r2, [r7, #0]
 801329c:	e001      	b.n	80132a2 <SPI_WaitFifoStateUntilTimeout+0x1a>
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
      /* To avoid GCC warning */
      UNUSED(tmpreg);
    }

    if (Timeout != HAL_MAX_DELAY)
 801329e:	1c73      	adds	r3, r6, #1
 80132a0:	d110      	bne.n	80132c4 <SPI_WaitFifoStateUntilTimeout+0x3c>
  while ((hspi->Instance->SR & Fifo) != State)
 80132a2:	6890      	ldr	r0, [r2, #8]
 80132a4:	4020      	ands	r0, r4
 80132a6:	42a8      	cmp	r0, r5
 80132a8:	d019      	beq.n	80132de <SPI_WaitFifoStateUntilTimeout+0x56>
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 80132aa:	f5b4 6fc0 	cmp.w	r4, #1536	; 0x600
 80132ae:	d1f6      	bne.n	801329e <SPI_WaitFifoStateUntilTimeout+0x16>
 80132b0:	2d00      	cmp	r5, #0
 80132b2:	d1f4      	bne.n	801329e <SPI_WaitFifoStateUntilTimeout+0x16>
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 80132b4:	7b13      	ldrb	r3, [r2, #12]
 80132b6:	b2db      	uxtb	r3, r3
 80132b8:	f88d 3007 	strb.w	r3, [sp, #7]
      UNUSED(tmpreg);
 80132bc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    if (Timeout != HAL_MAX_DELAY)
 80132c0:	1c73      	adds	r3, r6, #1
 80132c2:	d0ee      	beq.n	80132a2 <SPI_WaitFifoStateUntilTimeout+0x1a>
    {
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 80132c4:	b12e      	cbz	r6, 80132d2 <SPI_WaitFifoStateUntilTimeout+0x4a>
 80132c6:	f7fd f911 	bl	80104ec <HAL_GetTick>
 80132ca:	eba0 0008 	sub.w	r0, r0, r8
 80132ce:	42b0      	cmp	r0, r6
 80132d0:	d3e3      	bcc.n	801329a <SPI_WaitFifoStateUntilTimeout+0x12>
 80132d2:	4638      	mov	r0, r7
      }
    }
  }

  return HAL_OK;
}
 80132d4:	b002      	add	sp, #8
 80132d6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80132da:	f7ff bf87 	b.w	80131ec <SPI_WaitFifoStateUntilTimeout.part.1>
 80132de:	2000      	movs	r0, #0
 80132e0:	b002      	add	sp, #8
 80132e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80132e6:	bf00      	nop

080132e8 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 80132e8:	b570      	push	{r4, r5, r6, lr}
 80132ea:	b082      	sub	sp, #8
 80132ec:	460d      	mov	r5, r1
 80132ee:	4616      	mov	r6, r2
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80132f0:	9200      	str	r2, [sp, #0]
 80132f2:	460b      	mov	r3, r1
 80132f4:	2200      	movs	r2, #0
 80132f6:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
{
 80132fa:	4604      	mov	r4, r0
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80132fc:	f7ff ffc4 	bl	8013288 <SPI_WaitFifoStateUntilTimeout>
 8013300:	b980      	cbnz	r0, 8013324 <SPI_EndRxTxTransaction+0x3c>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8013302:	4602      	mov	r2, r0
 8013304:	9600      	str	r6, [sp, #0]
 8013306:	462b      	mov	r3, r5
 8013308:	2180      	movs	r1, #128	; 0x80
 801330a:	4620      	mov	r0, r4
 801330c:	f7ff ff98 	bl	8013240 <SPI_WaitFlagStateUntilTimeout>
 8013310:	b940      	cbnz	r0, 8013324 <SPI_EndRxTxTransaction+0x3c>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8013312:	4602      	mov	r2, r0
 8013314:	9600      	str	r6, [sp, #0]
 8013316:	462b      	mov	r3, r5
 8013318:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 801331c:	4620      	mov	r0, r4
 801331e:	f7ff ffb3 	bl	8013288 <SPI_WaitFifoStateUntilTimeout>
 8013322:	b120      	cbz	r0, 801332e <SPI_EndRxTxTransaction+0x46>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8013324:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8013326:	f043 0320 	orr.w	r3, r3, #32
 801332a:	6623      	str	r3, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 801332c:	2003      	movs	r0, #3
  }

  return HAL_OK;
}
 801332e:	b002      	add	sp, #8
 8013330:	bd70      	pop	{r4, r5, r6, pc}
 8013332:	bf00      	nop

08013334 <HAL_SPI_Init>:
  if (hspi == NULL)
 8013334:	2800      	cmp	r0, #0
 8013336:	d059      	beq.n	80133ec <HAL_SPI_Init+0xb8>
{
 8013338:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (hspi->State == HAL_SPI_STATE_RESET)
 801333a:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
{
 801333e:	b083      	sub	sp, #12
 8013340:	4604      	mov	r4, r0
  if (hspi->State == HAL_SPI_STATE_RESET)
 8013342:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8013346:	2b00      	cmp	r3, #0
 8013348:	d04b      	beq.n	80133e2 <HAL_SPI_Init+0xae>
  hspi->State = HAL_SPI_STATE_BUSY;
 801334a:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);
 801334c:	6822      	ldr	r2, [r4, #0]
  hspi->State = HAL_SPI_STATE_BUSY;
 801334e:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_SPI_DISABLE(hspi);
 8013352:	6813      	ldr	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8013354:	68e7      	ldr	r7, [r4, #12]
 8013356:	6b21      	ldr	r1, [r4, #48]	; 0x30
  __HAL_SPI_DISABLE(hspi);
 8013358:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 801335c:	f5b7 6fe0 	cmp.w	r7, #1792	; 0x700
  __HAL_SPI_DISABLE(hspi);
 8013360:	6013      	str	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8013362:	d937      	bls.n	80133d4 <HAL_SPI_Init+0xa0>
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8013364:	f5b7 6f70 	cmp.w	r7, #3840	; 0xf00
 8013368:	d142      	bne.n	80133f0 <HAL_SPI_Init+0xbc>
 801336a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 801336c:	2900      	cmp	r1, #0
 801336e:	d044      	beq.n	80133fa <HAL_SPI_Init+0xc6>
 8013370:	f04f 0e00 	mov.w	lr, #0
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8013374:	e9d4 6504 	ldrd	r6, r5, [r4, #16]
 8013378:	6863      	ldr	r3, [r4, #4]
 801337a:	9501      	str	r5, [sp, #4]
 801337c:	68a5      	ldr	r5, [r4, #8]
 801337e:	432b      	orrs	r3, r5
 8013380:	9d01      	ldr	r5, [sp, #4]
 8013382:	4333      	orrs	r3, r6
 8013384:	432b      	orrs	r3, r5
 8013386:	e9d4 5606 	ldrd	r5, r6, [r4, #24]
 801338a:	4333      	orrs	r3, r6
 801338c:	6a26      	ldr	r6, [r4, #32]
 801338e:	4333      	orrs	r3, r6
 8013390:	f405 7600 	and.w	r6, r5, #512	; 0x200
 8013394:	4333      	orrs	r3, r6
 8013396:	4303      	orrs	r3, r0
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8013398:	2902      	cmp	r1, #2
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 801339a:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 801339c:	d103      	bne.n	80133a6 <HAL_SPI_Init+0x72>
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
 801339e:	6813      	ldr	r3, [r2, #0]
 80133a0:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80133a4:	6013      	str	r3, [r2, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 80133a6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80133a8:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80133aa:	433b      	orrs	r3, r7
 80133ac:	0c2d      	lsrs	r5, r5, #16
 80133ae:	f005 0504 	and.w	r5, r5, #4
 80133b2:	430b      	orrs	r3, r1
 80133b4:	432b      	orrs	r3, r5
 80133b6:	ea43 030e 	orr.w	r3, r3, lr
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80133ba:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 80133be:	6053      	str	r3, [r2, #4]
    WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
 80133c0:	bf04      	itt	eq
 80133c2:	6ae3      	ldreq	r3, [r4, #44]	; 0x2c
 80133c4:	6113      	streq	r3, [r2, #16]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80133c6:	2000      	movs	r0, #0
  hspi->State     = HAL_SPI_STATE_READY;
 80133c8:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80133ca:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 80133cc:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
}
 80133d0:	b003      	add	sp, #12
 80133d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 80133d4:	d014      	beq.n	8013400 <HAL_SPI_Init+0xcc>
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80133d6:	2000      	movs	r0, #0
 80133d8:	62a0      	str	r0, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 80133da:	b1a9      	cbz	r1, 8013408 <HAL_SPI_Init+0xd4>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 80133dc:	f44f 5e80 	mov.w	lr, #4096	; 0x1000
 80133e0:	e7c8      	b.n	8013374 <HAL_SPI_Init+0x40>
    hspi->Lock = HAL_UNLOCKED;
 80133e2:	f880 205c 	strb.w	r2, [r0, #92]	; 0x5c
    HAL_SPI_MspInit(hspi);
 80133e6:	f00a fbd9 	bl	801db9c <HAL_SPI_MspInit>
 80133ea:	e7ae      	b.n	801334a <HAL_SPI_Init+0x16>
    return HAL_ERROR;
 80133ec:	2001      	movs	r0, #1
}
 80133ee:	4770      	bx	lr
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80133f0:	2000      	movs	r0, #0
 80133f2:	62a0      	str	r0, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 80133f4:	2900      	cmp	r1, #0
 80133f6:	d1bb      	bne.n	8013370 <HAL_SPI_Init+0x3c>
 80133f8:	4608      	mov	r0, r1
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 80133fa:	2102      	movs	r1, #2
 80133fc:	6321      	str	r1, [r4, #48]	; 0x30
 80133fe:	e7b7      	b.n	8013370 <HAL_SPI_Init+0x3c>
 8013400:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8013402:	2900      	cmp	r1, #0
 8013404:	d1ea      	bne.n	80133dc <HAL_SPI_Init+0xa8>
 8013406:	4601      	mov	r1, r0
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 8013408:	2301      	movs	r3, #1
 801340a:	4608      	mov	r0, r1
 801340c:	6323      	str	r3, [r4, #48]	; 0x30
 801340e:	4619      	mov	r1, r3
 8013410:	f44f 5e80 	mov.w	lr, #4096	; 0x1000
 8013414:	e7ae      	b.n	8013374 <HAL_SPI_Init+0x40>
 8013416:	bf00      	nop

08013418 <HAL_SPI_MspDeInit>:
 8013418:	4770      	bx	lr
 801341a:	bf00      	nop

0801341c <HAL_SPI_DeInit>:
  if (hspi == NULL)
 801341c:	b190      	cbz	r0, 8013444 <HAL_SPI_DeInit+0x28>
  __HAL_SPI_DISABLE(hspi);
 801341e:	6802      	ldr	r2, [r0, #0]
  hspi->State = HAL_SPI_STATE_BUSY;
 8013420:	2302      	movs	r3, #2
{
 8013422:	b510      	push	{r4, lr}
  hspi->State = HAL_SPI_STATE_BUSY;
 8013424:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
  __HAL_SPI_DISABLE(hspi);
 8013428:	6813      	ldr	r3, [r2, #0]
 801342a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801342e:	4604      	mov	r4, r0
 8013430:	6013      	str	r3, [r2, #0]
  HAL_SPI_MspDeInit(hspi);
 8013432:	f7ff fff1 	bl	8013418 <HAL_SPI_MspDeInit>
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8013436:	2000      	movs	r0, #0
 8013438:	6620      	str	r0, [r4, #96]	; 0x60
  __HAL_UNLOCK(hspi);
 801343a:	f884 005c 	strb.w	r0, [r4, #92]	; 0x5c
  hspi->State = HAL_SPI_STATE_RESET;
 801343e:	f884 005d 	strb.w	r0, [r4, #93]	; 0x5d
}
 8013442:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8013444:	2001      	movs	r0, #1
}
 8013446:	4770      	bx	lr

08013448 <HAL_SPI_Transmit>:
{
 8013448:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801344c:	460d      	mov	r5, r1
  __HAL_LOCK(hspi);
 801344e:	f890 105c 	ldrb.w	r1, [r0, #92]	; 0x5c
 8013452:	2901      	cmp	r1, #1
{
 8013454:	b082      	sub	sp, #8
  __HAL_LOCK(hspi);
 8013456:	d067      	beq.n	8013528 <HAL_SPI_Transmit+0xe0>
 8013458:	461e      	mov	r6, r3
 801345a:	2301      	movs	r3, #1
 801345c:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
 8013460:	4604      	mov	r4, r0
 8013462:	4690      	mov	r8, r2
  tickstart = HAL_GetTick();
 8013464:	f7fd f842 	bl	80104ec <HAL_GetTick>
 8013468:	4607      	mov	r7, r0
  if (hspi->State != HAL_SPI_STATE_READY)
 801346a:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
 801346e:	b2c0      	uxtb	r0, r0
 8013470:	2801      	cmp	r0, #1
 8013472:	d009      	beq.n	8013488 <HAL_SPI_Transmit+0x40>
    errorcode = HAL_BUSY;
 8013474:	2002      	movs	r0, #2
  hspi->State = HAL_SPI_STATE_READY;
 8013476:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8013478:	2300      	movs	r3, #0
  hspi->State = HAL_SPI_STATE_READY;
 801347a:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 801347e:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
 8013482:	b002      	add	sp, #8
 8013484:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((pData == NULL) || (Size == 0U))
 8013488:	2d00      	cmp	r5, #0
 801348a:	d0f4      	beq.n	8013476 <HAL_SPI_Transmit+0x2e>
 801348c:	f1b8 0f00 	cmp.w	r8, #0
 8013490:	d0f1      	beq.n	8013476 <HAL_SPI_Transmit+0x2e>
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8013492:	68a2      	ldr	r2, [r4, #8]
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8013494:	63a5      	str	r5, [r4, #56]	; 0x38
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8013496:	2303      	movs	r3, #3
 8013498:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 801349c:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80134a0:	f04f 0300 	mov.w	r3, #0
 80134a4:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 80134a6:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->RxXferSize  = 0U;
 80134a8:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
  hspi->RxISR       = NULL;
 80134ac:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
  hspi->TxXferCount = Size;
 80134b0:	f8a4 803e 	strh.w	r8, [r4, #62]	; 0x3e
  hspi->TxXferSize  = Size;
 80134b4:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 80134b8:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 80134bc:	6823      	ldr	r3, [r4, #0]
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80134be:	d103      	bne.n	80134c8 <HAL_SPI_Transmit+0x80>
    SPI_1LINE_TX(hspi);
 80134c0:	681a      	ldr	r2, [r3, #0]
 80134c2:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80134c6:	601a      	str	r2, [r3, #0]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80134c8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80134ca:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 80134ce:	d107      	bne.n	80134e0 <HAL_SPI_Transmit+0x98>
    SPI_RESET_CRC(hspi);
 80134d0:	681a      	ldr	r2, [r3, #0]
 80134d2:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80134d6:	601a      	str	r2, [r3, #0]
 80134d8:	681a      	ldr	r2, [r3, #0]
 80134da:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80134de:	601a      	str	r2, [r3, #0]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80134e0:	681a      	ldr	r2, [r3, #0]
 80134e2:	0652      	lsls	r2, r2, #25
 80134e4:	d403      	bmi.n	80134ee <HAL_SPI_Transmit+0xa6>
    __HAL_SPI_ENABLE(hspi);
 80134e6:	681a      	ldr	r2, [r3, #0]
 80134e8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80134ec:	601a      	str	r2, [r3, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80134ee:	68e2      	ldr	r2, [r4, #12]
 80134f0:	6861      	ldr	r1, [r4, #4]
 80134f2:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
 80134f6:	d91b      	bls.n	8013530 <HAL_SPI_Transmit+0xe8>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 80134f8:	2900      	cmp	r1, #0
 80134fa:	d03a      	beq.n	8013572 <HAL_SPI_Transmit+0x12a>
 80134fc:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 80134fe:	b292      	uxth	r2, r2
 8013500:	2a01      	cmp	r2, #1
 8013502:	d036      	beq.n	8013572 <HAL_SPI_Transmit+0x12a>
    while (hspi->TxXferCount > 0U)
 8013504:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8013506:	b29b      	uxth	r3, r3
 8013508:	2b00      	cmp	r3, #0
 801350a:	d042      	beq.n	8013592 <HAL_SPI_Transmit+0x14a>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 801350c:	6823      	ldr	r3, [r4, #0]
 801350e:	689a      	ldr	r2, [r3, #8]
 8013510:	0790      	lsls	r0, r2, #30
 8013512:	d42e      	bmi.n	8013572 <HAL_SPI_Transmit+0x12a>
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 8013514:	b136      	cbz	r6, 8013524 <HAL_SPI_Transmit+0xdc>
 8013516:	1c71      	adds	r1, r6, #1
 8013518:	d0f4      	beq.n	8013504 <HAL_SPI_Transmit+0xbc>
 801351a:	f7fc ffe7 	bl	80104ec <HAL_GetTick>
 801351e:	1bc0      	subs	r0, r0, r7
 8013520:	42b0      	cmp	r0, r6
 8013522:	d3ef      	bcc.n	8013504 <HAL_SPI_Transmit+0xbc>
          errorcode = HAL_TIMEOUT;
 8013524:	2003      	movs	r0, #3
 8013526:	e7a6      	b.n	8013476 <HAL_SPI_Transmit+0x2e>
  __HAL_LOCK(hspi);
 8013528:	2002      	movs	r0, #2
}
 801352a:	b002      	add	sp, #8
 801352c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 8013530:	b1a1      	cbz	r1, 801355c <HAL_SPI_Transmit+0x114>
 8013532:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8013534:	b292      	uxth	r2, r2
 8013536:	2a01      	cmp	r2, #1
 8013538:	d010      	beq.n	801355c <HAL_SPI_Transmit+0x114>
    while (hspi->TxXferCount > 0U)
 801353a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 801353c:	b29b      	uxth	r3, r3
 801353e:	b343      	cbz	r3, 8013592 <HAL_SPI_Transmit+0x14a>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8013540:	6823      	ldr	r3, [r4, #0]
 8013542:	689a      	ldr	r2, [r3, #8]
 8013544:	0792      	lsls	r2, r2, #30
 8013546:	d409      	bmi.n	801355c <HAL_SPI_Transmit+0x114>
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 8013548:	2e00      	cmp	r6, #0
 801354a:	d0eb      	beq.n	8013524 <HAL_SPI_Transmit+0xdc>
 801354c:	1c73      	adds	r3, r6, #1
 801354e:	d0f4      	beq.n	801353a <HAL_SPI_Transmit+0xf2>
 8013550:	f7fc ffcc 	bl	80104ec <HAL_GetTick>
 8013554:	1bc0      	subs	r0, r0, r7
 8013556:	42b0      	cmp	r0, r6
 8013558:	d3ef      	bcc.n	801353a <HAL_SPI_Transmit+0xf2>
 801355a:	e7e3      	b.n	8013524 <HAL_SPI_Transmit+0xdc>
        if (hspi->TxXferCount > 1U)
 801355c:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 801355e:	2a01      	cmp	r2, #1
 8013560:	d90f      	bls.n	8013582 <HAL_SPI_Transmit+0x13a>
          hspi->Instance->DR = *((uint16_t *)pData);
 8013562:	f835 2b02 	ldrh.w	r2, [r5], #2
 8013566:	60da      	str	r2, [r3, #12]
          hspi->TxXferCount -= 2U;
 8013568:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 801356a:	3b02      	subs	r3, #2
 801356c:	b29b      	uxth	r3, r3
 801356e:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8013570:	e7e3      	b.n	801353a <HAL_SPI_Transmit+0xf2>
        hspi->Instance->DR = *((uint16_t *)pData);
 8013572:	f835 2b02 	ldrh.w	r2, [r5], #2
 8013576:	60da      	str	r2, [r3, #12]
        hspi->TxXferCount--;
 8013578:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 801357a:	3b01      	subs	r3, #1
 801357c:	b29b      	uxth	r3, r3
 801357e:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8013580:	e7c0      	b.n	8013504 <HAL_SPI_Transmit+0xbc>
          *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 8013582:	782a      	ldrb	r2, [r5, #0]
 8013584:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 8013586:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8013588:	3b01      	subs	r3, #1
 801358a:	b29b      	uxth	r3, r3
          *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 801358c:	3501      	adds	r5, #1
          hspi->TxXferCount--;
 801358e:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8013590:	e7d3      	b.n	801353a <HAL_SPI_Transmit+0xf2>
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8013592:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8013594:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8013598:	d104      	bne.n	80135a4 <HAL_SPI_Transmit+0x15c>
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 801359a:	6822      	ldr	r2, [r4, #0]
 801359c:	6813      	ldr	r3, [r2, #0]
 801359e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80135a2:	6013      	str	r3, [r2, #0]
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 80135a4:	463a      	mov	r2, r7
 80135a6:	4631      	mov	r1, r6
 80135a8:	4620      	mov	r0, r4
 80135aa:	f7ff fe9d 	bl	80132e8 <SPI_EndRxTxTransaction>
 80135ae:	b108      	cbz	r0, 80135b4 <HAL_SPI_Transmit+0x16c>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 80135b0:	2320      	movs	r3, #32
 80135b2:	6623      	str	r3, [r4, #96]	; 0x60
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 80135b4:	68a3      	ldr	r3, [r4, #8]
 80135b6:	b933      	cbnz	r3, 80135c6 <HAL_SPI_Transmit+0x17e>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80135b8:	6822      	ldr	r2, [r4, #0]
 80135ba:	9301      	str	r3, [sp, #4]
 80135bc:	68d3      	ldr	r3, [r2, #12]
 80135be:	9301      	str	r3, [sp, #4]
 80135c0:	6893      	ldr	r3, [r2, #8]
 80135c2:	9301      	str	r3, [sp, #4]
 80135c4:	9b01      	ldr	r3, [sp, #4]
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80135c6:	6e20      	ldr	r0, [r4, #96]	; 0x60
    errorcode = HAL_BUSY;
 80135c8:	3000      	adds	r0, #0
 80135ca:	bf18      	it	ne
 80135cc:	2001      	movne	r0, #1
error:
 80135ce:	e752      	b.n	8013476 <HAL_SPI_Transmit+0x2e>

080135d0 <HAL_SPI_TransmitReceive>:
{
 80135d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80135d4:	4604      	mov	r4, r0
  __HAL_LOCK(hspi);
 80135d6:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
{
 80135da:	b085      	sub	sp, #20
  __IO uint16_t tmpreg = 0U;
 80135dc:	2500      	movs	r5, #0
  __HAL_LOCK(hspi);
 80135de:	2801      	cmp	r0, #1
  __IO uint16_t tmpreg = 0U;
 80135e0:	f8ad 500e 	strh.w	r5, [sp, #14]
{
 80135e4:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  __HAL_LOCK(hspi);
 80135e6:	f000 80b8 	beq.w	801375a <HAL_SPI_TransmitReceive+0x18a>
 80135ea:	4699      	mov	r9, r3
 80135ec:	2301      	movs	r3, #1
 80135ee:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
 80135f2:	4616      	mov	r6, r2
 80135f4:	4688      	mov	r8, r1
  tickstart = HAL_GetTick();
 80135f6:	f7fc ff79 	bl	80104ec <HAL_GetTick>
  tmp  = hspi->State;
 80135fa:	f894 205d 	ldrb.w	r2, [r4, #93]	; 0x5d
  tmp1 = hspi->Init.Mode;
 80135fe:	6863      	ldr	r3, [r4, #4]
  tmp  = hspi->State;
 8013600:	b2d2      	uxtb	r2, r2
  if (!((tmp == HAL_SPI_STATE_READY) || \
 8013602:	2a01      	cmp	r2, #1
  tickstart = HAL_GetTick();
 8013604:	4607      	mov	r7, r0
  if (!((tmp == HAL_SPI_STATE_READY) || \
 8013606:	d012      	beq.n	801362e <HAL_SPI_TransmitReceive+0x5e>
 8013608:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 801360c:	d00a      	beq.n	8013624 <HAL_SPI_TransmitReceive+0x54>
    errorcode = HAL_BUSY;
 801360e:	2602      	movs	r6, #2
  hspi->State = HAL_SPI_STATE_READY;
 8013610:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8013612:	2300      	movs	r3, #0
}
 8013614:	4630      	mov	r0, r6
  hspi->State = HAL_SPI_STATE_READY;
 8013616:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 801361a:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
 801361e:	b005      	add	sp, #20
 8013620:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
 8013624:	68a1      	ldr	r1, [r4, #8]
 8013626:	2900      	cmp	r1, #0
 8013628:	d1f1      	bne.n	801360e <HAL_SPI_TransmitReceive+0x3e>
 801362a:	2a04      	cmp	r2, #4
 801362c:	d1ef      	bne.n	801360e <HAL_SPI_TransmitReceive+0x3e>
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 801362e:	f1b8 0f00 	cmp.w	r8, #0
 8013632:	f000 8097 	beq.w	8013764 <HAL_SPI_TransmitReceive+0x194>
 8013636:	2e00      	cmp	r6, #0
 8013638:	f000 8094 	beq.w	8013764 <HAL_SPI_TransmitReceive+0x194>
 801363c:	f1b9 0f00 	cmp.w	r9, #0
 8013640:	f000 8090 	beq.w	8013764 <HAL_SPI_TransmitReceive+0x194>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8013644:	f894 205d 	ldrb.w	r2, [r4, #93]	; 0x5d
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8013648:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 801364a:	6426      	str	r6, [r4, #64]	; 0x40
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 801364c:	2a04      	cmp	r2, #4
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 801364e:	bf1c      	itt	ne
 8013650:	2205      	movne	r2, #5
 8013652:	f884 205d 	strbne.w	r2, [r4, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8013656:	2200      	movs	r2, #0
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8013658:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 801365c:	6622      	str	r2, [r4, #96]	; 0x60
  hspi->TxISR       = NULL;
 801365e:	e9c4 2213 	strd	r2, r2, [r4, #76]	; 0x4c
  hspi->RxXferCount = Size;
 8013662:	f8a4 9046 	strh.w	r9, [r4, #70]	; 0x46
  hspi->RxXferSize  = Size;
 8013666:	f8a4 9044 	strh.w	r9, [r4, #68]	; 0x44
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 801366a:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
  hspi->TxXferSize  = Size;
 801366e:	f8a4 903c 	strh.w	r9, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 8013672:	f8a4 903e 	strh.w	r9, [r4, #62]	; 0x3e
 8013676:	6822      	ldr	r2, [r4, #0]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8013678:	f000 80c7 	beq.w	801380a <HAL_SPI_TransmitReceive+0x23a>
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount > 1U))
 801367c:	68e1      	ldr	r1, [r4, #12]
 801367e:	f5b1 6fe0 	cmp.w	r1, #1792	; 0x700
 8013682:	d871      	bhi.n	8013768 <HAL_SPI_TransmitReceive+0x198>
 8013684:	f8b4 1046 	ldrh.w	r1, [r4, #70]	; 0x46
 8013688:	2901      	cmp	r1, #1
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 801368a:	6851      	ldr	r1, [r2, #4]
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount > 1U))
 801368c:	f240 811f 	bls.w	80138ce <HAL_SPI_TransmitReceive+0x2fe>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8013690:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
 8013694:	6051      	str	r1, [r2, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8013696:	6811      	ldr	r1, [r2, #0]
 8013698:	0648      	lsls	r0, r1, #25
 801369a:	d403      	bmi.n	80136a4 <HAL_SPI_TransmitReceive+0xd4>
    __HAL_SPI_ENABLE(hspi);
 801369c:	6811      	ldr	r1, [r2, #0]
 801369e:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 80136a2:	6011      	str	r1, [r2, #0]
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 80136a4:	2b00      	cmp	r3, #0
 80136a6:	f000 80fd 	beq.w	80138a4 <HAL_SPI_TransmitReceive+0x2d4>
 80136aa:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80136ac:	b29b      	uxth	r3, r3
 80136ae:	2b01      	cmp	r3, #1
 80136b0:	f000 80f8 	beq.w	80138a4 <HAL_SPI_TransmitReceive+0x2d4>
        txallowed = 1U;
 80136b4:	f04f 0901 	mov.w	r9, #1
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 80136b8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80136ba:	b29b      	uxth	r3, r3
 80136bc:	b92b      	cbnz	r3, 80136ca <HAL_SPI_TransmitReceive+0xfa>
 80136be:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80136c2:	b29b      	uxth	r3, r3
 80136c4:	2b00      	cmp	r3, #0
 80136c6:	f000 80a9 	beq.w	801381c <HAL_SPI_TransmitReceive+0x24c>
      if (txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
 80136ca:	f1b9 0f00 	cmp.w	r9, #0
 80136ce:	d01e      	beq.n	801370e <HAL_SPI_TransmitReceive+0x13e>
 80136d0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80136d2:	b29b      	uxth	r3, r3
 80136d4:	b1db      	cbz	r3, 801370e <HAL_SPI_TransmitReceive+0x13e>
 80136d6:	6823      	ldr	r3, [r4, #0]
 80136d8:	689a      	ldr	r2, [r3, #8]
 80136da:	0792      	lsls	r2, r2, #30
 80136dc:	d517      	bpl.n	801370e <HAL_SPI_TransmitReceive+0x13e>
        if (hspi->TxXferCount > 1U)
 80136de:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 80136e0:	2a01      	cmp	r2, #1
 80136e2:	f240 80ea 	bls.w	80138ba <HAL_SPI_TransmitReceive+0x2ea>
          hspi->Instance->DR = *((uint16_t *)pTxData);
 80136e6:	f838 2b02 	ldrh.w	r2, [r8], #2
 80136ea:	60da      	str	r2, [r3, #12]
          hspi->TxXferCount -= 2U;
 80136ec:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80136ee:	3b02      	subs	r3, #2
 80136f0:	b29b      	uxth	r3, r3
 80136f2:	87e3      	strh	r3, [r4, #62]	; 0x3e
        if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 80136f4:	f8b4 903e 	ldrh.w	r9, [r4, #62]	; 0x3e
 80136f8:	fa1f f389 	uxth.w	r3, r9
 80136fc:	2b00      	cmp	r3, #0
 80136fe:	f040 80bf 	bne.w	8013880 <HAL_SPI_TransmitReceive+0x2b0>
 8013702:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8013704:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8013708:	f000 80e9 	beq.w	80138de <HAL_SPI_TransmitReceive+0x30e>
        txallowed = 0U;
 801370c:	4699      	mov	r9, r3
      if ((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
 801370e:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8013712:	b29b      	uxth	r3, r3
 8013714:	b1c3      	cbz	r3, 8013748 <HAL_SPI_TransmitReceive+0x178>
 8013716:	6823      	ldr	r3, [r4, #0]
 8013718:	689a      	ldr	r2, [r3, #8]
 801371a:	07d2      	lsls	r2, r2, #31
 801371c:	d514      	bpl.n	8013748 <HAL_SPI_TransmitReceive+0x178>
        if (hspi->RxXferCount > 1U)
 801371e:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
 8013722:	2a01      	cmp	r2, #1
 8013724:	f240 809d 	bls.w	8013862 <HAL_SPI_TransmitReceive+0x292>
          *((uint16_t *)pRxData) = hspi->Instance->DR;
 8013728:	68da      	ldr	r2, [r3, #12]
 801372a:	f826 2b02 	strh.w	r2, [r6], #2
          hspi->RxXferCount -= 2U;
 801372e:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
 8013732:	3a02      	subs	r2, #2
 8013734:	b292      	uxth	r2, r2
 8013736:	f8a4 2046 	strh.w	r2, [r4, #70]	; 0x46
          if (hspi->RxXferCount <= 1U)
 801373a:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
 801373e:	2a01      	cmp	r2, #1
 8013740:	f240 80a1 	bls.w	8013886 <HAL_SPI_TransmitReceive+0x2b6>
        txallowed = 1U;
 8013744:	f04f 0901 	mov.w	r9, #1
      if ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout))
 8013748:	1c6b      	adds	r3, r5, #1
 801374a:	d0b5      	beq.n	80136b8 <HAL_SPI_TransmitReceive+0xe8>
 801374c:	f7fc fece 	bl	80104ec <HAL_GetTick>
 8013750:	1bc0      	subs	r0, r0, r7
 8013752:	42a8      	cmp	r0, r5
 8013754:	d3b0      	bcc.n	80136b8 <HAL_SPI_TransmitReceive+0xe8>
          errorcode = HAL_TIMEOUT;
 8013756:	2603      	movs	r6, #3
          goto error;
 8013758:	e75a      	b.n	8013610 <HAL_SPI_TransmitReceive+0x40>
  __HAL_LOCK(hspi);
 801375a:	2602      	movs	r6, #2
}
 801375c:	4630      	mov	r0, r6
 801375e:	b005      	add	sp, #20
 8013760:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    errorcode = HAL_ERROR;
 8013764:	2601      	movs	r6, #1
 8013766:	e753      	b.n	8013610 <HAL_SPI_TransmitReceive+0x40>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8013768:	6851      	ldr	r1, [r2, #4]
 801376a:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
 801376e:	6051      	str	r1, [r2, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8013770:	6811      	ldr	r1, [r2, #0]
 8013772:	0649      	lsls	r1, r1, #25
 8013774:	d570      	bpl.n	8013858 <HAL_SPI_TransmitReceive+0x288>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 8013776:	2b00      	cmp	r3, #0
 8013778:	f000 808c 	beq.w	8013894 <HAL_SPI_TransmitReceive+0x2c4>
 801377c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 801377e:	b29b      	uxth	r3, r3
 8013780:	2b01      	cmp	r3, #1
 8013782:	f000 8087 	beq.w	8013894 <HAL_SPI_TransmitReceive+0x2c4>
        txallowed = 1U;
 8013786:	f04f 0901 	mov.w	r9, #1
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 801378a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 801378c:	b29b      	uxth	r3, r3
 801378e:	b923      	cbnz	r3, 801379a <HAL_SPI_TransmitReceive+0x1ca>
 8013790:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8013794:	b29b      	uxth	r3, r3
 8013796:	2b00      	cmp	r3, #0
 8013798:	d040      	beq.n	801381c <HAL_SPI_TransmitReceive+0x24c>
      if (txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
 801379a:	f1b9 0f00 	cmp.w	r9, #0
 801379e:	d019      	beq.n	80137d4 <HAL_SPI_TransmitReceive+0x204>
 80137a0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80137a2:	b29b      	uxth	r3, r3
 80137a4:	b1b3      	cbz	r3, 80137d4 <HAL_SPI_TransmitReceive+0x204>
 80137a6:	6822      	ldr	r2, [r4, #0]
 80137a8:	6893      	ldr	r3, [r2, #8]
 80137aa:	0798      	lsls	r0, r3, #30
 80137ac:	d512      	bpl.n	80137d4 <HAL_SPI_TransmitReceive+0x204>
        hspi->Instance->DR = *((uint16_t *)pTxData);
 80137ae:	f838 3b02 	ldrh.w	r3, [r8], #2
 80137b2:	60d3      	str	r3, [r2, #12]
        hspi->TxXferCount--;
 80137b4:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80137b6:	3b01      	subs	r3, #1
 80137b8:	b29b      	uxth	r3, r3
 80137ba:	87e3      	strh	r3, [r4, #62]	; 0x3e
        if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 80137bc:	f8b4 903e 	ldrh.w	r9, [r4, #62]	; 0x3e
 80137c0:	fa1f f389 	uxth.w	r3, r9
 80137c4:	2b00      	cmp	r3, #0
 80137c6:	d158      	bne.n	801387a <HAL_SPI_TransmitReceive+0x2aa>
 80137c8:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80137ca:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 80137ce:	f000 8098 	beq.w	8013902 <HAL_SPI_TransmitReceive+0x332>
        txallowed = 0U;
 80137d2:	4699      	mov	r9, r3
      if ((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
 80137d4:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80137d8:	b29b      	uxth	r3, r3
 80137da:	b173      	cbz	r3, 80137fa <HAL_SPI_TransmitReceive+0x22a>
 80137dc:	6823      	ldr	r3, [r4, #0]
 80137de:	689a      	ldr	r2, [r3, #8]
 80137e0:	07d0      	lsls	r0, r2, #31
 80137e2:	d50a      	bpl.n	80137fa <HAL_SPI_TransmitReceive+0x22a>
        *((uint16_t *)pRxData) = hspi->Instance->DR;
 80137e4:	68db      	ldr	r3, [r3, #12]
 80137e6:	f826 3b02 	strh.w	r3, [r6], #2
        hspi->RxXferCount--;
 80137ea:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80137ee:	3b01      	subs	r3, #1
 80137f0:	b29b      	uxth	r3, r3
 80137f2:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
        txallowed = 1U;
 80137f6:	f04f 0901 	mov.w	r9, #1
      if ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout))
 80137fa:	1c69      	adds	r1, r5, #1
 80137fc:	d0c5      	beq.n	801378a <HAL_SPI_TransmitReceive+0x1ba>
 80137fe:	f7fc fe75 	bl	80104ec <HAL_GetTick>
 8013802:	1bc0      	subs	r0, r0, r7
 8013804:	42a8      	cmp	r0, r5
 8013806:	d3c0      	bcc.n	801378a <HAL_SPI_TransmitReceive+0x1ba>
 8013808:	e7a5      	b.n	8013756 <HAL_SPI_TransmitReceive+0x186>
    SPI_RESET_CRC(hspi);
 801380a:	6811      	ldr	r1, [r2, #0]
 801380c:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
 8013810:	6011      	str	r1, [r2, #0]
 8013812:	6811      	ldr	r1, [r2, #0]
 8013814:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8013818:	6011      	str	r1, [r2, #0]
 801381a:	e72f      	b.n	801367c <HAL_SPI_TransmitReceive+0xac>
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 801381c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 801381e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8013822:	f000 8089 	beq.w	8013938 <HAL_SPI_TransmitReceive+0x368>
 8013826:	6823      	ldr	r3, [r4, #0]
  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 8013828:	689e      	ldr	r6, [r3, #8]
 801382a:	f016 0610 	ands.w	r6, r6, #16
 801382e:	d007      	beq.n	8013840 <HAL_SPI_TransmitReceive+0x270>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8013830:	6e22      	ldr	r2, [r4, #96]	; 0x60
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 8013832:	f64f 71ef 	movw	r1, #65519	; 0xffef
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8013836:	f042 0202 	orr.w	r2, r2, #2
 801383a:	6622      	str	r2, [r4, #96]	; 0x60
    errorcode = HAL_ERROR;
 801383c:	2601      	movs	r6, #1
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 801383e:	6099      	str	r1, [r3, #8]
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8013840:	463a      	mov	r2, r7
 8013842:	4629      	mov	r1, r5
 8013844:	4620      	mov	r0, r4
 8013846:	f7ff fd4f 	bl	80132e8 <SPI_EndRxTxTransaction>
 801384a:	2800      	cmp	r0, #0
 801384c:	f43f aee0 	beq.w	8013610 <HAL_SPI_TransmitReceive+0x40>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8013850:	2320      	movs	r3, #32
 8013852:	6623      	str	r3, [r4, #96]	; 0x60
    errorcode = HAL_ERROR;
 8013854:	2601      	movs	r6, #1
 8013856:	e6db      	b.n	8013610 <HAL_SPI_TransmitReceive+0x40>
    __HAL_SPI_ENABLE(hspi);
 8013858:	6811      	ldr	r1, [r2, #0]
 801385a:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 801385e:	6011      	str	r1, [r2, #0]
 8013860:	e789      	b.n	8013776 <HAL_SPI_TransmitReceive+0x1a6>
          (*(uint8_t *)pRxData++) = *(__IO uint8_t *)&hspi->Instance->DR;
 8013862:	7b1b      	ldrb	r3, [r3, #12]
 8013864:	7033      	strb	r3, [r6, #0]
          hspi->RxXferCount--;
 8013866:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 801386a:	3b01      	subs	r3, #1
 801386c:	b29b      	uxth	r3, r3
          (*(uint8_t *)pRxData++) = *(__IO uint8_t *)&hspi->Instance->DR;
 801386e:	3601      	adds	r6, #1
          hspi->RxXferCount--;
 8013870:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
        txallowed = 1U;
 8013874:	f04f 0901 	mov.w	r9, #1
 8013878:	e766      	b.n	8013748 <HAL_SPI_TransmitReceive+0x178>
        txallowed = 0U;
 801387a:	f04f 0900 	mov.w	r9, #0
 801387e:	e7a9      	b.n	80137d4 <HAL_SPI_TransmitReceive+0x204>
        txallowed = 0U;
 8013880:	f04f 0900 	mov.w	r9, #0
 8013884:	e743      	b.n	801370e <HAL_SPI_TransmitReceive+0x13e>
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8013886:	685a      	ldr	r2, [r3, #4]
 8013888:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 801388c:	605a      	str	r2, [r3, #4]
        txallowed = 1U;
 801388e:	f04f 0901 	mov.w	r9, #1
 8013892:	e759      	b.n	8013748 <HAL_SPI_TransmitReceive+0x178>
      hspi->Instance->DR = *((uint16_t *)pTxData);
 8013894:	f838 3b02 	ldrh.w	r3, [r8], #2
 8013898:	60d3      	str	r3, [r2, #12]
      hspi->TxXferCount--;
 801389a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 801389c:	3b01      	subs	r3, #1
 801389e:	b29b      	uxth	r3, r3
 80138a0:	87e3      	strh	r3, [r4, #62]	; 0x3e
 80138a2:	e770      	b.n	8013786 <HAL_SPI_TransmitReceive+0x1b6>
      if (hspi->TxXferCount > 1U)
 80138a4:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80138a6:	2b01      	cmp	r3, #1
 80138a8:	d93c      	bls.n	8013924 <HAL_SPI_TransmitReceive+0x354>
        hspi->Instance->DR = *((uint16_t *)pTxData);
 80138aa:	f838 3b02 	ldrh.w	r3, [r8], #2
 80138ae:	60d3      	str	r3, [r2, #12]
        hspi->TxXferCount -= 2U;
 80138b0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80138b2:	3b02      	subs	r3, #2
 80138b4:	b29b      	uxth	r3, r3
 80138b6:	87e3      	strh	r3, [r4, #62]	; 0x3e
 80138b8:	e6fc      	b.n	80136b4 <HAL_SPI_TransmitReceive+0xe4>
          *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 80138ba:	f898 2000 	ldrb.w	r2, [r8]
 80138be:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 80138c0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80138c2:	3b01      	subs	r3, #1
 80138c4:	b29b      	uxth	r3, r3
          *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 80138c6:	f108 0801 	add.w	r8, r8, #1
          hspi->TxXferCount--;
 80138ca:	87e3      	strh	r3, [r4, #62]	; 0x3e
 80138cc:	e712      	b.n	80136f4 <HAL_SPI_TransmitReceive+0x124>
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80138ce:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 80138d2:	6051      	str	r1, [r2, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80138d4:	6811      	ldr	r1, [r2, #0]
 80138d6:	0649      	lsls	r1, r1, #25
 80138d8:	f53f aee4 	bmi.w	80136a4 <HAL_SPI_TransmitReceive+0xd4>
 80138dc:	e6de      	b.n	801369c <HAL_SPI_TransmitReceive+0xcc>
          if (((hspi->Instance->CR1 & SPI_CR1_MSTR) == 0U) && ((hspi->Instance->CR2 & SPI_CR2_NSSP) == SPI_CR2_NSSP))
 80138de:	6823      	ldr	r3, [r4, #0]
 80138e0:	681a      	ldr	r2, [r3, #0]
 80138e2:	0750      	lsls	r0, r2, #29
 80138e4:	d406      	bmi.n	80138f4 <HAL_SPI_TransmitReceive+0x324>
 80138e6:	685a      	ldr	r2, [r3, #4]
 80138e8:	0711      	lsls	r1, r2, #28
 80138ea:	d503      	bpl.n	80138f4 <HAL_SPI_TransmitReceive+0x324>
            SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
 80138ec:	681a      	ldr	r2, [r3, #0]
 80138ee:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80138f2:	601a      	str	r2, [r3, #0]
          SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 80138f4:	681a      	ldr	r2, [r3, #0]
 80138f6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80138fa:	601a      	str	r2, [r3, #0]
        txallowed = 0U;
 80138fc:	f04f 0900 	mov.w	r9, #0
 8013900:	e705      	b.n	801370e <HAL_SPI_TransmitReceive+0x13e>
          if (((hspi->Instance->CR1 & SPI_CR1_MSTR) == 0U) && ((hspi->Instance->CR2 & SPI_CR2_NSSP) == SPI_CR2_NSSP))
 8013902:	6813      	ldr	r3, [r2, #0]
 8013904:	0759      	lsls	r1, r3, #29
 8013906:	d406      	bmi.n	8013916 <HAL_SPI_TransmitReceive+0x346>
 8013908:	6853      	ldr	r3, [r2, #4]
 801390a:	071b      	lsls	r3, r3, #28
 801390c:	d503      	bpl.n	8013916 <HAL_SPI_TransmitReceive+0x346>
            SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
 801390e:	6813      	ldr	r3, [r2, #0]
 8013910:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8013914:	6013      	str	r3, [r2, #0]
          SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 8013916:	6813      	ldr	r3, [r2, #0]
 8013918:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 801391c:	6013      	str	r3, [r2, #0]
        txallowed = 0U;
 801391e:	f04f 0900 	mov.w	r9, #0
 8013922:	e757      	b.n	80137d4 <HAL_SPI_TransmitReceive+0x204>
        *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 8013924:	f898 3000 	ldrb.w	r3, [r8]
 8013928:	7313      	strb	r3, [r2, #12]
        hspi->TxXferCount--;
 801392a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 801392c:	3b01      	subs	r3, #1
 801392e:	b29b      	uxth	r3, r3
        *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 8013930:	f108 0801 	add.w	r8, r8, #1
        hspi->TxXferCount--;
 8013934:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8013936:	e6bd      	b.n	80136b4 <HAL_SPI_TransmitReceive+0xe4>
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 8013938:	2201      	movs	r2, #1
 801393a:	9700      	str	r7, [sp, #0]
 801393c:	4611      	mov	r1, r2
 801393e:	462b      	mov	r3, r5
 8013940:	4620      	mov	r0, r4
 8013942:	f7ff fc7d 	bl	8013240 <SPI_WaitFlagStateUntilTimeout>
 8013946:	b9e0      	cbnz	r0, 8013982 <HAL_SPI_TransmitReceive+0x3b2>
    if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8013948:	68e2      	ldr	r2, [r4, #12]
 801394a:	6823      	ldr	r3, [r4, #0]
 801394c:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
 8013950:	d01c      	beq.n	801398c <HAL_SPI_TransmitReceive+0x3bc>
      if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8013952:	6b21      	ldr	r1, [r4, #48]	; 0x30
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8013954:	7b1a      	ldrb	r2, [r3, #12]
 8013956:	f8ad 200e 	strh.w	r2, [sp, #14]
      if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 801395a:	2902      	cmp	r1, #2
      UNUSED(tmpreg);
 801395c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
      if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8013960:	f47f af62 	bne.w	8013828 <HAL_SPI_TransmitReceive+0x258>
        if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 8013964:	2201      	movs	r2, #1
 8013966:	9700      	str	r7, [sp, #0]
 8013968:	4611      	mov	r1, r2
 801396a:	462b      	mov	r3, r5
 801396c:	4620      	mov	r0, r4
 801396e:	f7ff fc67 	bl	8013240 <SPI_WaitFlagStateUntilTimeout>
 8013972:	b930      	cbnz	r0, 8013982 <HAL_SPI_TransmitReceive+0x3b2>
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8013974:	6823      	ldr	r3, [r4, #0]
 8013976:	7b1a      	ldrb	r2, [r3, #12]
 8013978:	f8ad 200e 	strh.w	r2, [sp, #14]
        UNUSED(tmpreg);
 801397c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 8013980:	e752      	b.n	8013828 <HAL_SPI_TransmitReceive+0x258>
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8013982:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8013984:	f043 0302 	orr.w	r3, r3, #2
 8013988:	6623      	str	r3, [r4, #96]	; 0x60
 801398a:	e6e4      	b.n	8013756 <HAL_SPI_TransmitReceive+0x186>
      tmpreg = hspi->Instance->DR;
 801398c:	68da      	ldr	r2, [r3, #12]
 801398e:	b292      	uxth	r2, r2
 8013990:	f8ad 200e 	strh.w	r2, [sp, #14]
      UNUSED(tmpreg);
 8013994:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 8013998:	e746      	b.n	8013828 <HAL_SPI_TransmitReceive+0x258>
 801399a:	bf00      	nop

0801399c <HAL_SPI_Transmit_DMA>:
  __HAL_LOCK(hspi);
 801399c:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
 80139a0:	2b01      	cmp	r3, #1
 80139a2:	d06c      	beq.n	8013a7e <HAL_SPI_Transmit_DMA+0xe2>
{
 80139a4:	b570      	push	{r4, r5, r6, lr}
 80139a6:	4604      	mov	r4, r0
  if (hspi->State != HAL_SPI_STATE_READY)
 80139a8:	f890 005d 	ldrb.w	r0, [r0, #93]	; 0x5d
  __HAL_LOCK(hspi);
 80139ac:	2301      	movs	r3, #1
  if (hspi->State != HAL_SPI_STATE_READY)
 80139ae:	b2c0      	uxtb	r0, r0
 80139b0:	4298      	cmp	r0, r3
  __HAL_LOCK(hspi);
 80139b2:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  if (hspi->State != HAL_SPI_STATE_READY)
 80139b6:	d004      	beq.n	80139c2 <HAL_SPI_Transmit_DMA+0x26>
    errorcode = HAL_BUSY;
 80139b8:	2002      	movs	r0, #2
  __HAL_UNLOCK(hspi);
 80139ba:	2300      	movs	r3, #0
 80139bc:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
 80139c0:	bd70      	pop	{r4, r5, r6, pc}
  if ((pData == NULL) || (Size == 0U))
 80139c2:	2900      	cmp	r1, #0
 80139c4:	d0f9      	beq.n	80139ba <HAL_SPI_Transmit_DMA+0x1e>
 80139c6:	2a00      	cmp	r2, #0
 80139c8:	d0f7      	beq.n	80139ba <HAL_SPI_Transmit_DMA+0x1e>
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80139ca:	68a0      	ldr	r0, [r4, #8]
  hspi->TxXferSize  = Size;
 80139cc:	87a2      	strh	r2, [r4, #60]	; 0x3c
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80139ce:	2300      	movs	r3, #0
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 80139d0:	2503      	movs	r5, #3
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80139d2:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 80139d6:	f884 505d 	strb.w	r5, [r4, #93]	; 0x5d
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 80139da:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80139dc:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 80139de:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->TxXferCount = Size;
 80139e0:	87e2      	strh	r2, [r4, #62]	; 0x3e
  hspi->RxISR       = NULL;
 80139e2:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
  hspi->RxXferSize  = 0U;
 80139e6:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
 80139ea:	6822      	ldr	r2, [r4, #0]
  hspi->RxXferCount = 0U;
 80139ec:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80139f0:	d103      	bne.n	80139fa <HAL_SPI_Transmit_DMA+0x5e>
    SPI_1LINE_TX(hspi);
 80139f2:	6813      	ldr	r3, [r2, #0]
 80139f4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80139f8:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80139fa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80139fc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8013a00:	d107      	bne.n	8013a12 <HAL_SPI_Transmit_DMA+0x76>
    SPI_RESET_CRC(hspi);
 8013a02:	6813      	ldr	r3, [r2, #0]
 8013a04:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8013a08:	6013      	str	r3, [r2, #0]
 8013a0a:	6813      	ldr	r3, [r2, #0]
 8013a0c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8013a10:	6013      	str	r3, [r2, #0]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 8013a12:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8013a14:	4e1f      	ldr	r6, [pc, #124]	; (8013a94 <HAL_SPI_Transmit_DMA+0xf8>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8013a16:	6853      	ldr	r3, [r2, #4]
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 8013a18:	68e5      	ldr	r5, [r4, #12]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 8013a1a:	6306      	str	r6, [r0, #48]	; 0x30
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
 8013a1c:	4e1e      	ldr	r6, [pc, #120]	; (8013a98 <HAL_SPI_Transmit_DMA+0xfc>)
 8013a1e:	62c6      	str	r6, [r0, #44]	; 0x2c
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 8013a20:	4e1e      	ldr	r6, [pc, #120]	; (8013a9c <HAL_SPI_Transmit_DMA+0x100>)
 8013a22:	6346      	str	r6, [r0, #52]	; 0x34
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8013a24:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  hspi->hdmatx->XferAbortCallback = NULL;
 8013a28:	2600      	movs	r6, #0
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 8013a2a:	f5b5 6fe0 	cmp.w	r5, #1792	; 0x700
  hspi->hdmatx->XferAbortCallback = NULL;
 8013a2e:	6386      	str	r6, [r0, #56]	; 0x38
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8013a30:	6053      	str	r3, [r2, #4]
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 8013a32:	d80e      	bhi.n	8013a52 <HAL_SPI_Transmit_DMA+0xb6>
 8013a34:	6983      	ldr	r3, [r0, #24]
 8013a36:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8013a3a:	d10a      	bne.n	8013a52 <HAL_SPI_Transmit_DMA+0xb6>
    if ((hspi->TxXferCount & 0x1U) == 0U)
 8013a3c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8013a3e:	f013 0f01 	tst.w	r3, #1
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8013a42:	6853      	ldr	r3, [r2, #4]
    if ((hspi->TxXferCount & 0x1U) == 0U)
 8013a44:	d11d      	bne.n	8013a82 <HAL_SPI_Transmit_DMA+0xe6>
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8013a46:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8013a4a:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U);
 8013a4c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8013a4e:	085b      	lsrs	r3, r3, #1
 8013a50:	87e3      	strh	r3, [r4, #62]	; 0x3e
  HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
 8013a52:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8013a54:	320c      	adds	r2, #12
 8013a56:	f7fd f8f7 	bl	8010c48 <HAL_DMA_Start_IT>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8013a5a:	6823      	ldr	r3, [r4, #0]
 8013a5c:	681a      	ldr	r2, [r3, #0]
 8013a5e:	0652      	lsls	r2, r2, #25
 8013a60:	d403      	bmi.n	8013a6a <HAL_SPI_Transmit_DMA+0xce>
    __HAL_SPI_ENABLE(hspi);
 8013a62:	681a      	ldr	r2, [r3, #0]
 8013a64:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8013a68:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8013a6a:	685a      	ldr	r2, [r3, #4]
 8013a6c:	f042 0220 	orr.w	r2, r2, #32
 8013a70:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8013a72:	685a      	ldr	r2, [r3, #4]
 8013a74:	f042 0202 	orr.w	r2, r2, #2
 8013a78:	605a      	str	r2, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 8013a7a:	2000      	movs	r0, #0
 8013a7c:	e79d      	b.n	80139ba <HAL_SPI_Transmit_DMA+0x1e>
  __HAL_LOCK(hspi);
 8013a7e:	2002      	movs	r0, #2
}
 8013a80:	4770      	bx	lr
      SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8013a82:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8013a86:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 8013a88:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8013a8a:	085b      	lsrs	r3, r3, #1
 8013a8c:	3301      	adds	r3, #1
 8013a8e:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8013a90:	e7df      	b.n	8013a52 <HAL_SPI_Transmit_DMA+0xb6>
 8013a92:	bf00      	nop
 8013a94:	08013aa5 	.word	0x08013aa5
 8013a98:	08013ad9 	.word	0x08013ad9
 8013a9c:	08013ab5 	.word	0x08013ab5

08013aa0 <HAL_SPI_TxHalfCpltCallback>:
 8013aa0:	4770      	bx	lr
 8013aa2:	bf00      	nop

08013aa4 <SPI_DMAHalfTransmitCplt>:
{
 8013aa4:	b508      	push	{r3, lr}
  HAL_SPI_TxHalfCpltCallback(hspi);
 8013aa6:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8013aa8:	f7ff fffa 	bl	8013aa0 <HAL_SPI_TxHalfCpltCallback>
}
 8013aac:	bd08      	pop	{r3, pc}
 8013aae:	bf00      	nop

08013ab0 <HAL_SPI_ErrorCallback>:
 8013ab0:	4770      	bx	lr
 8013ab2:	bf00      	nop

08013ab4 <SPI_DMAError>:
{
 8013ab4:	b508      	push	{r3, lr}
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8013ab6:	6a83      	ldr	r3, [r0, #40]	; 0x28
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8013ab8:	6819      	ldr	r1, [r3, #0]
 8013aba:	684a      	ldr	r2, [r1, #4]
 8013abc:	f022 0203 	bic.w	r2, r2, #3
 8013ac0:	604a      	str	r2, [r1, #4]
  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8013ac2:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_READY;
 8013ac4:	2101      	movs	r1, #1
  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8013ac6:	f042 0210 	orr.w	r2, r2, #16
 8013aca:	661a      	str	r2, [r3, #96]	; 0x60
  HAL_SPI_ErrorCallback(hspi);
 8013acc:	4618      	mov	r0, r3
  hspi->State = HAL_SPI_STATE_READY;
 8013ace:	f883 105d 	strb.w	r1, [r3, #93]	; 0x5d
  HAL_SPI_ErrorCallback(hspi);
 8013ad2:	f7ff ffed 	bl	8013ab0 <HAL_SPI_ErrorCallback>
}
 8013ad6:	bd08      	pop	{r3, pc}

08013ad8 <SPI_DMATransmitCplt>:
{
 8013ad8:	b530      	push	{r4, r5, lr}
 8013ada:	4605      	mov	r5, r0
 8013adc:	b083      	sub	sp, #12
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8013ade:	6a84      	ldr	r4, [r0, #40]	; 0x28
  tickstart = HAL_GetTick();
 8013ae0:	f7fc fd04 	bl	80104ec <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8013ae4:	682b      	ldr	r3, [r5, #0]
 8013ae6:	681b      	ldr	r3, [r3, #0]
 8013ae8:	069b      	lsls	r3, r3, #26
 8013aea:	d422      	bmi.n	8013b32 <SPI_DMATransmitCplt+0x5a>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 8013aec:	6823      	ldr	r3, [r4, #0]
 8013aee:	6859      	ldr	r1, [r3, #4]
 8013af0:	f021 0120 	bic.w	r1, r1, #32
 8013af4:	6059      	str	r1, [r3, #4]
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8013af6:	6859      	ldr	r1, [r3, #4]
 8013af8:	f021 0102 	bic.w	r1, r1, #2
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8013afc:	4602      	mov	r2, r0
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8013afe:	6059      	str	r1, [r3, #4]
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8013b00:	4620      	mov	r0, r4
 8013b02:	2164      	movs	r1, #100	; 0x64
 8013b04:	f7ff fbf0 	bl	80132e8 <SPI_EndRxTxTransaction>
 8013b08:	b118      	cbz	r0, 8013b12 <SPI_DMATransmitCplt+0x3a>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8013b0a:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8013b0c:	f043 0320 	orr.w	r3, r3, #32
 8013b10:	6623      	str	r3, [r4, #96]	; 0x60
    if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8013b12:	68a3      	ldr	r3, [r4, #8]
 8013b14:	b933      	cbnz	r3, 8013b24 <SPI_DMATransmitCplt+0x4c>
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8013b16:	6822      	ldr	r2, [r4, #0]
 8013b18:	9301      	str	r3, [sp, #4]
 8013b1a:	68d3      	ldr	r3, [r2, #12]
 8013b1c:	9301      	str	r3, [sp, #4]
 8013b1e:	6893      	ldr	r3, [r2, #8]
 8013b20:	9301      	str	r3, [sp, #4]
 8013b22:	9b01      	ldr	r3, [sp, #4]
    hspi->State = HAL_SPI_STATE_READY;
 8013b24:	2301      	movs	r3, #1
    hspi->TxXferCount = 0U;
 8013b26:	2200      	movs	r2, #0
 8013b28:	87e2      	strh	r2, [r4, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 8013b2a:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8013b2e:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8013b30:	b923      	cbnz	r3, 8013b3c <SPI_DMATransmitCplt+0x64>
  HAL_SPI_TxCpltCallback(hspi);
 8013b32:	4620      	mov	r0, r4
 8013b34:	f7fc fc7e 	bl	8010434 <HAL_SPI_TxCpltCallback>
}
 8013b38:	b003      	add	sp, #12
 8013b3a:	bd30      	pop	{r4, r5, pc}
      HAL_SPI_ErrorCallback(hspi);
 8013b3c:	4620      	mov	r0, r4
 8013b3e:	f7ff ffb7 	bl	8013ab0 <HAL_SPI_ErrorCallback>
}
 8013b42:	b003      	add	sp, #12
 8013b44:	bd30      	pop	{r4, r5, pc}
 8013b46:	bf00      	nop

08013b48 <HAL_SPI_GetState>:
  return hspi->State;
 8013b48:	f890 005d 	ldrb.w	r0, [r0, #93]	; 0x5d
}
 8013b4c:	4770      	bx	lr
 8013b4e:	bf00      	nop

08013b50 <gesture_postProc>:
  return last_scores;
}

/* Exported Functions ---------------------------------------------*/
uint8_t gesture_postProc(float * scores)
{
 8013b50:	b510      	push	{r4, lr}
 8013b52:	4a1d      	ldr	r2, [pc, #116]	; (8013bc8 <gesture_postProc+0x78>)
    last_scores[i] = (1.0f - alpha) * last_scores[i] + alpha * scores[i];
 8013b54:	ed9f 6a1d 	vldr	s12, [pc, #116]	; 8013bcc <gesture_postProc+0x7c>
 8013b58:	eddf 6a1d 	vldr	s13, [pc, #116]	; 8013bd0 <gesture_postProc+0x80>
 8013b5c:	f100 0128 	add.w	r1, r0, #40	; 0x28
{
 8013b60:	4613      	mov	r3, r2
    last_scores[i] = (1.0f - alpha) * last_scores[i] + alpha * scores[i];
 8013b62:	ecb0 7a01 	vldmia	r0!, {s14}
 8013b66:	edd3 7a00 	vldr	s15, [r3]
 8013b6a:	ee27 7a26 	vmul.f32	s14, s14, s13
 8013b6e:	ee67 7a86 	vmul.f32	s15, s15, s12
  for (int i = 0; i < AI_NETWORK_OUT_1_SIZE; ++i) {
 8013b72:	4281      	cmp	r1, r0
    last_scores[i] = (1.0f - alpha) * last_scores[i] + alpha * scores[i];
 8013b74:	ee77 7a87 	vadd.f32	s15, s15, s14
 8013b78:	ece3 7a01 	vstmia	r3!, {s15}
  for (int i = 0; i < AI_NETWORK_OUT_1_SIZE; ++i) {
 8013b7c:	d1f1      	bne.n	8013b62 <gesture_postProc+0x12>
  uint8_t max_idx = 0;
 8013b7e:	2400      	movs	r4, #0
  float max = -1e9f;
 8013b80:	ed9f 7a14 	vldr	s14, [pc, #80]	; 8013bd4 <gesture_postProc+0x84>
  for (int i = 0; i < size; ++i) {
 8013b84:	4623      	mov	r3, r4
    if (array[i] > max) {
 8013b86:	ecf2 7a01 	vldmia	r2!, {s15}
 8013b8a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8013b8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      max = array[i]; max_idx = i;
 8013b92:	bfc8      	it	gt
 8013b94:	b2dc      	uxtbgt	r4, r3
  for (int i = 0; i < size; ++i) {
 8013b96:	f103 0301 	add.w	r3, r3, #1
      max = array[i]; max_idx = i;
 8013b9a:	bfc8      	it	gt
 8013b9c:	eeb0 7a67 	vmovgt.f32	s14, s15
  for (int i = 0; i < size; ++i) {
 8013ba0:	2b0a      	cmp	r3, #10
 8013ba2:	d1f0      	bne.n	8013b86 <gesture_postProc+0x36>
  if (max > 0.3){
 8013ba4:	ee17 0a10 	vmov	r0, s14
 8013ba8:	f7f3 fbd6 	bl	8007358 <__aeabi_f2d>
 8013bac:	a304      	add	r3, pc, #16	; (adr r3, 8013bc0 <gesture_postProc+0x70>)
 8013bae:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013bb2:	f7f3 feb9 	bl	8007928 <__aeabi_dcmpgt>
    return 0;
 8013bb6:	2800      	cmp	r0, #0
  uint8_t predict;
  predict = argmax(exp_average(scores, FILT_ALPHA), AI_NETWORK_OUT_1_SIZE);
  //return (fmlp_temporal_filter(predict));
  return(predict);
}
 8013bb8:	bf14      	ite	ne
 8013bba:	4620      	movne	r0, r4
 8013bbc:	2000      	moveq	r0, #0
 8013bbe:	bd10      	pop	{r4, pc}
 8013bc0:	33333333 	.word	0x33333333
 8013bc4:	3fd33333 	.word	0x3fd33333
 8013bc8:	20001978 	.word	0x20001978
 8013bcc:	3f4ccccd 	.word	0x3f4ccccd
 8013bd0:	3e4ccccd 	.word	0x3e4ccccd
 8013bd4:	ce6e6b28 	.word	0xce6e6b28

08013bd8 <Gesture_run>:
/* Matteo - Buffer for NN input for datalog purpose */
char NN_input_buffer[6000];             // 128 samples, 6 axis, 6 characters for one value >> buffer of 4608

#ifdef NN_GMP
Gesture_output_t Gesture_run(SensorAxes_t ACC_Value, SensorAxes_t GYR_Value)
{
 8013bd8:	b082      	sub	sp, #8
 8013bda:	b5f0      	push	{r4, r5, r6, r7, lr}
  ai_i32 batch;
  Gesture_input_t iDataIN;
  //Gesture_input_t iDataInPreProc;
  int debug_check = 0;

  if (AI_HANDLE_NULL == network) {
 8013bdc:	4c34      	ldr	r4, [pc, #208]	; (8013cb0 <Gesture_run+0xd8>)
{
 8013bde:	b085      	sub	sp, #20
  if (AI_HANDLE_NULL == network) {
 8013be0:	6825      	ldr	r5, [r4, #0]
{
 8013be2:	930b      	str	r3, [sp, #44]	; 0x2c
 8013be4:	ae04      	add	r6, sp, #16
 8013be6:	e906 0007 	stmdb	r6, {r0, r1, r2}
  if (AI_HANDLE_NULL == network) {
 8013bea:	2d00      	cmp	r5, #0
 8013bec:	d056      	beq.n	8013c9c <Gesture_run+0xc4>
  
/* Matteo - Changed scale for acc from G to mG, Gyro in mdps */
//  iDataIN.AccX = (float)ACC_Value_Raw.AXIS_X * TargetBoardFeatures.AccSensiMultInG;
//  iDataIN.AccY = (float)ACC_Value_Raw.AXIS_Y * TargetBoardFeatures.AccSensiMultInG;
//  iDataIN.AccZ = (float)ACC_Value_Raw.AXIS_Z * TargetBoardFeatures.AccSensiMultInG;
  iDataIN.AccX = (float)ACC_Value.AXIS_X;
 8013bee:	eddd 7a01 	vldr	s15, [sp, #4]
  
  // Matteo - No need to rotate gravity for gesture
  //iDataInPreProc = gravity_rotate(&iDataIN);
  
  /* add samples to each active window */
  ai_size n_window = n_sample / WINDOW_STEP, pos = n_sample % WINDOW_STEP;
 8013bf2:	6862      	ldr	r2, [r4, #4]
  iDataIN.AccX = (float)ACC_Value.AXIS_X;
 8013bf4:	eef8 5ae7 	vcvt.f32.s32	s11, s15
  iDataIN.AccY = (float)ACC_Value.AXIS_Y;
 8013bf8:	eddd 7a02 	vldr	s15, [sp, #8]
 8013bfc:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
  iDataIN.AccZ = (float)ACC_Value.AXIS_Z;
 8013c00:	eddd 7a03 	vldr	s15, [sp, #12]
 8013c04:	eef8 6ae7 	vcvt.f32.s32	s13, s15
  iDataIN.GyrX = (float)GYR_Value.AXIS_X;
 8013c08:	ee07 3a90 	vmov	s15, r3
 8013c0c:	eeb8 5ae7 	vcvt.f32.s32	s10, s15
  iDataIN.GyrY = (float)GYR_Value.AXIS_Y;
 8013c10:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
  ai_size n_window = n_sample / WINDOW_STEP, pos = n_sample % WINDOW_STEP;
 8013c14:	f002 067f 	and.w	r6, r2, #127	; 0x7f
  iDataIN.GyrY = (float)GYR_Value.AXIS_Y;
 8013c18:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  iDataIN.GyrZ = (float)GYR_Value.AXIS_Z;
 8013c1c:	eddd 7a0d 	vldr	s15, [sp, #52]	; 0x34
    ai_int win_idx = (n_window - i) % N_OVERLAPPING_WIN;
    ai_int index = pos + i * WINDOW_STEP;
    ai_int win_offset = win_idx * AI_NETWORK_IN_1_SIZE;

    if (index < AI_NETWORK_IN_1_HEIGHT) {
      ai_size j = win_offset + index * AI_NETWORK_IN_1_WIDTH ;
 8013c20:	eb06 0046 	add.w	r0, r6, r6, lsl #1
 8013c24:	0041      	lsls	r1, r0, #1
  iDataIN.GyrZ = (float)GYR_Value.AXIS_Z;
 8013c26:	eef8 7ae7 	vcvt.f32.s32	s15, s15
      //window_buffer[j++] = iDataInPreProc.AccX;
      //window_buffer[j++] = iDataInPreProc.AccY;
      //window_buffer[j]   = iDataInPreProc.AccZ;
      /* Matteo - added Gyro data to buffer */
      window_buffer[j++] = iDataIN.AccX;
      window_buffer[j++] = iDataIN.AccY;
 8013c2a:	eb04 0e81 	add.w	lr, r4, r1, lsl #2
      window_buffer[j++] = iDataIN.AccX;
 8013c2e:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
      window_buffer[j++] = iDataIN.GyrY;
      window_buffer[j]   = iDataIN.GyrZ;
    }

    /* if buffer is full, run the network */
    if (index == (AI_NETWORK_IN_1_HEIGHT - 1)) {
 8013c32:	2e7f      	cmp	r6, #127	; 0x7f
  iDataIN.AccX = (float)ACC_Value.AXIS_X;
 8013c34:	edc0 5a02 	vstr	s11, [r0, #8]
      window_buffer[j++] = iDataIN.AccY;
 8013c38:	ed8e 6a03 	vstr	s12, [lr, #12]
      window_buffer[j++] = iDataIN.AccZ;
 8013c3c:	edce 6a04 	vstr	s13, [lr, #16]
      window_buffer[j++] = iDataIN.GyrX;
 8013c40:	ed8e 5a05 	vstr	s10, [lr, #20]
      window_buffer[j++] = iDataIN.GyrY;
 8013c44:	ed8e 7a06 	vstr	s14, [lr, #24]
      window_buffer[j]   = iDataIN.GyrZ;
 8013c48:	edce 7a07 	vstr	s15, [lr, #28]
    if (index == (AI_NETWORK_IN_1_HEIGHT - 1)) {
 8013c4c:	d12c      	bne.n	8013ca8 <Gesture_run+0xd0>
      ai_input[0].data  = AI_HANDLE_PTR(&window_buffer[win_offset]);
 8013c4e:	4b19      	ldr	r3, [pc, #100]	; (8013cb4 <Gesture_run+0xdc>)
      ai_output[0].data = AI_HANDLE_PTR(out);
      /* Matteo */
      //LedToggleTargetPlatform();
      batch = ai_network_run(network, &ai_input[0], &ai_output[0]);
 8013c50:	4628      	mov	r0, r5
      ai_input[0].data  = AI_HANDLE_PTR(&window_buffer[win_offset]);
 8013c52:	f104 0608 	add.w	r6, r4, #8
      ai_output[0].data = AI_HANDLE_PTR(out);
 8013c56:	f604 450c 	addw	r5, r4, #3084	; 0xc0c
      batch = ai_network_run(network, &ai_input[0], &ai_output[0]);
 8013c5a:	f103 0210 	add.w	r2, r3, #16
 8013c5e:	4619      	mov	r1, r3
      ai_input[0].data  = AI_HANDLE_PTR(&window_buffer[win_offset]);
 8013c60:	60de      	str	r6, [r3, #12]
      ai_output[0].data = AI_HANDLE_PTR(out);
 8013c62:	61dd      	str	r5, [r3, #28]
      batch = ai_network_run(network, &ai_input[0], &ai_output[0]);
 8013c64:	f000 fb24 	bl	80142b0 <ai_network_run>
      if (batch != 1) {
 8013c68:	2801      	cmp	r0, #1
 8013c6a:	d002      	beq.n	8013c72 <Gesture_run+0x9a>
        aiLogErr(ai_network_get_error(network),"ai_network_run");
 8013c6c:	6820      	ldr	r0, [r4, #0]
 8013c6e:	f000 f95d 	bl	8013f2c <ai_network_get_error>
      }
      last_prediction = gesture_postProc(out);
 8013c72:	4811      	ldr	r0, [pc, #68]	; (8013cb8 <Gesture_run+0xe0>)
 8013c74:	f7ff ff6c 	bl	8013b50 <gesture_postProc>
 8013c78:	3801      	subs	r0, #1
 8013c7a:	b2c0      	uxtb	r0, r0
 8013c7c:	2804      	cmp	r0, #4
 8013c7e:	bf98      	it	ls
 8013c80:	4b0e      	ldrls	r3, [pc, #56]	; (8013cbc <Gesture_run+0xe4>)
 8013c82:	6862      	ldr	r2, [r4, #4]
 8013c84:	bf94      	ite	ls
 8013c86:	5c18      	ldrbls	r0, [r3, r0]
 8013c88:	2000      	movhi	r0, #0
      debug_check++; 
      /* Matteo */
      //LedToggleTargetPlatform();
      ActivityCode = map2GestureClasses(last_prediction);
 8013c8a:	f884 0c08 	strb.w	r0, [r4, #3080]	; 0xc08
        //SD_CardLogging_AI_inference(NN_input_buffer, Pos, last_prediction);
      #endif
      //LedToggleTargetPlatform();
    }
  }
  ++n_sample;
 8013c8e:	3201      	adds	r2, #1
 8013c90:	6062      	str	r2, [r4, #4]
  
  //ActivityCode = map2GestureClasses(last_prediction);
  
    
  return ActivityCode;
}
 8013c92:	b005      	add	sp, #20
 8013c94:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8013c98:	b002      	add	sp, #8
 8013c9a:	4770      	bx	lr
      return Gesture_NOACTIVITY;
 8013c9c:	4628      	mov	r0, r5
}
 8013c9e:	b005      	add	sp, #20
 8013ca0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8013ca4:	b002      	add	sp, #8
 8013ca6:	4770      	bx	lr
 8013ca8:	f894 0c08 	ldrb.w	r0, [r4, #3080]	; 0xc08
 8013cac:	e7ef      	b.n	8013c8e <Gesture_run+0xb6>
 8013cae:	bf00      	nop
 8013cb0:	200019a0 	.word	0x200019a0
 8013cb4:	20000404 	.word	0x20000404
 8013cb8:	200025ac 	.word	0x200025ac
 8013cbc:	08022afc 	.word	0x08022afc

08013cc0 <Gesture_Initialize>:
* @param  None
* @retval 0 if initilazed OK, a negative value otherwise
*/

int8_t Gesture_Initialize(void)
{
 8013cc0:	b570      	push	{r4, r5, r6, lr}
  ai_error err;
  if (network != AI_HANDLE_NULL){
 8013cc2:	4c44      	ldr	r4, [pc, #272]	; (8013dd4 <Gesture_Initialize+0x114>)
 8013cc4:	6821      	ldr	r1, [r4, #0]
{
 8013cc6:	b08a      	sub	sp, #40	; 0x28
  if (network != AI_HANDLE_NULL){
 8013cc8:	2900      	cmp	r1, #0
 8013cca:	d160      	bne.n	8013d8e <Gesture_Initialize+0xce>
          AI_PLATFORM_API_MINOR,
          AI_PLATFORM_API_MICRO);

  /* enabling CRC clock for using AI libraries (for checking if STM32 
  microprocessor is used)*/
  __HAL_RCC_CRC_CLK_ENABLE();
 8013ccc:	4b42      	ldr	r3, [pc, #264]	; (8013dd8 <Gesture_Initialize+0x118>)
 8013cce:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8013cd0:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8013cd4:	649a      	str	r2, [r3, #72]	; 0x48
 8013cd6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8013cd8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8013cdc:	9301      	str	r3, [sp, #4]
    
  /* create an instance of the network */
  SENSING1_PRINTF("Creating the network...\r\n");
  err = ai_network_create(&network, AI_NETWORK_DATA_CONFIG);
 8013cde:	4620      	mov	r0, r4
  __HAL_RCC_CRC_CLK_ENABLE();
 8013ce0:	9b01      	ldr	r3, [sp, #4]
  err = ai_network_create(&network, AI_NETWORK_DATA_CONFIG);
 8013ce2:	f000 f925 	bl	8013f30 <ai_network_create>
  if (err.type) {
 8013ce6:	f010 0fff 	tst.w	r0, #255	; 0xff
 8013cea:	d153      	bne.n	8013d94 <Gesture_Initialize+0xd4>
      aiLogErr(err, "ai_network_create");
      return -3;
  }

  /* Query the created network to get relevant info from it */
  if (ai_network_get_info(network, &report) ) {
 8013cec:	f604 4134 	addw	r1, r4, #3124	; 0xc34
 8013cf0:	6820      	ldr	r0, [r4, #0]
 8013cf2:	f000 f899 	bl	8013e28 <ai_network_get_info>
 8013cf6:	4605      	mov	r5, r0
 8013cf8:	2800      	cmp	r0, #0
 8013cfa:	d056      	beq.n	8013daa <Gesture_Initialize+0xea>


/* Exported macro ------------------------------------------------------------*/
__STATIC_INLINE ai_u32 aiBufferSize(const ai_buffer* buffer)
{
    return buffer->height * buffer->width * buffer->channels;
 8013cfc:	f8b4 1c8c 	ldrh.w	r1, [r4, #3212]	; 0xc8c
 8013d00:	f8b4 2c8e 	ldrh.w	r2, [r4, #3214]	; 0xc8e
 8013d04:	f8d4 3c90 	ldr.w	r3, [r4, #3216]	; 0xc90
 8013d08:	fb02 f201 	mul.w	r2, r2, r1
 8013d0c:	fb03 f302 	mul.w	r3, r3, r2
    if (aiBufferSize(&report->activations)
 8013d10:	f249 0204 	movw	r2, #36868	; 0x9004
 8013d14:	4293      	cmp	r3, r2
 8013d16:	d140      	bne.n	8013d9a <Gesture_Initialize+0xda>
 8013d18:	f8b4 0c9c 	ldrh.w	r0, [r4, #3228]	; 0xc9c
 8013d1c:	f8b4 2c9e 	ldrh.w	r2, [r4, #3230]	; 0xc9e
 8013d20:	f8d4 3ca0 	ldr.w	r3, [r4, #3232]	; 0xca0
    if (aiBufferSize(&report->weights)
 8013d24:	492d      	ldr	r1, [pc, #180]	; (8013ddc <Gesture_Initialize+0x11c>)
 8013d26:	fb02 f200 	mul.w	r2, r2, r0
 8013d2a:	fb03 f302 	mul.w	r3, r3, r2
 8013d2e:	428b      	cmp	r3, r1
 8013d30:	d133      	bne.n	8013d9a <Gesture_Initialize+0xda>
    if ((AI_NETWORK_IN_NUM != report->n_inputs) ||
 8013d32:	f8d4 3c64 	ldr.w	r3, [r4, #3172]	; 0xc64
 8013d36:	f1b3 1f01 	cmp.w	r3, #65537	; 0x10001
 8013d3a:	d12e      	bne.n	8013d9a <Gesture_Initialize+0xda>
    if ((ai_input[0].format != AI_NETWORK_IN_1_FORMAT) ||
 8013d3c:	4b28      	ldr	r3, [pc, #160]	; (8013de0 <Gesture_Initialize+0x120>)
 8013d3e:	881a      	ldrh	r2, [r3, #0]
 8013d40:	2a01      	cmp	r2, #1
 8013d42:	d12a      	bne.n	8013d9a <Gesture_Initialize+0xda>
 8013d44:	8a1a      	ldrh	r2, [r3, #16]
 8013d46:	2a01      	cmp	r2, #1
 8013d48:	d127      	bne.n	8013d9a <Gesture_Initialize+0xda>
    if (AI_NETWORK_IN_1_WIDTH != ai_input[0].width){
 8013d4a:	88da      	ldrh	r2, [r3, #6]
 8013d4c:	2a06      	cmp	r2, #6
 8013d4e:	d124      	bne.n	8013d9a <Gesture_Initialize+0xda>
    if (AI_NETWORK_IN_1_HEIGHT != ai_input[0].height){
 8013d50:	889b      	ldrh	r3, [r3, #4]
 8013d52:	2b80      	cmp	r3, #128	; 0x80
 8013d54:	d121      	bne.n	8013d9a <Gesture_Initialize+0xda>
  SENSING1_PRINTF("Initializing the network...\r\n");

  /* build params structure to provide the references of the
   * activation and weight buffers */
  
  const ai_network_params params = {
 8013d56:	4a23      	ldr	r2, [pc, #140]	; (8013de4 <Gesture_Initialize+0x124>)
 8013d58:	9202      	str	r2, [sp, #8]
 8013d5a:	f04f 1501 	mov.w	r5, #65537	; 0x10001
 8013d5e:	e9cd 5103 	strd	r5, r1, [sp, #12]
     AI_NETWORK_DATA_WEIGHTS(ai_network_data_weights_get()),
 8013d62:	f000 faa7 	bl	80142b4 <ai_network_data_weights_get>
  const ai_network_params params = {
 8013d66:	4b20      	ldr	r3, [pc, #128]	; (8013de8 <Gesture_Initialize+0x128>)
 8013d68:	9005      	str	r0, [sp, #20]
 8013d6a:	f249 0204 	movw	r2, #36868	; 0x9004
 8013d6e:	4e1f      	ldr	r6, [pc, #124]	; (8013dec <Gesture_Initialize+0x12c>)
     AI_NETWORK_DATA_ACTIVATIONS(activations) };

  if (!ai_network_init(network, &params)) {
 8013d70:	6820      	ldr	r0, [r4, #0]
  const ai_network_params params = {
 8013d72:	9507      	str	r5, [sp, #28]
  if (!ai_network_init(network, &params)) {
 8013d74:	a902      	add	r1, sp, #8
  const ai_network_params params = {
 8013d76:	9606      	str	r6, [sp, #24]
 8013d78:	e9cd 2308 	strd	r2, r3, [sp, #32]
  if (!ai_network_init(network, &params)) {
 8013d7c:	f000 f8e8 	bl	8013f50 <ai_network_init>
 8013d80:	4605      	mov	r5, r0
 8013d82:	b1e0      	cbz	r0, 8013dbe <Gesture_Initialize+0xfe>
      aiLogErr(err, "ai_network_init");
      ai_network_destroy(&network);
      network = AI_HANDLE_NULL;
      return -6;
  }
  ActivityCode = Gesture_NOACTIVITY;
 8013d84:	2000      	movs	r0, #0
 8013d86:	f884 0c08 	strb.w	r0, [r4, #3080]	; 0xc08
  #endif
  SENSING1_PRINTF("Initialized NN_IGN_WSDM HAR\r\n");
#endif  

    return 0;
}
 8013d8a:	b00a      	add	sp, #40	; 0x28
 8013d8c:	bd70      	pop	{r4, r5, r6, pc}
	return -1;
 8013d8e:	f04f 30ff 	mov.w	r0, #4294967295
 8013d92:	e7fa      	b.n	8013d8a <Gesture_Initialize+0xca>
      return -3;
 8013d94:	f06f 0002 	mvn.w	r0, #2
 8013d98:	e7f7      	b.n	8013d8a <Gesture_Initialize+0xca>
      ai_network_destroy(&network);
 8013d9a:	480e      	ldr	r0, [pc, #56]	; (8013dd4 <Gesture_Initialize+0x114>)
 8013d9c:	f000 f8d6 	bl	8013f4c <ai_network_destroy>
      network = AI_HANDLE_NULL;
 8013da0:	2300      	movs	r3, #0
 8013da2:	6023      	str	r3, [r4, #0]
      return -5;
 8013da4:	f06f 0004 	mvn.w	r0, #4
 8013da8:	e7ef      	b.n	8013d8a <Gesture_Initialize+0xca>
      err = ai_network_get_error(network);
 8013daa:	6820      	ldr	r0, [r4, #0]
 8013dac:	f000 f8be 	bl	8013f2c <ai_network_get_error>
      ai_network_destroy(&network);
 8013db0:	4620      	mov	r0, r4
 8013db2:	f000 f8cb 	bl	8013f4c <ai_network_destroy>
      network = AI_HANDLE_NULL;
 8013db6:	6025      	str	r5, [r4, #0]
      return -4;
 8013db8:	f06f 0003 	mvn.w	r0, #3
 8013dbc:	e7e5      	b.n	8013d8a <Gesture_Initialize+0xca>
      err = ai_network_get_error(network);
 8013dbe:	6820      	ldr	r0, [r4, #0]
 8013dc0:	f000 f8b4 	bl	8013f2c <ai_network_get_error>
      ai_network_destroy(&network);
 8013dc4:	4803      	ldr	r0, [pc, #12]	; (8013dd4 <Gesture_Initialize+0x114>)
 8013dc6:	f000 f8c1 	bl	8013f4c <ai_network_destroy>
      network = AI_HANDLE_NULL;
 8013dca:	6025      	str	r5, [r4, #0]
      return -6;
 8013dcc:	f06f 0005 	mvn.w	r0, #5
 8013dd0:	e7db      	b.n	8013d8a <Gesture_Initialize+0xca>
 8013dd2:	bf00      	nop
 8013dd4:	200019a0 	.word	0x200019a0
 8013dd8:	40021000 	.word	0x40021000
 8013ddc:	00052378 	.word	0x00052378
 8013de0:	20000404 	.word	0x20000404
 8013de4:	00018010 	.word	0x00018010
 8013de8:	20002650 	.word	0x20002650
 8013dec:	00010010 	.word	0x00010010

08013df0 <Gesture_DeInitialize>:
void Gesture_DeInitialize(void)
{
 8013df0:	b510      	push	{r4, lr}
    ai_error err;

    SENSING1_PRINTF("Releasing the network...\r\n");
    if (network == AI_HANDLE_NULL)
 8013df2:	4c08      	ldr	r4, [pc, #32]	; (8013e14 <Gesture_DeInitialize+0x24>)
 8013df4:	6820      	ldr	r0, [r4, #0]
 8013df6:	b160      	cbz	r0, 8013e12 <Gesture_DeInitialize+0x22>
        return;
    if (ai_network_destroy(network) != AI_HANDLE_NULL) {
 8013df8:	f000 f8a8 	bl	8013f4c <ai_network_destroy>
 8013dfc:	b110      	cbz	r0, 8013e04 <Gesture_DeInitialize+0x14>
        err = ai_network_get_error(network);
 8013dfe:	6820      	ldr	r0, [r4, #0]
 8013e00:	f000 f894 	bl	8013f2c <ai_network_get_error>
        aiLogErr(err, "ai_network_destroy");
    }
    network = AI_HANDLE_NULL;
    __HAL_RCC_CRC_CLK_DISABLE();
 8013e04:	4a04      	ldr	r2, [pc, #16]	; (8013e18 <Gesture_DeInitialize+0x28>)
    network = AI_HANDLE_NULL;
 8013e06:	2300      	movs	r3, #0
 8013e08:	6023      	str	r3, [r4, #0]
    __HAL_RCC_CRC_CLK_DISABLE();
 8013e0a:	6c93      	ldr	r3, [r2, #72]	; 0x48
 8013e0c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8013e10:	6493      	str	r3, [r2, #72]	; 0x48

#ifdef TEST_IGN_WSDM  
   HAR_GetTestSamples_DeInit();
#endif

}
 8013e12:	bd10      	pop	{r4, pc}
 8013e14:	200019a0 	.word	0x200019a0
 8013e18:	40021000 	.word	0x40021000

08013e1c <Gesture_get_Activity_Code>:
 * @param  None
 * @retval activity index
 */
Gesture_output_t Gesture_get_Activity_Code(void)
{
  return ActivityCode;
 8013e1c:	4b01      	ldr	r3, [pc, #4]	; (8013e24 <Gesture_get_Activity_Code+0x8>)
}
 8013e1e:	f893 0c08 	ldrb.w	r0, [r3, #3080]	; 0xc08
 8013e22:	4770      	bx	lr
 8013e24:	200019a0 	.word	0x200019a0

08013e28 <ai_network_get_info>:
/**  PUBLIC APIs SECTION  *****************************************************/

AI_API_ENTRY
ai_bool ai_network_get_info(
  ai_handle network, ai_network_report* report)
{
 8013e28:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013e2a:	460d      	mov	r5, r1
 8013e2c:	b0a1      	sub	sp, #132	; 0x84
  ai_network* net_ctx = AI_NETWORK_ACQUIRE_CTX(network);
 8013e2e:	f7f0 fade 	bl	80043ee <ai_platform_context_acquire>

  if ( report && net_ctx )
 8013e32:	2d00      	cmp	r5, #0
 8013e34:	d062      	beq.n	8013efc <ai_network_get_info+0xd4>
 8013e36:	4604      	mov	r4, r0
 8013e38:	2800      	cmp	r0, #0
 8013e3a:	d05c      	beq.n	8013ef6 <ai_network_get_info+0xce>
      .model_signature   = AI_NETWORK_MODEL_SIGNATURE,
      .model_datetime    = AI_TOOLS_DATE_TIME,
      
      .compile_datetime  = AI_TOOLS_COMPILE_TIME,
      
      .runtime_revision  = ai_platform_runtime_get_revision(),
 8013e3c:	f7f0 fa71 	bl	8004322 <ai_platform_runtime_get_revision>
 8013e40:	4606      	mov	r6, r0
    ai_network_report r = {
 8013e42:	f7f0 fa86 	bl	8004352 <ai_platform_runtime_get_version>
 8013e46:	9006      	str	r0, [sp, #24]
 8013e48:	f7f0 fa9d 	bl	8004386 <ai_platform_api_get_version>
 8013e4c:	900a      	str	r0, [sp, #40]	; 0x28
 8013e4e:	f7f0 fab4 	bl	80043ba <ai_platform_interface_api_get_version>
 8013e52:	f104 0324 	add.w	r3, r4, #36	; 0x24
 8013e56:	900b      	str	r0, [sp, #44]	; 0x2c
 8013e58:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8013e5a:	f10d 0c58 	add.w	ip, sp, #88	; 0x58
 8013e5e:	f104 0714 	add.w	r7, r4, #20
 8013e62:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
 8013e66:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
      .weights           = net_ctx->params,
      .n_nodes           = 0,
      .signature         = net_ctx->signature,
    };

    AI_FOR_EACH_NODE_DO(node, net_ctx->input_node)
 8013e6a:	f8d4 c03c 	ldr.w	ip, [r4, #60]	; 0x3c
      .signature         = net_ctx->signature,
 8013e6e:	f8d4 e004 	ldr.w	lr, [r4, #4]
    ai_network_report r = {
 8013e72:	af1a      	add	r7, sp, #104	; 0x68
 8013e74:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
    AI_FOR_EACH_NODE_DO(node, net_ctx->input_node)
 8013e78:	f1bc 0f00 	cmp.w	ip, #0
 8013e7c:	d045      	beq.n	8013f0a <ai_network_get_info+0xe2>
 8013e7e:	f8dc 3008 	ldr.w	r3, [ip, #8]
 8013e82:	459c      	cmp	ip, r3
 8013e84:	d03e      	beq.n	8013f04 <ai_network_get_info+0xdc>
 8013e86:	2b00      	cmp	r3, #0
 8013e88:	d03c      	beq.n	8013f04 <ai_network_get_info+0xdc>
 8013e8a:	2102      	movs	r1, #2
 8013e8c:	e003      	b.n	8013e96 <ai_network_get_info+0x6e>
 8013e8e:	1c48      	adds	r0, r1, #1
 8013e90:	4613      	mov	r3, r2
 8013e92:	b11a      	cbz	r2, 8013e9c <ai_network_get_info+0x74>
 8013e94:	4601      	mov	r1, r0
 8013e96:	689a      	ldr	r2, [r3, #8]
 8013e98:	429a      	cmp	r2, r3
 8013e9a:	d1f8      	bne.n	8013e8e <ai_network_get_info+0x66>
 8013e9c:	1c0c      	adds	r4, r1, #0
 8013e9e:	bf18      	it	ne
 8013ea0:	2401      	movne	r4, #1
    {
      r.n_nodes++;
    }

    *report = r;
 8013ea2:	4b1b      	ldr	r3, [pc, #108]	; (8013f10 <ai_network_get_info+0xe8>)
 8013ea4:	4a1b      	ldr	r2, [pc, #108]	; (8013f14 <ai_network_get_info+0xec>)
 8013ea6:	911e      	str	r1, [sp, #120]	; 0x78
 8013ea8:	491b      	ldr	r1, [pc, #108]	; (8013f18 <ai_network_get_info+0xf0>)
 8013eaa:	9301      	str	r3, [sp, #4]
 8013eac:	4628      	mov	r0, r5
 8013eae:	4b1b      	ldr	r3, [pc, #108]	; (8013f1c <ai_network_get_info+0xf4>)
 8013eb0:	4d1b      	ldr	r5, [pc, #108]	; (8013f20 <ai_network_get_info+0xf8>)
 8013eb2:	9202      	str	r2, [sp, #8]
 8013eb4:	9103      	str	r1, [sp, #12]
 8013eb6:	f240 3203 	movw	r2, #771	; 0x303
 8013eba:	f240 1101 	movw	r1, #257	; 0x101
 8013ebe:	9504      	str	r5, [sp, #16]
 8013ec0:	9307      	str	r3, [sp, #28]
 8013ec2:	4d18      	ldr	r5, [pc, #96]	; (8013f24 <ai_network_get_info+0xfc>)
 8013ec4:	9208      	str	r2, [sp, #32]
 8013ec6:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8013eca:	4a17      	ldr	r2, [pc, #92]	; (8013f28 <ai_network_get_info+0x100>)
 8013ecc:	9109      	str	r1, [sp, #36]	; 0x24
 8013ece:	2101      	movs	r1, #1
 8013ed0:	950c      	str	r5, [sp, #48]	; 0x30
 8013ed2:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
 8013ed6:	2500      	movs	r5, #0
 8013ed8:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
 8013edc:	920f      	str	r2, [sp, #60]	; 0x3c
 8013ede:	230a      	movs	r3, #10
 8013ee0:	9110      	str	r1, [sp, #64]	; 0x40
 8013ee2:	227c      	movs	r2, #124	; 0x7c
 8013ee4:	a901      	add	r1, sp, #4
 8013ee6:	9605      	str	r6, [sp, #20]
 8013ee8:	f8cd e07c 	str.w	lr, [sp, #124]	; 0x7c
 8013eec:	9511      	str	r5, [sp, #68]	; 0x44
 8013eee:	e9cd 3514 	strd	r3, r5, [sp, #80]	; 0x50
 8013ef2:	f00a fe12 	bl	801eb1a <memcpy>

    return ( r.n_nodes>0 ) ? true : false;
  }
  
  return false;
}
 8013ef6:	4620      	mov	r0, r4
 8013ef8:	b021      	add	sp, #132	; 0x84
 8013efa:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return false;
 8013efc:	462c      	mov	r4, r5
}
 8013efe:	4620      	mov	r0, r4
 8013f00:	b021      	add	sp, #132	; 0x84
 8013f02:	bdf0      	pop	{r4, r5, r6, r7, pc}
    AI_FOR_EACH_NODE_DO(node, net_ctx->input_node)
 8013f04:	2401      	movs	r4, #1
      r.n_nodes++;
 8013f06:	4621      	mov	r1, r4
 8013f08:	e7cb      	b.n	8013ea2 <ai_network_get_info+0x7a>
    AI_FOR_EACH_NODE_DO(node, net_ctx->input_node)
 8013f0a:	4664      	mov	r4, ip
    ai_network_report r = {
 8013f0c:	4661      	mov	r1, ip
 8013f0e:	e7c8      	b.n	8013ea2 <ai_network_get_info+0x7a>
 8013f10:	08075444 	.word	0x08075444
 8013f14:	0807544c 	.word	0x0807544c
 8013f18:	08075470 	.word	0x08075470
 8013f1c:	080754a4 	.word	0x080754a4
 8013f20:	0807548c 	.word	0x0807548c
 8013f24:	0029bf24 	.word	0x0029bf24
 8013f28:	00060080 	.word	0x00060080

08013f2c <ai_network_get_error>:

AI_API_ENTRY
ai_error ai_network_get_error(ai_handle network)
{
  return ai_platform_network_get_error(network);
 8013f2c:	f7f0 ba84 	b.w	8004438 <ai_platform_network_get_error>

08013f30 <ai_network_create>:
}

AI_API_ENTRY
ai_error ai_network_create(
  ai_handle* network, const ai_buffer* network_config)
{
 8013f30:	b500      	push	{lr}
  return ai_platform_network_create(
 8013f32:	2301      	movs	r3, #1
{
 8013f34:	b083      	sub	sp, #12
  return ai_platform_network_create(
 8013f36:	2200      	movs	r2, #0
 8013f38:	e9cd 3200 	strd	r3, r2, [sp]
 8013f3c:	4a02      	ldr	r2, [pc, #8]	; (8013f48 <ai_network_create+0x18>)
 8013f3e:	f7f0 faa3 	bl	8004488 <ai_platform_network_create>
    network, network_config, 
    &AI_NET_OBJ_INSTANCE,
    AI_TOOLS_API_VERSION_MAJOR, AI_TOOLS_API_VERSION_MINOR, AI_TOOLS_API_VERSION_MICRO);
}
 8013f42:	b003      	add	sp, #12
 8013f44:	f85d fb04 	ldr.w	pc, [sp], #4
 8013f48:	20000424 	.word	0x20000424

08013f4c <ai_network_destroy>:

AI_API_ENTRY
ai_handle ai_network_destroy(ai_handle network)
{
  return ai_platform_network_destroy(network);
 8013f4c:	f7f0 bada 	b.w	8004504 <ai_platform_network_destroy>

08013f50 <ai_network_init>:
}

AI_API_ENTRY
ai_bool ai_network_init(
  ai_handle network, const ai_network_params* params)
{
 8013f50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013f54:	4688      	mov	r8, r1
  ai_network* net_ctx = ai_platform_network_init(network, params);
 8013f56:	f7f0 faf4 	bl	8004542 <ai_platform_network_init>
  if ( !net_ctx ) return false;
 8013f5a:	4684      	mov	ip, r0
 8013f5c:	2800      	cmp	r0, #0
 8013f5e:	f000 81a3 	beq.w	80142a8 <ai_network_init+0x358>
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8013f62:	4bd2      	ldr	r3, [pc, #840]	; (80142ac <ai_network_init+0x35c>)

  ai_bool ok = true;
  ok &= network_configure_weights(net_ctx, &params->params);
 8013f64:	f8d8 200c 	ldr.w	r2, [r8, #12]
  conv2d_2_weights_array.format |= AI_FMT_FLAG_CONST;
 8013f68:	6e9c      	ldr	r4, [r3, #104]	; 0x68
  conv2d_2_bias_array.format |= AI_FMT_FLAG_CONST;
 8013f6a:	6f98      	ldr	r0, [r3, #120]	; 0x78
  conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8013f6c:	6d9d      	ldr	r5, [r3, #88]	; 0x58
  conv2d_3_weights_array.format |= AI_FMT_FLAG_CONST;
 8013f6e:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8013f72:	6c9e      	ldr	r6, [r3, #72]	; 0x48
  conv2d_1_weights_array.data = weights + 0;
 8013f74:	651a      	str	r2, [r3, #80]	; 0x50
  conv2d_2_weights_array.format |= AI_FMT_FLAG_CONST;
 8013f76:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
  conv2d_2_bias_array.format |= AI_FMT_FLAG_CONST;
 8013f7a:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
  conv2d_2_weights_array.format |= AI_FMT_FLAG_CONST;
 8013f7e:	669c      	str	r4, [r3, #104]	; 0x68
  conv2d_2_bias_array.format |= AI_FMT_FLAG_CONST;
 8013f80:	6798      	str	r0, [r3, #120]	; 0x78
  conv2d_4_weights_array.format |= AI_FMT_FLAG_CONST;
 8013f82:	f8d3 40a8 	ldr.w	r4, [r3, #168]	; 0xa8
  conv2d_4_bias_array.format |= AI_FMT_FLAG_CONST;
 8013f86:	f8d3 00b8 	ldr.w	r0, [r3, #184]	; 0xb8
  conv2d_1_weights_array.data_start = weights + 0;
 8013f8a:	655a      	str	r2, [r3, #84]	; 0x54
  conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8013f8c:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
  conv2d_4_weights_array.format |= AI_FMT_FLAG_CONST;
 8013f90:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
  conv2d_4_bias_array.format |= AI_FMT_FLAG_CONST;
 8013f94:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
  conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8013f98:	659d      	str	r5, [r3, #88]	; 0x58
  conv2d_4_weights_array.format |= AI_FMT_FLAG_CONST;
 8013f9a:	f8c3 40a8 	str.w	r4, [r3, #168]	; 0xa8
  conv2d_3_bias_array.format |= AI_FMT_FLAG_CONST;
 8013f9e:	f8d3 5098 	ldr.w	r5, [r3, #152]	; 0x98
  conv2d_4_bias_array.format |= AI_FMT_FLAG_CONST;
 8013fa2:	f8c3 00b8 	str.w	r0, [r3, #184]	; 0xb8
  conv2d_1_bias_array.data = weights + 120;
 8013fa6:	f102 0478 	add.w	r4, r2, #120	; 0x78
  conv2d_2_weights_array.data = weights + 144;
 8013faa:	f102 0090 	add.w	r0, r2, #144	; 0x90
  conv2d_3_weights_array.format |= AI_FMT_FLAG_CONST;
 8013fae:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 8013fb2:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
  conv2d_1_bias_array.data_start = weights + 120;
 8013fb6:	e9c3 4418 	strd	r4, r4, [r3, #96]	; 0x60
  conv2d_2_weights_array.data_start = weights + 144;
 8013fba:	e9c3 001c 	strd	r0, r0, [r3, #112]	; 0x70
  conv2d_2_bias_array.data = weights + 1008;
 8013fbe:	f502 747c 	add.w	r4, r2, #1008	; 0x3f0
  conv2d_3_weights_array.data = weights + 1056;
 8013fc2:	f502 6084 	add.w	r0, r2, #1056	; 0x420
  conv2d_4_bias_array.data = weights + 6288;
 8013fc6:	f502 51c4 	add.w	r1, r2, #6272	; 0x1880
 8013fca:	3110      	adds	r1, #16
  conv2d_2_bias_array.data_start = weights + 1008;
 8013fcc:	e9c3 4420 	strd	r4, r4, [r3, #128]	; 0x80
  conv2d_3_weights_array.data_start = weights + 1056;
 8013fd0:	e9c3 0024 	strd	r0, r0, [r3, #144]	; 0x90
  conv2d_3_bias_array.data = weights + 2784;
 8013fd4:	f502 642e 	add.w	r4, r2, #2784	; 0xae0
  conv2d_4_weights_array.data = weights + 2832;
 8013fd8:	f502 6031 	add.w	r0, r2, #2832	; 0xb10
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8013fdc:	f046 4600 	orr.w	r6, r6, #2147483648	; 0x80000000
  conv2d_3_bias_array.format |= AI_FMT_FLAG_CONST;
 8013fe0:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8013fe4:	649e      	str	r6, [r3, #72]	; 0x48
  conv2d_3_bias_array.format |= AI_FMT_FLAG_CONST;
 8013fe6:	f8c3 5098 	str.w	r5, [r3, #152]	; 0x98
  conv2d_4_bias_array.data = weights + 6288;
 8013fea:	f8c3 10c0 	str.w	r1, [r3, #192]	; 0xc0
  conv2d_3_bias_array.data_start = weights + 2784;
 8013fee:	e9c3 4428 	strd	r4, r4, [r3, #160]	; 0xa0
  conv2d_4_weights_array.data_start = weights + 2832;
 8013ff2:	e9c3 002c 	strd	r0, r0, [r3, #176]	; 0xb0
  conv2d_4_bias_array.data_start = weights + 6288;
 8013ff6:	f8c3 10c4 	str.w	r1, [r3, #196]	; 0xc4
  conv2d_6_bias_array.format |= AI_FMT_FLAG_CONST;
 8013ffa:	f8d3 40f8 	ldr.w	r4, [r3, #248]	; 0xf8
  conv2d_6_weights_array.format |= AI_FMT_FLAG_CONST;
 8013ffe:	f8d3 50e8 	ldr.w	r5, [r3, #232]	; 0xe8
  conv2d_7_weights_array.format |= AI_FMT_FLAG_CONST;
 8014002:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
  conv2d_5_bias_array.format |= AI_FMT_FLAG_CONST;
 8014006:	f8d3 60d8 	ldr.w	r6, [r3, #216]	; 0xd8
  conv2d_7_bias_array.format |= AI_FMT_FLAG_CONST;
 801400a:	f8d3 1118 	ldr.w	r1, [r3, #280]	; 0x118
  conv2d_5_weights_array.format |= AI_FMT_FLAG_CONST;
 801400e:	f8d3 70c8 	ldr.w	r7, [r3, #200]	; 0xc8
  conv2d_6_bias_array.format |= AI_FMT_FLAG_CONST;
 8014012:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
 8014016:	f8c3 40f8 	str.w	r4, [r3, #248]	; 0xf8
  conv2d_6_weights_array.format |= AI_FMT_FLAG_CONST;
 801401a:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
  batch_normalization_8_bias_array.format |= AI_FMT_FLAG_CONST;
 801401e:	f8d3 4138 	ldr.w	r4, [r3, #312]	; 0x138
  conv2d_6_weights_array.format |= AI_FMT_FLAG_CONST;
 8014022:	f8c3 50e8 	str.w	r5, [r3, #232]	; 0xe8
  conv2d_7_weights_array.format |= AI_FMT_FLAG_CONST;
 8014026:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
  batch_normalization_8_scale_array.format |= AI_FMT_FLAG_CONST;
 801402a:	f8d3 5128 	ldr.w	r5, [r3, #296]	; 0x128
  conv2d_7_weights_array.format |= AI_FMT_FLAG_CONST;
 801402e:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
  conv2d_5_bias_array.format |= AI_FMT_FLAG_CONST;
 8014032:	f046 4600 	orr.w	r6, r6, #2147483648	; 0x80000000
  batch_normalization_8_bias_array.format |= AI_FMT_FLAG_CONST;
 8014036:	f044 4000 	orr.w	r0, r4, #2147483648	; 0x80000000
  conv2d_7_bias_array.format |= AI_FMT_FLAG_CONST;
 801403a:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
  conv2d_5_bias_array.format |= AI_FMT_FLAG_CONST;
 801403e:	f8c3 60d8 	str.w	r6, [r3, #216]	; 0xd8
  conv2d_7_bias_array.format |= AI_FMT_FLAG_CONST;
 8014042:	f8c3 1118 	str.w	r1, [r3, #280]	; 0x118
  batch_normalization_8_scale_array.format |= AI_FMT_FLAG_CONST;
 8014046:	f045 4600 	orr.w	r6, r5, #2147483648	; 0x80000000
  batch_normalization_8_bias_array.format |= AI_FMT_FLAG_CONST;
 801404a:	f8c3 0138 	str.w	r0, [r3, #312]	; 0x138
  conv2d_5_weights_array.data = weights + 6384;
 801404e:	f502 55c7 	add.w	r5, r2, #6368	; 0x18e0
  conv2d_5_bias_array.data = weights + 13296;
 8014052:	f502 544f 	add.w	r4, r2, #13248	; 0x33c0
  conv2d_6_weights_array.data = weights + 13392;
 8014056:	f502 5051 	add.w	r0, r2, #13376	; 0x3440
  conv2d_6_bias_array.data = weights + 22608;
 801405a:	f502 41b0 	add.w	r1, r2, #22528	; 0x5800
 801405e:	3150      	adds	r1, #80	; 0x50
  conv2d_5_weights_array.data = weights + 6384;
 8014060:	3510      	adds	r5, #16
  conv2d_5_bias_array.data = weights + 13296;
 8014062:	3430      	adds	r4, #48	; 0x30
  conv2d_6_weights_array.data = weights + 13392;
 8014064:	3010      	adds	r0, #16
  conv2d_5_weights_array.data_start = weights + 6384;
 8014066:	e9c3 5534 	strd	r5, r5, [r3, #208]	; 0xd0
  conv2d_5_bias_array.data_start = weights + 13296;
 801406a:	e9c3 4438 	strd	r4, r4, [r3, #224]	; 0xe0
  conv2d_6_weights_array.data_start = weights + 13392;
 801406e:	e9c3 003c 	strd	r0, r0, [r3, #240]	; 0xf0
  conv2d_6_bias_array.data = weights + 22608;
 8014072:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
  conv2d_6_bias_array.data_start = weights + 22608;
 8014076:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
  conv2d_7_weights_array.data = weights + 22736;
 801407a:	f502 45b1 	add.w	r5, r2, #22656	; 0x5880
  conv2d_7_bias_array.data = weights + 35024;
 801407e:	f502 4408 	add.w	r4, r2, #34816	; 0x8800
  batch_normalization_8_scale_array.data = weights + 35152;
 8014082:	f502 4009 	add.w	r0, r2, #35072	; 0x8900
  batch_normalization_8_bias_array.data = weights + 35920;
 8014086:	f502 410c 	add.w	r1, r2, #35840	; 0x8c00
  conv2d_7_weights_array.data = weights + 22736;
 801408a:	3550      	adds	r5, #80	; 0x50
  conv2d_7_bias_array.data = weights + 35024;
 801408c:	34d0      	adds	r4, #208	; 0xd0
  batch_normalization_8_scale_array.data = weights + 35152;
 801408e:	3050      	adds	r0, #80	; 0x50
  batch_normalization_8_bias_array.data = weights + 35920;
 8014090:	3150      	adds	r1, #80	; 0x50
  conv2d_5_weights_array.format |= AI_FMT_FLAG_CONST;
 8014092:	f047 4700 	orr.w	r7, r7, #2147483648	; 0x80000000
  batch_normalization_8_scale_array.format |= AI_FMT_FLAG_CONST;
 8014096:	f8c3 6128 	str.w	r6, [r3, #296]	; 0x128
  conv2d_7_weights_array.data = weights + 22736;
 801409a:	f8c3 5110 	str.w	r5, [r3, #272]	; 0x110
  conv2d_7_weights_array.data_start = weights + 22736;
 801409e:	f8c3 5114 	str.w	r5, [r3, #276]	; 0x114
  conv2d_7_bias_array.data = weights + 35024;
 80140a2:	f8c3 4120 	str.w	r4, [r3, #288]	; 0x120
  conv2d_7_bias_array.data_start = weights + 35024;
 80140a6:	f8c3 4124 	str.w	r4, [r3, #292]	; 0x124
  batch_normalization_8_scale_array.data = weights + 35152;
 80140aa:	f8c3 0130 	str.w	r0, [r3, #304]	; 0x130
  batch_normalization_8_scale_array.data_start = weights + 35152;
 80140ae:	f8c3 0134 	str.w	r0, [r3, #308]	; 0x134
  batch_normalization_8_bias_array.data = weights + 35920;
 80140b2:	f8c3 1140 	str.w	r1, [r3, #320]	; 0x140
  batch_normalization_8_bias_array.data_start = weights + 35920;
 80140b6:	f8c3 1144 	str.w	r1, [r3, #324]	; 0x144
  conv2d_5_weights_array.format |= AI_FMT_FLAG_CONST;
 80140ba:	f8c3 70c8 	str.w	r7, [r3, #200]	; 0xc8
  gru_1_kernel_array.format |= AI_FMT_FLAG_CONST;
 80140be:	f8d3 7148 	ldr.w	r7, [r3, #328]	; 0x148
  batch_normalization_9_scale_array.format |= AI_FMT_FLAG_CONST;
 80140c2:	f8d3 4178 	ldr.w	r4, [r3, #376]	; 0x178
  gru_1_bias_array.format |= AI_FMT_FLAG_CONST;
 80140c6:	f8d3 5168 	ldr.w	r5, [r3, #360]	; 0x168
  batch_normalization_9_bias_array.format |= AI_FMT_FLAG_CONST;
 80140ca:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
  gru_1_recurrent_array.format |= AI_FMT_FLAG_CONST;
 80140ce:	f8d3 6158 	ldr.w	r6, [r3, #344]	; 0x158
  gru_2_kernel_array.format |= AI_FMT_FLAG_CONST;
 80140d2:	f8d3 1198 	ldr.w	r1, [r3, #408]	; 0x198
  batch_normalization_9_scale_array.format |= AI_FMT_FLAG_CONST;
 80140d6:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
 80140da:	f8c3 4178 	str.w	r4, [r3, #376]	; 0x178
  gru_2_bias_array.format |= AI_FMT_FLAG_CONST;
 80140de:	f8d3 41b8 	ldr.w	r4, [r3, #440]	; 0x1b8
  gru_1_bias_array.format |= AI_FMT_FLAG_CONST;
 80140e2:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
  batch_normalization_9_bias_array.format |= AI_FMT_FLAG_CONST;
 80140e6:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
  gru_1_bias_array.format |= AI_FMT_FLAG_CONST;
 80140ea:	f8c3 5168 	str.w	r5, [r3, #360]	; 0x168
  batch_normalization_9_bias_array.format |= AI_FMT_FLAG_CONST;
 80140ee:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
  gru_2_recurrent_array.format |= AI_FMT_FLAG_CONST;
 80140f2:	f8d3 51a8 	ldr.w	r5, [r3, #424]	; 0x1a8
  gru_2_bias_array.format |= AI_FMT_FLAG_CONST;
 80140f6:	f044 4000 	orr.w	r0, r4, #2147483648	; 0x80000000
 80140fa:	f8c3 01b8 	str.w	r0, [r3, #440]	; 0x1b8
  gru_1_recurrent_array.format |= AI_FMT_FLAG_CONST;
 80140fe:	f046 4600 	orr.w	r6, r6, #2147483648	; 0x80000000
  gru_2_kernel_array.format |= AI_FMT_FLAG_CONST;
 8014102:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
  gru_1_bias_array.data = weights + 233296;
 8014106:	f502 3063 	add.w	r0, r2, #232448	; 0x38c00
  gru_1_recurrent_array.format |= AI_FMT_FLAG_CONST;
 801410a:	f8c3 6158 	str.w	r6, [r3, #344]	; 0x158
  gru_2_kernel_array.format |= AI_FMT_FLAG_CONST;
 801410e:	f8c3 1198 	str.w	r1, [r3, #408]	; 0x198
  gru_2_recurrent_array.format |= AI_FMT_FLAG_CONST;
 8014112:	f045 4600 	orr.w	r6, r5, #2147483648	; 0x80000000
  gru_1_bias_array.data = weights + 233296;
 8014116:	f500 7054 	add.w	r0, r0, #848	; 0x350
  batch_normalization_9_scale_array.data = weights + 234064;
 801411a:	f502 3164 	add.w	r1, r2, #233472	; 0x39000
  gru_1_kernel_array.data = weights + 36688;
 801411e:	f502 450f 	add.w	r5, r2, #36608	; 0x8f00
  gru_1_recurrent_array.data = weights + 184144;
 8014122:	f502 3433 	add.w	r4, r2, #183296	; 0x2cc00
  gru_1_kernel_array.data = weights + 36688;
 8014126:	3550      	adds	r5, #80	; 0x50
  gru_1_recurrent_array.data = weights + 184144;
 8014128:	f504 7454 	add.w	r4, r4, #848	; 0x350
  gru_1_bias_array.data = weights + 233296;
 801412c:	f8c3 0170 	str.w	r0, [r3, #368]	; 0x170
  gru_1_bias_array.data_start = weights + 233296;
 8014130:	f8c3 0174 	str.w	r0, [r3, #372]	; 0x174
  batch_normalization_9_scale_array.data = weights + 234064;
 8014134:	f501 7014 	add.w	r0, r1, #592	; 0x250
  gru_1_kernel_array.data = weights + 36688;
 8014138:	f8c3 5150 	str.w	r5, [r3, #336]	; 0x150
  gru_1_kernel_array.data_start = weights + 36688;
 801413c:	f8c3 5154 	str.w	r5, [r3, #340]	; 0x154
  gru_1_recurrent_array.data = weights + 184144;
 8014140:	f8c3 4160 	str.w	r4, [r3, #352]	; 0x160
  gru_1_recurrent_array.data_start = weights + 184144;
 8014144:	f8c3 4164 	str.w	r4, [r3, #356]	; 0x164
  batch_normalization_9_bias_array.data = weights + 234320;
 8014148:	f501 7154 	add.w	r1, r1, #848	; 0x350
  batch_normalization_9_scale_array.data = weights + 234064;
 801414c:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
  batch_normalization_9_scale_array.data_start = weights + 234064;
 8014150:	f8c3 0184 	str.w	r0, [r3, #388]	; 0x184
  gru_2_kernel_array.data = weights + 234576;
 8014154:	f502 3565 	add.w	r5, r2, #234496	; 0x39400
  gru_2_bias_array.data = weights + 332880;
 8014158:	f502 20a2 	add.w	r0, r2, #331776	; 0x51000
  gru_2_recurrent_array.data = weights + 283728;
 801415c:	f502 248a 	add.w	r4, r2, #282624	; 0x45000
  gru_2_kernel_array.data = weights + 234576;
 8014160:	3550      	adds	r5, #80	; 0x50
  gru_2_recurrent_array.data = weights + 283728;
 8014162:	f504 648a 	add.w	r4, r4, #1104	; 0x450
  batch_normalization_9_bias_array.data = weights + 234320;
 8014166:	f8c3 1190 	str.w	r1, [r3, #400]	; 0x190
  batch_normalization_9_bias_array.data_start = weights + 234320;
 801416a:	f8c3 1194 	str.w	r1, [r3, #404]	; 0x194
  gru_1_kernel_array.format |= AI_FMT_FLAG_CONST;
 801416e:	f047 4700 	orr.w	r7, r7, #2147483648	; 0x80000000
  gru_2_bias_array.data = weights + 332880;
 8014172:	f500 618a 	add.w	r1, r0, #1104	; 0x450
  gru_1_kernel_array.format |= AI_FMT_FLAG_CONST;
 8014176:	f8c3 7148 	str.w	r7, [r3, #328]	; 0x148
  gru_2_recurrent_array.format |= AI_FMT_FLAG_CONST;
 801417a:	f8c3 61a8 	str.w	r6, [r3, #424]	; 0x1a8
  gru_2_recurrent_array.data = weights + 283728;
 801417e:	f8c3 41b0 	str.w	r4, [r3, #432]	; 0x1b0
  gru_2_recurrent_array.data_start = weights + 283728;
 8014182:	f8c3 41b4 	str.w	r4, [r3, #436]	; 0x1b4
  gru_2_bias_array.data = weights + 332880;
 8014186:	f8c3 11c0 	str.w	r1, [r3, #448]	; 0x1c0
  gru_2_bias_array.data_start = weights + 332880;
 801418a:	f8c3 11c4 	str.w	r1, [r3, #452]	; 0x1c4
  gru_2_kernel_array.data = weights + 234576;
 801418e:	f8c3 51a0 	str.w	r5, [r3, #416]	; 0x1a0
  gru_2_kernel_array.data_start = weights + 234576;
 8014192:	f8c3 51a4 	str.w	r5, [r3, #420]	; 0x1a4
  batch_normalization_10_scale_array.format |= AI_FMT_FLAG_CONST;
 8014196:	f8d3 51c8 	ldr.w	r5, [r3, #456]	; 0x1c8
  batch_normalization_10_bias_array.format |= AI_FMT_FLAG_CONST;
 801419a:	f8d3 61d8 	ldr.w	r6, [r3, #472]	; 0x1d8
  ai_ptr activations = AI_PTR(AI_PTR_ALIGN(activation_buffer->data, 4));
 801419e:	f8d8 101c 	ldr.w	r1, [r8, #28]
  dense_1_weights_array.format |= AI_FMT_FLAG_CONST;
 80141a2:	f8d3 41e8 	ldr.w	r4, [r3, #488]	; 0x1e8
  batch_normalization_10_scale_array.data = weights + 333648;
 80141a6:	f500 60ea 	add.w	r0, r0, #1872	; 0x750
 80141aa:	f8c3 01d0 	str.w	r0, [r3, #464]	; 0x1d0
  batch_normalization_10_scale_array.data_start = weights + 333648;
 80141ae:	f8c3 01d4 	str.w	r0, [r3, #468]	; 0x1d4
  batch_normalization_10_scale_array.format |= AI_FMT_FLAG_CONST;
 80141b2:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
  AI_FLAG_SET(net_ctx->flags, AI_NETWORK_FLAG_OUT_COPY);
 80141b6:	f8dc 0008 	ldr.w	r0, [ip, #8]
  batch_normalization_10_scale_array.format |= AI_FMT_FLAG_CONST;
 80141ba:	f8c3 51c8 	str.w	r5, [r3, #456]	; 0x1c8
  batch_normalization_10_bias_array.format |= AI_FMT_FLAG_CONST;
 80141be:	f046 4600 	orr.w	r6, r6, #2147483648	; 0x80000000
  dense_1_bias_array.format |= AI_FMT_FLAG_CONST;
 80141c2:	f8d3 51f8 	ldr.w	r5, [r3, #504]	; 0x1f8
  batch_normalization_10_bias_array.format |= AI_FMT_FLAG_CONST;
 80141c6:	f8c3 61d8 	str.w	r6, [r3, #472]	; 0x1d8
  dense_1_weights_array.format |= AI_FMT_FLAG_CONST;
 80141ca:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
  AI_FLAG_SET(net_ctx->flags, AI_NETWORK_FLAG_OUT_COPY);
 80141ce:	f440 7600 	orr.w	r6, r0, #512	; 0x200
  ai_ptr activations = AI_PTR(AI_PTR_ALIGN(activation_buffer->data, 4));
 80141d2:	3103      	adds	r1, #3
  batch_normalization_10_bias_array.data = weights + 333904;
 80141d4:	f502 20a3 	add.w	r0, r2, #333824	; 0x51800
  dense_1_bias_array.data = weights + 336720;
 80141d8:	f502 22a4 	add.w	r2, r2, #335872	; 0x52000
  ai_ptr activations = AI_PTR(AI_PTR_ALIGN(activation_buffer->data, 4));
 80141dc:	f021 0103 	bic.w	r1, r1, #3
  dense_1_weights_array.format |= AI_FMT_FLAG_CONST;
 80141e0:	f8c3 41e8 	str.w	r4, [r3, #488]	; 0x1e8
  dense_1_bias_array.data = weights + 336720;
 80141e4:	f502 7254 	add.w	r2, r2, #848	; 0x350
  batch_normalization_10_bias_array.data = weights + 333904;
 80141e8:	f100 0450 	add.w	r4, r0, #80	; 0x50
  dense_1_bias_array.format |= AI_FMT_FLAG_CONST;
 80141ec:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
  dense_1_bias_array.data = weights + 336720;
 80141f0:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
  dense_1_bias_array.data_start = weights + 336720;
 80141f4:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
  batch_normalization_10_bias_array.data = weights + 333904;
 80141f8:	f8c3 41e0 	str.w	r4, [r3, #480]	; 0x1e0
  conv2d_2_output_array.data = activations + 18432;
 80141fc:	f501 4290 	add.w	r2, r1, #18432	; 0x4800
  batch_normalization_10_bias_array.data_start = weights + 333904;
 8014200:	f8c3 41e4 	str.w	r4, [r3, #484]	; 0x1e4
  dense_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8014204:	f8c3 51f8 	str.w	r5, [r3, #504]	; 0x1f8
  dense_1_output_array.data = activations + 256;
 8014208:	f501 7480 	add.w	r4, r1, #256	; 0x100
  gru_1_output_array.data = activations + 12288;
 801420c:	f501 5540 	add.w	r5, r1, #12288	; 0x3000
  dense_1_weights_array.data = weights + 334160;
 8014210:	f500 70a8 	add.w	r0, r0, #336	; 0x150
    input_0_output_array.data = NULL;
 8014214:	2700      	movs	r7, #0
  dense_1_weights_array.data = weights + 334160;
 8014216:	f8c3 01f0 	str.w	r0, [r3, #496]	; 0x1f0
  dense_1_weights_array.data_start = weights + 334160;
 801421a:	f8c3 01f4 	str.w	r0, [r3, #500]	; 0x1f4
  AI_FLAG_SET(net_ctx->flags, AI_NETWORK_FLAG_OUT_COPY);
 801421e:	f8cc 6008 	str.w	r6, [ip, #8]
  ok &= network_configure_activations(net_ctx, &params->activations);
  
  return ok;
 8014222:	2001      	movs	r0, #1
  conv2d_2_output_array.data = activations + 18432;
 8014224:	f8c3 2230 	str.w	r2, [r3, #560]	; 0x230
  conv2d_2_output_array.data_start = activations + 18432;
 8014228:	f8c3 2234 	str.w	r2, [r3, #564]	; 0x234
  conv2d_4_output_array.data = activations + 18432;
 801422c:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
  conv2d_4_output_array.data_start = activations + 18432;
 8014230:	f8c3 2254 	str.w	r2, [r3, #596]	; 0x254
  conv2d_6_output_array.data = activations + 18432;
 8014234:	f8c3 2270 	str.w	r2, [r3, #624]	; 0x270
  conv2d_1_output_array.data = activations + 0;
 8014238:	f8c3 1220 	str.w	r1, [r3, #544]	; 0x220
  conv2d_1_output_array.data_start = activations + 0;
 801423c:	f8c3 1224 	str.w	r1, [r3, #548]	; 0x224
  conv2d_3_output_array.data = activations + 0;
 8014240:	f8c3 1240 	str.w	r1, [r3, #576]	; 0x240
  conv2d_3_output_array.data_start = activations + 0;
 8014244:	f8c3 1244 	str.w	r1, [r3, #580]	; 0x244
  conv2d_5_output_array.data = activations + 0;
 8014248:	f8c3 1260 	str.w	r1, [r3, #608]	; 0x260
  conv2d_5_output_array.data_start = activations + 0;
 801424c:	f8c3 1264 	str.w	r1, [r3, #612]	; 0x264
    input_0_output_array.data = NULL;
 8014250:	f8c3 7210 	str.w	r7, [r3, #528]	; 0x210
  input_0_output_array.data_start = NULL;
 8014254:	f8c3 7214 	str.w	r7, [r3, #532]	; 0x214
  conv2d_6_output_array.data_start = activations + 18432;
 8014258:	f8c3 2274 	str.w	r2, [r3, #628]	; 0x274
  conv2d_7_output_in_array.data = activations + 0;
 801425c:	f8c3 1280 	str.w	r1, [r3, #640]	; 0x280
  conv2d_7_output_in_array.data_start = activations + 0;
 8014260:	f8c3 1284 	str.w	r1, [r3, #644]	; 0x284
  conv2d_7_output_out_array.data = activations + 0;
 8014264:	f8c3 1290 	str.w	r1, [r3, #656]	; 0x290
  conv2d_7_output_out_array.data_start = activations + 0;
 8014268:	f8c3 1294 	str.w	r1, [r3, #660]	; 0x294
  batch_normalization_8_output_array.data = activations + 0;
 801426c:	f8c3 12a0 	str.w	r1, [r3, #672]	; 0x2a0
  batch_normalization_8_output_array.data_start = activations + 0;
 8014270:	f8c3 12a4 	str.w	r1, [r3, #676]	; 0x2a4
  gru_2_output_array.data = activations + 0;
 8014274:	f8c3 12d0 	str.w	r1, [r3, #720]	; 0x2d0
  gru_2_output_array.data_start = activations + 0;
 8014278:	f8c3 12d4 	str.w	r1, [r3, #724]	; 0x2d4
  batch_normalization_10_output_array.data = activations + 0;
 801427c:	f8c3 12e0 	str.w	r1, [r3, #736]	; 0x2e0
  batch_normalization_10_output_array.data_start = activations + 0;
 8014280:	f8c3 12e4 	str.w	r1, [r3, #740]	; 0x2e4
  gru_1_output_array.data = activations + 12288;
 8014284:	f8c3 52b0 	str.w	r5, [r3, #688]	; 0x2b0
  gru_1_output_array.data_start = activations + 12288;
 8014288:	f8c3 52b4 	str.w	r5, [r3, #692]	; 0x2b4
  batch_normalization_9_output_array.data = activations + 12288;
 801428c:	f8c3 52c0 	str.w	r5, [r3, #704]	; 0x2c0
  batch_normalization_9_output_array.data_start = activations + 12288;
 8014290:	f8c3 52c4 	str.w	r5, [r3, #708]	; 0x2c4
  dense_1_output_array.data = activations + 256;
 8014294:	f8c3 42f0 	str.w	r4, [r3, #752]	; 0x2f0
  dense_1_output_array.data_start = activations + 256;
 8014298:	f8c3 42f4 	str.w	r4, [r3, #756]	; 0x2f4
  dense_1_nl_output_array.data = activations + 256;
 801429c:	f8c3 4300 	str.w	r4, [r3, #768]	; 0x300
  dense_1_nl_output_array.data_start = activations + 256;
 80142a0:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
}
 80142a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80142a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80142ac:	20000424 	.word	0x20000424

080142b0 <ai_network_run>:

AI_API_ENTRY
ai_i32 ai_network_run(
  ai_handle network, const ai_buffer* input, ai_buffer* output)
{
  return ai_platform_network_process(network, input, output);
 80142b0:	f7f0 b992 	b.w	80045d8 <ai_platform_network_process>

080142b4 <ai_network_data_weights_get>:
    0x04, 0xf7, 0x1a, 0xbd, 0x01, 0xb2, 0xe6, 0x3c, 0x8a, 0xf3,
    0xc6, 0x3a, 0x11, 0x18, 0x04, 0x3d, 0xc5, 0x04, 0x91, 0x3c
  };

  return AI_HANDLE_PTR(s_network_weights);
}
 80142b4:	4800      	ldr	r0, [pc, #0]	; (80142b8 <ai_network_data_weights_get+0x4>)
 80142b6:	4770      	bx	lr
 80142b8:	08022b3c 	.word	0x08022b3c

080142bc <disk_status>:
	BYTE pdrv		/* Physical drive number to identify the drive */
)
{
  DSTATUS stat;

  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 80142bc:	4b03      	ldr	r3, [pc, #12]	; (80142cc <disk_status+0x10>)
 80142be:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 80142c2:	4403      	add	r3, r0
 80142c4:	6852      	ldr	r2, [r2, #4]
 80142c6:	7a18      	ldrb	r0, [r3, #8]
 80142c8:	6853      	ldr	r3, [r2, #4]
 80142ca:	4718      	bx	r3
 80142cc:	2000b6b8 	.word	0x2000b6b8

080142d0 <disk_initialize>:
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
  DSTATUS stat = RES_OK;

  if(disk.is_initialized[pdrv] == 0)
 80142d0:	4b06      	ldr	r3, [pc, #24]	; (80142ec <disk_initialize+0x1c>)
 80142d2:	5c1a      	ldrb	r2, [r3, r0]
 80142d4:	b942      	cbnz	r2, 80142e8 <disk_initialize+0x18>
  {
    disk.is_initialized[pdrv] = 1;
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 80142d6:	eb03 0280 	add.w	r2, r3, r0, lsl #2
    disk.is_initialized[pdrv] = 1;
 80142da:	2101      	movs	r1, #1
 80142dc:	5419      	strb	r1, [r3, r0]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 80142de:	6852      	ldr	r2, [r2, #4]
 80142e0:	4403      	add	r3, r0
 80142e2:	6812      	ldr	r2, [r2, #0]
 80142e4:	7a18      	ldrb	r0, [r3, #8]
 80142e6:	4710      	bx	r2
  }
  return stat;
}
 80142e8:	2000      	movs	r0, #0
 80142ea:	4770      	bx	lr
 80142ec:	2000b6b8 	.word	0x2000b6b8

080142f0 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 80142f0:	b430      	push	{r4, r5}
  DRESULT res;

  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 80142f2:	4c05      	ldr	r4, [pc, #20]	; (8014308 <disk_read+0x18>)
 80142f4:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 80142f8:	4404      	add	r4, r0
 80142fa:	686d      	ldr	r5, [r5, #4]
 80142fc:	7a20      	ldrb	r0, [r4, #8]
 80142fe:	68ac      	ldr	r4, [r5, #8]
 8014300:	46a4      	mov	ip, r4
  return res;
}
 8014302:	bc30      	pop	{r4, r5}
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 8014304:	4760      	bx	ip
 8014306:	bf00      	nop
 8014308:	2000b6b8 	.word	0x2000b6b8

0801430c <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
 801430c:	b430      	push	{r4, r5}
  DRESULT res;

  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 801430e:	4c05      	ldr	r4, [pc, #20]	; (8014324 <disk_write+0x18>)
 8014310:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 8014314:	4404      	add	r4, r0
 8014316:	686d      	ldr	r5, [r5, #4]
 8014318:	7a20      	ldrb	r0, [r4, #8]
 801431a:	68ec      	ldr	r4, [r5, #12]
 801431c:	46a4      	mov	ip, r4
  return res;
}
 801431e:	bc30      	pop	{r4, r5}
  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 8014320:	4760      	bx	ip
 8014322:	bf00      	nop
 8014324:	2000b6b8 	.word	0x2000b6b8

08014328 <disk_ioctl>:
	void *buff		/* Buffer to send/receive control data */
)
{
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 8014328:	4b05      	ldr	r3, [pc, #20]	; (8014340 <disk_ioctl+0x18>)
{
 801432a:	b410      	push	{r4}
  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 801432c:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 8014330:	4403      	add	r3, r0
 8014332:	6864      	ldr	r4, [r4, #4]
 8014334:	7a18      	ldrb	r0, [r3, #8]
 8014336:	6923      	ldr	r3, [r4, #16]
  return res;
}
 8014338:	f85d 4b04 	ldr.w	r4, [sp], #4
  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 801433c:	4718      	bx	r3
 801433e:	bf00      	nop
 8014340:	2000b6b8 	.word	0x2000b6b8

08014344 <get_fattime>:
  * @retval Time in DWORD
  */
__weak DWORD get_fattime (void)
{
  return 0;
}
 8014344:	2000      	movs	r0, #0
 8014346:	4770      	bx	lr

08014348 <chk_lock>:
{
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
		if (Files[i].fs) {	/* Existing entry */
 8014348:	4a1e      	ldr	r2, [pc, #120]	; (80143c4 <chk_lock+0x7c>)
 801434a:	6813      	ldr	r3, [r2, #0]
{
 801434c:	b430      	push	{r4, r5}
		if (Files[i].fs) {	/* Existing entry */
 801434e:	2b00      	cmp	r3, #0
 8014350:	d035      	beq.n	80143be <chk_lock+0x76>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8014352:	6804      	ldr	r4, [r0, #0]
 8014354:	429c      	cmp	r4, r3
 8014356:	d00d      	beq.n	8014374 <chk_lock+0x2c>
	for (i = be = 0; i < _FS_LOCK; i++) {
 8014358:	2400      	movs	r4, #0
		if (Files[i].fs) {	/* Existing entry */
 801435a:	6913      	ldr	r3, [r2, #16]
 801435c:	2b00      	cmp	r3, #0
 801435e:	d02b      	beq.n	80143b8 <chk_lock+0x70>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8014360:	6805      	ldr	r5, [r0, #0]
 8014362:	42ab      	cmp	r3, r5
 8014364:	d01a      	beq.n	801439c <chk_lock+0x54>
		} else {			/* Blank entry */
			be = 1;
		}
	}
	if (i == _FS_LOCK) {	/* The object is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 8014366:	bb3c      	cbnz	r4, 80143b8 <chk_lock+0x70>
 8014368:	2902      	cmp	r1, #2
 801436a:	bf0c      	ite	eq
 801436c:	2000      	moveq	r0, #0
 801436e:	2012      	movne	r0, #18
	}

	/* The object has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
}
 8014370:	bc30      	pop	{r4, r5}
 8014372:	4770      	bx	lr
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8014374:	6854      	ldr	r4, [r2, #4]
 8014376:	6883      	ldr	r3, [r0, #8]
 8014378:	429c      	cmp	r4, r3
 801437a:	d1ed      	bne.n	8014358 <chk_lock+0x10>
				Files[i].clu == dp->obj.sclust &&
 801437c:	6894      	ldr	r4, [r2, #8]
 801437e:	6943      	ldr	r3, [r0, #20]
 8014380:	429c      	cmp	r4, r3
 8014382:	d1e9      	bne.n	8014358 <chk_lock+0x10>
	for (i = be = 0; i < _FS_LOCK; i++) {
 8014384:	2300      	movs	r3, #0
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 8014386:	b9a1      	cbnz	r1, 80143b2 <chk_lock+0x6a>
 8014388:	eb02 1203 	add.w	r2, r2, r3, lsl #4
}
 801438c:	bc30      	pop	{r4, r5}
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 801438e:	8993      	ldrh	r3, [r2, #12]
 8014390:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8014394:	bf14      	ite	ne
 8014396:	2000      	movne	r0, #0
 8014398:	2010      	moveq	r0, #16
}
 801439a:	4770      	bx	lr
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 801439c:	6955      	ldr	r5, [r2, #20]
 801439e:	6883      	ldr	r3, [r0, #8]
 80143a0:	429d      	cmp	r5, r3
 80143a2:	d1e0      	bne.n	8014366 <chk_lock+0x1e>
				Files[i].clu == dp->obj.sclust &&
 80143a4:	6943      	ldr	r3, [r0, #20]
 80143a6:	6990      	ldr	r0, [r2, #24]
 80143a8:	4298      	cmp	r0, r3
 80143aa:	d1dc      	bne.n	8014366 <chk_lock+0x1e>
	for (i = be = 0; i < _FS_LOCK; i++) {
 80143ac:	2301      	movs	r3, #1
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 80143ae:	2900      	cmp	r1, #0
 80143b0:	d0ea      	beq.n	8014388 <chk_lock+0x40>
 80143b2:	2010      	movs	r0, #16
}
 80143b4:	bc30      	pop	{r4, r5}
 80143b6:	4770      	bx	lr
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 80143b8:	2000      	movs	r0, #0
}
 80143ba:	bc30      	pop	{r4, r5}
 80143bc:	4770      	bx	lr
			be = 1;
 80143be:	2401      	movs	r4, #1
 80143c0:	e7cb      	b.n	801435a <chk_lock+0x12>
 80143c2:	bf00      	nop
 80143c4:	2000b690 	.word	0x2000b690

080143c8 <inc_lock>:
{
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
		if (Files[i].fs == dp->obj.fs &&
 80143c8:	4b24      	ldr	r3, [pc, #144]	; (801445c <inc_lock+0x94>)
{
 80143ca:	b4f0      	push	{r4, r5, r6, r7}
		if (Files[i].fs == dp->obj.fs &&
 80143cc:	681a      	ldr	r2, [r3, #0]
 80143ce:	6804      	ldr	r4, [r0, #0]
 80143d0:	4294      	cmp	r4, r2
 80143d2:	d01a      	beq.n	801440a <inc_lock+0x42>
 80143d4:	691d      	ldr	r5, [r3, #16]
 80143d6:	42a5      	cmp	r5, r4
 80143d8:	d006      	beq.n	80143e8 <inc_lock+0x20>
			Files[i].clu == dp->obj.sclust &&
			Files[i].ofs == dp->dptr) break;
	}

	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 80143da:	b302      	cbz	r2, 801441e <inc_lock+0x56>
 80143dc:	2d00      	cmp	r5, #0
 80143de:	d033      	beq.n	8014448 <inc_lock+0x80>
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
 80143e0:	2600      	movs	r6, #0
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */

	return i + 1;
}
 80143e2:	4630      	mov	r0, r6
 80143e4:	bcf0      	pop	{r4, r5, r6, r7}
 80143e6:	4770      	bx	lr
		if (Files[i].fs == dp->obj.fs &&
 80143e8:	695f      	ldr	r7, [r3, #20]
 80143ea:	6886      	ldr	r6, [r0, #8]
 80143ec:	42b7      	cmp	r7, r6
 80143ee:	d1f4      	bne.n	80143da <inc_lock+0x12>
			Files[i].clu == dp->obj.sclust &&
 80143f0:	699f      	ldr	r7, [r3, #24]
 80143f2:	6946      	ldr	r6, [r0, #20]
 80143f4:	42b7      	cmp	r7, r6
 80143f6:	d1f0      	bne.n	80143da <inc_lock+0x12>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 80143f8:	2201      	movs	r2, #1
 80143fa:	0115      	lsls	r5, r2, #4
 80143fc:	1958      	adds	r0, r3, r5
 80143fe:	8980      	ldrh	r0, [r0, #12]
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 8014400:	bb29      	cbnz	r1, 801444e <inc_lock+0x86>
 8014402:	1c41      	adds	r1, r0, #1
 8014404:	b289      	uxth	r1, r1
 8014406:	1c56      	adds	r6, r2, #1
 8014408:	e019      	b.n	801443e <inc_lock+0x76>
		if (Files[i].fs == dp->obj.fs &&
 801440a:	6886      	ldr	r6, [r0, #8]
 801440c:	685d      	ldr	r5, [r3, #4]
 801440e:	42ae      	cmp	r6, r5
 8014410:	d1e0      	bne.n	80143d4 <inc_lock+0xc>
			Files[i].clu == dp->obj.sclust &&
 8014412:	6946      	ldr	r6, [r0, #20]
 8014414:	689d      	ldr	r5, [r3, #8]
 8014416:	42ae      	cmp	r6, r5
 8014418:	d1dc      	bne.n	80143d4 <inc_lock+0xc>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 801441a:	2200      	movs	r2, #0
 801441c:	e7ed      	b.n	80143fa <inc_lock+0x32>
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 801441e:	2601      	movs	r6, #1
		Files[i].fs = dp->obj.fs;
 8014420:	0115      	lsls	r5, r2, #4
		Files[i].clu = dp->obj.sclust;
 8014422:	6887      	ldr	r7, [r0, #8]
		Files[i].ofs = dp->dptr;
 8014424:	6940      	ldr	r0, [r0, #20]
		Files[i].fs = dp->obj.fs;
 8014426:	515c      	str	r4, [r3, r5]
 8014428:	195a      	adds	r2, r3, r5
		Files[i].ofs = dp->dptr;
 801442a:	e9c2 7001 	strd	r7, r0, [r2, #4]
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 801442e:	2900      	cmp	r1, #0
		Files[i].ctr = 0;
 8014430:	f04f 0100 	mov.w	r1, #0
 8014434:	8191      	strh	r1, [r2, #12]
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 8014436:	bf14      	ite	ne
 8014438:	f44f 7180 	movne.w	r1, #256	; 0x100
 801443c:	2101      	moveq	r1, #1
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 801443e:	442b      	add	r3, r5
}
 8014440:	4630      	mov	r0, r6
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 8014442:	8199      	strh	r1, [r3, #12]
}
 8014444:	bcf0      	pop	{r4, r5, r6, r7}
 8014446:	4770      	bx	lr
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8014448:	2602      	movs	r6, #2
 801444a:	2201      	movs	r2, #1
 801444c:	e7e8      	b.n	8014420 <inc_lock+0x58>
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 801444e:	2800      	cmp	r0, #0
 8014450:	d1c6      	bne.n	80143e0 <inc_lock+0x18>
 8014452:	1c56      	adds	r6, r2, #1
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 8014454:	f44f 7180 	mov.w	r1, #256	; 0x100
 8014458:	e7f1      	b.n	801443e <inc_lock+0x76>
 801445a:	bf00      	nop
 801445c:	2000b690 	.word	0x2000b690

08014460 <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
 8014460:	b430      	push	{r4, r5}
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 8014462:	6804      	ldr	r4, [r0, #0]
 8014464:	b1f4      	cbz	r4, 80144a4 <get_ldnumber+0x44>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 8014466:	7825      	ldrb	r5, [r4, #0]
 8014468:	2d1f      	cmp	r5, #31
 801446a:	d90b      	bls.n	8014484 <get_ldnumber+0x24>
 801446c:	2d3a      	cmp	r5, #58	; 0x3a
 801446e:	d019      	beq.n	80144a4 <get_ldnumber+0x44>
 8014470:	4623      	mov	r3, r4
 8014472:	e002      	b.n	801447a <get_ldnumber+0x1a>
 8014474:	2a3a      	cmp	r2, #58	; 0x3a
 8014476:	d009      	beq.n	801448c <get_ldnumber+0x2c>
 8014478:	460b      	mov	r3, r1
 801447a:	785a      	ldrb	r2, [r3, #1]
 801447c:	2a1f      	cmp	r2, #31
 801447e:	f103 0101 	add.w	r1, r3, #1
 8014482:	d8f7      	bhi.n	8014474 <get_ldnumber+0x14>
			return vol;
		}
#if _FS_RPATH != 0 && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
 8014484:	2200      	movs	r2, #0
#endif
	}
	return vol;
}
 8014486:	4610      	mov	r0, r2
 8014488:	bc30      	pop	{r4, r5}
 801448a:	4770      	bx	lr
			i = *tp++ - '0';
 801448c:	3401      	adds	r4, #1
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 801448e:	42a1      	cmp	r1, r4
			i = *tp++ - '0';
 8014490:	f1a5 0230 	sub.w	r2, r5, #48	; 0x30
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 8014494:	d106      	bne.n	80144a4 <get_ldnumber+0x44>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 8014496:	2d30      	cmp	r5, #48	; 0x30
 8014498:	d104      	bne.n	80144a4 <get_ldnumber+0x44>
					*path = ++tt;
 801449a:	3302      	adds	r3, #2
 801449c:	6003      	str	r3, [r0, #0]
}
 801449e:	bc30      	pop	{r4, r5}
 80144a0:	4610      	mov	r0, r2
 80144a2:	4770      	bx	lr
	int vol = -1;
 80144a4:	f04f 32ff 	mov.w	r2, #4294967295
}
 80144a8:	4610      	mov	r0, r2
 80144aa:	bc30      	pop	{r4, r5}
 80144ac:	4770      	bx	lr
 80144ae:	bf00      	nop

080144b0 <validate>:
	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
)
{
	FRESULT res;

	if (!obj || !obj->fs || !obj->fs->fs_type || obj->fs->id != obj->id || (disk_status(obj->fs->drv) & STA_NOINIT)) {
 80144b0:	b1d8      	cbz	r0, 80144ea <validate+0x3a>
{
 80144b2:	b510      	push	{r4, lr}
	if (!obj || !obj->fs || !obj->fs->fs_type || obj->fs->id != obj->id || (disk_status(obj->fs->drv) & STA_NOINIT)) {
 80144b4:	6803      	ldr	r3, [r0, #0]
{
 80144b6:	b082      	sub	sp, #8
 80144b8:	4604      	mov	r4, r0
	if (!obj || !obj->fs || !obj->fs->fs_type || obj->fs->id != obj->id || (disk_status(obj->fs->drv) & STA_NOINIT)) {
 80144ba:	b12b      	cbz	r3, 80144c8 <validate+0x18>
 80144bc:	781a      	ldrb	r2, [r3, #0]
 80144be:	b11a      	cbz	r2, 80144c8 <validate+0x18>
 80144c0:	88d8      	ldrh	r0, [r3, #6]
 80144c2:	88a2      	ldrh	r2, [r4, #4]
 80144c4:	4290      	cmp	r0, r2
 80144c6:	d004      	beq.n	80144d2 <validate+0x22>
		*fs = 0;
 80144c8:	2300      	movs	r3, #0
		res = FR_INVALID_OBJECT;	/* The object is invalid */
 80144ca:	2009      	movs	r0, #9
		*fs = 0;
 80144cc:	600b      	str	r3, [r1, #0]
		*fs = obj->fs;			/* Owner file sytem object */
		ENTER_FF(obj->fs);		/* Lock file system */
		res = FR_OK;			/* Valid object */
	}
	return res;
}
 80144ce:	b002      	add	sp, #8
 80144d0:	bd10      	pop	{r4, pc}
	if (!obj || !obj->fs || !obj->fs->fs_type || obj->fs->id != obj->id || (disk_status(obj->fs->drv) & STA_NOINIT)) {
 80144d2:	7858      	ldrb	r0, [r3, #1]
 80144d4:	9101      	str	r1, [sp, #4]
 80144d6:	f7ff fef1 	bl	80142bc <disk_status>
 80144da:	f010 0001 	ands.w	r0, r0, #1
 80144de:	9901      	ldr	r1, [sp, #4]
 80144e0:	d1f2      	bne.n	80144c8 <validate+0x18>
		*fs = obj->fs;			/* Owner file sytem object */
 80144e2:	6823      	ldr	r3, [r4, #0]
 80144e4:	600b      	str	r3, [r1, #0]
}
 80144e6:	b002      	add	sp, #8
 80144e8:	bd10      	pop	{r4, pc}
		*fs = 0;
 80144ea:	2300      	movs	r3, #0
 80144ec:	600b      	str	r3, [r1, #0]
		res = FR_INVALID_OBJECT;	/* The object is invalid */
 80144ee:	2009      	movs	r0, #9
}
 80144f0:	4770      	bx	lr
 80144f2:	bf00      	nop

080144f4 <mem_cpy.part.0>:
void mem_cpy (void* dst, const void* src, UINT cnt) {
 80144f4:	440a      	add	r2, r1
 80144f6:	3801      	subs	r0, #1
			*d++ = *s++;
 80144f8:	f811 3b01 	ldrb.w	r3, [r1], #1
 80144fc:	f800 3f01 	strb.w	r3, [r0, #1]!
		} while (--cnt);
 8014500:	4291      	cmp	r1, r2
 8014502:	d1f9      	bne.n	80144f8 <mem_cpy.part.0+0x4>
}
 8014504:	4770      	bx	lr
 8014506:	bf00      	nop

08014508 <sync_window.part.4>:
FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
 8014508:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		wsect = fs->winsect;	/* Current sector number */
 801450a:	6b05      	ldr	r5, [r0, #48]	; 0x30
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 801450c:	f100 0734 	add.w	r7, r0, #52	; 0x34
FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
 8014510:	4604      	mov	r4, r0
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8014512:	462a      	mov	r2, r5
 8014514:	7840      	ldrb	r0, [r0, #1]
 8014516:	4639      	mov	r1, r7
 8014518:	2301      	movs	r3, #1
 801451a:	f7ff fef7 	bl	801430c <disk_write>
 801451e:	b9b0      	cbnz	r0, 801454e <sync_window.part.4+0x46>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8014520:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8014522:	69e3      	ldr	r3, [r4, #28]
			fs->wflag = 0;
 8014524:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8014526:	1aaa      	subs	r2, r5, r2
 8014528:	429a      	cmp	r2, r3
 801452a:	d20e      	bcs.n	801454a <sync_window.part.4+0x42>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 801452c:	78a6      	ldrb	r6, [r4, #2]
 801452e:	2e01      	cmp	r6, #1
 8014530:	d801      	bhi.n	8014536 <sync_window.part.4+0x2e>
 8014532:	e00a      	b.n	801454a <sync_window.part.4+0x42>
 8014534:	69e3      	ldr	r3, [r4, #28]
					disk_write(fs->drv, fs->win, wsect, 1);
 8014536:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 8014538:	441d      	add	r5, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 801453a:	3e01      	subs	r6, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 801453c:	462a      	mov	r2, r5
 801453e:	2301      	movs	r3, #1
 8014540:	4639      	mov	r1, r7
 8014542:	f7ff fee3 	bl	801430c <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8014546:	2e01      	cmp	r6, #1
 8014548:	d1f4      	bne.n	8014534 <sync_window.part.4+0x2c>
	FRESULT res = FR_OK;
 801454a:	2000      	movs	r0, #0
}
 801454c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			res = FR_DISK_ERR;
 801454e:	2001      	movs	r0, #1
}
 8014550:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8014552:	bf00      	nop

08014554 <sync_fs>:
{
 8014554:	b570      	push	{r4, r5, r6, lr}
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8014556:	78c3      	ldrb	r3, [r0, #3]
{
 8014558:	4605      	mov	r5, r0
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 801455a:	b95b      	cbnz	r3, 8014574 <sync_fs+0x20>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 801455c:	782b      	ldrb	r3, [r5, #0]
 801455e:	2b03      	cmp	r3, #3
 8014560:	d00f      	beq.n	8014582 <sync_fs+0x2e>
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 8014562:	2200      	movs	r2, #0
 8014564:	7868      	ldrb	r0, [r5, #1]
 8014566:	4611      	mov	r1, r2
 8014568:	f7ff fede 	bl	8014328 <disk_ioctl>
 801456c:	3000      	adds	r0, #0
 801456e:	bf18      	it	ne
 8014570:	2001      	movne	r0, #1
}
 8014572:	bd70      	pop	{r4, r5, r6, pc}
 8014574:	f7ff ffc8 	bl	8014508 <sync_window.part.4>
	if (res == FR_OK) {
 8014578:	2800      	cmp	r0, #0
 801457a:	d1fa      	bne.n	8014572 <sync_fs+0x1e>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 801457c:	782b      	ldrb	r3, [r5, #0]
 801457e:	2b03      	cmp	r3, #3
 8014580:	d1ef      	bne.n	8014562 <sync_fs+0xe>
 8014582:	792b      	ldrb	r3, [r5, #4]
 8014584:	2b01      	cmp	r3, #1
 8014586:	d1ec      	bne.n	8014562 <sync_fs+0xe>
			mem_set(fs->win, 0, SS(fs));
 8014588:	f105 0134 	add.w	r1, r5, #52	; 0x34
	BYTE *d = (BYTE*)dst;
 801458c:	460b      	mov	r3, r1
 801458e:	f505 720d 	add.w	r2, r5, #564	; 0x234
		*d++ = (BYTE)val;
 8014592:	2400      	movs	r4, #0
 8014594:	f803 4b01 	strb.w	r4, [r3], #1
	} while (--cnt);
 8014598:	429a      	cmp	r2, r3
 801459a:	d1fb      	bne.n	8014594 <sync_fs+0x40>
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
 801459c:	e9d5 3004 	ldrd	r3, r0, [r5, #16]
	*ptr++ = (BYTE)val; val >>= 8;
 80145a0:	0a06      	lsrs	r6, r0, #8
 80145a2:	f885 021c 	strb.w	r0, [r5, #540]	; 0x21c
	*ptr++ = (BYTE)val; val >>= 8;
 80145a6:	f885 621d 	strb.w	r6, [r5, #541]	; 0x21d
 80145aa:	0c06      	lsrs	r6, r0, #16
	*ptr++ = (BYTE)val; val >>= 8;
 80145ac:	0e00      	lsrs	r0, r0, #24
			fs->winsect = fs->volbase + 1;
 80145ae:	6a2a      	ldr	r2, [r5, #32]
	*ptr++ = (BYTE)val; val >>= 8;
 80145b0:	f885 621e 	strb.w	r6, [r5, #542]	; 0x21e
	*ptr++ = (BYTE)val;
 80145b4:	f885 021f 	strb.w	r0, [r5, #543]	; 0x21f
	*ptr++ = (BYTE)val; val >>= 8;
 80145b8:	0a1e      	lsrs	r6, r3, #8
	*ptr++ = (BYTE)val; val >>= 8;
 80145ba:	0c18      	lsrs	r0, r3, #16
	*ptr++ = (BYTE)val; val >>= 8;
 80145bc:	f885 3220 	strb.w	r3, [r5, #544]	; 0x220
	*ptr++ = (BYTE)val; val >>= 8;
 80145c0:	0e1b      	lsrs	r3, r3, #24
	*ptr++ = (BYTE)val; val >>= 8;
 80145c2:	f885 6221 	strb.w	r6, [r5, #545]	; 0x221
	*ptr++ = (BYTE)val; val >>= 8;
 80145c6:	f885 0222 	strb.w	r0, [r5, #546]	; 0x222
	*ptr++ = (BYTE)val; val >>= 8;
 80145ca:	2655      	movs	r6, #85	; 0x55
	*ptr++ = (BYTE)val;
 80145cc:	20aa      	movs	r0, #170	; 0xaa
	*ptr++ = (BYTE)val;
 80145ce:	f885 3223 	strb.w	r3, [r5, #547]	; 0x223
	*ptr++ = (BYTE)val; val >>= 8;
 80145d2:	2352      	movs	r3, #82	; 0x52
			fs->winsect = fs->volbase + 1;
 80145d4:	3201      	adds	r2, #1
	*ptr++ = (BYTE)val; val >>= 8;
 80145d6:	f885 6232 	strb.w	r6, [r5, #562]	; 0x232
	*ptr++ = (BYTE)val;
 80145da:	f885 0233 	strb.w	r0, [r5, #563]	; 0x233
	*ptr++ = (BYTE)val; val >>= 8;
 80145de:	2661      	movs	r6, #97	; 0x61
	*ptr++ = (BYTE)val;
 80145e0:	2041      	movs	r0, #65	; 0x41
	*ptr++ = (BYTE)val; val >>= 8;
 80145e2:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
	*ptr++ = (BYTE)val; val >>= 8;
 80145e6:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
	*ptr++ = (BYTE)val; val >>= 8;
 80145ea:	2372      	movs	r3, #114	; 0x72
	*ptr++ = (BYTE)val;
 80145ec:	f885 0037 	strb.w	r0, [r5, #55]	; 0x37
	*ptr++ = (BYTE)val; val >>= 8;
 80145f0:	f885 021a 	strb.w	r0, [r5, #538]	; 0x21a
	*ptr++ = (BYTE)val; val >>= 8;
 80145f4:	f885 3218 	strb.w	r3, [r5, #536]	; 0x218
	*ptr++ = (BYTE)val; val >>= 8;
 80145f8:	f885 3219 	strb.w	r3, [r5, #537]	; 0x219
			fs->winsect = fs->volbase + 1;
 80145fc:	632a      	str	r2, [r5, #48]	; 0x30
	*ptr++ = (BYTE)val; val >>= 8;
 80145fe:	f885 6036 	strb.w	r6, [r5, #54]	; 0x36
	*ptr++ = (BYTE)val;
 8014602:	f885 621b 	strb.w	r6, [r5, #539]	; 0x21b
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 8014606:	2301      	movs	r3, #1
 8014608:	7868      	ldrb	r0, [r5, #1]
 801460a:	f7ff fe7f 	bl	801430c <disk_write>
			fs->fsi_flag = 0;
 801460e:	712c      	strb	r4, [r5, #4]
 8014610:	e7a7      	b.n	8014562 <sync_fs+0xe>
 8014612:	bf00      	nop

08014614 <move_window.part.5>:
FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
 8014614:	b538      	push	{r3, r4, r5, lr}
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8014616:	78c3      	ldrb	r3, [r0, #3]
FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
 8014618:	4604      	mov	r4, r0
 801461a:	460d      	mov	r5, r1
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 801461c:	b113      	cbz	r3, 8014624 <move_window.part.5+0x10>
 801461e:	f7ff ff73 	bl	8014508 <sync_window.part.4>
		if (res == FR_OK) {			/* Fill sector window with new data */
 8014622:	b970      	cbnz	r0, 8014642 <move_window.part.5+0x2e>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8014624:	462a      	mov	r2, r5
 8014626:	2301      	movs	r3, #1
 8014628:	f104 0134 	add.w	r1, r4, #52	; 0x34
 801462c:	7860      	ldrb	r0, [r4, #1]
 801462e:	f7ff fe5f 	bl	80142f0 <disk_read>
				res = FR_DISK_ERR;
 8014632:	2800      	cmp	r0, #0
 8014634:	bf18      	it	ne
 8014636:	f04f 35ff 	movne.w	r5, #4294967295
			fs->winsect = sector;
 801463a:	6325      	str	r5, [r4, #48]	; 0x30
				res = FR_DISK_ERR;
 801463c:	bf0c      	ite	eq
 801463e:	2000      	moveq	r0, #0
 8014640:	2001      	movne	r0, #1
}
 8014642:	bd38      	pop	{r3, r4, r5, pc}

08014644 <check_fs>:
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8014644:	f04f 33ff 	mov.w	r3, #4294967295
 8014648:	2200      	movs	r2, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
 801464a:	4299      	cmp	r1, r3
{
 801464c:	b510      	push	{r4, lr}
 801464e:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8014650:	70c2      	strb	r2, [r0, #3]
 8014652:	6303      	str	r3, [r0, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014654:	d134      	bne.n	80146c0 <check_fs+0x7c>
	rv = rv << 8 | ptr[0];
 8014656:	f894 1233 	ldrb.w	r1, [r4, #563]	; 0x233
 801465a:	f894 3232 	ldrb.w	r3, [r4, #562]	; 0x232
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 801465e:	f64a 2255 	movw	r2, #43605	; 0xaa55
	rv = rv << 8 | ptr[0];
 8014662:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8014666:	4293      	cmp	r3, r2
 8014668:	d128      	bne.n	80146bc <check_fs+0x78>
	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 801466a:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 801466e:	2be9      	cmp	r3, #233	; 0xe9
 8014670:	d005      	beq.n	801467e <check_fs+0x3a>
 8014672:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8014674:	4a17      	ldr	r2, [pc, #92]	; (80146d4 <check_fs+0x90>)
 8014676:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 801467a:	4293      	cmp	r3, r2
 801467c:	d126      	bne.n	80146cc <check_fs+0x88>
	rv = rv << 8 | ptr[2];
 801467e:	f8b4 006c 	ldrh.w	r0, [r4, #108]	; 0x6c
	rv = rv << 8 | ptr[1];
 8014682:	f894 206b 	ldrb.w	r2, [r4, #107]	; 0x6b
	rv = rv << 8 | ptr[0];
 8014686:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 801468a:	4913      	ldr	r1, [pc, #76]	; (80146d8 <check_fs+0x94>)
	rv = rv << 8 | ptr[1];
 801468c:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	rv = rv << 8 | ptr[0];
 8014690:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 8014694:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8014698:	428b      	cmp	r3, r1
 801469a:	d019      	beq.n	80146d0 <check_fs+0x8c>
	rv = rv << 8 | ptr[2];
 801469c:	f8b4 1088 	ldrh.w	r1, [r4, #136]	; 0x88
	rv = rv << 8 | ptr[1];
 80146a0:	f894 3087 	ldrb.w	r3, [r4, #135]	; 0x87
	rv = rv << 8 | ptr[0];
 80146a4:	f894 0086 	ldrb.w	r0, [r4, #134]	; 0x86
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 80146a8:	4a0c      	ldr	r2, [pc, #48]	; (80146dc <check_fs+0x98>)
	rv = rv << 8 | ptr[1];
 80146aa:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 80146ae:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 80146b2:	4290      	cmp	r0, r2
 80146b4:	bf14      	ite	ne
 80146b6:	2002      	movne	r0, #2
 80146b8:	2000      	moveq	r0, #0
}
 80146ba:	bd10      	pop	{r4, pc}
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 80146bc:	2003      	movs	r0, #3
}
 80146be:	bd10      	pop	{r4, pc}
 80146c0:	f7ff ffa8 	bl	8014614 <move_window.part.5>
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 80146c4:	2800      	cmp	r0, #0
 80146c6:	d0c6      	beq.n	8014656 <check_fs+0x12>
 80146c8:	2004      	movs	r0, #4
}
 80146ca:	bd10      	pop	{r4, pc}
	return 2;
 80146cc:	2002      	movs	r0, #2
}
 80146ce:	bd10      	pop	{r4, pc}
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 80146d0:	2000      	movs	r0, #0
}
 80146d2:	bd10      	pop	{r4, pc}
 80146d4:	009000eb 	.word	0x009000eb
 80146d8:	00544146 	.word	0x00544146
 80146dc:	33544146 	.word	0x33544146

080146e0 <find_volume>:
{
 80146e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	*rfs = 0;
 80146e4:	2300      	movs	r3, #0
{
 80146e6:	b085      	sub	sp, #20
	*rfs = 0;
 80146e8:	600b      	str	r3, [r1, #0]
{
 80146ea:	460e      	mov	r6, r1
 80146ec:	4690      	mov	r8, r2
	vol = get_ldnumber(path);
 80146ee:	f7ff feb7 	bl	8014460 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 80146f2:	1e05      	subs	r5, r0, #0
 80146f4:	f2c0 80ce 	blt.w	8014894 <find_volume+0x1b4>
	fs = FatFs[vol];					/* Get pointer to the file system object */
 80146f8:	4fc9      	ldr	r7, [pc, #804]	; (8014a20 <find_volume+0x340>)
 80146fa:	eb07 0385 	add.w	r3, r7, r5, lsl #2
 80146fe:	6a1c      	ldr	r4, [r3, #32]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8014700:	2c00      	cmp	r4, #0
 8014702:	f000 80f5 	beq.w	80148f0 <find_volume+0x210>
	*rfs = fs;							/* Return pointer to the file system object */
 8014706:	6034      	str	r4, [r6, #0]
	if (fs->fs_type) {					/* If the volume has been mounted */
 8014708:	7823      	ldrb	r3, [r4, #0]
	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 801470a:	f008 06fe 	and.w	r6, r8, #254	; 0xfe
	if (fs->fs_type) {					/* If the volume has been mounted */
 801470e:	b17b      	cbz	r3, 8014730 <find_volume+0x50>
		stat = disk_status(fs->drv);
 8014710:	7860      	ldrb	r0, [r4, #1]
 8014712:	f7ff fdd3 	bl	80142bc <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8014716:	07c2      	lsls	r2, r0, #31
 8014718:	d40a      	bmi.n	8014730 <find_volume+0x50>
			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 801471a:	2e00      	cmp	r6, #0
 801471c:	f000 80f5 	beq.w	801490a <find_volume+0x22a>
 8014720:	f010 0004 	ands.w	r0, r0, #4
 8014724:	f000 80b7 	beq.w	8014896 <find_volume+0x1b6>
				return FR_WRITE_PROTECTED;
 8014728:	200a      	movs	r0, #10
}
 801472a:	b005      	add	sp, #20
 801472c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	fs->fs_type = 0;					/* Clear the file system object */
 8014730:	2300      	movs	r3, #0
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8014732:	b2e8      	uxtb	r0, r5
	fs->fs_type = 0;					/* Clear the file system object */
 8014734:	7023      	strb	r3, [r4, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8014736:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8014738:	f7ff fdca 	bl	80142d0 <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 801473c:	07c3      	lsls	r3, r0, #31
 801473e:	f100 80ad 	bmi.w	801489c <find_volume+0x1bc>
	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 8014742:	b10e      	cbz	r6, 8014748 <find_volume+0x68>
 8014744:	0745      	lsls	r5, r0, #29
 8014746:	d4ef      	bmi.n	8014728 <find_volume+0x48>
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 8014748:	2100      	movs	r1, #0
 801474a:	4620      	mov	r0, r4
 801474c:	f7ff ff7a 	bl	8014644 <check_fs>
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 8014750:	2802      	cmp	r0, #2
 8014752:	f000 80a7 	beq.w	80148a4 <find_volume+0x1c4>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8014756:	2804      	cmp	r0, #4
 8014758:	f000 80d5 	beq.w	8014906 <find_volume+0x226>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 801475c:	2801      	cmp	r0, #1
 801475e:	f200 80c3 	bhi.w	80148e8 <find_volume+0x208>
	bsect = 0;
 8014762:	2600      	movs	r6, #0
	rv = rv << 8 | ptr[0];
 8014764:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 8014768:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
 801476c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8014770:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8014774:	f040 80b8 	bne.w	80148e8 <find_volume+0x208>
	rv = rv << 8 | ptr[0];
 8014778:	f894 204b 	ldrb.w	r2, [r4, #75]	; 0x4b
 801477c:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 8014780:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
 8014784:	d109      	bne.n	801479a <find_volume+0xba>
	rv = rv << 8 | ptr[2];
 8014786:	f8b4 105a 	ldrh.w	r1, [r4, #90]	; 0x5a
	rv = rv << 8 | ptr[1];
 801478a:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
	rv = rv << 8 | ptr[0];
 801478e:	f894 2058 	ldrb.w	r2, [r4, #88]	; 0x58
	rv = rv << 8 | ptr[1];
 8014792:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 8014796:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 801479a:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
		fs->fsize = fasize;
 801479e:	61e3      	str	r3, [r4, #28]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 80147a0:	1e51      	subs	r1, r2, #1
 80147a2:	2901      	cmp	r1, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 80147a4:	70a2      	strb	r2, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 80147a6:	f200 809f 	bhi.w	80148e8 <find_volume+0x208>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 80147aa:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
 80147ae:	b288      	uxth	r0, r1
 80147b0:	8160      	strh	r0, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 80147b2:	2800      	cmp	r0, #0
 80147b4:	f000 8098 	beq.w	80148e8 <find_volume+0x208>
 80147b8:	1e48      	subs	r0, r1, #1
 80147ba:	4208      	tst	r0, r1
 80147bc:	f040 8094 	bne.w	80148e8 <find_volume+0x208>
	rv = rv << 8 | ptr[0];
 80147c0:	f894 0046 	ldrb.w	r0, [r4, #70]	; 0x46
 80147c4:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 80147c8:	ea45 2500 	orr.w	r5, r5, r0, lsl #8
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 80147cc:	0728      	lsls	r0, r5, #28
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 80147ce:	8125      	strh	r5, [r4, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 80147d0:	f040 808a 	bne.w	80148e8 <find_volume+0x208>
	rv = rv << 8 | ptr[0];
 80147d4:	f894 c048 	ldrb.w	ip, [r4, #72]	; 0x48
 80147d8:	f894 0047 	ldrb.w	r0, [r4, #71]	; 0x47
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 80147dc:	ea50 200c 	orrs.w	r0, r0, ip, lsl #8
 80147e0:	d109      	bne.n	80147f6 <find_volume+0x116>
	rv = rv << 8 | ptr[2];
 80147e2:	f8b4 e056 	ldrh.w	lr, [r4, #86]	; 0x56
	rv = rv << 8 | ptr[1];
 80147e6:	f894 c055 	ldrb.w	ip, [r4, #85]	; 0x55
	rv = rv << 8 | ptr[0];
 80147ea:	f894 0054 	ldrb.w	r0, [r4, #84]	; 0x54
	rv = rv << 8 | ptr[1];
 80147ee:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
	rv = rv << 8 | ptr[0];
 80147f2:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
	rv = rv << 8 | ptr[0];
 80147f6:	f894 e043 	ldrb.w	lr, [r4, #67]	; 0x43
 80147fa:	f894 c042 	ldrb.w	ip, [r4, #66]	; 0x42
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 80147fe:	ea5c 2c0e 	orrs.w	ip, ip, lr, lsl #8
 8014802:	d071      	beq.n	80148e8 <find_volume+0x208>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 8014804:	fb03 f802 	mul.w	r8, r3, r2
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 8014808:	eb0c 1e15 	add.w	lr, ip, r5, lsr #4
 801480c:	eb0e 0208 	add.w	r2, lr, r8
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 8014810:	4290      	cmp	r0, r2
 8014812:	d369      	bcc.n	80148e8 <find_volume+0x208>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 8014814:	1a80      	subs	r0, r0, r2
 8014816:	fbb0 f1f1 	udiv	r1, r0, r1
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 801481a:	2900      	cmp	r1, #0
 801481c:	d064      	beq.n	80148e8 <find_volume+0x208>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 801481e:	f64f 70f5 	movw	r0, #65525	; 0xfff5
 8014822:	4281      	cmp	r1, r0
 8014824:	d873      	bhi.n	801490e <find_volume+0x22e>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 8014826:	f640 7ef5 	movw	lr, #4085	; 0xff5
 801482a:	4571      	cmp	r1, lr
 801482c:	eb0c 0006 	add.w	r0, ip, r6
 8014830:	4432      	add	r2, r6
 8014832:	f101 0c02 	add.w	ip, r1, #2
 8014836:	f200 809c 	bhi.w	8014972 <find_volume+0x292>
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 801483a:	f8c4 c018 	str.w	ip, [r4, #24]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 801483e:	e9c4 6008 	strd	r6, r0, [r4, #32]
		fs->database = bsect + sysect;					/* Data start sector */
 8014842:	62e2      	str	r2, [r4, #44]	; 0x2c
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 8014844:	2d00      	cmp	r5, #0
 8014846:	d04f      	beq.n	80148e8 <find_volume+0x208>
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8014848:	eb0c 024c 	add.w	r2, ip, ip, lsl #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 801484c:	4440      	add	r0, r8
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 801484e:	f00c 0c01 	and.w	ip, ip, #1
 8014852:	eb0c 0c52 	add.w	ip, ip, r2, lsr #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 8014856:	62a0      	str	r0, [r4, #40]	; 0x28
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8014858:	2201      	movs	r2, #1
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 801485a:	f20c 1cff 	addw	ip, ip, #511	; 0x1ff
 801485e:	ebb3 2f5c 	cmp.w	r3, ip, lsr #9
 8014862:	d341      	bcc.n	80148e8 <find_volume+0x208>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8014864:	f04f 33ff 	mov.w	r3, #4294967295
 8014868:	e9c4 3304 	strd	r3, r3, [r4, #16]
		fs->fsi_flag = 0x80;
 801486c:	2180      	movs	r1, #128	; 0x80
 801486e:	7121      	strb	r1, [r4, #4]
	fs->id = ++Fsid;		/* File system mount ID */
 8014870:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
		if (Files[i].fs == fs) Files[i].fs = 0;
 8014872:	6839      	ldr	r1, [r7, #0]
	fs->fs_type = fmt;		/* FAT sub-type */
 8014874:	7022      	strb	r2, [r4, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 8014876:	3301      	adds	r3, #1
 8014878:	b29b      	uxth	r3, r3
		if (Files[i].fs == fs) Files[i].fs = 0;
 801487a:	428c      	cmp	r4, r1
	fs->id = ++Fsid;		/* File system mount ID */
 801487c:	84bb      	strh	r3, [r7, #36]	; 0x24
 801487e:	80e3      	strh	r3, [r4, #6]
		if (Files[i].fs == fs) Files[i].fs = 0;
 8014880:	bf04      	itt	eq
 8014882:	2300      	moveq	r3, #0
 8014884:	603b      	streq	r3, [r7, #0]
 8014886:	693b      	ldr	r3, [r7, #16]
 8014888:	429c      	cmp	r4, r3
 801488a:	f04f 0000 	mov.w	r0, #0
 801488e:	d102      	bne.n	8014896 <find_volume+0x1b6>
 8014890:	6138      	str	r0, [r7, #16]
 8014892:	e000      	b.n	8014896 <find_volume+0x1b6>
	if (vol < 0) return FR_INVALID_DRIVE;
 8014894:	200b      	movs	r0, #11
}
 8014896:	b005      	add	sp, #20
 8014898:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 801489c:	2003      	movs	r0, #3
}
 801489e:	b005      	add	sp, #20
 80148a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80148a4:	466d      	mov	r5, sp
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 80148a6:	4629      	mov	r1, r5
 80148a8:	f504 73fe 	add.w	r3, r4, #508	; 0x1fc
 80148ac:	f504 760f 	add.w	r6, r4, #572	; 0x23c
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 80148b0:	f813 2c06 	ldrb.w	r2, [r3, #-6]
 80148b4:	b14a      	cbz	r2, 80148ca <find_volume+0x1ea>
	rv = rv << 8 | ptr[2];
 80148b6:	f8b3 c000 	ldrh.w	ip, [r3]
	rv = rv << 8 | ptr[1];
 80148ba:	f813 0c01 	ldrb.w	r0, [r3, #-1]
	rv = rv << 8 | ptr[0];
 80148be:	f813 2c02 	ldrb.w	r2, [r3, #-2]
	rv = rv << 8 | ptr[1];
 80148c2:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
	rv = rv << 8 | ptr[0];
 80148c6:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 80148ca:	3310      	adds	r3, #16
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 80148cc:	42b3      	cmp	r3, r6
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 80148ce:	f841 2b04 	str.w	r2, [r1], #4
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 80148d2:	d1ed      	bne.n	80148b0 <find_volume+0x1d0>
 80148d4:	f105 0810 	add.w	r8, r5, #16
			bsect = br[i];
 80148d8:	f855 6b04 	ldr.w	r6, [r5], #4
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 80148dc:	b966      	cbnz	r6, 80148f8 <find_volume+0x218>
 80148de:	2003      	movs	r0, #3
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 80148e0:	45a8      	cmp	r8, r5
 80148e2:	d1f9      	bne.n	80148d8 <find_volume+0x1f8>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 80148e4:	2804      	cmp	r0, #4
 80148e6:	d00e      	beq.n	8014906 <find_volume+0x226>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 80148e8:	200d      	movs	r0, #13
}
 80148ea:	b005      	add	sp, #20
 80148ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 80148f0:	200c      	movs	r0, #12
}
 80148f2:	b005      	add	sp, #20
 80148f4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 80148f8:	4631      	mov	r1, r6
 80148fa:	4620      	mov	r0, r4
 80148fc:	f7ff fea2 	bl	8014644 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 8014900:	2801      	cmp	r0, #1
 8014902:	d8ed      	bhi.n	80148e0 <find_volume+0x200>
 8014904:	e72e      	b.n	8014764 <find_volume+0x84>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8014906:	2001      	movs	r0, #1
 8014908:	e7c5      	b.n	8014896 <find_volume+0x1b6>
			return FR_OK;				/* The file system object is valid */
 801490a:	4630      	mov	r0, r6
 801490c:	e7c3      	b.n	8014896 <find_volume+0x1b6>
	rv = rv << 8 | ptr[0];
 801490e:	f894 905f 	ldrb.w	r9, [r4, #95]	; 0x5f
 8014912:	f894 805e 	ldrb.w	r8, [r4, #94]	; 0x5e
		fs->volbase = bsect;							/* Volume start sector */
 8014916:	6226      	str	r6, [r4, #32]
		fs->database = bsect + sysect;					/* Data start sector */
 8014918:	4432      	add	r2, r6
 801491a:	3102      	adds	r1, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 801491c:	eb0c 0006 	add.w	r0, ip, r6
		fs->database = bsect + sysect;					/* Data start sector */
 8014920:	62e2      	str	r2, [r4, #44]	; 0x2c
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 8014922:	ea58 2209 	orrs.w	r2, r8, r9, lsl #8
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8014926:	61a1      	str	r1, [r4, #24]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8014928:	6260      	str	r0, [r4, #36]	; 0x24
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 801492a:	d1dd      	bne.n	80148e8 <find_volume+0x208>
			if (fs->n_rootdir) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 801492c:	2d00      	cmp	r5, #0
 801492e:	d1db      	bne.n	80148e8 <find_volume+0x208>
	rv = rv << 8 | ptr[2];
 8014930:	f8b4 2062 	ldrh.w	r2, [r4, #98]	; 0x62
	rv = rv << 8 | ptr[1];
 8014934:	f894 5061 	ldrb.w	r5, [r4, #97]	; 0x61
	rv = rv << 8 | ptr[0];
 8014938:	f894 0060 	ldrb.w	r0, [r4, #96]	; 0x60
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 801493c:	0089      	lsls	r1, r1, #2
	rv = rv << 8 | ptr[1];
 801493e:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8014942:	f201 12ff 	addw	r2, r1, #511	; 0x1ff
	rv = rv << 8 | ptr[0];
 8014946:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 801494a:	ebb3 2f52 	cmp.w	r3, r2, lsr #9
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 801494e:	62a0      	str	r0, [r4, #40]	; 0x28
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8014950:	d3ca      	bcc.n	80148e8 <find_volume+0x208>
	rv = rv << 8 | ptr[0];
 8014952:	f894 2065 	ldrb.w	r2, [r4, #101]	; 0x65
 8014956:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
 801495a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		fs->fsi_flag = 0x80;
 801495e:	2180      	movs	r1, #128	; 0x80
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8014960:	f04f 32ff 	mov.w	r2, #4294967295
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 8014964:	2b01      	cmp	r3, #1
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8014966:	e9c4 2204 	strd	r2, r2, [r4, #16]
		fs->fsi_flag = 0x80;
 801496a:	7121      	strb	r1, [r4, #4]
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 801496c:	d00e      	beq.n	801498c <find_volume+0x2ac>
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 801496e:	2203      	movs	r2, #3
 8014970:	e77e      	b.n	8014870 <find_volume+0x190>
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8014972:	f8c4 c018 	str.w	ip, [r4, #24]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8014976:	e9c4 6008 	strd	r6, r0, [r4, #32]
		fs->database = bsect + sysect;					/* Data start sector */
 801497a:	62e2      	str	r2, [r4, #44]	; 0x2c
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 801497c:	2d00      	cmp	r5, #0
 801497e:	d0b3      	beq.n	80148e8 <find_volume+0x208>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 8014980:	4440      	add	r0, r8
 8014982:	62a0      	str	r0, [r4, #40]	; 0x28
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8014984:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 8014988:	2202      	movs	r2, #2
 801498a:	e766      	b.n	801485a <find_volume+0x17a>
	if (sector != fs->winsect) {	/* Window offset changed? */
 801498c:	6b23      	ldr	r3, [r4, #48]	; 0x30
			&& move_window(fs, bsect + 1) == FR_OK)
 801498e:	1c71      	adds	r1, r6, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014990:	4299      	cmp	r1, r3
 8014992:	d004      	beq.n	801499e <find_volume+0x2be>
 8014994:	4620      	mov	r0, r4
 8014996:	f7ff fe3d 	bl	8014614 <move_window.part.5>
			&& move_window(fs, bsect + 1) == FR_OK)
 801499a:	2800      	cmp	r0, #0
 801499c:	d1e7      	bne.n	801496e <find_volume+0x28e>
	rv = rv << 8 | ptr[0];
 801499e:	f894 2233 	ldrb.w	r2, [r4, #563]	; 0x233
 80149a2:	f894 3232 	ldrb.w	r3, [r4, #562]	; 0x232
 80149a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 80149aa:	f64a 2255 	movw	r2, #43605	; 0xaa55
			fs->fsi_flag = 0;
 80149ae:	2100      	movs	r1, #0
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 80149b0:	4293      	cmp	r3, r2
			fs->fsi_flag = 0;
 80149b2:	7121      	strb	r1, [r4, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 80149b4:	d1db      	bne.n	801496e <find_volume+0x28e>
	rv = rv << 8 | ptr[2];
 80149b6:	8ee0      	ldrh	r0, [r4, #54]	; 0x36
	rv = rv << 8 | ptr[1];
 80149b8:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
	rv = rv << 8 | ptr[0];
 80149bc:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 80149c0:	4918      	ldr	r1, [pc, #96]	; (8014a24 <find_volume+0x344>)
	rv = rv << 8 | ptr[1];
 80149c2:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	rv = rv << 8 | ptr[0];
 80149c6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 80149ca:	428b      	cmp	r3, r1
 80149cc:	d1cf      	bne.n	801496e <find_volume+0x28e>
	rv = rv << 8 | ptr[2];
 80149ce:	f8b4 021a 	ldrh.w	r0, [r4, #538]	; 0x21a
	rv = rv << 8 | ptr[1];
 80149d2:	f894 2219 	ldrb.w	r2, [r4, #537]	; 0x219
	rv = rv << 8 | ptr[0];
 80149d6:	f894 3218 	ldrb.w	r3, [r4, #536]	; 0x218
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 80149da:	f101 51ff 	add.w	r1, r1, #534773760	; 0x1fe00000
 80149de:	f501 5100 	add.w	r1, r1, #8192	; 0x2000
	rv = rv << 8 | ptr[1];
 80149e2:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 80149e6:	3120      	adds	r1, #32
	rv = rv << 8 | ptr[0];
 80149e8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 80149ec:	428b      	cmp	r3, r1
 80149ee:	d1be      	bne.n	801496e <find_volume+0x28e>
	rv = rv << 8 | ptr[1];
 80149f0:	f894 3221 	ldrb.w	r3, [r4, #545]	; 0x221
	rv = rv << 8 | ptr[2];
 80149f4:	f8b4 1222 	ldrh.w	r1, [r4, #546]	; 0x222
 80149f8:	f8b4 521e 	ldrh.w	r5, [r4, #542]	; 0x21e
	rv = rv << 8 | ptr[1];
 80149fc:	f894 021d 	ldrb.w	r0, [r4, #541]	; 0x21d
	rv = rv << 8 | ptr[0];
 8014a00:	f894 221c 	ldrb.w	r2, [r4, #540]	; 0x21c
	rv = rv << 8 | ptr[1];
 8014a04:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 8014a08:	f894 3220 	ldrb.w	r3, [r4, #544]	; 0x220
	rv = rv << 8 | ptr[1];
 8014a0c:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
	rv = rv << 8 | ptr[0];
 8014a10:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8014a14:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 8014a18:	e9c4 3204 	strd	r3, r2, [r4, #16]
 8014a1c:	e7a7      	b.n	801496e <find_volume+0x28e>
 8014a1e:	bf00      	nop
 8014a20:	2000b690 	.word	0x2000b690
 8014a24:	41615252 	.word	0x41615252

08014a28 <put_fat.part.7>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 8014a28:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		switch (fs->fs_type) {
 8014a2c:	7803      	ldrb	r3, [r0, #0]
 8014a2e:	2b02      	cmp	r3, #2
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 8014a30:	4604      	mov	r4, r0
 8014a32:	460d      	mov	r5, r1
 8014a34:	4616      	mov	r6, r2
		switch (fs->fs_type) {
 8014a36:	d058      	beq.n	8014aea <put_fat.part.7+0xc2>
 8014a38:	2b03      	cmp	r3, #3
 8014a3a:	d037      	beq.n	8014aac <put_fat.part.7+0x84>
 8014a3c:	2b01      	cmp	r3, #1
 8014a3e:	d002      	beq.n	8014a46 <put_fat.part.7+0x1e>
	FRESULT res = FR_INT_ERR;
 8014a40:	2002      	movs	r0, #2
}
 8014a42:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8014a46:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014a48:	6b03      	ldr	r3, [r0, #48]	; 0x30
			bc = (UINT)clst; bc += bc / 2;
 8014a4a:	eb05 0755 	add.w	r7, r5, r5, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8014a4e:	eb01 2157 	add.w	r1, r1, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014a52:	4299      	cmp	r1, r3
 8014a54:	d162      	bne.n	8014b1c <put_fat.part.7+0xf4>
			p = fs->win + bc++ % SS(fs);
 8014a56:	f107 0801 	add.w	r8, r7, #1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8014a5a:	07eb      	lsls	r3, r5, #31
			p = fs->win + bc++ % SS(fs);
 8014a5c:	f3c7 0708 	ubfx	r7, r7, #0, #9
 8014a60:	ea4f 2158 	mov.w	r1, r8, lsr #9
 8014a64:	f104 0934 	add.w	r9, r4, #52	; 0x34
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8014a68:	d562      	bpl.n	8014b30 <put_fat.part.7+0x108>
 8014a6a:	f819 3007 	ldrb.w	r3, [r9, r7]
 8014a6e:	f003 030f 	and.w	r3, r3, #15
 8014a72:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
 8014a76:	f809 3007 	strb.w	r3, [r9, r7]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8014a7a:	6a62      	ldr	r2, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014a7c:	6b23      	ldr	r3, [r4, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8014a7e:	4411      	add	r1, r2
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014a80:	4299      	cmp	r1, r3
			fs->wflag = 1;
 8014a82:	f04f 0201 	mov.w	r2, #1
 8014a86:	70e2      	strb	r2, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014a88:	d004      	beq.n	8014a94 <put_fat.part.7+0x6c>
 8014a8a:	4620      	mov	r0, r4
 8014a8c:	f7ff fdc2 	bl	8014614 <move_window.part.5>
			if (res != FR_OK) break;
 8014a90:	2800      	cmp	r0, #0
 8014a92:	d1d6      	bne.n	8014a42 <put_fat.part.7+0x1a>
			p = fs->win + bc % SS(fs);
 8014a94:	f3c8 0808 	ubfx	r8, r8, #0, #9
 8014a98:	44c8      	add	r8, r9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8014a9a:	f3c6 1607 	ubfx	r6, r6, #4, #8
			fs->wflag = 1;
 8014a9e:	2301      	movs	r3, #1
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8014aa0:	f888 6000 	strb.w	r6, [r8]
			fs->wflag = 1;
 8014aa4:	70e3      	strb	r3, [r4, #3]
 8014aa6:	2000      	movs	r0, #0
}
 8014aa8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8014aac:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014aae:	6b03      	ldr	r3, [r0, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8014ab0:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014ab4:	4299      	cmp	r1, r3
 8014ab6:	d136      	bne.n	8014b26 <put_fat.part.7+0xfe>
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 8014ab8:	00ad      	lsls	r5, r5, #2
 8014aba:	f104 0134 	add.w	r1, r4, #52	; 0x34
 8014abe:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
 8014ac2:	194b      	adds	r3, r1, r5
 8014ac4:	f026 4670 	bic.w	r6, r6, #4026531840	; 0xf0000000
	rv = rv << 8 | ptr[2];
 8014ac8:	885a      	ldrh	r2, [r3, #2]
	rv = rv << 8 | ptr[0];
 8014aca:	0412      	lsls	r2, r2, #16
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 8014acc:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 8014ad0:	4332      	orrs	r2, r6
	*ptr++ = (BYTE)val; val >>= 8;
 8014ad2:	554a      	strb	r2, [r1, r5]
 8014ad4:	0a16      	lsrs	r6, r2, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8014ad6:	0c10      	lsrs	r0, r2, #16
			fs->wflag = 1;
 8014ad8:	2101      	movs	r1, #1
	*ptr++ = (BYTE)val; val >>= 8;
 8014ada:	0e12      	lsrs	r2, r2, #24
 8014adc:	7098      	strb	r0, [r3, #2]
	*ptr++ = (BYTE)val; val >>= 8;
 8014ade:	705e      	strb	r6, [r3, #1]
	*ptr++ = (BYTE)val;
 8014ae0:	70da      	strb	r2, [r3, #3]
			fs->wflag = 1;
 8014ae2:	70e1      	strb	r1, [r4, #3]
 8014ae4:	2000      	movs	r0, #0
}
 8014ae6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8014aea:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014aec:	6b03      	ldr	r3, [r0, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8014aee:	eb01 2115 	add.w	r1, r1, r5, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014af2:	4299      	cmp	r1, r3
 8014af4:	d003      	beq.n	8014afe <put_fat.part.7+0xd6>
 8014af6:	f7ff fd8d 	bl	8014614 <move_window.part.5>
			if (res != FR_OK) break;
 8014afa:	2800      	cmp	r0, #0
 8014afc:	d1a1      	bne.n	8014a42 <put_fat.part.7+0x1a>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
 8014afe:	006d      	lsls	r5, r5, #1
 8014b00:	f104 0334 	add.w	r3, r4, #52	; 0x34
 8014b04:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
 8014b08:	195a      	adds	r2, r3, r5
	*ptr++ = (BYTE)val; val >>= 8;
 8014b0a:	555e      	strb	r6, [r3, r5]
 8014b0c:	f3c6 2107 	ubfx	r1, r6, #8, #8
			fs->wflag = 1;
 8014b10:	2301      	movs	r3, #1
	*ptr++ = (BYTE)val;
 8014b12:	7051      	strb	r1, [r2, #1]
			fs->wflag = 1;
 8014b14:	70e3      	strb	r3, [r4, #3]
 8014b16:	2000      	movs	r0, #0
}
 8014b18:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8014b1c:	f7ff fd7a 	bl	8014614 <move_window.part.5>
			if (res != FR_OK) break;
 8014b20:	2800      	cmp	r0, #0
 8014b22:	d098      	beq.n	8014a56 <put_fat.part.7+0x2e>
 8014b24:	e78d      	b.n	8014a42 <put_fat.part.7+0x1a>
 8014b26:	f7ff fd75 	bl	8014614 <move_window.part.5>
			if (res != FR_OK) break;
 8014b2a:	2800      	cmp	r0, #0
 8014b2c:	d0c4      	beq.n	8014ab8 <put_fat.part.7+0x90>
 8014b2e:	e788      	b.n	8014a42 <put_fat.part.7+0x1a>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8014b30:	f809 6007 	strb.w	r6, [r9, r7]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8014b34:	6a62      	ldr	r2, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014b36:	6b23      	ldr	r3, [r4, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8014b38:	4411      	add	r1, r2
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014b3a:	4299      	cmp	r1, r3
			fs->wflag = 1;
 8014b3c:	f04f 0201 	mov.w	r2, #1
 8014b40:	70e2      	strb	r2, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014b42:	d10a      	bne.n	8014b5a <put_fat.part.7+0x132>
			p = fs->win + bc % SS(fs);
 8014b44:	f3c8 0808 	ubfx	r8, r8, #0, #9
 8014b48:	44c8      	add	r8, r9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8014b4a:	f3c6 2203 	ubfx	r2, r6, #8, #4
 8014b4e:	f898 3000 	ldrb.w	r3, [r8]
 8014b52:	f023 060f 	bic.w	r6, r3, #15
 8014b56:	4316      	orrs	r6, r2
 8014b58:	e7a1      	b.n	8014a9e <put_fat.part.7+0x76>
 8014b5a:	4620      	mov	r0, r4
 8014b5c:	f7ff fd5a 	bl	8014614 <move_window.part.5>
			if (res != FR_OK) break;
 8014b60:	2800      	cmp	r0, #0
 8014b62:	f47f af6e 	bne.w	8014a42 <put_fat.part.7+0x1a>
 8014b66:	e7ed      	b.n	8014b44 <put_fat.part.7+0x11c>

08014b68 <get_fat.isra.8>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8014b68:	2901      	cmp	r1, #1
 8014b6a:	d92c      	bls.n	8014bc6 <get_fat.isra.8+0x5e>
 8014b6c:	6982      	ldr	r2, [r0, #24]
 8014b6e:	4291      	cmp	r1, r2
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
 8014b70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014b72:	4606      	mov	r6, r0
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8014b74:	d225      	bcs.n	8014bc2 <get_fat.isra.8+0x5a>
		switch (fs->fs_type) {
 8014b76:	7803      	ldrb	r3, [r0, #0]
 8014b78:	2b02      	cmp	r3, #2
 8014b7a:	460c      	mov	r4, r1
 8014b7c:	d03b      	beq.n	8014bf6 <get_fat.isra.8+0x8e>
 8014b7e:	2b03      	cmp	r3, #3
 8014b80:	d023      	beq.n	8014bca <get_fat.isra.8+0x62>
 8014b82:	2b01      	cmp	r3, #1
 8014b84:	d11d      	bne.n	8014bc2 <get_fat.isra.8+0x5a>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8014b86:	6a43      	ldr	r3, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014b88:	f8d0 c030 	ldr.w	ip, [r0, #48]	; 0x30
			bc = (UINT)clst; bc += bc / 2;
 8014b8c:	eb01 0751 	add.w	r7, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8014b90:	eb03 2157 	add.w	r1, r3, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014b94:	4561      	cmp	r1, ip
 8014b96:	d14a      	bne.n	8014c2e <get_fat.isra.8+0xc6>
			wc = fs->win[bc++ % SS(fs)];
 8014b98:	f3c7 0208 	ubfx	r2, r7, #0, #9
 8014b9c:	3701      	adds	r7, #1
 8014b9e:	4432      	add	r2, r6
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8014ba0:	eb03 2157 	add.w	r1, r3, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014ba4:	4561      	cmp	r1, ip
			wc = fs->win[bc++ % SS(fs)];
 8014ba6:	f892 5034 	ldrb.w	r5, [r2, #52]	; 0x34
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014baa:	d148      	bne.n	8014c3e <get_fat.isra.8+0xd6>
			wc |= fs->win[bc % SS(fs)] << 8;
 8014bac:	f3c7 0308 	ubfx	r3, r7, #0, #9
 8014bb0:	4433      	add	r3, r6
 8014bb2:	f893 0034 	ldrb.w	r0, [r3, #52]	; 0x34
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8014bb6:	07e3      	lsls	r3, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 8014bb8:	ea45 2000 	orr.w	r0, r5, r0, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8014bbc:	d545      	bpl.n	8014c4a <get_fat.isra.8+0xe2>
 8014bbe:	0900      	lsrs	r0, r0, #4
}
 8014bc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			val = 1;	/* Internal error */
 8014bc2:	2001      	movs	r0, #1
}
 8014bc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		val = 1;	/* Internal error */
 8014bc6:	2001      	movs	r0, #1
}
 8014bc8:	4770      	bx	lr
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8014bca:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014bcc:	6b03      	ldr	r3, [r0, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8014bce:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014bd2:	4299      	cmp	r1, r3
 8014bd4:	d126      	bne.n	8014c24 <get_fat.isra.8+0xbc>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8014bd6:	00a1      	lsls	r1, r4, #2
 8014bd8:	f106 0334 	add.w	r3, r6, #52	; 0x34
 8014bdc:	f401 71fe 	and.w	r1, r1, #508	; 0x1fc
 8014be0:	185a      	adds	r2, r3, r1
	rv = rv << 8 | ptr[0];
 8014be2:	5c58      	ldrb	r0, [r3, r1]
	rv = rv << 8 | ptr[2];
 8014be4:	8851      	ldrh	r1, [r2, #2]
	rv = rv << 8 | ptr[1];
 8014be6:	7853      	ldrb	r3, [r2, #1]
 8014be8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 8014bec:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8014bf0:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
}
 8014bf4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8014bf6:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014bf8:	6b03      	ldr	r3, [r0, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8014bfa:	eb01 2114 	add.w	r1, r1, r4, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014bfe:	4299      	cmp	r1, r3
 8014c00:	d005      	beq.n	8014c0e <get_fat.isra.8+0xa6>
 8014c02:	f7ff fd07 	bl	8014614 <move_window.part.5>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8014c06:	b110      	cbz	r0, 8014c0e <get_fat.isra.8+0xa6>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 8014c08:	f04f 30ff 	mov.w	r0, #4294967295
}
 8014c0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8014c0e:	0061      	lsls	r1, r4, #1
 8014c10:	f106 0334 	add.w	r3, r6, #52	; 0x34
 8014c14:	f401 71ff 	and.w	r1, r1, #510	; 0x1fe
 8014c18:	185a      	adds	r2, r3, r1
	rv = rv << 8 | ptr[0];
 8014c1a:	5c58      	ldrb	r0, [r3, r1]
 8014c1c:	7853      	ldrb	r3, [r2, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8014c1e:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
}
 8014c22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8014c24:	f7ff fcf6 	bl	8014614 <move_window.part.5>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8014c28:	2800      	cmp	r0, #0
 8014c2a:	d0d4      	beq.n	8014bd6 <get_fat.isra.8+0x6e>
 8014c2c:	e7ec      	b.n	8014c08 <get_fat.isra.8+0xa0>
 8014c2e:	f7ff fcf1 	bl	8014614 <move_window.part.5>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8014c32:	2800      	cmp	r0, #0
 8014c34:	d1e8      	bne.n	8014c08 <get_fat.isra.8+0xa0>
 8014c36:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8014c38:	f8d6 c030 	ldr.w	ip, [r6, #48]	; 0x30
 8014c3c:	e7ac      	b.n	8014b98 <get_fat.isra.8+0x30>
 8014c3e:	4630      	mov	r0, r6
 8014c40:	f7ff fce8 	bl	8014614 <move_window.part.5>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8014c44:	2800      	cmp	r0, #0
 8014c46:	d0b1      	beq.n	8014bac <get_fat.isra.8+0x44>
 8014c48:	e7de      	b.n	8014c08 <get_fat.isra.8+0xa0>
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8014c4a:	f3c0 000b 	ubfx	r0, r0, #0, #12
}
 8014c4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08014c50 <dir_sdi>:
	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 8014c50:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8014c54:	d229      	bcs.n	8014caa <dir_sdi+0x5a>
 8014c56:	06ca      	lsls	r2, r1, #27
{
 8014c58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014c5a:	460c      	mov	r4, r1
	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 8014c5c:	d123      	bne.n	8014ca6 <dir_sdi+0x56>
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 8014c5e:	6881      	ldr	r1, [r0, #8]
	dp->dptr = ofs;				/* Set current offset */
 8014c60:	6144      	str	r4, [r0, #20]
 8014c62:	4605      	mov	r5, r0
	FATFS *fs = dp->obj.fs;
 8014c64:	6806      	ldr	r6, [r0, #0]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 8014c66:	bb19      	cbnz	r1, 8014cb0 <dir_sdi+0x60>
 8014c68:	7833      	ldrb	r3, [r6, #0]
 8014c6a:	2b02      	cmp	r3, #2
 8014c6c:	d901      	bls.n	8014c72 <dir_sdi+0x22>
		clst = fs->dirbase;
 8014c6e:	6ab3      	ldr	r3, [r6, #40]	; 0x28
	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 8014c70:	b9eb      	cbnz	r3, 8014cae <dir_sdi+0x5e>
		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
 8014c72:	8933      	ldrh	r3, [r6, #8]
 8014c74:	ebb3 1f54 	cmp.w	r3, r4, lsr #5
 8014c78:	d915      	bls.n	8014ca6 <dir_sdi+0x56>
		dp->sect = fs->dirbase;
 8014c7a:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8014c7c:	61eb      	str	r3, [r5, #28]
	dp->clust = clst;					/* Current cluster# */
 8014c7e:	61a9      	str	r1, [r5, #24]
	if (!dp->sect) return FR_INT_ERR;
 8014c80:	b18b      	cbz	r3, 8014ca6 <dir_sdi+0x56>
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 8014c82:	f3c4 0208 	ubfx	r2, r4, #0, #9
 8014c86:	3634      	adds	r6, #52	; 0x34
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 8014c88:	eb03 2454 	add.w	r4, r3, r4, lsr #9
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 8014c8c:	4416      	add	r6, r2
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 8014c8e:	e9c5 4607 	strd	r4, r6, [r5, #28]
	return FR_OK;
 8014c92:	2000      	movs	r0, #0
}
 8014c94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8014c96:	69b3      	ldr	r3, [r6, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8014c98:	3b02      	subs	r3, #2
	clst -= 2;
 8014c9a:	1e8a      	subs	r2, r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8014c9c:	429a      	cmp	r2, r3
 8014c9e:	d31e      	bcc.n	8014cde <dir_sdi+0x8e>
		dp->sect = clust2sect(fs, clst);
 8014ca0:	2300      	movs	r3, #0
 8014ca2:	e9c5 1306 	strd	r1, r3, [r5, #24]
		return FR_INT_ERR;
 8014ca6:	2002      	movs	r0, #2
}
 8014ca8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return FR_INT_ERR;
 8014caa:	2002      	movs	r0, #2
}
 8014cac:	4770      	bx	lr
 8014cae:	4619      	mov	r1, r3
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 8014cb0:	8977      	ldrh	r7, [r6, #10]
 8014cb2:	027f      	lsls	r7, r7, #9
		while (ofs >= csz) {				/* Follow cluster chain */
 8014cb4:	42bc      	cmp	r4, r7
 8014cb6:	d3ee      	bcc.n	8014c96 <dir_sdi+0x46>
 8014cb8:	4630      	mov	r0, r6
 8014cba:	e007      	b.n	8014ccc <dir_sdi+0x7c>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 8014cbc:	2801      	cmp	r0, #1
 8014cbe:	d9f2      	bls.n	8014ca6 <dir_sdi+0x56>
 8014cc0:	69b3      	ldr	r3, [r6, #24]
 8014cc2:	4283      	cmp	r3, r0
 8014cc4:	d9ef      	bls.n	8014ca6 <dir_sdi+0x56>
		while (ofs >= csz) {				/* Follow cluster chain */
 8014cc6:	42a7      	cmp	r7, r4
 8014cc8:	d8e6      	bhi.n	8014c98 <dir_sdi+0x48>
 8014cca:	6828      	ldr	r0, [r5, #0]
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 8014ccc:	f7ff ff4c 	bl	8014b68 <get_fat.isra.8>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8014cd0:	1c43      	adds	r3, r0, #1
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 8014cd2:	4601      	mov	r1, r0
			ofs -= csz;
 8014cd4:	eba4 0407 	sub.w	r4, r4, r7
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8014cd8:	d1f0      	bne.n	8014cbc <dir_sdi+0x6c>
 8014cda:	2001      	movs	r0, #1
}
 8014cdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return clst * fs->csize + fs->database;
 8014cde:	8973      	ldrh	r3, [r6, #10]
 8014ce0:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 8014ce2:	fb02 0303 	mla	r3, r2, r3, r0
		dp->sect = clust2sect(fs, clst);
 8014ce6:	61eb      	str	r3, [r5, #28]
 8014ce8:	e7c9      	b.n	8014c7e <dir_sdi+0x2e>
 8014cea:	bf00      	nop

08014cec <create_chain>:
{
 8014cec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8014cf0:	4607      	mov	r7, r0
	if (clst == 0) {	/* Create a new chain */
 8014cf2:	4688      	mov	r8, r1
	FATFS *fs = obj->fs;
 8014cf4:	6806      	ldr	r6, [r0, #0]
	if (clst == 0) {	/* Create a new chain */
 8014cf6:	bb29      	cbnz	r1, 8014d44 <create_chain+0x58>
		scl = fs->last_clst;				/* Get suggested cluster to start from */
 8014cf8:	6935      	ldr	r5, [r6, #16]
 8014cfa:	69b3      	ldr	r3, [r6, #24]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8014cfc:	b9f5      	cbnz	r5, 8014d3c <create_chain+0x50>
 8014cfe:	2501      	movs	r5, #1
 8014d00:	462c      	mov	r4, r5
 8014d02:	e006      	b.n	8014d12 <create_chain+0x26>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
 8014d04:	2801      	cmp	r0, #1
 8014d06:	d015      	beq.n	8014d34 <create_chain+0x48>
 8014d08:	3001      	adds	r0, #1
 8014d0a:	d031      	beq.n	8014d70 <create_chain+0x84>
			if (ncl == scl) return 0;		/* No free cluster */
 8014d0c:	42ac      	cmp	r4, r5
 8014d0e:	d034      	beq.n	8014d7a <create_chain+0x8e>
 8014d10:	69b3      	ldr	r3, [r6, #24]
			ncl++;							/* Next cluster */
 8014d12:	3401      	adds	r4, #1
			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 8014d14:	429c      	cmp	r4, r3
 8014d16:	d302      	bcc.n	8014d1e <create_chain+0x32>
				if (ncl > scl) return 0;	/* No free cluster */
 8014d18:	2d01      	cmp	r5, #1
 8014d1a:	d92e      	bls.n	8014d7a <create_chain+0x8e>
				ncl = 2;
 8014d1c:	2402      	movs	r4, #2
			cs = get_fat(obj, ncl);			/* Get the cluster status */
 8014d1e:	4621      	mov	r1, r4
 8014d20:	6838      	ldr	r0, [r7, #0]
 8014d22:	f7ff ff21 	bl	8014b68 <get_fat.isra.8>
			if (cs == 0) break;				/* Found a free cluster */
 8014d26:	2800      	cmp	r0, #0
 8014d28:	d1ec      	bne.n	8014d04 <create_chain+0x18>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8014d2a:	2c01      	cmp	r4, #1
 8014d2c:	d902      	bls.n	8014d34 <create_chain+0x48>
 8014d2e:	69b3      	ldr	r3, [r6, #24]
 8014d30:	429c      	cmp	r4, r3
 8014d32:	d314      	bcc.n	8014d5e <create_chain+0x72>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 8014d34:	2401      	movs	r4, #1
}
 8014d36:	4620      	mov	r0, r4
 8014d38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8014d3c:	429d      	cmp	r5, r3
 8014d3e:	bf28      	it	cs
 8014d40:	2501      	movcs	r5, #1
 8014d42:	e7dd      	b.n	8014d00 <create_chain+0x14>
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8014d44:	4630      	mov	r0, r6
 8014d46:	f7ff ff0f 	bl	8014b68 <get_fat.isra.8>
		if (cs < 2) return 1;				/* Invalid FAT value */
 8014d4a:	2801      	cmp	r0, #1
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8014d4c:	4604      	mov	r4, r0
		if (cs < 2) return 1;				/* Invalid FAT value */
 8014d4e:	d9f1      	bls.n	8014d34 <create_chain+0x48>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 8014d50:	1c43      	adds	r3, r0, #1
 8014d52:	d00d      	beq.n	8014d70 <create_chain+0x84>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 8014d54:	69b3      	ldr	r3, [r6, #24]
 8014d56:	4283      	cmp	r3, r0
 8014d58:	d8ed      	bhi.n	8014d36 <create_chain+0x4a>
 8014d5a:	4645      	mov	r5, r8
 8014d5c:	e7d0      	b.n	8014d00 <create_chain+0x14>
 8014d5e:	f04f 32ff 	mov.w	r2, #4294967295
 8014d62:	4621      	mov	r1, r4
 8014d64:	4630      	mov	r0, r6
 8014d66:	f7ff fe5f 	bl	8014a28 <put_fat.part.7>
		if (res == FR_OK && clst != 0) {
 8014d6a:	b150      	cbz	r0, 8014d82 <create_chain+0x96>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 8014d6c:	2801      	cmp	r0, #1
 8014d6e:	d1e1      	bne.n	8014d34 <create_chain+0x48>
				ncl = 2;
 8014d70:	f04f 34ff 	mov.w	r4, #4294967295
}
 8014d74:	4620      	mov	r0, r4
 8014d76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if (ncl > scl) return 0;	/* No free cluster */
 8014d7a:	2400      	movs	r4, #0
}
 8014d7c:	4620      	mov	r0, r4
 8014d7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (res == FR_OK && clst != 0) {
 8014d82:	f1b8 0f00 	cmp.w	r8, #0
 8014d86:	d00c      	beq.n	8014da2 <create_chain+0xb6>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8014d88:	f1b8 0f01 	cmp.w	r8, #1
 8014d8c:	d9d2      	bls.n	8014d34 <create_chain+0x48>
 8014d8e:	69b3      	ldr	r3, [r6, #24]
 8014d90:	4598      	cmp	r8, r3
 8014d92:	d2cf      	bcs.n	8014d34 <create_chain+0x48>
 8014d94:	4641      	mov	r1, r8
 8014d96:	4622      	mov	r2, r4
 8014d98:	4630      	mov	r0, r6
 8014d9a:	f7ff fe45 	bl	8014a28 <put_fat.part.7>
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 8014d9e:	2800      	cmp	r0, #0
 8014da0:	d1e4      	bne.n	8014d6c <create_chain+0x80>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 8014da2:	e9d6 2305 	ldrd	r2, r3, [r6, #20]
 8014da6:	3b02      	subs	r3, #2
 8014da8:	429a      	cmp	r2, r3
		fs->last_clst = ncl;
 8014daa:	6134      	str	r4, [r6, #16]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 8014dac:	d801      	bhi.n	8014db2 <create_chain+0xc6>
 8014dae:	3a01      	subs	r2, #1
 8014db0:	6172      	str	r2, [r6, #20]
		fs->fsi_flag |= 1;
 8014db2:	7933      	ldrb	r3, [r6, #4]
 8014db4:	f043 0301 	orr.w	r3, r3, #1
 8014db8:	7133      	strb	r3, [r6, #4]
 8014dba:	e7bc      	b.n	8014d36 <create_chain+0x4a>

08014dbc <remove_chain>:
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8014dbc:	2901      	cmp	r1, #1
 8014dbe:	d93f      	bls.n	8014e40 <remove_chain+0x84>
{
 8014dc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	FATFS *fs = obj->fs;
 8014dc2:	6805      	ldr	r5, [r0, #0]
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8014dc4:	69ab      	ldr	r3, [r5, #24]
 8014dc6:	428b      	cmp	r3, r1
 8014dc8:	460c      	mov	r4, r1
 8014dca:	4607      	mov	r7, r0
 8014dcc:	d92c      	bls.n	8014e28 <remove_chain+0x6c>
	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 8014dce:	bb3a      	cbnz	r2, 8014e20 <remove_chain+0x64>
 8014dd0:	4628      	mov	r0, r5
 8014dd2:	e01b      	b.n	8014e0c <remove_chain+0x50>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 8014dd4:	2e01      	cmp	r6, #1
 8014dd6:	4628      	mov	r0, r5
 8014dd8:	d026      	beq.n	8014e28 <remove_chain+0x6c>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 8014dda:	1c73      	adds	r3, r6, #1
 8014ddc:	d032      	beq.n	8014e44 <remove_chain+0x88>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8014dde:	2c01      	cmp	r4, #1
 8014de0:	d922      	bls.n	8014e28 <remove_chain+0x6c>
 8014de2:	69ab      	ldr	r3, [r5, #24]
 8014de4:	429c      	cmp	r4, r3
 8014de6:	d21f      	bcs.n	8014e28 <remove_chain+0x6c>
 8014de8:	f7ff fe1e 	bl	8014a28 <put_fat.part.7>
			if (res != FR_OK) return res;
 8014dec:	b9b8      	cbnz	r0, 8014e1e <remove_chain+0x62>
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 8014dee:	e9d5 3205 	ldrd	r3, r2, [r5, #20]
 8014df2:	1e91      	subs	r1, r2, #2
 8014df4:	428b      	cmp	r3, r1
 8014df6:	d205      	bcs.n	8014e04 <remove_chain+0x48>
			fs->fsi_flag |= 1;
 8014df8:	7929      	ldrb	r1, [r5, #4]
			fs->free_clst++;
 8014dfa:	3301      	adds	r3, #1
			fs->fsi_flag |= 1;
 8014dfc:	f041 0101 	orr.w	r1, r1, #1
			fs->free_clst++;
 8014e00:	616b      	str	r3, [r5, #20]
			fs->fsi_flag |= 1;
 8014e02:	7129      	strb	r1, [r5, #4]
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 8014e04:	42b2      	cmp	r2, r6
 8014e06:	d909      	bls.n	8014e1c <remove_chain+0x60>
 8014e08:	6838      	ldr	r0, [r7, #0]
 8014e0a:	4634      	mov	r4, r6
		nxt = get_fat(obj, clst);			/* Get cluster status */
 8014e0c:	4621      	mov	r1, r4
 8014e0e:	f7ff feab 	bl	8014b68 <get_fat.isra.8>
 8014e12:	4621      	mov	r1, r4
		if (nxt == 0) break;				/* Empty cluster? */
 8014e14:	4606      	mov	r6, r0
 8014e16:	2200      	movs	r2, #0
 8014e18:	2800      	cmp	r0, #0
 8014e1a:	d1db      	bne.n	8014dd4 <remove_chain+0x18>
	return FR_OK;
 8014e1c:	2000      	movs	r0, #0
}
 8014e1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8014e20:	2a01      	cmp	r2, #1
 8014e22:	d901      	bls.n	8014e28 <remove_chain+0x6c>
 8014e24:	4293      	cmp	r3, r2
 8014e26:	d801      	bhi.n	8014e2c <remove_chain+0x70>
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8014e28:	2002      	movs	r0, #2
}
 8014e2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8014e2c:	4611      	mov	r1, r2
 8014e2e:	4628      	mov	r0, r5
 8014e30:	f04f 32ff 	mov.w	r2, #4294967295
 8014e34:	f7ff fdf8 	bl	8014a28 <put_fat.part.7>
		if (res != FR_OK) return res;
 8014e38:	2800      	cmp	r0, #0
 8014e3a:	d1f0      	bne.n	8014e1e <remove_chain+0x62>
 8014e3c:	6838      	ldr	r0, [r7, #0]
 8014e3e:	e7e5      	b.n	8014e0c <remove_chain+0x50>
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8014e40:	2002      	movs	r0, #2
}
 8014e42:	4770      	bx	lr
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 8014e44:	2001      	movs	r0, #1
}
 8014e46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08014e48 <dir_next>:
{
 8014e48:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 8014e4c:	69c3      	ldr	r3, [r0, #28]
 8014e4e:	b1f3      	cbz	r3, 8014e8e <dir_next+0x46>
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 8014e50:	6945      	ldr	r5, [r0, #20]
 8014e52:	3520      	adds	r5, #32
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 8014e54:	f5b5 1f00 	cmp.w	r5, #2097152	; 0x200000
 8014e58:	d219      	bcs.n	8014e8e <dir_next+0x46>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8014e5a:	f3c5 0808 	ubfx	r8, r5, #0, #9
 8014e5e:	460f      	mov	r7, r1
 8014e60:	4604      	mov	r4, r0
	FATFS *fs = dp->obj.fs;
 8014e62:	f8d0 9000 	ldr.w	r9, [r0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8014e66:	f1b8 0f00 	cmp.w	r8, #0
 8014e6a:	d108      	bne.n	8014e7e <dir_next+0x36>
		if (!dp->clust) {		/* Static table */
 8014e6c:	6981      	ldr	r1, [r0, #24]
		dp->sect++;				/* Next sector */
 8014e6e:	3301      	adds	r3, #1
 8014e70:	61c3      	str	r3, [r0, #28]
		if (!dp->clust) {		/* Static table */
 8014e72:	b979      	cbnz	r1, 8014e94 <dir_next+0x4c>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 8014e74:	f8b9 3008 	ldrh.w	r3, [r9, #8]
 8014e78:	ebb3 1f55 	cmp.w	r3, r5, lsr #5
 8014e7c:	d92f      	bls.n	8014ede <dir_next+0x96>
 8014e7e:	f109 0634 	add.w	r6, r9, #52	; 0x34
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 8014e82:	4446      	add	r6, r8
 8014e84:	6226      	str	r6, [r4, #32]
	dp->dptr = ofs;						/* Current entry */
 8014e86:	6165      	str	r5, [r4, #20]
	return FR_OK;
 8014e88:	2000      	movs	r0, #0
}
 8014e8a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 8014e8e:	2004      	movs	r0, #4
}
 8014e90:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 8014e94:	f8b9 300a 	ldrh.w	r3, [r9, #10]
 8014e98:	3b01      	subs	r3, #1
 8014e9a:	ea13 2355 	ands.w	r3, r3, r5, lsr #9
 8014e9e:	d1ee      	bne.n	8014e7e <dir_next+0x36>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 8014ea0:	4648      	mov	r0, r9
 8014ea2:	f7ff fe61 	bl	8014b68 <get_fat.isra.8>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8014ea6:	2801      	cmp	r0, #1
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 8014ea8:	4682      	mov	sl, r0
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8014eaa:	d967      	bls.n	8014f7c <dir_next+0x134>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 8014eac:	f1b0 3fff 	cmp.w	r0, #4294967295
 8014eb0:	d01d      	beq.n	8014eee <dir_next+0xa6>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 8014eb2:	f8d9 3018 	ldr.w	r3, [r9, #24]
 8014eb6:	4283      	cmp	r3, r0
 8014eb8:	d91b      	bls.n	8014ef2 <dir_next+0xaa>
 8014eba:	f109 0634 	add.w	r6, r9, #52	; 0x34
 8014ebe:	1e87      	subs	r7, r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8014ec0:	3b02      	subs	r3, #2
 8014ec2:	42bb      	cmp	r3, r7
	return clst * fs->csize + fs->database;
 8014ec4:	bf84      	itt	hi
 8014ec6:	f8b9 300a 	ldrhhi.w	r3, [r9, #10]
 8014eca:	f8d9 202c 	ldrhi.w	r2, [r9, #44]	; 0x2c
				dp->clust = clst;		/* Initialize data for new cluster */
 8014ece:	f8c4 a018 	str.w	sl, [r4, #24]
	return clst * fs->csize + fs->database;
 8014ed2:	bf8c      	ite	hi
 8014ed4:	fb07 2703 	mlahi	r7, r7, r3, r2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8014ed8:	2700      	movls	r7, #0
				dp->sect = clust2sect(fs, clst);
 8014eda:	61e7      	str	r7, [r4, #28]
 8014edc:	e7d1      	b.n	8014e82 <dir_next+0x3a>
				dp->sect = 0; return FR_NO_FILE;
 8014ede:	2300      	movs	r3, #0
 8014ee0:	61e3      	str	r3, [r4, #28]
 8014ee2:	2004      	movs	r0, #4
 8014ee4:	e7d4      	b.n	8014e90 <dir_next+0x48>
 8014ee6:	4648      	mov	r0, r9
 8014ee8:	f7ff fb0e 	bl	8014508 <sync_window.part.4>
					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 8014eec:	b198      	cbz	r0, 8014f16 <dir_next+0xce>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 8014eee:	2001      	movs	r0, #1
 8014ef0:	e7ce      	b.n	8014e90 <dir_next+0x48>
					if (!stretch) {								/* If no stretch, report EOT */
 8014ef2:	2f00      	cmp	r7, #0
 8014ef4:	d0f3      	beq.n	8014ede <dir_next+0x96>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 8014ef6:	69a1      	ldr	r1, [r4, #24]
 8014ef8:	4620      	mov	r0, r4
 8014efa:	f7ff fef7 	bl	8014cec <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8014efe:	4682      	mov	sl, r0
 8014f00:	2800      	cmp	r0, #0
 8014f02:	d03d      	beq.n	8014f80 <dir_next+0x138>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 8014f04:	2801      	cmp	r0, #1
 8014f06:	d039      	beq.n	8014f7c <dir_next+0x134>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8014f08:	f1b0 3fff 	cmp.w	r0, #4294967295
 8014f0c:	d0ef      	beq.n	8014eee <dir_next+0xa6>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8014f0e:	f899 3003 	ldrb.w	r3, [r9, #3]
 8014f12:	2b00      	cmp	r3, #0
 8014f14:	d1e7      	bne.n	8014ee6 <dir_next+0x9e>
					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
 8014f16:	f109 0634 	add.w	r6, r9, #52	; 0x34
	BYTE *d = (BYTE*)dst;
 8014f1a:	4633      	mov	r3, r6
 8014f1c:	f509 710d 	add.w	r1, r9, #564	; 0x234
		*d++ = (BYTE)val;
 8014f20:	2200      	movs	r2, #0
 8014f22:	f803 2b01 	strb.w	r2, [r3], #1
	} while (--cnt);
 8014f26:	4299      	cmp	r1, r3
 8014f28:	d1fb      	bne.n	8014f22 <dir_next+0xda>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8014f2a:	f8d9 3018 	ldr.w	r3, [r9, #24]
 8014f2e:	f8b9 100a 	ldrh.w	r1, [r9, #10]
 8014f32:	1e9a      	subs	r2, r3, #2
	clst -= 2;
 8014f34:	f1aa 0702 	sub.w	r7, sl, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8014f38:	4297      	cmp	r7, r2
	return clst * fs->csize + fs->database;
 8014f3a:	bf36      	itet	cc
 8014f3c:	f8d9 202c 	ldrcc.w	r2, [r9, #44]	; 0x2c
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8014f40:	2200      	movcs	r2, #0
	return clst * fs->csize + fs->database;
 8014f42:	fb07 2201 	mlacc	r2, r7, r1, r2
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 8014f46:	f8c9 2030 	str.w	r2, [r9, #48]	; 0x30
 8014f4a:	b311      	cbz	r1, 8014f92 <dir_next+0x14a>
 8014f4c:	f04f 0b00 	mov.w	fp, #0
 8014f50:	e008      	b.n	8014f64 <dir_next+0x11c>
 8014f52:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
 8014f56:	f8b9 300a 	ldrh.w	r3, [r9, #10]
 8014f5a:	3201      	adds	r2, #1
 8014f5c:	455b      	cmp	r3, fp
 8014f5e:	f8c9 2030 	str.w	r2, [r9, #48]	; 0x30
 8014f62:	d90f      	bls.n	8014f84 <dir_next+0x13c>
						fs->wflag = 1;
 8014f64:	f04f 0301 	mov.w	r3, #1
 8014f68:	f889 3003 	strb.w	r3, [r9, #3]
 8014f6c:	4648      	mov	r0, r9
 8014f6e:	f7ff facb 	bl	8014508 <sync_window.part.4>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 8014f72:	f10b 0b01 	add.w	fp, fp, #1
						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
 8014f76:	2800      	cmp	r0, #0
 8014f78:	d0eb      	beq.n	8014f52 <dir_next+0x10a>
 8014f7a:	e7b8      	b.n	8014eee <dir_next+0xa6>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8014f7c:	2002      	movs	r0, #2
 8014f7e:	e787      	b.n	8014e90 <dir_next+0x48>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8014f80:	2007      	movs	r0, #7
 8014f82:	e785      	b.n	8014e90 <dir_next+0x48>
 8014f84:	f8d9 3018 	ldr.w	r3, [r9, #24]
					fs->winsect -= n;							/* Restore window offset */
 8014f88:	eba2 020b 	sub.w	r2, r2, fp
 8014f8c:	f8c9 2030 	str.w	r2, [r9, #48]	; 0x30
 8014f90:	e796      	b.n	8014ec0 <dir_next+0x78>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 8014f92:	468b      	mov	fp, r1
 8014f94:	e7f8      	b.n	8014f88 <dir_next+0x140>
 8014f96:	bf00      	nop

08014f98 <dir_find>:
{
 8014f98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8014f9c:	2100      	movs	r1, #0
{
 8014f9e:	b087      	sub	sp, #28
 8014fa0:	4605      	mov	r5, r0
	FATFS *fs = dp->obj.fs;
 8014fa2:	6807      	ldr	r7, [r0, #0]
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8014fa4:	f7ff fe54 	bl	8014c50 <dir_sdi>
	if (res != FR_OK) return res;
 8014fa8:	4682      	mov	sl, r0
 8014faa:	2800      	cmp	r0, #0
 8014fac:	d145      	bne.n	801503a <dir_find+0xa2>
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 8014fae:	f04f 33ff 	mov.w	r3, #4294967295
 8014fb2:	f04f 0bff 	mov.w	fp, #255	; 0xff
 8014fb6:	632b      	str	r3, [r5, #48]	; 0x30
			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 8014fb8:	4698      	mov	r8, r3
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 8014fba:	46d9      	mov	r9, fp
 8014fbc:	e00b      	b.n	8014fd6 <dir_find+0x3e>
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8014fbe:	2b0f      	cmp	r3, #15
 8014fc0:	d03f      	beq.n	8015042 <dir_find+0xaa>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 8014fc2:	f8c5 8030 	str.w	r8, [r5, #48]	; 0x30
 8014fc6:	f04f 09ff 	mov.w	r9, #255	; 0xff
		res = dir_next(dp, 0);	/* Next entry */
 8014fca:	2100      	movs	r1, #0
 8014fcc:	4628      	mov	r0, r5
 8014fce:	f7ff ff3b 	bl	8014e48 <dir_next>
	} while (res == FR_OK);
 8014fd2:	2800      	cmp	r0, #0
 8014fd4:	d14c      	bne.n	8015070 <dir_find+0xd8>
		res = move_window(fs, dp->sect);
 8014fd6:	69e9      	ldr	r1, [r5, #28]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8014fd8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014fda:	4299      	cmp	r1, r3
 8014fdc:	d004      	beq.n	8014fe8 <dir_find+0x50>
 8014fde:	4638      	mov	r0, r7
 8014fe0:	f7ff fb18 	bl	8014614 <move_window.part.5>
		if (res != FR_OK) break;
 8014fe4:	2800      	cmp	r0, #0
 8014fe6:	d143      	bne.n	8015070 <dir_find+0xd8>
		c = dp->dir[DIR_Name];
 8014fe8:	6a2c      	ldr	r4, [r5, #32]
 8014fea:	7826      	ldrb	r6, [r4, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8014fec:	2e00      	cmp	r6, #0
 8014fee:	d05b      	beq.n	80150a8 <dir_find+0x110>
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 8014ff0:	7ae2      	ldrb	r2, [r4, #11]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8014ff2:	2ee5      	cmp	r6, #229	; 0xe5
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 8014ff4:	f002 033f 	and.w	r3, r2, #63	; 0x3f
 8014ff8:	71ab      	strb	r3, [r5, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8014ffa:	d0e2      	beq.n	8014fc2 <dir_find+0x2a>
 8014ffc:	0712      	lsls	r2, r2, #28
 8014ffe:	d4de      	bmi.n	8014fbe <dir_find+0x26>
			if (a == AM_LFN) {			/* An LFN entry is found */
 8015000:	2b0f      	cmp	r3, #15
 8015002:	d01e      	beq.n	8015042 <dir_find+0xaa>
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 8015004:	f1b9 0f00 	cmp.w	r9, #0
 8015008:	d037      	beq.n	801507a <dir_find+0xe2>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 801500a:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
 801500e:	07db      	lsls	r3, r3, #31
 8015010:	d4d7      	bmi.n	8014fc2 <dir_find+0x2a>
		r = *d++ - *s++;
 8015012:	4620      	mov	r0, r4
 8015014:	4629      	mov	r1, r5
 8015016:	f810 3b0b 	ldrb.w	r3, [r0], #11
 801501a:	f811 2f24 	ldrb.w	r2, [r1, #36]!
 801501e:	3401      	adds	r4, #1
 8015020:	1a9b      	subs	r3, r3, r2
	} while (--cnt && r == 0);
 8015022:	2b00      	cmp	r3, #0
 8015024:	d1cd      	bne.n	8014fc2 <dir_find+0x2a>
		r = *d++ - *s++;
 8015026:	f814 3b01 	ldrb.w	r3, [r4], #1
 801502a:	f811 2f01 	ldrb.w	r2, [r1, #1]!
	} while (--cnt && r == 0);
 801502e:	4284      	cmp	r4, r0
		r = *d++ - *s++;
 8015030:	eba3 0302 	sub.w	r3, r3, r2
	} while (--cnt && r == 0);
 8015034:	d1f5      	bne.n	8015022 <dir_find+0x8a>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 8015036:	2b00      	cmp	r3, #0
 8015038:	d1c3      	bne.n	8014fc2 <dir_find+0x2a>
}
 801503a:	4650      	mov	r0, sl
 801503c:	b007      	add	sp, #28
 801503e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
 8015042:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
 8015046:	0658      	lsls	r0, r3, #25
 8015048:	d4bf      	bmi.n	8014fca <dir_find+0x32>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 801504a:	0671      	lsls	r1, r6, #25
 801504c:	d527      	bpl.n	801509e <dir_find+0x106>
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 801504e:	696b      	ldr	r3, [r5, #20]
						sum = dp->dir[LDIR_Chksum];
 8015050:	f894 b00d 	ldrb.w	fp, [r4, #13]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 8015054:	632b      	str	r3, [r5, #48]	; 0x30
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 8015056:	f006 06bf 	and.w	r6, r6, #191	; 0xbf
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 801505a:	7b63      	ldrb	r3, [r4, #13]
 801505c:	455b      	cmp	r3, fp
 801505e:	d029      	beq.n	80150b4 <dir_find+0x11c>
 8015060:	f04f 09ff 	mov.w	r9, #255	; 0xff
		res = dir_next(dp, 0);	/* Next entry */
 8015064:	2100      	movs	r1, #0
 8015066:	4628      	mov	r0, r5
 8015068:	f7ff feee 	bl	8014e48 <dir_next>
	} while (res == FR_OK);
 801506c:	2800      	cmp	r0, #0
 801506e:	d0b2      	beq.n	8014fd6 <dir_find+0x3e>
 8015070:	4682      	mov	sl, r0
}
 8015072:	4650      	mov	r0, sl
 8015074:	b007      	add	sp, #28
 8015076:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801507a:	f104 000b 	add.w	r0, r4, #11
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 801507e:	4621      	mov	r1, r4
		sum = (sum >> 1) + (sum << 7) + *dir++;
 8015080:	f811 2b01 	ldrb.w	r2, [r1], #1
 8015084:	ea4f 13c9 	mov.w	r3, r9, lsl #7
 8015088:	ea43 0959 	orr.w	r9, r3, r9, lsr #1
 801508c:	fa52 f989 	uxtab	r9, r2, r9
	} while (--n);
 8015090:	4281      	cmp	r1, r0
		sum = (sum >> 1) + (sum << 7) + *dir++;
 8015092:	fa5f f989 	uxtb.w	r9, r9
	} while (--n);
 8015096:	d1f3      	bne.n	8015080 <dir_find+0xe8>
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 8015098:	45cb      	cmp	fp, r9
 801509a:	d1b6      	bne.n	801500a <dir_find+0x72>
 801509c:	e7cd      	b.n	801503a <dir_find+0xa2>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 801509e:	45b1      	cmp	r9, r6
 80150a0:	d0db      	beq.n	801505a <dir_find+0xc2>
 80150a2:	f04f 09ff 	mov.w	r9, #255	; 0xff
 80150a6:	e7dd      	b.n	8015064 <dir_find+0xcc>
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 80150a8:	f04f 0a04 	mov.w	sl, #4
}
 80150ac:	4650      	mov	r0, sl
 80150ae:	b007      	add	sp, #28
 80150b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	rv = rv << 8 | ptr[0];
 80150b4:	7ee2      	ldrb	r2, [r4, #27]
 80150b6:	7ea3      	ldrb	r3, [r4, #26]
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 80150b8:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
 80150bc:	d1d0      	bne.n	8015060 <dir_find+0xc8>
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 80150be:	7823      	ldrb	r3, [r4, #0]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 80150c0:	68f9      	ldr	r1, [r7, #12]
 80150c2:	4a2a      	ldr	r2, [pc, #168]	; (801516c <dir_find+0x1d4>)
 80150c4:	9104      	str	r1, [sp, #16]
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 80150c6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80150ca:	3b01      	subs	r3, #1
 80150cc:	eb03 0043 	add.w	r0, r3, r3, lsl #1
 80150d0:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 80150d4:	2101      	movs	r1, #1
			if (uc != 0xFFFF) return 0;		/* Check filler */
 80150d6:	e9cd b700 	strd	fp, r7, [sp]
 80150da:	e9cd a502 	strd	sl, r5, [sp, #8]
 80150de:	9f04      	ldr	r7, [sp, #16]
 80150e0:	9605      	str	r6, [sp, #20]
 80150e2:	4625      	mov	r5, r4
 80150e4:	4691      	mov	r9, r2
 80150e6:	461c      	mov	r4, r3
 80150e8:	460b      	mov	r3, r1
 80150ea:	e011      	b.n	8015110 <dir_find+0x178>
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 80150ec:	2cfe      	cmp	r4, #254	; 0xfe
 80150ee:	d81d      	bhi.n	801512c <dir_find+0x194>
 80150f0:	f001 f830 	bl	8016154 <ff_wtoupper>
 80150f4:	4683      	mov	fp, r0
 80150f6:	f837 0014 	ldrh.w	r0, [r7, r4, lsl #1]
 80150fa:	f001 f82b 	bl	8016154 <ff_wtoupper>
 80150fe:	4583      	cmp	fp, r0
 8015100:	d114      	bne.n	801512c <dir_find+0x194>
	rv = rv << 8 | ptr[0];
 8015102:	4633      	mov	r3, r6
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 8015104:	4654      	mov	r4, sl
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8015106:	4a1a      	ldr	r2, [pc, #104]	; (8015170 <dir_find+0x1d8>)
 8015108:	454a      	cmp	r2, r9
 801510a:	d016      	beq.n	801513a <dir_find+0x1a2>
 801510c:	f819 1f01 	ldrb.w	r1, [r9, #1]!
	rv = rv << 8 | ptr[0];
 8015110:	5c6e      	ldrb	r6, [r5, r1]
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 8015112:	1868      	adds	r0, r5, r1
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 8015114:	f104 0a01 	add.w	sl, r4, #1
	rv = rv << 8 | ptr[0];
 8015118:	7840      	ldrb	r0, [r0, #1]
 801511a:	ea46 2600 	orr.w	r6, r6, r0, lsl #8
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 801511e:	4630      	mov	r0, r6
		if (wc) {
 8015120:	2b00      	cmp	r3, #0
 8015122:	d1e3      	bne.n	80150ec <dir_find+0x154>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8015124:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8015128:	4296      	cmp	r6, r2
 801512a:	d0ec      	beq.n	8015106 <dir_find+0x16e>
 801512c:	e9dd b700 	ldrd	fp, r7, [sp]
 8015130:	e9dd a502 	ldrd	sl, r5, [sp, #8]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8015134:	f04f 09ff 	mov.w	r9, #255	; 0xff
 8015138:	e747      	b.n	8014fca <dir_find+0x32>
 801513a:	469c      	mov	ip, r3
 801513c:	4623      	mov	r3, r4
 801513e:	462c      	mov	r4, r5
 8015140:	e9dd b700 	ldrd	fp, r7, [sp]
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 8015144:	7822      	ldrb	r2, [r4, #0]
 8015146:	9e05      	ldr	r6, [sp, #20]
 8015148:	0652      	lsls	r2, r2, #25
 801514a:	e9dd a502 	ldrd	sl, r5, [sp, #8]
 801514e:	d508      	bpl.n	8015162 <dir_find+0x1ca>
 8015150:	f1bc 0f00 	cmp.w	ip, #0
 8015154:	d005      	beq.n	8015162 <dir_find+0x1ca>
 8015156:	9a04      	ldr	r2, [sp, #16]
 8015158:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 801515c:	2b00      	cmp	r3, #0
 801515e:	f47f af7f 	bne.w	8015060 <dir_find+0xc8>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8015162:	3e01      	subs	r6, #1
 8015164:	fa5f f986 	uxtb.w	r9, r6
 8015168:	e72f      	b.n	8014fca <dir_find+0x32>
 801516a:	bf00      	nop
 801516c:	08074eb4 	.word	0x08074eb4
 8015170:	08074ec0 	.word	0x08074ec0

08015174 <follow_path>:
{
 8015174:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	FATFS *fs = obj->fs;
 8015178:	f8d0 b000 	ldr.w	fp, [r0]
{
 801517c:	b085      	sub	sp, #20
 801517e:	4607      	mov	r7, r0
 8015180:	460e      	mov	r6, r1
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 8015182:	f811 3b01 	ldrb.w	r3, [r1], #1
 8015186:	2b2f      	cmp	r3, #47	; 0x2f
 8015188:	d0fa      	beq.n	8015180 <follow_path+0xc>
 801518a:	2b5c      	cmp	r3, #92	; 0x5c
 801518c:	d0f8      	beq.n	8015180 <follow_path+0xc>
		obj->sclust = 0;					/* Start from root directory */
 801518e:	2100      	movs	r1, #0
 8015190:	60b9      	str	r1, [r7, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 8015192:	7830      	ldrb	r0, [r6, #0]
 8015194:	281f      	cmp	r0, #31
 8015196:	f240 812f 	bls.w	80153f8 <follow_path+0x284>
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 801519a:	9101      	str	r1, [sp, #4]
 801519c:	465b      	mov	r3, fp
		w = p[si++];					/* Get a character */
 801519e:	b280      	uxth	r0, r0
		if (w < ' ') break;				/* Break if end of the path name */
 80151a0:	281f      	cmp	r0, #31
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
 80151a2:	68dd      	ldr	r5, [r3, #12]
		if (w < ' ') break;				/* Break if end of the path name */
 80151a4:	d946      	bls.n	8015234 <follow_path+0xc0>
		if (w == '/' || w == '\\') {	/* Break if a separator is found */
 80151a6:	282f      	cmp	r0, #47	; 0x2f
 80151a8:	d02c      	beq.n	8015204 <follow_path+0x90>
 80151aa:	285c      	cmp	r0, #92	; 0x5c
 80151ac:	d02a      	beq.n	8015204 <follow_path+0x90>
 80151ae:	f1a5 0902 	sub.w	r9, r5, #2
 80151b2:	46b0      	mov	r8, r6
		w = p[si++];					/* Get a character */
 80151b4:	2401      	movs	r4, #1
 80151b6:	e010      	b.n	80151da <follow_path+0x66>
		lfn[di++] = w;					/* Store the Unicode character */
 80151b8:	f829 0f02 	strh.w	r0, [r9, #2]!
		w = p[si++];					/* Get a character */
 80151bc:	f818 0f01 	ldrb.w	r0, [r8, #1]!
		if (w < ' ') break;				/* Break if end of the path name */
 80151c0:	281f      	cmp	r0, #31
		w = p[si++];					/* Get a character */
 80151c2:	f104 0301 	add.w	r3, r4, #1
		if (w < ' ') break;				/* Break if end of the path name */
 80151c6:	f240 8113 	bls.w	80153f0 <follow_path+0x27c>
		if (w == '/' || w == '\\') {	/* Break if a separator is found */
 80151ca:	282f      	cmp	r0, #47	; 0x2f
 80151cc:	d01c      	beq.n	8015208 <follow_path+0x94>
 80151ce:	285c      	cmp	r0, #92	; 0x5c
 80151d0:	d01a      	beq.n	8015208 <follow_path+0x94>
		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 80151d2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80151d6:	d011      	beq.n	80151fc <follow_path+0x88>
 80151d8:	461c      	mov	r4, r3
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
 80151da:	2101      	movs	r1, #1
 80151dc:	f000 ff96 	bl	801610c <ff_convert>
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 80151e0:	b160      	cbz	r0, 80151fc <follow_path+0x88>
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 80151e2:	287f      	cmp	r0, #127	; 0x7f
 80151e4:	d8e8      	bhi.n	80151b8 <follow_path+0x44>
	while (*str && *str != chr) str++;
 80151e6:	2822      	cmp	r0, #34	; 0x22
 80151e8:	d008      	beq.n	80151fc <follow_path+0x88>
 80151ea:	4a94      	ldr	r2, [pc, #592]	; (801543c <follow_path+0x2c8>)
 80151ec:	232a      	movs	r3, #42	; 0x2a
 80151ee:	e003      	b.n	80151f8 <follow_path+0x84>
 80151f0:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80151f4:	2b00      	cmp	r3, #0
 80151f6:	d0df      	beq.n	80151b8 <follow_path+0x44>
 80151f8:	4298      	cmp	r0, r3
 80151fa:	d1f9      	bne.n	80151f0 <follow_path+0x7c>
	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
 80151fc:	2006      	movs	r0, #6
}
 80151fe:	b005      	add	sp, #20
 8015200:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
 8015204:	2400      	movs	r4, #0
		w = p[si++];					/* Get a character */
 8015206:	2301      	movs	r3, #1
 8015208:	4433      	add	r3, r6
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 801520a:	781a      	ldrb	r2, [r3, #0]
 801520c:	2a2f      	cmp	r2, #47	; 0x2f
 801520e:	461e      	mov	r6, r3
 8015210:	f103 0301 	add.w	r3, r3, #1
 8015214:	d0f9      	beq.n	801520a <follow_path+0x96>
 8015216:	2a5c      	cmp	r2, #92	; 0x5c
 8015218:	d0f7      	beq.n	801520a <follow_path+0x96>
	while (di) {						/* Snip off trailing spaces and dots if exist */
 801521a:	b15c      	cbz	r4, 8015234 <follow_path+0xc0>
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 801521c:	f04f 0900 	mov.w	r9, #0
 8015220:	eb05 0244 	add.w	r2, r5, r4, lsl #1
		w = lfn[di - 1];
 8015224:	f832 3d02 	ldrh.w	r3, [r2, #-2]!
		if (w != ' ' && w != '.') break;
 8015228:	2b20      	cmp	r3, #32
 801522a:	d001      	beq.n	8015230 <follow_path+0xbc>
 801522c:	2b2e      	cmp	r3, #46	; 0x2e
 801522e:	d104      	bne.n	801523a <follow_path+0xc6>
	while (di) {						/* Snip off trailing spaces and dots if exist */
 8015230:	3c01      	subs	r4, #1
 8015232:	d1f7      	bne.n	8015224 <follow_path+0xb0>
	lfn[di] = 0;						/* LFN is created */
 8015234:	2300      	movs	r3, #0
 8015236:	802b      	strh	r3, [r5, #0]
 8015238:	e7e0      	b.n	80151fc <follow_path+0x88>
 801523a:	9b01      	ldr	r3, [sp, #4]
 801523c:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
 8015240:	eb05 0244 	add.w	r2, r5, r4, lsl #1
	mem_set(dp->fn, ' ', 11);
 8015244:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8015248:	f107 002f 	add.w	r0, r7, #47	; 0x2f
		*d++ = (BYTE)val;
 801524c:	2120      	movs	r1, #32
 801524e:	f803 1b01 	strb.w	r1, [r3], #1
	} while (--cnt);
 8015252:	4283      	cmp	r3, r0
 8015254:	d1fb      	bne.n	801524e <follow_path+0xda>
 8015256:	1eab      	subs	r3, r5, #2
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 8015258:	f04f 0800 	mov.w	r8, #0
 801525c:	e001      	b.n	8015262 <follow_path+0xee>
 801525e:	f108 0801 	add.w	r8, r8, #1
 8015262:	f833 0f02 	ldrh.w	r0, [r3, #2]!
 8015266:	2820      	cmp	r0, #32
 8015268:	d0f9      	beq.n	801525e <follow_path+0xea>
 801526a:	282e      	cmp	r0, #46	; 0x2e
 801526c:	d0f7      	beq.n	801525e <follow_path+0xea>
	if (si) cf |= NS_LOSS | NS_LFN;
 801526e:	f1b8 0f00 	cmp.w	r8, #0
 8015272:	d001      	beq.n	8015278 <follow_path+0x104>
 8015274:	f049 0903 	orr.w	r9, r9, #3
 8015278:	4613      	mov	r3, r2
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 801527a:	f833 2d02 	ldrh.w	r2, [r3, #-2]!
 801527e:	2a2e      	cmp	r2, #46	; 0x2e
 8015280:	d001      	beq.n	8015286 <follow_path+0x112>
 8015282:	3c01      	subs	r4, #1
 8015284:	d1f9      	bne.n	801527a <follow_path+0x106>
		dp->fn[i++] = (BYTE)w;
 8015286:	2300      	movs	r3, #0
 8015288:	469a      	mov	sl, r3
 801528a:	2208      	movs	r2, #8
		w = lfn[si++];					/* Get an LFN character */
 801528c:	f108 0801 	add.w	r8, r8, #1
		if (!w) break;					/* Break on end of the LFN */
 8015290:	b340      	cbz	r0, 80152e4 <follow_path+0x170>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 8015292:	2820      	cmp	r0, #32
 8015294:	d06f      	beq.n	8015376 <follow_path+0x202>
 8015296:	282e      	cmp	r0, #46	; 0x2e
 8015298:	d072      	beq.n	8015380 <follow_path+0x20c>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
 801529a:	4293      	cmp	r3, r2
 801529c:	d21a      	bcs.n	80152d4 <follow_path+0x160>
 801529e:	4544      	cmp	r4, r8
 80152a0:	d070      	beq.n	8015384 <follow_path+0x210>
		if (w >= 0x80) {				/* Non ASCII character */
 80152a2:	287f      	cmp	r0, #127	; 0x7f
 80152a4:	f200 808b 	bhi.w	80153be <follow_path+0x24a>
	while (*str && *str != chr) str++;
 80152a8:	282b      	cmp	r0, #43	; 0x2b
 80152aa:	f000 8099 	beq.w	80153e0 <follow_path+0x26c>
 80152ae:	f8df c194 	ldr.w	ip, [pc, #404]	; 8015444 <follow_path+0x2d0>
 80152b2:	212c      	movs	r1, #44	; 0x2c
 80152b4:	4281      	cmp	r1, r0
 80152b6:	f000 8093 	beq.w	80153e0 <follow_path+0x26c>
 80152ba:	f81c 1f01 	ldrb.w	r1, [ip, #1]!
 80152be:	2900      	cmp	r1, #0
 80152c0:	d1f8      	bne.n	80152b4 <follow_path+0x140>
				if (IsUpper(w)) {		/* ASCII large capital */
 80152c2:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
 80152c6:	2919      	cmp	r1, #25
 80152c8:	f200 809f 	bhi.w	801540a <follow_path+0x296>
					b |= 2;
 80152cc:	f04a 0a02 	orr.w	sl, sl, #2
 80152d0:	b2c0      	uxtb	r0, r0
 80152d2:	e088      	b.n	80153e6 <follow_path+0x272>
			if (ni == 11) {				/* Long extension */
 80152d4:	2a0b      	cmp	r2, #11
 80152d6:	f000 80a6 	beq.w	8015426 <follow_path+0x2b2>
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 80152da:	4544      	cmp	r4, r8
 80152dc:	d054      	beq.n	8015388 <follow_path+0x214>
 80152de:	f049 0903 	orr.w	r9, r9, #3
			if (si > di) break;			/* No extension */
 80152e2:	d251      	bcs.n	8015388 <follow_path+0x214>
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 80152e4:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 80152e8:	2be5      	cmp	r3, #229	; 0xe5
 80152ea:	bf04      	itt	eq
 80152ec:	2305      	moveq	r3, #5
 80152ee:	f887 3024 	strbeq.w	r3, [r7, #36]	; 0x24
	if (ni == 8) b <<= 2;
 80152f2:	2a08      	cmp	r2, #8
 80152f4:	bf04      	itt	eq
 80152f6:	ea4f 0a8a 	moveq.w	sl, sl, lsl #2
 80152fa:	fa5f fa8a 	uxtbeq.w	sl, sl
 80152fe:	f00a 030c 	and.w	r3, sl, #12
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 8015302:	2b0c      	cmp	r3, #12
 8015304:	d048      	beq.n	8015398 <follow_path+0x224>
 8015306:	f00a 0a03 	and.w	sl, sl, #3
 801530a:	f1ba 0f03 	cmp.w	sl, #3
 801530e:	d043      	beq.n	8015398 <follow_path+0x224>
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 8015310:	f019 0f02 	tst.w	r9, #2
 8015314:	d108      	bne.n	8015328 <follow_path+0x1b4>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 8015316:	f1ba 0f01 	cmp.w	sl, #1
 801531a:	bf08      	it	eq
 801531c:	f049 0910 	orreq.w	r9, r9, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 8015320:	2b04      	cmp	r3, #4
 8015322:	bf08      	it	eq
 8015324:	f049 0908 	orreq.w	r9, r9, #8
	dp->fn[NSFLAG] = cf;	/* SFN is created */
 8015328:	f887 902f 	strb.w	r9, [r7, #47]	; 0x2f
			res = dir_find(dp);				/* Find an object with the segment name */
 801532c:	4638      	mov	r0, r7
 801532e:	f7ff fe33 	bl	8014f98 <dir_find>
			ns = dp->fn[NSFLAG];
 8015332:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
			if (res != FR_OK) {				/* Failed to find the object */
 8015336:	2800      	cmp	r0, #0
 8015338:	d139      	bne.n	80153ae <follow_path+0x23a>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 801533a:	075a      	lsls	r2, r3, #29
 801533c:	f53f af5f 	bmi.w	80151fe <follow_path+0x8a>
			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 8015340:	79bb      	ldrb	r3, [r7, #6]
 8015342:	06db      	lsls	r3, r3, #27
 8015344:	d56b      	bpl.n	801541e <follow_path+0x2aa>
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8015346:	697b      	ldr	r3, [r7, #20]
	if (fs->fs_type == FS_FAT32) {
 8015348:	f89b 1000 	ldrb.w	r1, [fp]
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 801534c:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8015350:	f10b 0334 	add.w	r3, fp, #52	; 0x34
 8015354:	4413      	add	r3, r2
	if (fs->fs_type == FS_FAT32) {
 8015356:	2903      	cmp	r1, #3
	rv = rv << 8 | ptr[0];
 8015358:	7ed8      	ldrb	r0, [r3, #27]
 801535a:	7e9a      	ldrb	r2, [r3, #26]
	cl = ld_word(dir + DIR_FstClusLO);
 801535c:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	if (fs->fs_type == FS_FAT32) {
 8015360:	d105      	bne.n	801536e <follow_path+0x1fa>
	rv = rv << 8 | ptr[0];
 8015362:	7d59      	ldrb	r1, [r3, #21]
 8015364:	7d1b      	ldrb	r3, [r3, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8015366:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 801536a:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 801536e:	60ba      	str	r2, [r7, #8]
 8015370:	7830      	ldrb	r0, [r6, #0]
 8015372:	683b      	ldr	r3, [r7, #0]
			res = create_name(dp, &path);	/* Get a segment name of the path */
 8015374:	e713      	b.n	801519e <follow_path+0x2a>
			cf |= NS_LOSS | NS_LFN; continue;
 8015376:	f049 0903 	orr.w	r9, r9, #3
 801537a:	f835 0018 	ldrh.w	r0, [r5, r8, lsl #1]
 801537e:	e785      	b.n	801528c <follow_path+0x118>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 8015380:	4544      	cmp	r4, r8
 8015382:	d1f8      	bne.n	8015376 <follow_path+0x202>
			if (ni == 11) {				/* Long extension */
 8015384:	2a0b      	cmp	r2, #11
 8015386:	d04e      	beq.n	8015426 <follow_path+0x2b2>
			b <<= 2; continue;
 8015388:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 801538c:	fa5f fa8a 	uxtb.w	sl, sl
 8015390:	46a0      	mov	r8, r4
			si = di; i = 8; ni = 11;	/* Enter extension section */
 8015392:	220b      	movs	r2, #11
 8015394:	2308      	movs	r3, #8
 8015396:	e7f0      	b.n	801537a <follow_path+0x206>
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 8015398:	f049 0902 	orr.w	r9, r9, #2
	dp->fn[NSFLAG] = cf;	/* SFN is created */
 801539c:	f887 902f 	strb.w	r9, [r7, #47]	; 0x2f
			res = dir_find(dp);				/* Find an object with the segment name */
 80153a0:	4638      	mov	r0, r7
 80153a2:	f7ff fdf9 	bl	8014f98 <dir_find>
			ns = dp->fn[NSFLAG];
 80153a6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
			if (res != FR_OK) {				/* Failed to find the object */
 80153aa:	2800      	cmp	r0, #0
 80153ac:	d0c5      	beq.n	801533a <follow_path+0x1c6>
				if (res == FR_NO_FILE) {	/* Object is not found */
 80153ae:	2804      	cmp	r0, #4
 80153b0:	f47f af25 	bne.w	80151fe <follow_path+0x8a>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 80153b4:	f013 0f04 	tst.w	r3, #4
 80153b8:	bf08      	it	eq
 80153ba:	2005      	moveq	r0, #5
 80153bc:	e71f      	b.n	80151fe <follow_path+0x8a>
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
 80153be:	2100      	movs	r1, #0
 80153c0:	e9cd 3202 	strd	r3, r2, [sp, #8]
 80153c4:	f000 fea2 	bl	801610c <ff_convert>
 80153c8:	f049 0902 	orr.w	r9, r9, #2
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 80153cc:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 80153d0:	b130      	cbz	r0, 80153e0 <follow_path+0x26c>
 80153d2:	491b      	ldr	r1, [pc, #108]	; (8015440 <follow_path+0x2cc>)
 80153d4:	4408      	add	r0, r1
 80153d6:	f810 0c70 	ldrb.w	r0, [r0, #-112]
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 80153da:	2800      	cmp	r0, #0
 80153dc:	f47f af64 	bne.w	80152a8 <follow_path+0x134>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 80153e0:	f049 0903 	orr.w	r9, r9, #3
 80153e4:	205f      	movs	r0, #95	; 0x5f
		dp->fn[i++] = (BYTE)w;
 80153e6:	18f9      	adds	r1, r7, r3
 80153e8:	3301      	adds	r3, #1
 80153ea:	f881 0024 	strb.w	r0, [r1, #36]	; 0x24
 80153ee:	e7c4      	b.n	801537a <follow_path+0x206>
	*path = &p[si];						/* Return pointer to the next segment */
 80153f0:	441e      	add	r6, r3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 80153f2:	f04f 0904 	mov.w	r9, #4
 80153f6:	e713      	b.n	8015220 <follow_path+0xac>
		dp->fn[NSFLAG] = NS_NONAME;
 80153f8:	2380      	movs	r3, #128	; 0x80
		res = dir_sdi(dp, 0);
 80153fa:	4638      	mov	r0, r7
		dp->fn[NSFLAG] = NS_NONAME;
 80153fc:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
}
 8015400:	b005      	add	sp, #20
 8015402:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		res = dir_sdi(dp, 0);
 8015406:	f7ff bc23 	b.w	8014c50 <dir_sdi>
					if (IsLower(w)) {	/* ASCII small capital */
 801540a:	f1a0 0161 	sub.w	r1, r0, #97	; 0x61
 801540e:	2919      	cmp	r1, #25
						b |= 1; w -= 0x20;
 8015410:	bf97      	itett	ls
 8015412:	3820      	subls	r0, #32
 8015414:	b2c0      	uxtbhi	r0, r0
 8015416:	b2c0      	uxtbls	r0, r0
 8015418:	f04a 0a01 	orrls.w	sl, sl, #1
 801541c:	e7e3      	b.n	80153e6 <follow_path+0x272>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 801541e:	2005      	movs	r0, #5
}
 8015420:	b005      	add	sp, #20
 8015422:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8015426:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 801542a:	2be5      	cmp	r3, #229	; 0xe5
				cf |= NS_LOSS | NS_LFN; break;
 801542c:	f049 0903 	orr.w	r9, r9, #3
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8015430:	f47f af65 	bne.w	80152fe <follow_path+0x18a>
 8015434:	2305      	movs	r3, #5
 8015436:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
 801543a:	e760      	b.n	80152fe <follow_path+0x18a>
 801543c:	080754ad 	.word	0x080754ad
 8015440:	08074eb4 	.word	0x08074eb4
 8015444:	080754b9 	.word	0x080754b9

08015448 <dir_register>:
{
 8015448:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 801544c:	f890 302f 	ldrb.w	r3, [r0, #47]	; 0x2f
 8015450:	f013 07a0 	ands.w	r7, r3, #160	; 0xa0
{
 8015454:	b08b      	sub	sp, #44	; 0x2c
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 8015456:	f040 80f0 	bne.w	801563a <dir_register+0x1f2>
	FATFS *fs = dp->obj.fs;
 801545a:	f8d0 a000 	ldr.w	sl, [r0]
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
 801545e:	f8da 300c 	ldr.w	r3, [sl, #12]
 8015462:	881a      	ldrh	r2, [r3, #0]
 8015464:	2a00      	cmp	r2, #0
 8015466:	f000 817c 	beq.w	8015762 <dir_register+0x31a>
 801546a:	f833 2f02 	ldrh.w	r2, [r3, #2]!
 801546e:	3701      	adds	r7, #1
 8015470:	2a00      	cmp	r2, #0
 8015472:	d1fa      	bne.n	801546a <dir_register+0x22>
	mem_cpy(sn, dp->fn, 12);
 8015474:	f100 0524 	add.w	r5, r0, #36	; 0x24
 8015478:	4604      	mov	r4, r0
 801547a:	4629      	mov	r1, r5
 801547c:	a807      	add	r0, sp, #28
 801547e:	220c      	movs	r2, #12
 8015480:	f7ff f838 	bl	80144f4 <mem_cpy.part.0>
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 8015484:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
 8015488:	07de      	lsls	r6, r3, #31
 801548a:	d454      	bmi.n	8015536 <dir_register+0xee>
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 801548c:	079b      	lsls	r3, r3, #30
 801548e:	f140 80d2 	bpl.w	8015636 <dir_register+0x1ee>
 8015492:	4bb5      	ldr	r3, [pc, #724]	; (8015768 <dir_register+0x320>)
 8015494:	370c      	adds	r7, #12
 8015496:	fba3 3707 	umull	r3, r7, r3, r7
 801549a:	08bf      	lsrs	r7, r7, #2
 801549c:	3701      	adds	r7, #1
	res = dir_sdi(dp, 0);
 801549e:	2100      	movs	r1, #0
 80154a0:	4620      	mov	r0, r4
	FATFS *fs = dp->obj.fs;
 80154a2:	f8d4 8000 	ldr.w	r8, [r4]
	res = dir_sdi(dp, 0);
 80154a6:	f7ff fbd3 	bl	8014c50 <dir_sdi>
	if (res == FR_OK) {
 80154aa:	4683      	mov	fp, r0
 80154ac:	2800      	cmp	r0, #0
 80154ae:	f040 80ae 	bne.w	801560e <dir_register+0x1c6>
		n = 0;
 80154b2:	4606      	mov	r6, r0
 80154b4:	e008      	b.n	80154c8 <dir_register+0x80>
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 80154b6:	b1bb      	cbz	r3, 80154e8 <dir_register+0xa0>
				n = 0;					/* Not a blank entry. Restart to search */
 80154b8:	2600      	movs	r6, #0
			res = dir_next(dp, 1);
 80154ba:	2101      	movs	r1, #1
 80154bc:	4620      	mov	r0, r4
 80154be:	f7ff fcc3 	bl	8014e48 <dir_next>
		} while (res == FR_OK);	/* Next entry with table stretch enabled */
 80154c2:	2800      	cmp	r0, #0
 80154c4:	f040 80a2 	bne.w	801560c <dir_register+0x1c4>
			res = move_window(fs, dp->sect);
 80154c8:	69e3      	ldr	r3, [r4, #28]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80154ca:	f8d8 2030 	ldr.w	r2, [r8, #48]	; 0x30
 80154ce:	4293      	cmp	r3, r2
 80154d0:	4640      	mov	r0, r8
 80154d2:	4619      	mov	r1, r3
 80154d4:	d004      	beq.n	80154e0 <dir_register+0x98>
 80154d6:	f7ff f89d 	bl	8014614 <move_window.part.5>
			if (res != FR_OK) break;
 80154da:	2800      	cmp	r0, #0
 80154dc:	f040 8096 	bne.w	801560c <dir_register+0x1c4>
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 80154e0:	6a23      	ldr	r3, [r4, #32]
 80154e2:	781b      	ldrb	r3, [r3, #0]
 80154e4:	2be5      	cmp	r3, #229	; 0xe5
 80154e6:	d1e6      	bne.n	80154b6 <dir_register+0x6e>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
 80154e8:	3601      	adds	r6, #1
 80154ea:	42b7      	cmp	r7, r6
 80154ec:	d1e5      	bne.n	80154ba <dir_register+0x72>
	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 80154ee:	1e7b      	subs	r3, r7, #1
 80154f0:	9300      	str	r3, [sp, #0]
 80154f2:	f040 80b3 	bne.w	801565c <dir_register+0x214>
		res = move_window(fs, dp->sect);
 80154f6:	69e1      	ldr	r1, [r4, #28]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80154f8:	f8da 3030 	ldr.w	r3, [sl, #48]	; 0x30
 80154fc:	4299      	cmp	r1, r3
 80154fe:	f040 80a2 	bne.w	8015646 <dir_register+0x1fe>
			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
 8015502:	6a23      	ldr	r3, [r4, #32]
		*d++ = (BYTE)val;
 8015504:	2100      	movs	r1, #0
 8015506:	f103 0220 	add.w	r2, r3, #32
 801550a:	f803 1b01 	strb.w	r1, [r3], #1
	} while (--cnt);
 801550e:	4293      	cmp	r3, r2
 8015510:	d1fb      	bne.n	801550a <dir_register+0xc2>
 8015512:	4629      	mov	r1, r5
 8015514:	220b      	movs	r2, #11
 8015516:	6a20      	ldr	r0, [r4, #32]
 8015518:	f7fe ffec 	bl	80144f4 <mem_cpy.part.0>
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 801551c:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8015520:	6a21      	ldr	r1, [r4, #32]
 8015522:	f003 0318 	and.w	r3, r3, #24
			fs->wflag = 1;
 8015526:	2201      	movs	r2, #1
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 8015528:	730b      	strb	r3, [r1, #12]
			fs->wflag = 1;
 801552a:	f88a 2003 	strb.w	r2, [sl, #3]
}
 801552e:	4658      	mov	r0, fp
 8015530:	b00b      	add	sp, #44	; 0x2c
 8015532:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 8015536:	2340      	movs	r3, #64	; 0x40
 8015538:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
 801553c:	220b      	movs	r2, #11
 801553e:	a907      	add	r1, sp, #28
 8015540:	4628      	mov	r0, r5
		for (n = 1; n < 100; n++) {
 8015542:	f04f 0801 	mov.w	r8, #1
				if (sr & 0x10000) sr ^= 0x11021;
 8015546:	4e89      	ldr	r6, [pc, #548]	; (801576c <dir_register+0x324>)
 8015548:	f7fe ffd4 	bl	80144f4 <mem_cpy.part.0>
		for (n = 1; n < 100; n++) {
 801554c:	4643      	mov	r3, r8
 801554e:	f10d 0c1b 	add.w	ip, sp, #27
 8015552:	2207      	movs	r2, #7
		c = (BYTE)((seq % 16) + '0');
 8015554:	f003 000f 	and.w	r0, r3, #15
 8015558:	f100 0130 	add.w	r1, r0, #48	; 0x30
		if (c > '9') c += 7;
 801555c:	2939      	cmp	r1, #57	; 0x39
 801555e:	bf88      	it	hi
 8015560:	f100 0137 	addhi.w	r1, r0, #55	; 0x37
	} while (seq);
 8015564:	091b      	lsrs	r3, r3, #4
		ns[i--] = c;
 8015566:	f102 32ff 	add.w	r2, r2, #4294967295
 801556a:	f80c 1901 	strb.w	r1, [ip], #-1
	} while (seq);
 801556e:	d1f1      	bne.n	8015554 <dir_register+0x10c>
	ns[i] = '~';
 8015570:	a90a      	add	r1, sp, #40	; 0x28
 8015572:	4411      	add	r1, r2
 8015574:	207e      	movs	r0, #126	; 0x7e
 8015576:	f801 0c14 	strb.w	r0, [r1, #-20]
	for (j = 0; j < i && dst[j] != ' '; j++) {
 801557a:	2a00      	cmp	r2, #0
 801557c:	d050      	beq.n	8015620 <dir_register+0x1d8>
 801557e:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
 8015582:	2920      	cmp	r1, #32
 8015584:	d008      	beq.n	8015598 <dir_register+0x150>
 8015586:	4629      	mov	r1, r5
 8015588:	e003      	b.n	8015592 <dir_register+0x14a>
 801558a:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 801558e:	2820      	cmp	r0, #32
 8015590:	d002      	beq.n	8015598 <dir_register+0x150>
 8015592:	3301      	adds	r3, #1
 8015594:	429a      	cmp	r2, r3
 8015596:	d1f8      	bne.n	801558a <dir_register+0x142>
 8015598:	1e59      	subs	r1, r3, #1
 801559a:	4429      	add	r1, r5
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 801559c:	a80a      	add	r0, sp, #40	; 0x28
 801559e:	4410      	add	r0, r2
 80155a0:	2a07      	cmp	r2, #7
 80155a2:	f103 0301 	add.w	r3, r3, #1
 80155a6:	bf96      	itet	ls
 80155a8:	f810 0c14 	ldrbls.w	r0, [r0, #-20]
 80155ac:	2020      	movhi	r0, #32
 80155ae:	3201      	addls	r2, #1
	} while (j < 8);
 80155b0:	2b07      	cmp	r3, #7
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 80155b2:	f801 0f01 	strb.w	r0, [r1, #1]!
	} while (j < 8);
 80155b6:	d9f1      	bls.n	801559c <dir_register+0x154>
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
 80155b8:	4620      	mov	r0, r4
 80155ba:	f7ff fced 	bl	8014f98 <dir_find>
 80155be:	4683      	mov	fp, r0
			if (res != FR_OK) break;
 80155c0:	bb80      	cbnz	r0, 8015624 <dir_register+0x1dc>
		for (n = 1; n < 100; n++) {
 80155c2:	f108 0801 	add.w	r8, r8, #1
 80155c6:	f1b8 0f64 	cmp.w	r8, #100	; 0x64
 80155ca:	d023      	beq.n	8015614 <dir_register+0x1cc>
 80155cc:	220b      	movs	r2, #11
 80155ce:	a907      	add	r1, sp, #28
 80155d0:	4628      	mov	r0, r5
			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
 80155d2:	f8da 900c 	ldr.w	r9, [sl, #12]
 80155d6:	f7fe ff8d 	bl	80144f4 <mem_cpy.part.0>
	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 80155da:	f1b8 0f05 	cmp.w	r8, #5
 80155de:	d913      	bls.n	8015608 <dir_register+0x1c0>
 80155e0:	f1a9 0c02 	sub.w	ip, r9, #2
 80155e4:	4643      	mov	r3, r8
		while (*lfn) {	/* Create a CRC */
 80155e6:	f83c 2f02 	ldrh.w	r2, [ip, #2]!
 80155ea:	2a00      	cmp	r2, #0
 80155ec:	d0af      	beq.n	801554e <dir_register+0x106>
 80155ee:	2110      	movs	r1, #16
				sr = (sr << 1) + (wc & 1);
 80155f0:	f002 0001 	and.w	r0, r2, #1
 80155f4:	eb00 0343 	add.w	r3, r0, r3, lsl #1
				if (sr & 0x10000) sr ^= 0x11021;
 80155f8:	03d8      	lsls	r0, r3, #15
 80155fa:	bf48      	it	mi
 80155fc:	4073      	eormi	r3, r6
			for (i = 0; i < 16; i++) {
 80155fe:	3901      	subs	r1, #1
				wc >>= 1;
 8015600:	ea4f 0252 	mov.w	r2, r2, lsr #1
			for (i = 0; i < 16; i++) {
 8015604:	d1f4      	bne.n	80155f0 <dir_register+0x1a8>
 8015606:	e7ee      	b.n	80155e6 <dir_register+0x19e>
	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 8015608:	4643      	mov	r3, r8
 801560a:	e7a0      	b.n	801554e <dir_register+0x106>
			if (res != FR_OK) break;
 801560c:	4683      	mov	fp, r0
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 801560e:	f1bb 0f04 	cmp.w	fp, #4
 8015612:	d18c      	bne.n	801552e <dir_register+0xe6>
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 8015614:	f04f 0b07 	mov.w	fp, #7
}
 8015618:	4658      	mov	r0, fp
 801561a:	b00b      	add	sp, #44	; 0x2c
 801561c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (j = 0; j < i && dst[j] != ' '; j++) {
 8015620:	4613      	mov	r3, r2
 8015622:	e7b9      	b.n	8015598 <dir_register+0x150>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 8015624:	2804      	cmp	r0, #4
 8015626:	d182      	bne.n	801552e <dir_register+0xe6>
		dp->fn[NSFLAG] = sn[NSFLAG];
 8015628:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
 801562c:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 8015630:	079b      	lsls	r3, r3, #30
 8015632:	f53f af2e 	bmi.w	8015492 <dir_register+0x4a>
 8015636:	2701      	movs	r7, #1
 8015638:	e731      	b.n	801549e <dir_register+0x56>
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 801563a:	f04f 0b06 	mov.w	fp, #6
}
 801563e:	4658      	mov	r0, fp
 8015640:	b00b      	add	sp, #44	; 0x2c
 8015642:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015646:	4650      	mov	r0, sl
 8015648:	f7fe ffe4 	bl	8014614 <move_window.part.5>
		if (res == FR_OK) {
 801564c:	2800      	cmp	r0, #0
 801564e:	f43f af58 	beq.w	8015502 <dir_register+0xba>
 8015652:	4683      	mov	fp, r0
}
 8015654:	4658      	mov	r0, fp
 8015656:	b00b      	add	sp, #44	; 0x2c
 8015658:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
 801565c:	6961      	ldr	r1, [r4, #20]
 801565e:	9b00      	ldr	r3, [sp, #0]
 8015660:	4620      	mov	r0, r4
 8015662:	eba1 1143 	sub.w	r1, r1, r3, lsl #5
 8015666:	f7ff faf3 	bl	8014c50 <dir_sdi>
		if (res == FR_OK) {
 801566a:	2800      	cmp	r0, #0
 801566c:	d1f1      	bne.n	8015652 <dir_register+0x20a>
	BYTE sum = 0;
 801566e:	4602      	mov	r2, r0
		if (res == FR_OK) {
 8015670:	4629      	mov	r1, r5
 8015672:	f104 002f 	add.w	r0, r4, #47	; 0x2f
		sum = (sum >> 1) + (sum << 7) + *dir++;
 8015676:	01d3      	lsls	r3, r2, #7
 8015678:	f811 6b01 	ldrb.w	r6, [r1], #1
 801567c:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
 8015680:	fa56 f383 	uxtab	r3, r6, r3
	} while (--n);
 8015684:	4281      	cmp	r1, r0
		sum = (sum >> 1) + (sum << 7) + *dir++;
 8015686:	b2da      	uxtb	r2, r3
	} while (--n);
 8015688:	d1f5      	bne.n	8015676 <dir_register+0x22e>
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 801568a:	e9cd 5b02 	strd	r5, fp, [sp, #8]
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 801568e:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 8015770 <dir_register+0x328>
 8015692:	9201      	str	r2, [sp, #4]
				res = move_window(fs, dp->sect);
 8015694:	69e1      	ldr	r1, [r4, #28]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8015696:	f8da 3030 	ldr.w	r3, [sl, #48]	; 0x30
 801569a:	4299      	cmp	r1, r3
 801569c:	d004      	beq.n	80156a8 <dir_register+0x260>
 801569e:	4650      	mov	r0, sl
 80156a0:	f7fe ffb8 	bl	8014614 <move_window.part.5>
				if (res != FR_OK) break;
 80156a4:	2800      	cmp	r0, #0
 80156a6:	d1d4      	bne.n	8015652 <dir_register+0x20a>
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
 80156a8:	f89d b000 	ldrb.w	fp, [sp]
 80156ac:	6a21      	ldr	r1, [r4, #32]
	dir[LDIR_Chksum] = sum;			/* Set checksum */
 80156ae:	9e01      	ldr	r6, [sp, #4]
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
 80156b0:	f8da e00c 	ldr.w	lr, [sl, #12]
	dir[LDIR_Chksum] = sum;			/* Set checksum */
 80156b4:	734e      	strb	r6, [r1, #13]
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 80156b6:	f10b 32ff 	add.w	r2, fp, #4294967295
	dir[LDIR_Type] = 0;
 80156ba:	2500      	movs	r5, #0
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 80156bc:	eb02 0042 	add.w	r0, r2, r2, lsl #1
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 80156c0:	f04f 060f 	mov.w	r6, #15
	dir[LDIR_Type] = 0;
 80156c4:	730d      	strb	r5, [r1, #12]
	s = wc = 0;
 80156c6:	462b      	mov	r3, r5
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 80156c8:	eb02 0280 	add.w	r2, r2, r0, lsl #2
	*ptr++ = (BYTE)val; val >>= 8;
 80156cc:	768d      	strb	r5, [r1, #26]
	s = wc = 0;
 80156ce:	4628      	mov	r0, r5
	*ptr++ = (BYTE)val;
 80156d0:	76cd      	strb	r5, [r1, #27]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 80156d2:	72ce      	strb	r6, [r1, #11]
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 80156d4:	2501      	movs	r5, #1
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 80156d6:	f64f 78ff 	movw	r8, #65535	; 0xffff
	*ptr++ = (BYTE)val; val >>= 8;
 80156da:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80156de:	e016      	b.n	801570e <dir_register+0x2c6>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 80156e0:	f83e 3012 	ldrh.w	r3, [lr, r2, lsl #1]
	*ptr++ = (BYTE)val; val >>= 8;
 80156e4:	554b      	strb	r3, [r1, r5]
 80156e6:	0a1d      	lsrs	r5, r3, #8
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 80156e8:	3201      	adds	r2, #1
	*ptr++ = (BYTE)val;
 80156ea:	707d      	strb	r5, [r7, #1]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 80156ec:	bbbb      	cbnz	r3, 801575e <dir_register+0x316>
	} while (++s < 13);
 80156ee:	2e0c      	cmp	r6, #12
 80156f0:	d821      	bhi.n	8015736 <dir_register+0x2ee>
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 80156f2:	f819 3006 	ldrb.w	r3, [r9, r6]
 80156f6:	18cd      	adds	r5, r1, r3
	*ptr++ = (BYTE)val; val >>= 8;
 80156f8:	f801 c003 	strb.w	ip, [r1, r3]
 80156fc:	3002      	adds	r0, #2
	*ptr++ = (BYTE)val;
 80156fe:	f885 c001 	strb.w	ip, [r5, #1]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 8015702:	f64f 73ff 	movw	r3, #65535	; 0xffff
	} while (++s < 13);
 8015706:	280c      	cmp	r0, #12
 8015708:	d80e      	bhi.n	8015728 <dir_register+0x2e0>
 801570a:	f819 5000 	ldrb.w	r5, [r9, r0]
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 801570e:	4543      	cmp	r3, r8
 8015710:	eb01 0705 	add.w	r7, r1, r5
 8015714:	f100 0601 	add.w	r6, r0, #1
 8015718:	d1e2      	bne.n	80156e0 <dir_register+0x298>
	*ptr++ = (BYTE)val;
 801571a:	4630      	mov	r0, r6
	} while (++s < 13);
 801571c:	280c      	cmp	r0, #12
	*ptr++ = (BYTE)val; val >>= 8;
 801571e:	f801 c005 	strb.w	ip, [r1, r5]
	*ptr++ = (BYTE)val;
 8015722:	f887 c001 	strb.w	ip, [r7, #1]
	} while (++s < 13);
 8015726:	d9f0      	bls.n	801570a <dir_register+0x2c2>
	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
 8015728:	f64f 70ff 	movw	r0, #65535	; 0xffff
 801572c:	4283      	cmp	r3, r0
 801572e:	d002      	beq.n	8015736 <dir_register+0x2ee>
 8015730:	f83e 3012 	ldrh.w	r3, [lr, r2, lsl #1]
 8015734:	b90b      	cbnz	r3, 801573a <dir_register+0x2f2>
 8015736:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
				fs->wflag = 1;
 801573a:	2301      	movs	r3, #1
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 801573c:	f881 b000 	strb.w	fp, [r1]
				res = dir_next(dp, 0);	/* Next entry */
 8015740:	4620      	mov	r0, r4
 8015742:	2100      	movs	r1, #0
				fs->wflag = 1;
 8015744:	f88a 3003 	strb.w	r3, [sl, #3]
				res = dir_next(dp, 0);	/* Next entry */
 8015748:	f7ff fb7e 	bl	8014e48 <dir_next>
			} while (res == FR_OK && --nent);
 801574c:	2800      	cmp	r0, #0
 801574e:	d180      	bne.n	8015652 <dir_register+0x20a>
 8015750:	9b00      	ldr	r3, [sp, #0]
 8015752:	3b01      	subs	r3, #1
 8015754:	9300      	str	r3, [sp, #0]
 8015756:	d19d      	bne.n	8015694 <dir_register+0x24c>
 8015758:	e9dd 5b02 	ldrd	r5, fp, [sp, #8]
 801575c:	e6cb      	b.n	80154f6 <dir_register+0xae>
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 801575e:	4630      	mov	r0, r6
 8015760:	e7d1      	b.n	8015706 <dir_register+0x2be>
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
 8015762:	4617      	mov	r7, r2
 8015764:	e686      	b.n	8015474 <dir_register+0x2c>
 8015766:	bf00      	nop
 8015768:	4ec4ec4f 	.word	0x4ec4ec4f
 801576c:	00011021 	.word	0x00011021
 8015770:	08074eb4 	.word	0x08074eb4

08015774 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 8015774:	b510      	push	{r4, lr}
 8015776:	b084      	sub	sp, #16
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 8015778:	ab04      	add	r3, sp, #16
{
 801577a:	9001      	str	r0, [sp, #4]
	const TCHAR *rp = path;
 801577c:	f843 1d04 	str.w	r1, [r3, #-4]!


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
 8015780:	4618      	mov	r0, r3
{
 8015782:	9100      	str	r1, [sp, #0]
 8015784:	4614      	mov	r4, r2
	vol = get_ldnumber(&rp);
 8015786:	f7fe fe6b 	bl	8014460 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 801578a:	2800      	cmp	r0, #0
 801578c:	db1e      	blt.n	80157cc <f_mount+0x58>
	cfs = FatFs[vol];					/* Pointer to fs object */
 801578e:	4b14      	ldr	r3, [pc, #80]	; (80157e0 <f_mount+0x6c>)
 8015790:	0080      	lsls	r0, r0, #2
 8015792:	181a      	adds	r2, r3, r0
 8015794:	6a12      	ldr	r2, [r2, #32]

	if (cfs) {
 8015796:	b15a      	cbz	r2, 80157b0 <f_mount+0x3c>
		if (Files[i].fs == fs) Files[i].fs = 0;
 8015798:	6819      	ldr	r1, [r3, #0]
 801579a:	428a      	cmp	r2, r1
 801579c:	bf04      	itt	eq
 801579e:	2100      	moveq	r1, #0
 80157a0:	6019      	streq	r1, [r3, #0]
 80157a2:	6919      	ldr	r1, [r3, #16]
 80157a4:	428a      	cmp	r2, r1
 80157a6:	bf04      	itt	eq
 80157a8:	2100      	moveq	r1, #0
 80157aa:	6119      	streq	r1, [r3, #16]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 80157ac:	2100      	movs	r1, #0
 80157ae:	7011      	strb	r1, [r2, #0]
	}

	if (fs) {
 80157b0:	9a01      	ldr	r2, [sp, #4]
		fs->fs_type = 0;				/* Clear new fs object */
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 80157b2:	4403      	add	r3, r0
	if (fs) {
 80157b4:	b132      	cbz	r2, 80157c4 <f_mount+0x50>
		fs->fs_type = 0;				/* Clear new fs object */
 80157b6:	2000      	movs	r0, #0

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 80157b8:	2c01      	cmp	r4, #1
		fs->fs_type = 0;				/* Clear new fs object */
 80157ba:	7010      	strb	r0, [r2, #0]
	FatFs[vol] = fs;					/* Register new fs object */
 80157bc:	621a      	str	r2, [r3, #32]
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 80157be:	d008      	beq.n	80157d2 <f_mount+0x5e>

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
 80157c0:	b004      	add	sp, #16
 80157c2:	bd10      	pop	{r4, pc}
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 80157c4:	4610      	mov	r0, r2
	FatFs[vol] = fs;					/* Register new fs object */
 80157c6:	621a      	str	r2, [r3, #32]
}
 80157c8:	b004      	add	sp, #16
 80157ca:	bd10      	pop	{r4, pc}
	if (vol < 0) return FR_INVALID_DRIVE;
 80157cc:	200b      	movs	r0, #11
}
 80157ce:	b004      	add	sp, #16
 80157d0:	bd10      	pop	{r4, pc}
	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 80157d2:	4602      	mov	r2, r0
 80157d4:	a901      	add	r1, sp, #4
 80157d6:	4668      	mov	r0, sp
 80157d8:	f7fe ff82 	bl	80146e0 <find_volume>
}
 80157dc:	b004      	add	sp, #16
 80157de:	bd10      	pop	{r4, pc}
 80157e0:	2000b690 	.word	0x2000b690

080157e4 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 80157e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80157e8:	b091      	sub	sp, #68	; 0x44
 80157ea:	9101      	str	r1, [sp, #4]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 80157ec:	2800      	cmp	r0, #0
 80157ee:	d046      	beq.n	801587e <f_open+0x9a>

	/* Get logical drive */
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 80157f0:	f002 063f 	and.w	r6, r2, #63	; 0x3f
 80157f4:	4604      	mov	r4, r0
 80157f6:	4690      	mov	r8, r2
	res = find_volume(&path, &fs, mode);
 80157f8:	a902      	add	r1, sp, #8
 80157fa:	4632      	mov	r2, r6
 80157fc:	a801      	add	r0, sp, #4
 80157fe:	f7fe ff6f 	bl	80146e0 <find_volume>
	if (res == FR_OK) {
 8015802:	4605      	mov	r5, r0
 8015804:	b128      	cbz	r0, 8015812 <f_open+0x2e>
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 8015806:	2300      	movs	r3, #0
 8015808:	6023      	str	r3, [r4, #0]

	LEAVE_FF(fs, res);
}
 801580a:	4628      	mov	r0, r5
 801580c:	b011      	add	sp, #68	; 0x44
 801580e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dj.obj.fs = fs;
 8015812:	9b02      	ldr	r3, [sp, #8]
 8015814:	9303      	str	r3, [sp, #12]
		INIT_NAMBUF(fs);
 8015816:	f44f 7000 	mov.w	r0, #512	; 0x200
 801581a:	f000 fc73 	bl	8016104 <ff_memalloc>
 801581e:	4607      	mov	r7, r0
 8015820:	b390      	cbz	r0, 8015888 <f_open+0xa4>
		res = follow_path(&dj, path);	/* Follow the file path */
 8015822:	e9dd 1301 	ldrd	r1, r3, [sp, #4]
		INIT_NAMBUF(fs);
 8015826:	60d8      	str	r0, [r3, #12]
		res = follow_path(&dj, path);	/* Follow the file path */
 8015828:	a803      	add	r0, sp, #12
 801582a:	f7ff fca3 	bl	8015174 <follow_path>
 801582e:	f008 0a1c 	and.w	sl, r8, #28
		if (res == FR_OK) {
 8015832:	4681      	mov	r9, r0
 8015834:	bb50      	cbnz	r0, 801588c <f_open+0xa8>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 8015836:	f99d 303b 	ldrsb.w	r3, [sp, #59]	; 0x3b
 801583a:	2b00      	cmp	r3, #0
 801583c:	f2c0 80a5 	blt.w	801598a <f_open+0x1a6>
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 8015840:	f016 0f3e 	tst.w	r6, #62	; 0x3e
 8015844:	bf14      	ite	ne
 8015846:	f04f 0b01 	movne.w	fp, #1
 801584a:	f04f 0b00 	moveq.w	fp, #0
 801584e:	4659      	mov	r1, fp
 8015850:	a803      	add	r0, sp, #12
 8015852:	f7fe fd79 	bl	8014348 <chk_lock>
 8015856:	4681      	mov	r9, r0
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8015858:	f1ba 0f00 	cmp.w	sl, #0
 801585c:	d01e      	beq.n	801589c <f_open+0xb8>
			if (res != FR_OK) {					/* No file, create new */
 801585e:	2800      	cmp	r0, #0
 8015860:	f040 8096 	bne.w	8015990 <f_open+0x1ac>
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 8015864:	f89d 3012 	ldrb.w	r3, [sp, #18]
 8015868:	f013 0f11 	tst.w	r3, #17
 801586c:	f040 80f4 	bne.w	8015a58 <f_open+0x274>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 8015870:	f018 0f04 	tst.w	r8, #4
 8015874:	f000 80f6 	beq.w	8015a64 <f_open+0x280>
 8015878:	f04f 0908 	mov.w	r9, #8
 801587c:	e009      	b.n	8015892 <f_open+0xae>
	if (!fp) return FR_INVALID_OBJECT;
 801587e:	2509      	movs	r5, #9
}
 8015880:	4628      	mov	r0, r5
 8015882:	b011      	add	sp, #68	; 0x44
 8015884:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		INIT_NAMBUF(fs);
 8015888:	2511      	movs	r5, #17
 801588a:	e7be      	b.n	801580a <f_open+0x26>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 801588c:	f1ba 0f00 	cmp.w	sl, #0
 8015890:	d17e      	bne.n	8015990 <f_open+0x1ac>
		FREE_NAMBUF();
 8015892:	4638      	mov	r0, r7
 8015894:	f000 fc38 	bl	8016108 <ff_memfree>
 8015898:	464d      	mov	r5, r9
 801589a:	e7b4      	b.n	8015806 <f_open+0x22>
			if (res == FR_OK) {					/* Following succeeded */
 801589c:	2800      	cmp	r0, #0
 801589e:	d1f8      	bne.n	8015892 <f_open+0xae>
				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
 80158a0:	f89d 3012 	ldrb.w	r3, [sp, #18]
 80158a4:	06d8      	lsls	r0, r3, #27
 80158a6:	f100 80d2 	bmi.w	8015a4e <f_open+0x26a>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
 80158aa:	f018 0f02 	tst.w	r8, #2
 80158ae:	d006      	beq.n	80158be <f_open+0xda>
 80158b0:	07d9      	lsls	r1, r3, #31
 80158b2:	d504      	bpl.n	80158be <f_open+0xda>
		FREE_NAMBUF();
 80158b4:	4638      	mov	r0, r7
 80158b6:	f000 fc27 	bl	8016108 <ff_memfree>
						res = FR_DENIED;
 80158ba:	2507      	movs	r5, #7
 80158bc:	e7a3      	b.n	8015806 <f_open+0x22>
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 80158be:	f018 0f08 	tst.w	r8, #8
 80158c2:	9b02      	ldr	r3, [sp, #8]
 80158c4:	d003      	beq.n	80158ce <f_open+0xea>
				mode |= FA_MODIFIED;
 80158c6:	f046 0640 	orr.w	r6, r6, #64	; 0x40
 80158ca:	f04f 0b01 	mov.w	fp, #1
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 80158ce:	6b1a      	ldr	r2, [r3, #48]	; 0x30
			fp->dir_ptr = dj.dir;
 80158d0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 80158d2:	6262      	str	r2, [r4, #36]	; 0x24
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 80158d4:	4659      	mov	r1, fp
 80158d6:	a803      	add	r0, sp, #12
			fp->dir_ptr = dj.dir;
 80158d8:	62a3      	str	r3, [r4, #40]	; 0x28
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 80158da:	f7fe fd75 	bl	80143c8 <inc_lock>
 80158de:	6120      	str	r0, [r4, #16]
			if (!fp->obj.lockid) res = FR_INT_ERR;
 80158e0:	b920      	cbnz	r0, 80158ec <f_open+0x108>
		FREE_NAMBUF();
 80158e2:	4638      	mov	r0, r7
 80158e4:	f000 fc10 	bl	8016108 <ff_memfree>
						res = FR_INT_ERR;
 80158e8:	2502      	movs	r5, #2
 80158ea:	e78c      	b.n	8015806 <f_open+0x22>
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 80158ec:	9802      	ldr	r0, [sp, #8]
 80158ee:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	if (fs->fs_type == FS_FAT32) {
 80158f0:	7801      	ldrb	r1, [r0, #0]
	rv = rv << 8 | ptr[0];
 80158f2:	f893 c01b 	ldrb.w	ip, [r3, #27]
 80158f6:	7e9a      	ldrb	r2, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 80158f8:	2903      	cmp	r1, #3
	cl = ld_word(dir + DIR_FstClusLO);
 80158fa:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
	if (fs->fs_type == FS_FAT32) {
 80158fe:	d106      	bne.n	801590e <f_open+0x12a>
	rv = rv << 8 | ptr[0];
 8015900:	f893 c015 	ldrb.w	ip, [r3, #21]
 8015904:	7d19      	ldrb	r1, [r3, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8015906:	ea41 210c 	orr.w	r1, r1, ip, lsl #8
 801590a:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 801590e:	60a2      	str	r2, [r4, #8]
	rv = rv << 8 | ptr[2];
 8015910:	f8b3 c01e 	ldrh.w	ip, [r3, #30]
	rv = rv << 8 | ptr[1];
 8015914:	7f5a      	ldrb	r2, [r3, #29]
	rv = rv << 8 | ptr[0];
 8015916:	7f1b      	ldrb	r3, [r3, #28]
			fp->obj.id = fs->id;
 8015918:	88c1      	ldrh	r1, [r0, #6]
 801591a:	80a1      	strh	r1, [r4, #4]
	rv = rv << 8 | ptr[1];
 801591c:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
	rv = rv << 8 | ptr[0];
 8015920:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
 8015924:	f104 0830 	add.w	r8, r4, #48	; 0x30
			fp->cltbl = 0;			/* Disable fast seek mode */
 8015928:	2200      	movs	r2, #0
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 801592a:	60e3      	str	r3, [r4, #12]
			fp->obj.fs = fs;	 	/* Validate the file object */
 801592c:	6020      	str	r0, [r4, #0]
			fp->cltbl = 0;			/* Disable fast seek mode */
 801592e:	62e2      	str	r2, [r4, #44]	; 0x2c
			fp->err = 0;			/* Clear error flag */
 8015930:	7562      	strb	r2, [r4, #21]
			fp->sect = 0;			/* Invalidate current data sector */
 8015932:	6222      	str	r2, [r4, #32]
			fp->fptr = 0;			/* Set file pointer top of the file */
 8015934:	61a2      	str	r2, [r4, #24]
			fp->flag = mode;		/* Set file access mode */
 8015936:	7526      	strb	r6, [r4, #20]
	BYTE *d = (BYTE*)dst;
 8015938:	4643      	mov	r3, r8
 801593a:	f504 710c 	add.w	r1, r4, #560	; 0x230
		*d++ = (BYTE)val;
 801593e:	f803 2b01 	strb.w	r2, [r3], #1
	} while (--cnt);
 8015942:	428b      	cmp	r3, r1
 8015944:	d1fb      	bne.n	801593e <f_open+0x15a>
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 8015946:	06b2      	lsls	r2, r6, #26
 8015948:	d51b      	bpl.n	8015982 <f_open+0x19e>
 801594a:	68e6      	ldr	r6, [r4, #12]
 801594c:	b1ce      	cbz	r6, 8015982 <f_open+0x19e>
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 801594e:	f8b0 900a 	ldrh.w	r9, [r0, #10]
				clst = fp->obj.sclust;				/* Follow the cluster chain */
 8015952:	68a1      	ldr	r1, [r4, #8]
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 8015954:	61a6      	str	r6, [r4, #24]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 8015956:	ea4f 2949 	mov.w	r9, r9, lsl #9
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 801595a:	454e      	cmp	r6, r9
 801595c:	d805      	bhi.n	801596a <f_open+0x186>
 801595e:	e086      	b.n	8015a6e <f_open+0x28a>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 8015960:	1c43      	adds	r3, r0, #1
 8015962:	d07c      	beq.n	8015a5e <f_open+0x27a>
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8015964:	45b1      	cmp	r9, r6
 8015966:	f080 8082 	bcs.w	8015a6e <f_open+0x28a>
					clst = get_fat(&fp->obj, clst);
 801596a:	6820      	ldr	r0, [r4, #0]
 801596c:	f7ff f8fc 	bl	8014b68 <get_fat.isra.8>
					if (clst <= 1) res = FR_INT_ERR;
 8015970:	2801      	cmp	r0, #1
					clst = get_fat(&fp->obj, clst);
 8015972:	4601      	mov	r1, r0
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8015974:	eba6 0609 	sub.w	r6, r6, r9
					if (clst <= 1) res = FR_INT_ERR;
 8015978:	d8f2      	bhi.n	8015960 <f_open+0x17c>
 801597a:	f04f 0902 	mov.w	r9, #2
				fp->clust = clst;
 801597e:	61e1      	str	r1, [r4, #28]
 8015980:	e787      	b.n	8015892 <f_open+0xae>
		FREE_NAMBUF();
 8015982:	4638      	mov	r0, r7
 8015984:	f000 fbc0 	bl	8016108 <ff_memfree>
 8015988:	e73f      	b.n	801580a <f_open+0x26>
				res = FR_INVALID_NAME;
 801598a:	f04f 0906 	mov.w	r9, #6
 801598e:	e780      	b.n	8015892 <f_open+0xae>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 8015990:	f1b9 0f04 	cmp.w	r9, #4
 8015994:	f47f af7d 	bne.w	8015892 <f_open+0xae>
	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8015998:	4b51      	ldr	r3, [pc, #324]	; (8015ae0 <f_open+0x2fc>)
 801599a:	681a      	ldr	r2, [r3, #0]
 801599c:	b12a      	cbz	r2, 80159aa <f_open+0x1c6>
 801599e:	691b      	ldr	r3, [r3, #16]
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 80159a0:	f04f 0912 	mov.w	r9, #18
	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 80159a4:	2b00      	cmp	r3, #0
 80159a6:	f47f af74 	bne.w	8015892 <f_open+0xae>
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 80159aa:	a803      	add	r0, sp, #12
 80159ac:	f7ff fd4c 	bl	8015448 <dir_register>
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 80159b0:	f046 0608 	orr.w	r6, r6, #8
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 80159b4:	4681      	mov	r9, r0
 80159b6:	2800      	cmp	r0, #0
 80159b8:	f47f af6b 	bne.w	8015892 <f_open+0xae>
				dw = GET_FATTIME();
 80159bc:	f7fe fcc2 	bl	8014344 <get_fattime>
					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
 80159c0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 80159c2:	9b02      	ldr	r3, [sp, #8]
	*ptr++ = (BYTE)val; val >>= 8;
 80159c4:	f3c0 4107 	ubfx	r1, r0, #16, #8
	*ptr++ = (BYTE)val; val >>= 8;
 80159c8:	fa5f fe80 	uxtb.w	lr, r0
	*ptr++ = (BYTE)val; val >>= 8;
 80159cc:	f3c0 2c07 	ubfx	ip, r0, #8, #8
	*ptr++ = (BYTE)val;
 80159d0:	0e00      	lsrs	r0, r0, #24
	*ptr++ = (BYTE)val; val >>= 8;
 80159d2:	7411      	strb	r1, [r2, #16]
	*ptr++ = (BYTE)val;
 80159d4:	7450      	strb	r0, [r2, #17]
	*ptr++ = (BYTE)val; val >>= 8;
 80159d6:	f882 e00e 	strb.w	lr, [r2, #14]
	*ptr++ = (BYTE)val; val >>= 8;
 80159da:	f882 c00f 	strb.w	ip, [r2, #15]
					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
 80159de:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	*ptr++ = (BYTE)val; val >>= 8;
 80159e0:	7611      	strb	r1, [r2, #24]
	*ptr++ = (BYTE)val;
 80159e2:	7650      	strb	r0, [r2, #25]
	*ptr++ = (BYTE)val; val >>= 8;
 80159e4:	f882 e016 	strb.w	lr, [r2, #22]
	*ptr++ = (BYTE)val; val >>= 8;
 80159e8:	f882 c017 	strb.w	ip, [r2, #23]
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 80159ec:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80159ee:	2120      	movs	r1, #32
 80159f0:	72d1      	strb	r1, [r2, #11]
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 80159f2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	if (fs->fs_type == FS_FAT32) {
 80159f4:	7819      	ldrb	r1, [r3, #0]
	rv = rv << 8 | ptr[0];
 80159f6:	7ed0      	ldrb	r0, [r2, #27]
 80159f8:	f892 801a 	ldrb.w	r8, [r2, #26]
	if (fs->fs_type == FS_FAT32) {
 80159fc:	2903      	cmp	r1, #3
	cl = ld_word(dir + DIR_FstClusLO);
 80159fe:	ea48 2800 	orr.w	r8, r8, r0, lsl #8
	if (fs->fs_type == FS_FAT32) {
 8015a02:	d05a      	beq.n	8015aba <f_open+0x2d6>
	*ptr++ = (BYTE)val; val >>= 8;
 8015a04:	2100      	movs	r1, #0
 8015a06:	7691      	strb	r1, [r2, #26]
	*ptr++ = (BYTE)val;
 8015a08:	76d1      	strb	r1, [r2, #27]
	if (fs->fs_type == FS_FAT32) {
 8015a0a:	7818      	ldrb	r0, [r3, #0]
 8015a0c:	2803      	cmp	r0, #3
 8015a0e:	d051      	beq.n	8015ab4 <f_open+0x2d0>
					st_dword(dj.dir + DIR_FileSize, 0);
 8015a10:	990b      	ldr	r1, [sp, #44]	; 0x2c
	*ptr++ = (BYTE)val; val >>= 8;
 8015a12:	2200      	movs	r2, #0
					fs->wflag = 1;
 8015a14:	2001      	movs	r0, #1
	*ptr++ = (BYTE)val; val >>= 8;
 8015a16:	770a      	strb	r2, [r1, #28]
	*ptr++ = (BYTE)val; val >>= 8;
 8015a18:	774a      	strb	r2, [r1, #29]
	*ptr++ = (BYTE)val; val >>= 8;
 8015a1a:	778a      	strb	r2, [r1, #30]
	*ptr++ = (BYTE)val;
 8015a1c:	77ca      	strb	r2, [r1, #31]
					fs->wflag = 1;
 8015a1e:	70d8      	strb	r0, [r3, #3]
					if (cl) {							/* Remove the cluster chain if exist */
 8015a20:	f1b8 0f00 	cmp.w	r8, #0
 8015a24:	f43f af4f 	beq.w	80158c6 <f_open+0xe2>
						res = remove_chain(&dj.obj, cl, 0);
 8015a28:	4641      	mov	r1, r8
 8015a2a:	a803      	add	r0, sp, #12
						dw = fs->winsect;
 8015a2c:	f8d3 a030 	ldr.w	sl, [r3, #48]	; 0x30
						res = remove_chain(&dj.obj, cl, 0);
 8015a30:	f7ff f9c4 	bl	8014dbc <remove_chain>
						if (res == FR_OK) {
 8015a34:	4681      	mov	r9, r0
 8015a36:	2800      	cmp	r0, #0
 8015a38:	f47f af2b 	bne.w	8015892 <f_open+0xae>
							res = move_window(fs, dw);
 8015a3c:	9b02      	ldr	r3, [sp, #8]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8015a3e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8015a40:	4592      	cmp	sl, r2
 8015a42:	f108 38ff 	add.w	r8, r8, #4294967295
 8015a46:	d13f      	bne.n	8015ac8 <f_open+0x2e4>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 8015a48:	f8c3 8010 	str.w	r8, [r3, #16]
 8015a4c:	e73b      	b.n	80158c6 <f_open+0xe2>
		FREE_NAMBUF();
 8015a4e:	4638      	mov	r0, r7
 8015a50:	f000 fb5a 	bl	8016108 <ff_memfree>
					res = FR_NO_FILE;
 8015a54:	2504      	movs	r5, #4
 8015a56:	e6d6      	b.n	8015806 <f_open+0x22>
					res = FR_DENIED;
 8015a58:	f04f 0907 	mov.w	r9, #7
 8015a5c:	e719      	b.n	8015892 <f_open+0xae>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 8015a5e:	f04f 0901 	mov.w	r9, #1
 8015a62:	e78c      	b.n	801597e <f_open+0x19a>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 8015a64:	f018 0f08 	tst.w	r8, #8
 8015a68:	d1a8      	bne.n	80159bc <f_open+0x1d8>
 8015a6a:	9b02      	ldr	r3, [sp, #8]
 8015a6c:	e72f      	b.n	80158ce <f_open+0xea>
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 8015a6e:	f3c6 0308 	ubfx	r3, r6, #0, #9
				fp->clust = clst;
 8015a72:	61e1      	str	r1, [r4, #28]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 8015a74:	2b00      	cmp	r3, #0
 8015a76:	d084      	beq.n	8015982 <f_open+0x19e>
					if ((sc = clust2sect(fs, clst)) == 0) {
 8015a78:	9802      	ldr	r0, [sp, #8]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8015a7a:	6983      	ldr	r3, [r0, #24]
	clst -= 2;
 8015a7c:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8015a7e:	3b02      	subs	r3, #2
 8015a80:	4299      	cmp	r1, r3
 8015a82:	f4bf af2e 	bcs.w	80158e2 <f_open+0xfe>
	return clst * fs->csize + fs->database;
 8015a86:	8942      	ldrh	r2, [r0, #10]
 8015a88:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8015a8a:	fb01 3202 	mla	r2, r1, r2, r3
					if ((sc = clust2sect(fs, clst)) == 0) {
 8015a8e:	2a00      	cmp	r2, #0
 8015a90:	f43f af27 	beq.w	80158e2 <f_open+0xfe>
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 8015a94:	eb02 2256 	add.w	r2, r2, r6, lsr #9
 8015a98:	6222      	str	r2, [r4, #32]
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 8015a9a:	7840      	ldrb	r0, [r0, #1]
 8015a9c:	4641      	mov	r1, r8
 8015a9e:	2301      	movs	r3, #1
 8015aa0:	f7fe fc26 	bl	80142f0 <disk_read>
 8015aa4:	2800      	cmp	r0, #0
 8015aa6:	f43f af6c 	beq.w	8015982 <f_open+0x19e>
		FREE_NAMBUF();
 8015aaa:	4638      	mov	r0, r7
 8015aac:	f000 fb2c 	bl	8016108 <ff_memfree>
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 8015ab0:	2501      	movs	r5, #1
 8015ab2:	e6a8      	b.n	8015806 <f_open+0x22>
	*ptr++ = (BYTE)val; val >>= 8;
 8015ab4:	7511      	strb	r1, [r2, #20]
	*ptr++ = (BYTE)val;
 8015ab6:	7551      	strb	r1, [r2, #21]
 8015ab8:	e7aa      	b.n	8015a10 <f_open+0x22c>
	rv = rv << 8 | ptr[0];
 8015aba:	7d50      	ldrb	r0, [r2, #21]
 8015abc:	7d11      	ldrb	r1, [r2, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8015abe:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 8015ac2:	ea48 4801 	orr.w	r8, r8, r1, lsl #16
 8015ac6:	e79d      	b.n	8015a04 <f_open+0x220>
 8015ac8:	4618      	mov	r0, r3
 8015aca:	4651      	mov	r1, sl
 8015acc:	f7fe fda2 	bl	8014614 <move_window.part.5>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 8015ad0:	9b02      	ldr	r3, [sp, #8]
		if (res == FR_OK) {
 8015ad2:	4681      	mov	r9, r0
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 8015ad4:	f8c3 8010 	str.w	r8, [r3, #16]
		if (res == FR_OK) {
 8015ad8:	2800      	cmp	r0, #0
 8015ada:	f43f aef4 	beq.w	80158c6 <f_open+0xe2>
 8015ade:	e6d8      	b.n	8015892 <f_open+0xae>
 8015ae0:	2000b690 	.word	0x2000b690

08015ae4 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 8015ae4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015ae8:	469a      	mov	sl, r3
 8015aea:	b085      	sub	sp, #20
	DWORD clst, sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;


	*bw = 0;	/* Clear write byte counter */
 8015aec:	2300      	movs	r3, #0
{
 8015aee:	468b      	mov	fp, r1
	*bw = 0;	/* Clear write byte counter */
 8015af0:	f8ca 3000 	str.w	r3, [sl]
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 8015af4:	a903      	add	r1, sp, #12
{
 8015af6:	4616      	mov	r6, r2
 8015af8:	4604      	mov	r4, r0
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 8015afa:	f7fe fcd9 	bl	80144b0 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8015afe:	4680      	mov	r8, r0
 8015b00:	2800      	cmp	r0, #0
 8015b02:	d155      	bne.n	8015bb0 <f_write+0xcc>
 8015b04:	f894 8015 	ldrb.w	r8, [r4, #21]
 8015b08:	f1b8 0f00 	cmp.w	r8, #0
 8015b0c:	d150      	bne.n	8015bb0 <f_write+0xcc>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8015b0e:	7d22      	ldrb	r2, [r4, #20]
 8015b10:	0791      	lsls	r1, r2, #30
 8015b12:	f140 80a4 	bpl.w	8015c5e <f_write+0x17a>

	/* Check fptr wrap-around (file size cannot reach 4GiB on FATxx) */
	if ((!_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 8015b16:	69a3      	ldr	r3, [r4, #24]
 8015b18:	42f3      	cmn	r3, r6
 8015b1a:	d300      	bcc.n	8015b1e <f_write+0x3a>
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 8015b1c:	43de      	mvns	r6, r3
	}

	for ( ;  btw;							/* Repeat until all data written */
 8015b1e:	2e00      	cmp	r6, #0
 8015b20:	d074      	beq.n	8015c0c <f_write+0x128>
 8015b22:	f104 0230 	add.w	r2, r4, #48	; 0x30
 8015b26:	9201      	str	r2, [sp, #4]
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 8015b28:	f3c3 0008 	ubfx	r0, r3, #0, #9
 8015b2c:	2800      	cmp	r0, #0
 8015b2e:	d14d      	bne.n	8015bcc <f_write+0xe8>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 8015b30:	9a03      	ldr	r2, [sp, #12]
 8015b32:	f8b2 900a 	ldrh.w	r9, [r2, #10]
 8015b36:	0a58      	lsrs	r0, r3, #9
 8015b38:	f109 39ff 	add.w	r9, r9, #4294967295
			if (csect == 0) {				/* On the cluster boundary? */
 8015b3c:	ea19 0900 	ands.w	r9, r9, r0
 8015b40:	d10f      	bne.n	8015b62 <f_write+0x7e>
				if (fp->fptr == 0) {		/* On the top of the file? */
 8015b42:	2b00      	cmp	r3, #0
 8015b44:	d166      	bne.n	8015c14 <f_write+0x130>
					clst = fp->obj.sclust;	/* Follow from the origin */
 8015b46:	68a0      	ldr	r0, [r4, #8]
					if (clst == 0) {		/* If no cluster is allocated, */
 8015b48:	2800      	cmp	r0, #0
 8015b4a:	f000 809b 	beq.w	8015c84 <f_write+0x1a0>
					{
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
					}
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 8015b4e:	2801      	cmp	r0, #1
 8015b50:	f000 80b4 	beq.w	8015cbc <f_write+0x1d8>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8015b54:	1c43      	adds	r3, r0, #1
 8015b56:	d027      	beq.n	8015ba8 <f_write+0xc4>
				fp->clust = clst;			/* Update current cluster */
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 8015b58:	68a3      	ldr	r3, [r4, #8]
				fp->clust = clst;			/* Update current cluster */
 8015b5a:	61e0      	str	r0, [r4, #28]
 8015b5c:	9a03      	ldr	r2, [sp, #12]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 8015b5e:	b903      	cbnz	r3, 8015b62 <f_write+0x7e>
 8015b60:	60a0      	str	r0, [r4, #8]
			}
#if _FS_TINY
			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
#else
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 8015b62:	f994 3014 	ldrsb.w	r3, [r4, #20]
 8015b66:	2b00      	cmp	r3, #0
 8015b68:	db6b      	blt.n	8015c42 <f_write+0x15e>
	clst -= 2;
 8015b6a:	69e7      	ldr	r7, [r4, #28]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8015b6c:	6993      	ldr	r3, [r2, #24]
	clst -= 2;
 8015b6e:	3f02      	subs	r7, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8015b70:	3b02      	subs	r3, #2
 8015b72:	429f      	cmp	r7, r3
 8015b74:	f080 80a2 	bcs.w	8015cbc <f_write+0x1d8>
	return clst * fs->csize + fs->database;
 8015b78:	8953      	ldrh	r3, [r2, #10]
 8015b7a:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8015b7c:	fb03 1707 	mla	r7, r3, r7, r1
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
				fp->flag &= (BYTE)~FA_DIRTY;
			}
#endif
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fs, FR_INT_ERR);
 8015b80:	2f00      	cmp	r7, #0
 8015b82:	f000 809b 	beq.w	8015cbc <f_write+0x1d8>
			sect += csect;
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
 8015b86:	0a75      	lsrs	r5, r6, #9
			sect += csect;
 8015b88:	444f      	add	r7, r9
			if (cc) {						/* Write maximum contiguous sectors directly */
 8015b8a:	d015      	beq.n	8015bb8 <f_write+0xd4>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8015b8c:	eb09 0105 	add.w	r1, r9, r5
 8015b90:	4299      	cmp	r1, r3
					cc = fs->csize - csect;
 8015b92:	bf88      	it	hi
 8015b94:	eba3 0509 	subhi.w	r5, r3, r9
				}
				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8015b98:	7850      	ldrb	r0, [r2, #1]
 8015b9a:	462b      	mov	r3, r5
 8015b9c:	463a      	mov	r2, r7
 8015b9e:	4659      	mov	r1, fp
 8015ba0:	f7fe fbb4 	bl	801430c <disk_write>
 8015ba4:	2800      	cmp	r0, #0
 8015ba6:	d05d      	beq.n	8015c64 <f_write+0x180>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8015ba8:	f04f 0801 	mov.w	r8, #1
 8015bac:	f884 8015 	strb.w	r8, [r4, #21]
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */

	LEAVE_FF(fs, FR_OK);
}
 8015bb0:	4640      	mov	r0, r8
 8015bb2:	b005      	add	sp, #20
 8015bb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 8015bb8:	6a23      	ldr	r3, [r4, #32]
 8015bba:	69a0      	ldr	r0, [r4, #24]
 8015bbc:	42bb      	cmp	r3, r7
 8015bbe:	d002      	beq.n	8015bc6 <f_write+0xe2>
 8015bc0:	68e3      	ldr	r3, [r4, #12]
 8015bc2:	4283      	cmp	r3, r0
 8015bc4:	d854      	bhi.n	8015c70 <f_write+0x18c>
			fp->sect = sect;
 8015bc6:	6227      	str	r7, [r4, #32]
 8015bc8:	f3c0 0008 	ubfx	r0, r0, #0, #9
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 8015bcc:	f5c0 7500 	rsb	r5, r0, #512	; 0x200
 8015bd0:	9b01      	ldr	r3, [sp, #4]
 8015bd2:	42b5      	cmp	r5, r6
 8015bd4:	bf28      	it	cs
 8015bd6:	4635      	movcs	r5, r6
 8015bd8:	4418      	add	r0, r3
 8015bda:	462a      	mov	r2, r5
 8015bdc:	4659      	mov	r1, fp
 8015bde:	f7fe fc89 	bl	80144f4 <mem_cpy.part.0>
		fp->flag |= FA_DIRTY;
 8015be2:	7d23      	ldrb	r3, [r4, #20]
 8015be4:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8015be8:	7523      	strb	r3, [r4, #20]
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
 8015bea:	69a3      	ldr	r3, [r4, #24]
 8015bec:	68e1      	ldr	r1, [r4, #12]
 8015bee:	f8da 2000 	ldr.w	r2, [sl]
 8015bf2:	442b      	add	r3, r5
 8015bf4:	4299      	cmp	r1, r3
 8015bf6:	bf38      	it	cc
 8015bf8:	4619      	movcc	r1, r3
 8015bfa:	442a      	add	r2, r5
	for ( ;  btw;							/* Repeat until all data written */
 8015bfc:	1b76      	subs	r6, r6, r5
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
 8015bfe:	61a3      	str	r3, [r4, #24]
 8015c00:	60e1      	str	r1, [r4, #12]
 8015c02:	44ab      	add	fp, r5
 8015c04:	f8ca 2000 	str.w	r2, [sl]
	for ( ;  btw;							/* Repeat until all data written */
 8015c08:	d18e      	bne.n	8015b28 <f_write+0x44>
 8015c0a:	7d22      	ldrb	r2, [r4, #20]
	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 8015c0c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8015c10:	7522      	strb	r2, [r4, #20]
	LEAVE_FF(fs, FR_OK);
 8015c12:	e7cd      	b.n	8015bb0 <f_write+0xcc>
					if (fp->cltbl) {
 8015c14:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8015c16:	2a00      	cmp	r2, #0
 8015c18:	d03c      	beq.n	8015c94 <f_write+0x1b0>
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8015c1a:	6821      	ldr	r1, [r4, #0]
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8015c1c:	6853      	ldr	r3, [r2, #4]
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8015c1e:	8949      	ldrh	r1, [r1, #10]
 8015c20:	fbb0 f0f1 	udiv	r0, r0, r1
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8015c24:	3204      	adds	r2, #4
		if (ncl == 0) return 0;	/* End of table? (error) */
 8015c26:	b92b      	cbnz	r3, 8015c34 <f_write+0x150>
 8015c28:	e7ef      	b.n	8015c0a <f_write+0x126>
		cl -= ncl; tbl++;		/* Next fragment */
 8015c2a:	1ac0      	subs	r0, r0, r3
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8015c2c:	f852 3f08 	ldr.w	r3, [r2, #8]!
		if (ncl == 0) return 0;	/* End of table? (error) */
 8015c30:	2b00      	cmp	r3, #0
 8015c32:	d0ea      	beq.n	8015c0a <f_write+0x126>
		if (cl < ncl) break;	/* In this fragment? */
 8015c34:	4283      	cmp	r3, r0
 8015c36:	d9f8      	bls.n	8015c2a <f_write+0x146>
	return cl + *tbl;	/* Return the cluster number */
 8015c38:	6853      	ldr	r3, [r2, #4]
 8015c3a:	4418      	add	r0, r3
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8015c3c:	2800      	cmp	r0, #0
 8015c3e:	d186      	bne.n	8015b4e <f_write+0x6a>
 8015c40:	e7e3      	b.n	8015c0a <f_write+0x126>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8015c42:	7850      	ldrb	r0, [r2, #1]
 8015c44:	9901      	ldr	r1, [sp, #4]
 8015c46:	6a22      	ldr	r2, [r4, #32]
 8015c48:	2301      	movs	r3, #1
 8015c4a:	f7fe fb5f 	bl	801430c <disk_write>
 8015c4e:	2800      	cmp	r0, #0
 8015c50:	d1aa      	bne.n	8015ba8 <f_write+0xc4>
				fp->flag &= (BYTE)~FA_DIRTY;
 8015c52:	7d23      	ldrb	r3, [r4, #20]
 8015c54:	9a03      	ldr	r2, [sp, #12]
 8015c56:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015c5a:	7523      	strb	r3, [r4, #20]
 8015c5c:	e785      	b.n	8015b6a <f_write+0x86>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8015c5e:	f04f 0807 	mov.w	r8, #7
 8015c62:	e7a5      	b.n	8015bb0 <f_write+0xcc>
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 8015c64:	6a21      	ldr	r1, [r4, #32]
 8015c66:	1bc9      	subs	r1, r1, r7
 8015c68:	42a9      	cmp	r1, r5
 8015c6a:	d31b      	bcc.n	8015ca4 <f_write+0x1c0>
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 8015c6c:	026d      	lsls	r5, r5, #9
				continue;
 8015c6e:	e7bc      	b.n	8015bea <f_write+0x106>
				disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
 8015c70:	7850      	ldrb	r0, [r2, #1]
 8015c72:	9901      	ldr	r1, [sp, #4]
 8015c74:	2301      	movs	r3, #1
 8015c76:	463a      	mov	r2, r7
 8015c78:	f7fe fb3a 	bl	80142f0 <disk_read>
				fp->fptr < fp->obj.objsize &&
 8015c7c:	2800      	cmp	r0, #0
 8015c7e:	d193      	bne.n	8015ba8 <f_write+0xc4>
 8015c80:	69a0      	ldr	r0, [r4, #24]
 8015c82:	e7a0      	b.n	8015bc6 <f_write+0xe2>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
 8015c84:	4649      	mov	r1, r9
 8015c86:	4620      	mov	r0, r4
 8015c88:	f7ff f830 	bl	8014cec <create_chain>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8015c8c:	2800      	cmp	r0, #0
 8015c8e:	f47f af5e 	bne.w	8015b4e <f_write+0x6a>
 8015c92:	e7ba      	b.n	8015c0a <f_write+0x126>
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 8015c94:	69e1      	ldr	r1, [r4, #28]
 8015c96:	4620      	mov	r0, r4
 8015c98:	f7ff f828 	bl	8014cec <create_chain>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8015c9c:	2800      	cmp	r0, #0
 8015c9e:	f47f af56 	bne.w	8015b4e <f_write+0x6a>
 8015ca2:	e7b2      	b.n	8015c0a <f_write+0x126>
 8015ca4:	eb0b 2141 	add.w	r1, fp, r1, lsl #9
 8015ca8:	f44f 7200 	mov.w	r2, #512	; 0x200
 8015cac:	9801      	ldr	r0, [sp, #4]
 8015cae:	f7fe fc21 	bl	80144f4 <mem_cpy.part.0>
					fp->flag &= (BYTE)~FA_DIRTY;
 8015cb2:	7d23      	ldrb	r3, [r4, #20]
 8015cb4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015cb8:	7523      	strb	r3, [r4, #20]
 8015cba:	e7d7      	b.n	8015c6c <f_write+0x188>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 8015cbc:	f04f 0802 	mov.w	r8, #2
 8015cc0:	f884 8015 	strb.w	r8, [r4, #21]
 8015cc4:	e774      	b.n	8015bb0 <f_write+0xcc>
 8015cc6:	bf00      	nop

08015cc8 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 8015cc8:	b570      	push	{r4, r5, r6, lr}
 8015cca:	b082      	sub	sp, #8
#if _FS_EXFAT
	DIR dj;
	DEF_NAMBUF
#endif

	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 8015ccc:	a901      	add	r1, sp, #4
{
 8015cce:	4604      	mov	r4, r0
	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 8015cd0:	f7fe fbee 	bl	80144b0 <validate>
	if (res == FR_OK) {
 8015cd4:	2800      	cmp	r0, #0
 8015cd6:	d139      	bne.n	8015d4c <f_sync+0x84>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 8015cd8:	7d23      	ldrb	r3, [r4, #20]
 8015cda:	065a      	lsls	r2, r3, #25
 8015cdc:	d536      	bpl.n	8015d4c <f_sync+0x84>
#if !_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 8015cde:	061b      	lsls	r3, r3, #24
 8015ce0:	d43d      	bmi.n	8015d5e <f_sync+0x96>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
				fp->flag &= (BYTE)~FA_DIRTY;
			}
#endif
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
 8015ce2:	f7fe fb2f 	bl	8014344 <get_fattime>
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
 8015ce6:	9e01      	ldr	r6, [sp, #4]
 8015ce8:	6a61      	ldr	r1, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8015cea:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8015cec:	4299      	cmp	r1, r3
			tm = GET_FATTIME();				/* Modified time */
 8015cee:	4605      	mov	r5, r0
	if (sector != fs->winsect) {	/* Window offset changed? */
 8015cf0:	d12e      	bne.n	8015d50 <f_sync+0x88>
				if (res == FR_OK) {
					dir = fp->dir_ptr;
 8015cf2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
 8015cf4:	7ada      	ldrb	r2, [r3, #11]
 8015cf6:	f042 0220 	orr.w	r2, r2, #32
 8015cfa:	72da      	strb	r2, [r3, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
 8015cfc:	68a2      	ldr	r2, [r4, #8]
 8015cfe:	6821      	ldr	r1, [r4, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 8015d00:	769a      	strb	r2, [r3, #26]
 8015d02:	f3c2 2007 	ubfx	r0, r2, #8, #8
	*ptr++ = (BYTE)val;
 8015d06:	76d8      	strb	r0, [r3, #27]
	if (fs->fs_type == FS_FAT32) {
 8015d08:	7809      	ldrb	r1, [r1, #0]
 8015d0a:	2903      	cmp	r1, #3
 8015d0c:	d103      	bne.n	8015d16 <f_sync+0x4e>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 8015d0e:	0c12      	lsrs	r2, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8015d10:	0a11      	lsrs	r1, r2, #8
 8015d12:	751a      	strb	r2, [r3, #20]
	*ptr++ = (BYTE)val;
 8015d14:	7559      	strb	r1, [r3, #21]
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 8015d16:	68e2      	ldr	r2, [r4, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 8015d18:	771a      	strb	r2, [r3, #28]
 8015d1a:	0a11      	lsrs	r1, r2, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8015d1c:	7759      	strb	r1, [r3, #29]
 8015d1e:	0c10      	lsrs	r0, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8015d20:	0a29      	lsrs	r1, r5, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8015d22:	0e12      	lsrs	r2, r2, #24
	*ptr++ = (BYTE)val; val >>= 8;
 8015d24:	759d      	strb	r5, [r3, #22]
	*ptr++ = (BYTE)val; val >>= 8;
 8015d26:	7798      	strb	r0, [r3, #30]
	*ptr++ = (BYTE)val;
 8015d28:	77da      	strb	r2, [r3, #31]
	*ptr++ = (BYTE)val; val >>= 8;
 8015d2a:	75d9      	strb	r1, [r3, #23]
 8015d2c:	0c28      	lsrs	r0, r5, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8015d2e:	2200      	movs	r2, #0
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
					st_word(dir + DIR_LstAccDate, 0);
					fs->wflag = 1;
 8015d30:	2101      	movs	r1, #1
	*ptr++ = (BYTE)val; val >>= 8;
 8015d32:	0e2d      	lsrs	r5, r5, #24
 8015d34:	7618      	strb	r0, [r3, #24]
	*ptr++ = (BYTE)val;
 8015d36:	765d      	strb	r5, [r3, #25]
	*ptr++ = (BYTE)val; val >>= 8;
 8015d38:	749a      	strb	r2, [r3, #18]
	*ptr++ = (BYTE)val;
 8015d3a:	74da      	strb	r2, [r3, #19]
					res = sync_fs(fs);					/* Restore it to the directory */
 8015d3c:	4630      	mov	r0, r6
					fs->wflag = 1;
 8015d3e:	70f1      	strb	r1, [r6, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 8015d40:	f7fe fc08 	bl	8014554 <sync_fs>
					fp->flag &= (BYTE)~FA_MODIFIED;
 8015d44:	7d23      	ldrb	r3, [r4, #20]
 8015d46:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8015d4a:	7523      	strb	r3, [r4, #20]
			}
		}
	}

	LEAVE_FF(fs, res);
}
 8015d4c:	b002      	add	sp, #8
 8015d4e:	bd70      	pop	{r4, r5, r6, pc}
 8015d50:	4630      	mov	r0, r6
 8015d52:	f7fe fc5f 	bl	8014614 <move_window.part.5>
				if (res == FR_OK) {
 8015d56:	2800      	cmp	r0, #0
 8015d58:	d1f8      	bne.n	8015d4c <f_sync+0x84>
 8015d5a:	9e01      	ldr	r6, [sp, #4]
 8015d5c:	e7c9      	b.n	8015cf2 <f_sync+0x2a>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 8015d5e:	9b01      	ldr	r3, [sp, #4]
 8015d60:	6a22      	ldr	r2, [r4, #32]
 8015d62:	7858      	ldrb	r0, [r3, #1]
 8015d64:	f104 0130 	add.w	r1, r4, #48	; 0x30
 8015d68:	2301      	movs	r3, #1
 8015d6a:	f7fe facf 	bl	801430c <disk_write>
 8015d6e:	b920      	cbnz	r0, 8015d7a <f_sync+0xb2>
				fp->flag &= (BYTE)~FA_DIRTY;
 8015d70:	7d23      	ldrb	r3, [r4, #20]
 8015d72:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015d76:	7523      	strb	r3, [r4, #20]
 8015d78:	e7b3      	b.n	8015ce2 <f_sync+0x1a>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 8015d7a:	2001      	movs	r0, #1
 8015d7c:	e7e6      	b.n	8015d4c <f_sync+0x84>
 8015d7e:	bf00      	nop

08015d80 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
 8015d80:	b530      	push	{r4, r5, lr}
 8015d82:	b083      	sub	sp, #12
 8015d84:	4604      	mov	r4, r0
	FRESULT res;
	FATFS *fs;

#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 8015d86:	f7ff ff9f 	bl	8015cc8 <f_sync>
	if (res == FR_OK)
 8015d8a:	b108      	cbz	r0, 8015d90 <f_close+0x10>
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 8015d8c:	b003      	add	sp, #12
 8015d8e:	bd30      	pop	{r4, r5, pc}
		res = validate(&fp->obj, &fs);	/* Lock volume */
 8015d90:	a901      	add	r1, sp, #4
 8015d92:	4620      	mov	r0, r4
 8015d94:	f7fe fb8c 	bl	80144b0 <validate>
		if (res == FR_OK) {
 8015d98:	2800      	cmp	r0, #0
 8015d9a:	d1f7      	bne.n	8015d8c <f_close+0xc>
	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 8015d9c:	6923      	ldr	r3, [r4, #16]
 8015d9e:	3b01      	subs	r3, #1
 8015da0:	2b01      	cmp	r3, #1
 8015da2:	d80d      	bhi.n	8015dc0 <f_close+0x40>
		n = Files[i].ctr;
 8015da4:	490b      	ldr	r1, [pc, #44]	; (8015dd4 <f_close+0x54>)
 8015da6:	011b      	lsls	r3, r3, #4
 8015da8:	18cd      	adds	r5, r1, r3
 8015daa:	89aa      	ldrh	r2, [r5, #12]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 8015dac:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8015db0:	d00e      	beq.n	8015dd0 <f_close+0x50>
		if (n > 0) n--;				/* Decrement read mode open count */
 8015db2:	b93a      	cbnz	r2, 8015dc4 <f_close+0x44>
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8015db4:	2200      	movs	r2, #0
 8015db6:	50ca      	str	r2, [r1, r3]
				fp->obj.fs = 0;			/* Invalidate file object */
 8015db8:	2300      	movs	r3, #0
 8015dba:	6023      	str	r3, [r4, #0]
}
 8015dbc:	b003      	add	sp, #12
 8015dbe:	bd30      	pop	{r4, r5, pc}
		res = FR_INT_ERR;			/* Invalid index nunber */
 8015dc0:	2002      	movs	r0, #2
 8015dc2:	e7e3      	b.n	8015d8c <f_close+0xc>
		if (n > 0) n--;				/* Decrement read mode open count */
 8015dc4:	3a01      	subs	r2, #1
 8015dc6:	b292      	uxth	r2, r2
		Files[i].ctr = n;
 8015dc8:	81aa      	strh	r2, [r5, #12]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8015dca:	2a00      	cmp	r2, #0
 8015dcc:	d1f4      	bne.n	8015db8 <f_close+0x38>
 8015dce:	e7f1      	b.n	8015db4 <f_close+0x34>
		Files[i].ctr = n;
 8015dd0:	81a8      	strh	r0, [r5, #12]
 8015dd2:	e7ef      	b.n	8015db4 <f_close+0x34>
 8015dd4:	2000b690 	.word	0x2000b690

08015dd8 <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File pointer from top of file */
)
{
 8015dd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015ddc:	b083      	sub	sp, #12
 8015dde:	460e      	mov	r6, r1
	FSIZE_t ifptr;
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif

	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 8015de0:	a901      	add	r1, sp, #4
{
 8015de2:	4604      	mov	r4, r0
	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 8015de4:	f7fe fb64 	bl	80144b0 <validate>
	if (res == FR_OK) res = (FRESULT)fp->err;
 8015de8:	4605      	mov	r5, r0
 8015dea:	2800      	cmp	r0, #0
 8015dec:	d14c      	bne.n	8015e88 <f_lseek+0xb0>
 8015dee:	7d65      	ldrb	r5, [r4, #21]
#if _FS_EXFAT && !_FS_READONLY
	if (res == FR_OK && fs->fs_type == FS_EXFAT) {
		res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
	}
#endif
	if (res != FR_OK) LEAVE_FF(fs, res);
 8015df0:	2d00      	cmp	r5, #0
 8015df2:	d149      	bne.n	8015e88 <f_lseek+0xb0>

#if _USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
 8015df4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8015df6:	2a00      	cmp	r2, #0
 8015df8:	d04a      	beq.n	8015e90 <f_lseek+0xb8>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
 8015dfa:	1c71      	adds	r1, r6, #1
 8015dfc:	f000 8096 	beq.w	8015f2c <f_lseek+0x154>
 8015e00:	68e3      	ldr	r3, [r4, #12]
 8015e02:	429e      	cmp	r6, r3
 8015e04:	bf28      	it	cs
 8015e06:	461e      	movcs	r6, r3
			} else {
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
			}
		} else {						/* Fast seek */
			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
			fp->fptr = ofs;				/* Set file pointer */
 8015e08:	61a6      	str	r6, [r4, #24]
			if (ofs) {
 8015e0a:	2e00      	cmp	r6, #0
 8015e0c:	d03c      	beq.n	8015e88 <f_lseek+0xb0>
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8015e0e:	6821      	ldr	r1, [r4, #0]
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8015e10:	6853      	ldr	r3, [r2, #4]
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8015e12:	8949      	ldrh	r1, [r1, #10]
				fp->clust = clmt_clust(fp, ofs - 1);
 8015e14:	1e70      	subs	r0, r6, #1
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8015e16:	0a40      	lsrs	r0, r0, #9
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8015e18:	3204      	adds	r2, #4
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8015e1a:	fbb0 f1f1 	udiv	r1, r0, r1
		if (ncl == 0) return 0;	/* End of table? (error) */
 8015e1e:	b933      	cbnz	r3, 8015e2e <f_lseek+0x56>
 8015e20:	e0c0      	b.n	8015fa4 <f_lseek+0x1cc>
		cl -= ncl; tbl++;		/* Next fragment */
 8015e22:	1ac9      	subs	r1, r1, r3
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8015e24:	f852 3f08 	ldr.w	r3, [r2, #8]!
		if (ncl == 0) return 0;	/* End of table? (error) */
 8015e28:	2b00      	cmp	r3, #0
 8015e2a:	f000 80bb 	beq.w	8015fa4 <f_lseek+0x1cc>
		if (cl < ncl) break;	/* In this fragment? */
 8015e2e:	428b      	cmp	r3, r1
 8015e30:	d9f7      	bls.n	8015e22 <f_lseek+0x4a>
	return cl + *tbl;	/* Return the cluster number */
 8015e32:	6853      	ldr	r3, [r2, #4]
 8015e34:	440b      	add	r3, r1
 8015e36:	1e9a      	subs	r2, r3, #2
				dsc = clust2sect(fs, fp->clust);
 8015e38:	9901      	ldr	r1, [sp, #4]
				fp->clust = clmt_clust(fp, ofs - 1);
 8015e3a:	61e3      	str	r3, [r4, #28]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8015e3c:	698b      	ldr	r3, [r1, #24]
 8015e3e:	3b02      	subs	r3, #2
 8015e40:	4293      	cmp	r3, r2
 8015e42:	f240 80a6 	bls.w	8015f92 <f_lseek+0x1ba>
	return clst * fs->csize + fs->database;
 8015e46:	894f      	ldrh	r7, [r1, #10]
 8015e48:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 8015e4a:	fb02 3307 	mla	r3, r2, r7, r3
				if (!dsc) ABORT(fs, FR_INT_ERR);
 8015e4e:	2b00      	cmp	r3, #0
 8015e50:	f000 809f 	beq.w	8015f92 <f_lseek+0x1ba>
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8015e54:	f3c6 0608 	ubfx	r6, r6, #0, #9
 8015e58:	b1b6      	cbz	r6, 8015e88 <f_lseek+0xb0>
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 8015e5a:	1e7e      	subs	r6, r7, #1
 8015e5c:	4030      	ands	r0, r6
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8015e5e:	6a22      	ldr	r2, [r4, #32]
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 8015e60:	18c6      	adds	r6, r0, r3
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8015e62:	42b2      	cmp	r2, r6
 8015e64:	d010      	beq.n	8015e88 <f_lseek+0xb0>
#if !_FS_TINY
#if !_FS_READONLY
					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 8015e66:	f994 3014 	ldrsb.w	r3, [r4, #20]
 8015e6a:	7848      	ldrb	r0, [r1, #1]
 8015e6c:	2b00      	cmp	r3, #0
 8015e6e:	f104 0730 	add.w	r7, r4, #48	; 0x30
 8015e72:	f2c0 80eb 	blt.w	801604c <f_lseek+0x274>
						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
						fp->flag &= (BYTE)~FA_DIRTY;
					}
#endif
					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current sector */
 8015e76:	4639      	mov	r1, r7
 8015e78:	2301      	movs	r3, #1
 8015e7a:	4632      	mov	r2, r6
 8015e7c:	f7fe fa38 	bl	80142f0 <disk_read>
 8015e80:	2800      	cmp	r0, #0
 8015e82:	f040 808c 	bne.w	8015f9e <f_lseek+0x1c6>
#endif
					fp->sect = dsc;
 8015e86:	6226      	str	r6, [r4, #32]
			fp->sect = nsect;
		}
	}

	LEAVE_FF(fs, res);
}
 8015e88:	4628      	mov	r0, r5
 8015e8a:	b003      	add	sp, #12
 8015e8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (ofs > fp->obj.objsize && (_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
 8015e90:	68e3      	ldr	r3, [r4, #12]
 8015e92:	42b3      	cmp	r3, r6
 8015e94:	d204      	bcs.n	8015ea0 <f_lseek+0xc8>
 8015e96:	7d22      	ldrb	r2, [r4, #20]
 8015e98:	f012 0f02 	tst.w	r2, #2
 8015e9c:	bf08      	it	eq
 8015e9e:	461e      	moveq	r6, r3
		fp->fptr = nsect = 0;
 8015ea0:	2200      	movs	r2, #0
		ifptr = fp->fptr;
 8015ea2:	69a3      	ldr	r3, [r4, #24]
		fp->fptr = nsect = 0;
 8015ea4:	61a2      	str	r2, [r4, #24]
		if (ofs) {
 8015ea6:	2e00      	cmp	r6, #0
 8015ea8:	d0ee      	beq.n	8015e88 <f_lseek+0xb0>
			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
 8015eaa:	9a01      	ldr	r2, [sp, #4]
 8015eac:	f8b2 800a 	ldrh.w	r8, [r2, #10]
 8015eb0:	ea4f 2848 	mov.w	r8, r8, lsl #9
			if (ifptr > 0 &&
 8015eb4:	2b00      	cmp	r3, #0
 8015eb6:	d033      	beq.n	8015f20 <f_lseek+0x148>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 8015eb8:	3b01      	subs	r3, #1
 8015eba:	1e72      	subs	r2, r6, #1
 8015ebc:	fbb3 f1f8 	udiv	r1, r3, r8
 8015ec0:	fbb2 f2f8 	udiv	r2, r2, r8
			if (ifptr > 0 &&
 8015ec4:	428a      	cmp	r2, r1
 8015ec6:	d32b      	bcc.n	8015f20 <f_lseek+0x148>
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 8015ec8:	f1c8 0200 	rsb	r2, r8, #0
 8015ecc:	4013      	ands	r3, r2
				clst = fp->clust;
 8015ece:	69e7      	ldr	r7, [r4, #28]
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 8015ed0:	61a3      	str	r3, [r4, #24]
				ofs -= fp->fptr;
 8015ed2:	1af6      	subs	r6, r6, r3
			if (clst != 0) {
 8015ed4:	2f00      	cmp	r7, #0
 8015ed6:	f000 808a 	beq.w	8015fee <f_lseek+0x216>
				while (ofs > bcs) {						/* Cluster following loop */
 8015eda:	4546      	cmp	r6, r8
 8015edc:	d812      	bhi.n	8015f04 <f_lseek+0x12c>
 8015ede:	e072      	b.n	8015fc6 <f_lseek+0x1ee>
						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
 8015ee0:	f7fe ff04 	bl	8014cec <create_chain>
						if (clst == 0) {				/* Clip file size in case of disk full */
 8015ee4:	4607      	mov	r7, r0
 8015ee6:	2800      	cmp	r0, #0
 8015ee8:	f000 80bd 	beq.w	8016066 <f_lseek+0x28e>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8015eec:	1c7b      	adds	r3, r7, #1
 8015eee:	d056      	beq.n	8015f9e <f_lseek+0x1c6>
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
 8015ef0:	2f01      	cmp	r7, #1
 8015ef2:	d94e      	bls.n	8015f92 <f_lseek+0x1ba>
 8015ef4:	9b01      	ldr	r3, [sp, #4]
 8015ef6:	699b      	ldr	r3, [r3, #24]
 8015ef8:	42bb      	cmp	r3, r7
 8015efa:	d94a      	bls.n	8015f92 <f_lseek+0x1ba>
				while (ofs > bcs) {						/* Cluster following loop */
 8015efc:	45b0      	cmp	r8, r6
					fp->clust = clst;
 8015efe:	61e7      	str	r7, [r4, #28]
 8015f00:	69a3      	ldr	r3, [r4, #24]
				while (ofs > bcs) {						/* Cluster following loop */
 8015f02:	d260      	bcs.n	8015fc6 <f_lseek+0x1ee>
					ofs -= bcs; fp->fptr += bcs;
 8015f04:	4443      	add	r3, r8
 8015f06:	61a3      	str	r3, [r4, #24]
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 8015f08:	7d23      	ldrb	r3, [r4, #20]
 8015f0a:	079a      	lsls	r2, r3, #30
						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
 8015f0c:	4639      	mov	r1, r7
 8015f0e:	4620      	mov	r0, r4
					ofs -= bcs; fp->fptr += bcs;
 8015f10:	eba6 0608 	sub.w	r6, r6, r8
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 8015f14:	d4e4      	bmi.n	8015ee0 <f_lseek+0x108>
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
 8015f16:	6820      	ldr	r0, [r4, #0]
 8015f18:	f7fe fe26 	bl	8014b68 <get_fat.isra.8>
 8015f1c:	4607      	mov	r7, r0
 8015f1e:	e7e5      	b.n	8015eec <f_lseek+0x114>
				clst = fp->obj.sclust;					/* start from the first cluster */
 8015f20:	68a7      	ldr	r7, [r4, #8]
				if (clst == 0) {						/* If no cluster chain, create a new chain */
 8015f22:	2f00      	cmp	r7, #0
 8015f24:	d043      	beq.n	8015fae <f_lseek+0x1d6>
 8015f26:	2300      	movs	r3, #0
				fp->clust = clst;
 8015f28:	61e7      	str	r7, [r4, #28]
 8015f2a:	e7d3      	b.n	8015ed4 <f_lseek+0xfc>
			cl = fp->obj.sclust;		/* Origin of the chain */
 8015f2c:	68a7      	ldr	r7, [r4, #8]
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8015f2e:	f8d2 9000 	ldr.w	r9, [r2]
 8015f32:	f102 0a04 	add.w	sl, r2, #4
 8015f36:	f04f 0802 	mov.w	r8, #2
			if (cl) {
 8015f3a:	b9bf      	cbnz	r7, 8015f6c <f_lseek+0x194>
			if (ulen <= tlen) {
 8015f3c:	45c8      	cmp	r8, r9
			*fp->cltbl = ulen;	/* Number of items used */
 8015f3e:	f8c2 8000 	str.w	r8, [r2]
			if (ulen <= tlen) {
 8015f42:	d832      	bhi.n	8015faa <f_lseek+0x1d2>
				*tbl = 0;		/* Terminate table */
 8015f44:	2300      	movs	r3, #0
 8015f46:	f8ca 3000 	str.w	r3, [sl]
 8015f4a:	e79d      	b.n	8015e88 <f_lseek+0xb0>
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 8015f4c:	f108 0802 	add.w	r8, r8, #2
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 8015f50:	45c1      	cmp	r9, r8
 8015f52:	d305      	bcc.n	8015f60 <f_lseek+0x188>
						*tbl++ = ncl; *tbl++ = tcl;
 8015f54:	4653      	mov	r3, sl
 8015f56:	f843 bb08 	str.w	fp, [r3], #8
 8015f5a:	f8ca 7004 	str.w	r7, [sl, #4]
 8015f5e:	469a      	mov	sl, r3
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 8015f60:	9b01      	ldr	r3, [sp, #4]
 8015f62:	699b      	ldr	r3, [r3, #24]
 8015f64:	4283      	cmp	r3, r0
 8015f66:	f240 8082 	bls.w	801606e <f_lseek+0x296>
 8015f6a:	4607      	mov	r7, r0
 8015f6c:	463e      	mov	r6, r7
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 8015f6e:	f04f 0b00 	mov.w	fp, #0
 8015f72:	e003      	b.n	8015f7c <f_lseek+0x1a4>
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8015f74:	1c42      	adds	r2, r0, #1
 8015f76:	d012      	beq.n	8015f9e <f_lseek+0x1c6>
					} while (cl == pcl + 1);
 8015f78:	4283      	cmp	r3, r0
 8015f7a:	d1e7      	bne.n	8015f4c <f_lseek+0x174>
						cl = get_fat(&fp->obj, cl);
 8015f7c:	4631      	mov	r1, r6
 8015f7e:	6820      	ldr	r0, [r4, #0]
 8015f80:	f7fe fdf2 	bl	8014b68 <get_fat.isra.8>
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 8015f84:	2801      	cmp	r0, #1
					} while (cl == pcl + 1);
 8015f86:	f106 0301 	add.w	r3, r6, #1
						pcl = cl; ncl++;
 8015f8a:	f10b 0b01 	add.w	fp, fp, #1
 8015f8e:	4606      	mov	r6, r0
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 8015f90:	d8f0      	bhi.n	8015f74 <f_lseek+0x19c>
 8015f92:	2502      	movs	r5, #2
}
 8015f94:	4628      	mov	r0, r5
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 8015f96:	7565      	strb	r5, [r4, #21]
}
 8015f98:	b003      	add	sp, #12
 8015f9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8015f9e:	2501      	movs	r5, #1
 8015fa0:	7565      	strb	r5, [r4, #21]
 8015fa2:	e771      	b.n	8015e88 <f_lseek+0xb0>
		if (ncl == 0) return 0;	/* End of table? (error) */
 8015fa4:	f06f 0201 	mvn.w	r2, #1
 8015fa8:	e746      	b.n	8015e38 <f_lseek+0x60>
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
 8015faa:	2511      	movs	r5, #17
 8015fac:	e76c      	b.n	8015e88 <f_lseek+0xb0>
					clst = create_chain(&fp->obj, 0);
 8015fae:	4639      	mov	r1, r7
 8015fb0:	4620      	mov	r0, r4
 8015fb2:	f7fe fe9b 	bl	8014cec <create_chain>
					if (clst == 1) ABORT(fs, FR_INT_ERR);
 8015fb6:	2801      	cmp	r0, #1
					clst = create_chain(&fp->obj, 0);
 8015fb8:	4607      	mov	r7, r0
					if (clst == 1) ABORT(fs, FR_INT_ERR);
 8015fba:	d0ea      	beq.n	8015f92 <f_lseek+0x1ba>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8015fbc:	1c41      	adds	r1, r0, #1
 8015fbe:	d0ee      	beq.n	8015f9e <f_lseek+0x1c6>
					fp->obj.sclust = clst;
 8015fc0:	60a0      	str	r0, [r4, #8]
 8015fc2:	69a3      	ldr	r3, [r4, #24]
 8015fc4:	e7b0      	b.n	8015f28 <f_lseek+0x150>
				fp->fptr += ofs;
 8015fc6:	4433      	add	r3, r6
				if (ofs % SS(fs)) {
 8015fc8:	f3c6 0208 	ubfx	r2, r6, #0, #9
				fp->fptr += ofs;
 8015fcc:	61a3      	str	r3, [r4, #24]
				if (ofs % SS(fs)) {
 8015fce:	2a00      	cmp	r2, #0
 8015fd0:	d04b      	beq.n	801606a <f_lseek+0x292>
					nsect = clust2sect(fs, clst);	/* Current sector */
 8015fd2:	9901      	ldr	r1, [sp, #4]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8015fd4:	698a      	ldr	r2, [r1, #24]
	clst -= 2;
 8015fd6:	1eb8      	subs	r0, r7, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8015fd8:	3a02      	subs	r2, #2
 8015fda:	4290      	cmp	r0, r2
 8015fdc:	d2d9      	bcs.n	8015f92 <f_lseek+0x1ba>
	return clst * fs->csize + fs->database;
 8015fde:	894f      	ldrh	r7, [r1, #10]
 8015fe0:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 8015fe2:	fb00 2707 	mla	r7, r0, r7, r2
					if (!nsect) ABORT(fs, FR_INT_ERR);
 8015fe6:	2f00      	cmp	r7, #0
 8015fe8:	d0d3      	beq.n	8015f92 <f_lseek+0x1ba>
					nsect += (DWORD)(ofs / SS(fs));
 8015fea:	eb07 2756 	add.w	r7, r7, r6, lsr #9
		if (!_FS_READONLY && fp->fptr > fp->obj.objsize) {		/* Set file change flag if the file size is extended */
 8015fee:	68e2      	ldr	r2, [r4, #12]
 8015ff0:	429a      	cmp	r2, r3
 8015ff2:	f3c3 0108 	ubfx	r1, r3, #0, #9
 8015ff6:	d204      	bcs.n	8016002 <f_lseek+0x22a>
			fp->flag |= FA_MODIFIED;
 8015ff8:	7d22      	ldrb	r2, [r4, #20]
			fp->obj.objsize = fp->fptr;
 8015ffa:	60e3      	str	r3, [r4, #12]
			fp->flag |= FA_MODIFIED;
 8015ffc:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 8016000:	7523      	strb	r3, [r4, #20]
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
 8016002:	2900      	cmp	r1, #0
 8016004:	f43f af40 	beq.w	8015e88 <f_lseek+0xb0>
 8016008:	6a22      	ldr	r2, [r4, #32]
 801600a:	42ba      	cmp	r2, r7
 801600c:	f43f af3c 	beq.w	8015e88 <f_lseek+0xb0>
			if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
 8016010:	f994 3014 	ldrsb.w	r3, [r4, #20]
 8016014:	9901      	ldr	r1, [sp, #4]
 8016016:	2b00      	cmp	r3, #0
 8016018:	7848      	ldrb	r0, [r1, #1]
 801601a:	f104 0630 	add.w	r6, r4, #48	; 0x30
 801601e:	db08      	blt.n	8016032 <f_lseek+0x25a>
			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 8016020:	4631      	mov	r1, r6
 8016022:	2301      	movs	r3, #1
 8016024:	463a      	mov	r2, r7
 8016026:	f7fe f963 	bl	80142f0 <disk_read>
 801602a:	2800      	cmp	r0, #0
 801602c:	d1b7      	bne.n	8015f9e <f_lseek+0x1c6>
			fp->sect = nsect;
 801602e:	6227      	str	r7, [r4, #32]
 8016030:	e72a      	b.n	8015e88 <f_lseek+0xb0>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8016032:	2301      	movs	r3, #1
 8016034:	4631      	mov	r1, r6
 8016036:	f7fe f969 	bl	801430c <disk_write>
 801603a:	2800      	cmp	r0, #0
 801603c:	d1af      	bne.n	8015f9e <f_lseek+0x1c6>
				fp->flag &= (BYTE)~FA_DIRTY;
 801603e:	7d23      	ldrb	r3, [r4, #20]
 8016040:	9a01      	ldr	r2, [sp, #4]
 8016042:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8016046:	7523      	strb	r3, [r4, #20]
 8016048:	7850      	ldrb	r0, [r2, #1]
 801604a:	e7e9      	b.n	8016020 <f_lseek+0x248>
						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 801604c:	2301      	movs	r3, #1
 801604e:	4639      	mov	r1, r7
 8016050:	f7fe f95c 	bl	801430c <disk_write>
 8016054:	2800      	cmp	r0, #0
 8016056:	d1a2      	bne.n	8015f9e <f_lseek+0x1c6>
						fp->flag &= (BYTE)~FA_DIRTY;
 8016058:	7d23      	ldrb	r3, [r4, #20]
 801605a:	9a01      	ldr	r2, [sp, #4]
 801605c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8016060:	7523      	strb	r3, [r4, #20]
 8016062:	7850      	ldrb	r0, [r2, #1]
 8016064:	e707      	b.n	8015e76 <f_lseek+0x9e>
 8016066:	69a3      	ldr	r3, [r4, #24]
 8016068:	e7c1      	b.n	8015fee <f_lseek+0x216>
		fp->fptr = nsect = 0;
 801606a:	4617      	mov	r7, r2
 801606c:	e7bf      	b.n	8015fee <f_lseek+0x216>
 801606e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8016070:	e764      	b.n	8015f3c <f_lseek+0x164>
 8016072:	bf00      	nop

08016074 <FATFS_UnLinkDriverEx.part.1>:
  *         drivers.
  * @param  path: pointer to the logical drive path
  * @param  lun : not used
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_UnLinkDriverEx(char *path, uint8_t lun)
 8016074:	b410      	push	{r4}
  uint8_t DiskNum = 0;
  uint8_t ret = 1;

  if(disk.nbr >= 1)
  {
    DiskNum = path[0] - '0';
 8016076:	7803      	ldrb	r3, [r0, #0]
    if(disk.drv[DiskNum] != 0)
 8016078:	490a      	ldr	r1, [pc, #40]	; (80160a4 <FATFS_UnLinkDriverEx.part.1+0x30>)
    DiskNum = path[0] - '0';
 801607a:	3b30      	subs	r3, #48	; 0x30
    if(disk.drv[DiskNum] != 0)
 801607c:	b2db      	uxtb	r3, r3
 801607e:	eb01 0483 	add.w	r4, r1, r3, lsl #2
 8016082:	6862      	ldr	r2, [r4, #4]
 8016084:	b152      	cbz	r2, 801609c <FATFS_UnLinkDriverEx.part.1+0x28>
    {
      disk.drv[DiskNum] = 0;
      disk.lun[DiskNum] = 0;
      disk.nbr--;
 8016086:	7a4a      	ldrb	r2, [r1, #9]
      disk.lun[DiskNum] = 0;
 8016088:	440b      	add	r3, r1
      disk.nbr--;
 801608a:	3a01      	subs	r2, #1
      disk.drv[DiskNum] = 0;
 801608c:	2000      	movs	r0, #0
      disk.nbr--;
 801608e:	b2d2      	uxtb	r2, r2
      disk.lun[DiskNum] = 0;
 8016090:	7218      	strb	r0, [r3, #8]
      disk.nbr--;
 8016092:	724a      	strb	r2, [r1, #9]
      disk.drv[DiskNum] = 0;
 8016094:	6060      	str	r0, [r4, #4]
      ret = 0;
    }
  }

  return ret;
}
 8016096:	f85d 4b04 	ldr.w	r4, [sp], #4
 801609a:	4770      	bx	lr
  uint8_t ret = 1;
 801609c:	2001      	movs	r0, #1
}
 801609e:	f85d 4b04 	ldr.w	r4, [sp], #4
 80160a2:	4770      	bx	lr
 80160a4:	2000b6b8 	.word	0x2000b6b8

080160a8 <FATFS_LinkDriver>:
{
 80160a8:	b4f0      	push	{r4, r5, r6, r7}
  if(disk.nbr < _VOLUMES)
 80160aa:	4b10      	ldr	r3, [pc, #64]	; (80160ec <FATFS_LinkDriver+0x44>)
 80160ac:	7a5c      	ldrb	r4, [r3, #9]
 80160ae:	b114      	cbz	r4, 80160b6 <FATFS_LinkDriver+0xe>
  uint8_t ret = 1;
 80160b0:	2001      	movs	r0, #1
}
 80160b2:	bcf0      	pop	{r4, r5, r6, r7}
 80160b4:	4770      	bx	lr
    disk.is_initialized[disk.nbr] = 0;
 80160b6:	7a5f      	ldrb	r7, [r3, #9]
    disk.drv[disk.nbr] = drv;
 80160b8:	7a5e      	ldrb	r6, [r3, #9]
    disk.lun[disk.nbr] = lun;
 80160ba:	7a5d      	ldrb	r5, [r3, #9]
 80160bc:	f004 02ff 	and.w	r2, r4, #255	; 0xff
    DiskNum = disk.nbr++;
 80160c0:	7a5c      	ldrb	r4, [r3, #9]
    disk.is_initialized[disk.nbr] = 0;
 80160c2:	55da      	strb	r2, [r3, r7]
    disk.drv[disk.nbr] = drv;
 80160c4:	eb03 0686 	add.w	r6, r3, r6, lsl #2
    DiskNum = disk.nbr++;
 80160c8:	b2e4      	uxtb	r4, r4
    disk.drv[disk.nbr] = drv;
 80160ca:	6070      	str	r0, [r6, #4]
    disk.lun[disk.nbr] = lun;
 80160cc:	441d      	add	r5, r3
    DiskNum = disk.nbr++;
 80160ce:	1c60      	adds	r0, r4, #1
 80160d0:	b2c0      	uxtb	r0, r0
 80160d2:	7258      	strb	r0, [r3, #9]
    disk.lun[disk.nbr] = lun;
 80160d4:	722a      	strb	r2, [r5, #8]
    path[0] = DiskNum + '0';
 80160d6:	3430      	adds	r4, #48	; 0x30
    path[1] = ':';
 80160d8:	253a      	movs	r5, #58	; 0x3a
    path[2] = '/';
 80160da:	232f      	movs	r3, #47	; 0x2f
    path[0] = DiskNum + '0';
 80160dc:	700c      	strb	r4, [r1, #0]
    path[3] = 0;
 80160de:	4610      	mov	r0, r2
    path[1] = ':';
 80160e0:	704d      	strb	r5, [r1, #1]
    path[3] = 0;
 80160e2:	70ca      	strb	r2, [r1, #3]
    path[2] = '/';
 80160e4:	708b      	strb	r3, [r1, #2]
}
 80160e6:	bcf0      	pop	{r4, r5, r6, r7}
 80160e8:	4770      	bx	lr
 80160ea:	bf00      	nop
 80160ec:	2000b6b8 	.word	0x2000b6b8

080160f0 <FATFS_UnLinkDriver>:
  if(disk.nbr >= 1)
 80160f0:	4b03      	ldr	r3, [pc, #12]	; (8016100 <FATFS_UnLinkDriver+0x10>)
 80160f2:	7a5b      	ldrb	r3, [r3, #9]
 80160f4:	b90b      	cbnz	r3, 80160fa <FATFS_UnLinkDriver+0xa>
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_UnLinkDriver(char *path)
{
  return FATFS_UnLinkDriverEx(path, 0);
}
 80160f6:	2001      	movs	r0, #1
 80160f8:	4770      	bx	lr
 80160fa:	f7ff bfbb 	b.w	8016074 <FATFS_UnLinkDriverEx.part.1>
 80160fe:	bf00      	nop
 8016100:	2000b6b8 	.word	0x2000b6b8

08016104 <ff_memalloc>:

void* ff_memalloc (	/* Returns pointer to the allocated memory block */
	UINT msize		/* Number of bytes to allocate */
)
{
	return ff_malloc(msize);	/* Allocate a new memory block with POSIX API */
 8016104:	f008 bcea 	b.w	801eadc <malloc>

08016108 <ff_memfree>:

void ff_memfree (
	void* mblock	/* Pointer to the memory block to free */
)
{
	ff_free(mblock);	/* Discard the memory block with POSIX API */
 8016108:	f008 bcf0 	b.w	801eaec <free>

0801610c <ff_convert>:
)
{
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 801610c:	287f      	cmp	r0, #127	; 0x7f
 801610e:	d91a      	bls.n	8016146 <ff_convert+0x3a>
		c = chr;

	} else {
		if (dir) {		/* OEM code to Unicode */
 8016110:	b991      	cbnz	r1, 8016138 <ff_convert+0x2c>
{
 8016112:	b410      	push	{r4}
 8016114:	4a0e      	ldr	r2, [pc, #56]	; (8016150 <ff_convert+0x44>)
		if (dir) {		/* OEM code to Unicode */
 8016116:	23c7      	movs	r3, #199	; 0xc7
 8016118:	e003      	b.n	8016122 <ff_convert+0x16>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];

		} else {		/* Unicode to OEM code */
			for (c = 0; c < 0x80; c++) {
 801611a:	2980      	cmp	r1, #128	; 0x80
 801611c:	d016      	beq.n	801614c <ff_convert+0x40>
 801611e:	f832 3f02 	ldrh.w	r3, [r2, #2]!
				if (chr == Tbl[c]) break;
 8016122:	4298      	cmp	r0, r3
 8016124:	b28c      	uxth	r4, r1
 8016126:	f101 0101 	add.w	r1, r1, #1
 801612a:	d1f6      	bne.n	801611a <ff_convert+0xe>
 801612c:	f104 0080 	add.w	r0, r4, #128	; 0x80
 8016130:	b280      	uxth	r0, r0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
 8016132:	f85d 4b04 	ldr.w	r4, [sp], #4
 8016136:	4770      	bx	lr
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 8016138:	28ff      	cmp	r0, #255	; 0xff
 801613a:	d805      	bhi.n	8016148 <ff_convert+0x3c>
 801613c:	4b04      	ldr	r3, [pc, #16]	; (8016150 <ff_convert+0x44>)
 801613e:	3880      	subs	r0, #128	; 0x80
 8016140:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 8016144:	4770      	bx	lr
}
 8016146:	4770      	bx	lr
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 8016148:	2000      	movs	r0, #0
 801614a:	4770      	bx	lr
 801614c:	2000      	movs	r0, #0
 801614e:	e7f0      	b.n	8016132 <ff_convert+0x26>
 8016150:	08074f64 	.word	0x08074f64

08016154 <ff_wtoupper>:


WCHAR ff_wtoupper (	/* Returns upper converted character */
	WCHAR chr		/* Unicode character to be upper converted (BMP only) */
)
{
 8016154:	b470      	push	{r4, r5, r6}
	};
	const WCHAR *p;
	WCHAR bc, nc, cmd;


	p = chr < 0x1000 ? cvt1 : cvt2;
 8016156:	4b26      	ldr	r3, [pc, #152]	; (80161f0 <ff_wtoupper+0x9c>)
 8016158:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 801615c:	f103 02bc 	add.w	r2, r3, #188	; 0xbc
 8016160:	f641 517d 	movw	r1, #7549	; 0x1d7d
 8016164:	bf3c      	itt	cc
 8016166:	4613      	movcc	r3, r2
 8016168:	2161      	movcc	r1, #97	; 0x61
 801616a:	3304      	adds	r3, #4
 801616c:	e00d      	b.n	801618a <ff_wtoupper+0x36>
	for (;;) {
		bc = *p++;								/* Get block base */
		if (!bc || chr < bc) break;
 801616e:	4281      	cmp	r1, r0
 8016170:	d80e      	bhi.n	8016190 <ff_wtoupper+0x3c>
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 8016172:	f833 2c02 	ldrh.w	r2, [r3, #-2]
 8016176:	b2d4      	uxtb	r4, r2
		if (chr < bc + nc) {	/* In the block? */
 8016178:	1865      	adds	r5, r4, r1
 801617a:	42a8      	cmp	r0, r5
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 801617c:	ea4f 2212 	mov.w	r2, r2, lsr #8
		if (chr < bc + nc) {	/* In the block? */
 8016180:	db08      	blt.n	8016194 <ff_wtoupper+0x40>
 8016182:	3304      	adds	r3, #4
			case 7: chr -= 80; break;				/* Shift -80 */
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
			}
			break;
		}
		if (!cmd) p += nc;
 8016184:	b17a      	cbz	r2, 80161a6 <ff_wtoupper+0x52>
 8016186:	f833 1c04 	ldrh.w	r1, [r3, #-4]
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 801618a:	461e      	mov	r6, r3
		if (!bc || chr < bc) break;
 801618c:	2900      	cmp	r1, #0
 801618e:	d1ee      	bne.n	801616e <ff_wtoupper+0x1a>
	}

	return chr;
}
 8016190:	bc70      	pop	{r4, r5, r6}
 8016192:	4770      	bx	lr
			switch (cmd) {
 8016194:	2a08      	cmp	r2, #8
 8016196:	d8fb      	bhi.n	8016190 <ff_wtoupper+0x3c>
 8016198:	e8df f002 	tbb	[pc, r2]
 801619c:	1b18120e 	.word	0x1b18120e
 80161a0:	2724211e 	.word	0x2724211e
 80161a4:	0a          	.byte	0x0a
 80161a5:	00          	.byte	0x00
		if (!cmd) p += nc;
 80161a6:	eb06 0344 	add.w	r3, r6, r4, lsl #1
 80161aa:	f836 1014 	ldrh.w	r1, [r6, r4, lsl #1]
 80161ae:	e7dc      	b.n	801616a <ff_wtoupper+0x16>
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
 80161b0:	f5a0 50e3 	sub.w	r0, r0, #7264	; 0x1c60
 80161b4:	b280      	uxth	r0, r0
 80161b6:	e7eb      	b.n	8016190 <ff_wtoupper+0x3c>
			case 0:	chr = p[chr - bc]; break;		/* Table conversion */
 80161b8:	1a41      	subs	r1, r0, r1
 80161ba:	f833 0011 	ldrh.w	r0, [r3, r1, lsl #1]
 80161be:	e7e7      	b.n	8016190 <ff_wtoupper+0x3c>
			case 1:	chr -= (chr - bc) & 1; break;	/* Case pairs */
 80161c0:	1a41      	subs	r1, r0, r1
 80161c2:	f001 0301 	and.w	r3, r1, #1
 80161c6:	1ac0      	subs	r0, r0, r3
 80161c8:	b280      	uxth	r0, r0
 80161ca:	e7e1      	b.n	8016190 <ff_wtoupper+0x3c>
			case 2: chr -= 16; break;				/* Shift -16 */
 80161cc:	3810      	subs	r0, #16
 80161ce:	b280      	uxth	r0, r0
 80161d0:	e7de      	b.n	8016190 <ff_wtoupper+0x3c>
			case 3:	chr -= 32; break;				/* Shift -32 */
 80161d2:	3820      	subs	r0, #32
 80161d4:	b280      	uxth	r0, r0
 80161d6:	e7db      	b.n	8016190 <ff_wtoupper+0x3c>
			case 4:	chr -= 48; break;				/* Shift -48 */
 80161d8:	3830      	subs	r0, #48	; 0x30
 80161da:	b280      	uxth	r0, r0
 80161dc:	e7d8      	b.n	8016190 <ff_wtoupper+0x3c>
			case 5:	chr -= 26; break;				/* Shift -26 */
 80161de:	381a      	subs	r0, #26
 80161e0:	b280      	uxth	r0, r0
 80161e2:	e7d5      	b.n	8016190 <ff_wtoupper+0x3c>
			case 6:	chr += 8; break;				/* Shift +8 */
 80161e4:	3008      	adds	r0, #8
 80161e6:	b280      	uxth	r0, r0
 80161e8:	e7d2      	b.n	8016190 <ff_wtoupper+0x3c>
			case 7: chr -= 80; break;				/* Shift -80 */
 80161ea:	3850      	subs	r0, #80	; 0x50
 80161ec:	b280      	uxth	r0, r0
 80161ee:	e7cf      	b.n	8016190 <ff_wtoupper+0x3c>
 80161f0:	08075064 	.word	0x08075064

080161f4 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 80161f4:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 80161f6:	f001 fa71 	bl	80176dc <vTaskStartScheduler>
  
  return osOK;
}
 80161fa:	2000      	movs	r0, #0
 80161fc:	bd08      	pop	{r3, pc}
 80161fe:	bf00      	nop

08016200 <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 8016200:	b530      	push	{r4, r5, lr}

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8016202:	f9b0 4008 	ldrsh.w	r4, [r0, #8]
{
 8016206:	b085      	sub	sp, #20
  if (priority != osPriorityError) {
 8016208:	2c84      	cmp	r4, #132	; 0x84
{
 801620a:	4602      	mov	r2, r0
    fpriority += (priority - osPriorityIdle);
 801620c:	bf14      	ite	ne
 801620e:	3403      	addne	r4, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8016210:	2400      	moveq	r4, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8016212:	ad03      	add	r5, sp, #12
{
 8016214:	460b      	mov	r3, r1
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8016216:	6840      	ldr	r0, [r0, #4]
 8016218:	6811      	ldr	r1, [r2, #0]
 801621a:	8a12      	ldrh	r2, [r2, #16]
 801621c:	e9cd 4500 	strd	r4, r5, [sp]
 8016220:	f001 f982 	bl	8017528 <xTaskCreate>
 8016224:	2801      	cmp	r0, #1
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 8016226:	bf0c      	ite	eq
 8016228:	9803      	ldreq	r0, [sp, #12]
    return NULL;
 801622a:	2000      	movne	r0, #0
}
 801622c:	b005      	add	sp, #20
 801622e:	bd30      	pop	{r4, r5, pc}

08016230 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 8016230:	b508      	push	{r3, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 8016232:	2800      	cmp	r0, #0
 8016234:	bf08      	it	eq
 8016236:	2001      	moveq	r0, #1
 8016238:	f001 fbb8 	bl	80179ac <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 801623c:	2000      	movs	r0, #0
 801623e:	bd08      	pop	{r3, pc}

08016240 <osTimerCreate>:
* @param  argument      argument to the timer call back function.
* @retval  timer ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osTimerCreate shall be consistent in every CMSIS-RTOS.
*/
osTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument)
{
 8016240:	b500      	push	{lr}
 8016242:	b083      	sub	sp, #12
                      (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
                      (void *) argument,
                      (TaskFunction_t)timer_def->ptimer,
                      (StaticTimer_t *)timer_def->controlblock);  
#else
  return xTimerCreate((const char *)"",
 8016244:	6803      	ldr	r3, [r0, #0]
 8016246:	9300      	str	r3, [sp, #0]
 8016248:	4613      	mov	r3, r2
 801624a:	f1a1 0201 	sub.w	r2, r1, #1
 801624e:	fab2 f282 	clz	r2, r2
 8016252:	0952      	lsrs	r2, r2, #5
 8016254:	2101      	movs	r1, #1
 8016256:	4803      	ldr	r0, [pc, #12]	; (8016264 <osTimerCreate+0x24>)
 8016258:	f001 fe8c 	bl	8017f74 <xTimerCreate>
#endif

#else 
	return NULL;
#endif
}
 801625c:	b003      	add	sp, #12
 801625e:	f85d fb04 	ldr.w	pc, [sp], #4
 8016262:	bf00      	nop
 8016264:	08075b2c 	.word	0x08075b2c

08016268 <osTimerStart>:
* @param  millisec      time delay value of the timer.
* @retval  status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osTimerStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osTimerStart (osTimerId timer_id, uint32_t millisec)
{
 8016268:	b510      	push	{r4, lr}
 801626a:	b084      	sub	sp, #16
  osStatus result = osOK;
#if (configUSE_TIMERS == 1)  
  portBASE_TYPE taskWoken = pdFALSE;
 801626c:	2400      	movs	r4, #0
  TickType_t ticks = millisec / portTICK_PERIOD_MS;

  if (ticks == 0)
    ticks = 1;
 801626e:	42a1      	cmp	r1, r4
 8016270:	bf14      	ite	ne
 8016272:	460a      	movne	r2, r1
 8016274:	2201      	moveq	r2, #1
  portBASE_TYPE taskWoken = pdFALSE;
 8016276:	9403      	str	r4, [sp, #12]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8016278:	f3ef 8305 	mrs	r3, IPSR
    
  if (inHandlerMode()) 
 801627c:	b15b      	cbz	r3, 8016296 <osTimerStart+0x2e>
  {
    if (xTimerChangePeriodFromISR(timer_id, ticks, &taskWoken) != pdPASS)
 801627e:	9400      	str	r4, [sp, #0]
 8016280:	ab03      	add	r3, sp, #12
 8016282:	2109      	movs	r1, #9
 8016284:	f001 fe9a 	bl	8017fbc <xTimerGenericCommand>
 8016288:	2801      	cmp	r0, #1
 801628a:	d10a      	bne.n	80162a2 <osTimerStart+0x3a>
    {
      result = osErrorOS;
    }
    else
    {
      portEND_SWITCHING_ISR(taskWoken);     
 801628c:	9b03      	ldr	r3, [sp, #12]
 801628e:	b95b      	cbnz	r3, 80162a8 <osTimerStart+0x40>
  osStatus result = osOK;
 8016290:	2000      	movs	r0, #0

#else 
  result = osErrorOS;
#endif
  return result;
}
 8016292:	b004      	add	sp, #16
 8016294:	bd10      	pop	{r4, pc}
    if (xTimerChangePeriod(timer_id, ticks, 0) != pdPASS)
 8016296:	9300      	str	r3, [sp, #0]
 8016298:	2104      	movs	r1, #4
 801629a:	f001 fe8f 	bl	8017fbc <xTimerGenericCommand>
 801629e:	2801      	cmp	r0, #1
 80162a0:	d0f6      	beq.n	8016290 <osTimerStart+0x28>
      result = osErrorOS;
 80162a2:	20ff      	movs	r0, #255	; 0xff
}
 80162a4:	b004      	add	sp, #16
 80162a6:	bd10      	pop	{r4, pc}
      portEND_SWITCHING_ISR(taskWoken);     
 80162a8:	4b05      	ldr	r3, [pc, #20]	; (80162c0 <osTimerStart+0x58>)
 80162aa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80162ae:	601a      	str	r2, [r3, #0]
 80162b0:	f3bf 8f4f 	dsb	sy
 80162b4:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 80162b8:	4620      	mov	r0, r4
}
 80162ba:	b004      	add	sp, #16
 80162bc:	bd10      	pop	{r4, pc}
 80162be:	bf00      	nop
 80162c0:	e000ed04 	.word	0xe000ed04

080162c4 <osTimerStop>:
* @param  timer_id      timer ID obtained by \ref osTimerCreate
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osTimerStop shall be consistent in every CMSIS-RTOS.
*/
osStatus osTimerStop (osTimerId timer_id)
{
 80162c4:	b510      	push	{r4, lr}
 80162c6:	b084      	sub	sp, #16
  osStatus result = osOK;
#if (configUSE_TIMERS == 1)  
  portBASE_TYPE taskWoken = pdFALSE;
 80162c8:	2400      	movs	r4, #0
 80162ca:	9403      	str	r4, [sp, #12]
 80162cc:	f3ef 8305 	mrs	r3, IPSR

  if (inHandlerMode()) {
 80162d0:	b163      	cbz	r3, 80162ec <osTimerStop+0x28>
    if (xTimerStopFromISR(timer_id, &taskWoken) != pdPASS) {
 80162d2:	9400      	str	r4, [sp, #0]
 80162d4:	ab03      	add	r3, sp, #12
 80162d6:	4622      	mov	r2, r4
 80162d8:	2108      	movs	r1, #8
 80162da:	f001 fe6f 	bl	8017fbc <xTimerGenericCommand>
 80162de:	2801      	cmp	r0, #1
 80162e0:	d10b      	bne.n	80162fa <osTimerStop+0x36>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 80162e2:	9b03      	ldr	r3, [sp, #12]
 80162e4:	b963      	cbnz	r3, 8016300 <osTimerStop+0x3c>
  osStatus result = osOK;
 80162e6:	2000      	movs	r0, #0
  }
#else 
  result = osErrorOS;
#endif 
  return result;
}
 80162e8:	b004      	add	sp, #16
 80162ea:	bd10      	pop	{r4, pc}
    if (xTimerStop(timer_id, 0) != pdPASS) {
 80162ec:	9300      	str	r3, [sp, #0]
 80162ee:	461a      	mov	r2, r3
 80162f0:	2103      	movs	r1, #3
 80162f2:	f001 fe63 	bl	8017fbc <xTimerGenericCommand>
 80162f6:	2801      	cmp	r0, #1
 80162f8:	d0f5      	beq.n	80162e6 <osTimerStop+0x22>
      result = osErrorOS;
 80162fa:	20ff      	movs	r0, #255	; 0xff
}
 80162fc:	b004      	add	sp, #16
 80162fe:	bd10      	pop	{r4, pc}
    portEND_SWITCHING_ISR(taskWoken);
 8016300:	4b05      	ldr	r3, [pc, #20]	; (8016318 <osTimerStop+0x54>)
 8016302:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8016306:	601a      	str	r2, [r3, #0]
 8016308:	f3bf 8f4f 	dsb	sy
 801630c:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 8016310:	4620      	mov	r0, r4
}
 8016312:	b004      	add	sp, #16
 8016314:	bd10      	pop	{r4, pc}
 8016316:	bf00      	nop
 8016318:	e000ed04 	.word	0xe000ed04

0801631c <osTimerDelete>:
 801631c:	f3ef 8305 	mrs	r3, IPSR
{
osStatus result = osOK;

#if (configUSE_TIMERS == 1)

   if (inHandlerMode()) {
 8016320:	b97b      	cbnz	r3, 8016342 <osTimerDelete+0x26>
{
 8016322:	b500      	push	{lr}
 8016324:	b083      	sub	sp, #12
     return osErrorISR;
  }
  else { 
    if ((xTimerDelete(timer_id, osWaitForever )) != pdPASS) {
 8016326:	f04f 32ff 	mov.w	r2, #4294967295
 801632a:	9200      	str	r2, [sp, #0]
 801632c:	2105      	movs	r1, #5
 801632e:	461a      	mov	r2, r3
 8016330:	f001 fe44 	bl	8017fbc <xTimerGenericCommand>
      result = osErrorOS;
 8016334:	2801      	cmp	r0, #1
 8016336:	bf0c      	ite	eq
 8016338:	2000      	moveq	r0, #0
 801633a:	20ff      	movne	r0, #255	; 0xff
#else 
  result = osErrorOS;
#endif 
 
  return result;
}
 801633c:	b003      	add	sp, #12
 801633e:	f85d fb04 	ldr.w	pc, [sp], #4
     return osErrorISR;
 8016342:	2082      	movs	r0, #130	; 0x82
}
 8016344:	4770      	bx	lr
 8016346:	bf00      	nop

08016348 <osMutexRelease>:
* @param mutex_id      mutex ID obtained by \ref osMutexCreate.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osMutexRelease (osMutexId mutex_id)
{
 8016348:	b510      	push	{r4, lr}
 801634a:	b082      	sub	sp, #8
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 801634c:	2400      	movs	r4, #0
 801634e:	9401      	str	r4, [sp, #4]
 8016350:	f3ef 8305 	mrs	r3, IPSR
  
  if (inHandlerMode()) {
 8016354:	b14b      	cbz	r3, 801636a <osMutexRelease+0x22>
    if (xSemaphoreGiveFromISR(mutex_id, &taskWoken) != pdTRUE) {
 8016356:	a901      	add	r1, sp, #4
 8016358:	f000 fecc 	bl	80170f4 <xQueueGiveFromISR>
 801635c:	2801      	cmp	r0, #1
 801635e:	d10a      	bne.n	8016376 <osMutexRelease+0x2e>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 8016360:	9b01      	ldr	r3, [sp, #4]
 8016362:	b95b      	cbnz	r3, 801637c <osMutexRelease+0x34>
  osStatus result = osOK;
 8016364:	2000      	movs	r0, #0
  else if (xSemaphoreGive(mutex_id) != pdTRUE) 
  {
    result = osErrorOS;
  }
  return result;
}
 8016366:	b002      	add	sp, #8
 8016368:	bd10      	pop	{r4, pc}
  else if (xSemaphoreGive(mutex_id) != pdTRUE) 
 801636a:	461a      	mov	r2, r3
 801636c:	4619      	mov	r1, r3
 801636e:	f000 fd9d 	bl	8016eac <xQueueGenericSend>
 8016372:	2801      	cmp	r0, #1
 8016374:	d0f6      	beq.n	8016364 <osMutexRelease+0x1c>
    result = osErrorOS;
 8016376:	20ff      	movs	r0, #255	; 0xff
}
 8016378:	b002      	add	sp, #8
 801637a:	bd10      	pop	{r4, pc}
    portEND_SWITCHING_ISR(taskWoken);
 801637c:	4b05      	ldr	r3, [pc, #20]	; (8016394 <osMutexRelease+0x4c>)
 801637e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8016382:	601a      	str	r2, [r3, #0]
 8016384:	f3bf 8f4f 	dsb	sy
 8016388:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 801638c:	4620      	mov	r0, r4
}
 801638e:	b002      	add	sp, #8
 8016390:	bd10      	pop	{r4, pc}
 8016392:	bf00      	nop
 8016394:	e000ed04 	.word	0xe000ed04

08016398 <osSemaphoreCreate>:
#endif    
  }
#else  // configSUPPORT_STATIC_ALLOCATION == 0  && configSUPPORT_DYNAMIC_ALLOCATION == 1
  osSemaphoreId sema;
 
  if (count == 1) {
 8016398:	2901      	cmp	r1, #1
{ 
 801639a:	4608      	mov	r0, r1
  if (count == 1) {
 801639c:	d001      	beq.n	80163a2 <osSemaphoreCreate+0xa>
    vSemaphoreCreateBinary(sema);
    return sema;
  }
  else {
#if (configUSE_COUNTING_SEMAPHORES == 1 )	
    return xSemaphoreCreateCounting(count, count);
 801639e:	f000 bd67 	b.w	8016e70 <xQueueCreateCountingSemaphore>
{ 
 80163a2:	b510      	push	{r4, lr}
    vSemaphoreCreateBinary(sema);
 80163a4:	2203      	movs	r2, #3
 80163a6:	2100      	movs	r1, #0
 80163a8:	f000 fd38 	bl	8016e1c <xQueueGenericCreate>
 80163ac:	4604      	mov	r4, r0
 80163ae:	b120      	cbz	r0, 80163ba <osSemaphoreCreate+0x22>
 80163b0:	2300      	movs	r3, #0
 80163b2:	461a      	mov	r2, r3
 80163b4:	4619      	mov	r1, r3
 80163b6:	f000 fd79 	bl	8016eac <xQueueGenericSend>
#else
    return NULL;
#endif
  }
#endif
}
 80163ba:	4620      	mov	r0, r4
 80163bc:	bd10      	pop	{r4, pc}
 80163be:	bf00      	nop

080163c0 <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
 80163c0:	b510      	push	{r4, lr}
 80163c2:	b082      	sub	sp, #8
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 80163c4:	2400      	movs	r4, #0
 80163c6:	9401      	str	r4, [sp, #4]
  
  
  if (semaphore_id == NULL) {
 80163c8:	b310      	cbz	r0, 8016410 <osSemaphoreWait+0x50>
 80163ca:	460a      	mov	r2, r1
 80163cc:	f3ef 8305 	mrs	r3, IPSR
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 80163d0:	b93b      	cbnz	r3, 80163e2 <osSemaphoreWait+0x22>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
      return osErrorOS;
    }
	portEND_SWITCHING_ISR(taskWoken);
  }  
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
 80163d2:	4619      	mov	r1, r3
 80163d4:	f000 fee4 	bl	80171a0 <xQueueGenericReceive>
 80163d8:	2801      	cmp	r0, #1
 80163da:	d116      	bne.n	801640a <osSemaphoreWait+0x4a>
    return osErrorOS;
  }
  
  return osOK;
 80163dc:	2000      	movs	r0, #0
}
 80163de:	b002      	add	sp, #8
 80163e0:	bd10      	pop	{r4, pc}
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 80163e2:	aa01      	add	r2, sp, #4
 80163e4:	4621      	mov	r1, r4
 80163e6:	f000 ffb7 	bl	8017358 <xQueueReceiveFromISR>
 80163ea:	2801      	cmp	r0, #1
 80163ec:	d10d      	bne.n	801640a <osSemaphoreWait+0x4a>
	portEND_SWITCHING_ISR(taskWoken);
 80163ee:	9b01      	ldr	r3, [sp, #4]
 80163f0:	2b00      	cmp	r3, #0
 80163f2:	d0f3      	beq.n	80163dc <osSemaphoreWait+0x1c>
 80163f4:	4b08      	ldr	r3, [pc, #32]	; (8016418 <osSemaphoreWait+0x58>)
 80163f6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80163fa:	601a      	str	r2, [r3, #0]
 80163fc:	f3bf 8f4f 	dsb	sy
 8016400:	f3bf 8f6f 	isb	sy
  return osOK;
 8016404:	4620      	mov	r0, r4
}
 8016406:	b002      	add	sp, #8
 8016408:	bd10      	pop	{r4, pc}
      return osErrorOS;
 801640a:	20ff      	movs	r0, #255	; 0xff
}
 801640c:	b002      	add	sp, #8
 801640e:	bd10      	pop	{r4, pc}
    return osErrorParameter;
 8016410:	2080      	movs	r0, #128	; 0x80
}
 8016412:	b002      	add	sp, #8
 8016414:	bd10      	pop	{r4, pc}
 8016416:	bf00      	nop
 8016418:	e000ed04 	.word	0xe000ed04

0801641c <osSemaphoreRelease>:
 801641c:	f7ff bf94 	b.w	8016348 <osMutexRelease>

08016420 <osPoolCreate>:
* @param  pool_def      memory pool definition referenced with \ref osPool.
* @retval  memory pool ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osPoolCreate shall be consistent in every CMSIS-RTOS.
*/
osPoolId osPoolCreate (const osPoolDef_t *pool_def)
{
 8016420:	b5f0      	push	{r4, r5, r6, r7, lr}
 8016422:	4606      	mov	r6, r0
 8016424:	b083      	sub	sp, #12
  osPoolId thePool;
  int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
  uint32_t i;
  
  /* First have to allocate memory for the pool control block. */
 thePool = pvPortMalloc(sizeof(os_pool_cb_t));
 8016426:	2014      	movs	r0, #20
  int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
 8016428:	6877      	ldr	r7, [r6, #4]
 thePool = pvPortMalloc(sizeof(os_pool_cb_t));
 801642a:	f000 f977 	bl	801671c <pvPortMalloc>

  
  if (thePool) {
 801642e:	4605      	mov	r5, r0
 8016430:	b1e8      	cbz	r0, 801646e <osPoolCreate+0x4e>
  int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
 8016432:	3703      	adds	r7, #3
    thePool->pool_sz = pool_def->pool_sz;
 8016434:	6830      	ldr	r0, [r6, #0]
 8016436:	60a8      	str	r0, [r5, #8]
  int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
 8016438:	f027 0703 	bic.w	r7, r7, #3
    thePool->item_sz = itemSize;
    thePool->currentIndex = 0;
 801643c:	2400      	movs	r4, #0
 801643e:	e9c5 7403 	strd	r7, r4, [r5, #12]
    
    /* Memory for markers */
    thePool->markers = pvPortMalloc(pool_def->pool_sz);
 8016442:	f000 f96b 	bl	801671c <pvPortMalloc>
 8016446:	6068      	str	r0, [r5, #4]
   
    if (thePool->markers) {
 8016448:	b1a0      	cbz	r0, 8016474 <osPoolCreate+0x54>
      /* Now allocate the pool itself. */
     thePool->pool = pvPortMalloc(pool_def->pool_sz * itemSize);
 801644a:	6830      	ldr	r0, [r6, #0]
 801644c:	fb00 f007 	mul.w	r0, r0, r7
 8016450:	f000 f964 	bl	801671c <pvPortMalloc>
 8016454:	4607      	mov	r7, r0
 8016456:	6028      	str	r0, [r5, #0]
      
      if (thePool->pool) {
 8016458:	b198      	cbz	r0, 8016482 <osPoolCreate+0x62>
        for (i = 0; i < pool_def->pool_sz; i++) {
 801645a:	6833      	ldr	r3, [r6, #0]
 801645c:	b13b      	cbz	r3, 801646e <osPoolCreate+0x4e>
 801645e:	4623      	mov	r3, r4
          thePool->markers[i] = 0;
 8016460:	4621      	mov	r1, r4
 8016462:	686a      	ldr	r2, [r5, #4]
 8016464:	54d1      	strb	r1, [r2, r3]
        for (i = 0; i < pool_def->pool_sz; i++) {
 8016466:	6832      	ldr	r2, [r6, #0]
 8016468:	3301      	adds	r3, #1
 801646a:	429a      	cmp	r2, r3
 801646c:	d8f9      	bhi.n	8016462 <osPoolCreate+0x42>
  return thePool;
 
#else
  return NULL;
#endif
}
 801646e:	4628      	mov	r0, r5
 8016470:	b003      	add	sp, #12
 8016472:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8016474:	9001      	str	r0, [sp, #4]
      vPortFree(thePool);
 8016476:	4628      	mov	r0, r5
 8016478:	f000 f9d0 	bl	801681c <vPortFree>
      thePool = NULL;
 801647c:	9b01      	ldr	r3, [sp, #4]
 801647e:	461d      	mov	r5, r3
  return thePool;
 8016480:	e7f5      	b.n	801646e <osPoolCreate+0x4e>
        vPortFree(thePool->markers);
 8016482:	6868      	ldr	r0, [r5, #4]
 8016484:	f000 f9ca 	bl	801681c <vPortFree>
        vPortFree(thePool);
 8016488:	4628      	mov	r0, r5
 801648a:	f000 f9c7 	bl	801681c <vPortFree>
        thePool = NULL;
 801648e:	463d      	mov	r5, r7
 8016490:	e7ed      	b.n	801646e <osPoolCreate+0x4e>
 8016492:	bf00      	nop

08016494 <osPoolAlloc>:
* @param pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
* @retval  address of the allocated memory block or NULL in case of no memory available.
* @note   MUST REMAIN UNCHANGED: \b osPoolAlloc shall be consistent in every CMSIS-RTOS.
*/
void *osPoolAlloc (osPoolId pool_id)
{
 8016494:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8016498:	4680      	mov	r8, r0
 801649a:	f3ef 8405 	mrs	r4, IPSR
  int dummy = 0;
  void *p = NULL;
  uint32_t i;
  uint32_t index;
  
  if (inHandlerMode()) {
 801649e:	2c00      	cmp	r4, #0
 80164a0:	d03c      	beq.n	801651c <osPoolAlloc+0x88>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 80164a2:	f3ef 8411 	mrs	r4, BASEPRI
 80164a6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80164aa:	f383 8811 	msr	BASEPRI, r3
 80164ae:	f3bf 8f6f 	isb	sy
 80164b2:	f3bf 8f4f 	dsb	sy
    dummy = portSET_INTERRUPT_MASK_FROM_ISR();
 80164b6:	46a4      	mov	ip, r4
  }
  else {
    vPortEnterCritical();
  }
  
  for (i = 0; i < pool_id->pool_sz; i++) {
 80164b8:	f8d8 4008 	ldr.w	r4, [r8, #8]
 80164bc:	b1e4      	cbz	r4, 80164f8 <osPoolAlloc+0x64>
    index = pool_id->currentIndex + i;
 80164be:	f8d8 3010 	ldr.w	r3, [r8, #16]
    if (index >= pool_id->pool_sz) {
      index = 0;
    }
    
    if (pool_id->markers[index] == 0) {
 80164c2:	f8d8 6004 	ldr.w	r6, [r8, #4]
 80164c6:	18e7      	adds	r7, r4, r3
 80164c8:	e001      	b.n	80164ce <osPoolAlloc+0x3a>
  for (i = 0; i < pool_id->pool_sz; i++) {
 80164ca:	42bb      	cmp	r3, r7
 80164cc:	d01c      	beq.n	8016508 <osPoolAlloc+0x74>
    if (index >= pool_id->pool_sz) {
 80164ce:	429c      	cmp	r4, r3
 80164d0:	bf8a      	itet	hi
 80164d2:	18f2      	addhi	r2, r6, r3
 80164d4:	4632      	movls	r2, r6
 80164d6:	461d      	movhi	r5, r3
    if (pool_id->markers[index] == 0) {
 80164d8:	7811      	ldrb	r1, [r2, #0]
      index = 0;
 80164da:	bf98      	it	ls
 80164dc:	2500      	movls	r5, #0
 80164de:	3301      	adds	r3, #1
    if (pool_id->markers[index] == 0) {
 80164e0:	2900      	cmp	r1, #0
 80164e2:	d1f2      	bne.n	80164ca <osPoolAlloc+0x36>
      pool_id->markers[index] = 1;
 80164e4:	2301      	movs	r3, #1
 80164e6:	7013      	strb	r3, [r2, #0]
      p = (void *)((uint32_t)(pool_id->pool) + (index * pool_id->item_sz));
 80164e8:	f8d8 400c 	ldr.w	r4, [r8, #12]
 80164ec:	f8d8 0000 	ldr.w	r0, [r8]
      pool_id->currentIndex = index;
 80164f0:	f8c8 5010 	str.w	r5, [r8, #16]
      p = (void *)((uint32_t)(pool_id->pool) + (index * pool_id->item_sz));
 80164f4:	fb04 0405 	mla	r4, r4, r5, r0
 80164f8:	f3ef 8305 	mrs	r3, IPSR
      break;
    }
  }
  
  if (inHandlerMode()) {
 80164fc:	b14b      	cbz	r3, 8016512 <osPoolAlloc+0x7e>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 80164fe:	f38c 8811 	msr	BASEPRI, ip
  else {
    vPortExitCritical();
  }
  
  return p;
}
 8016502:	4620      	mov	r0, r4
 8016504:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  void *p = NULL;
 8016508:	2400      	movs	r4, #0
 801650a:	f3ef 8305 	mrs	r3, IPSR
  if (inHandlerMode()) {
 801650e:	2b00      	cmp	r3, #0
 8016510:	d1f5      	bne.n	80164fe <osPoolAlloc+0x6a>
    vPortExitCritical();
 8016512:	f000 fa39 	bl	8016988 <vPortExitCritical>
}
 8016516:	4620      	mov	r0, r4
 8016518:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    vPortEnterCritical();
 801651c:	f000 fa12 	bl	8016944 <vPortEnterCritical>
  int dummy = 0;
 8016520:	46a4      	mov	ip, r4
 8016522:	e7c9      	b.n	80164b8 <osPoolAlloc+0x24>

08016524 <osMailCreate>:
* @param   thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval mail queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMailCreate shall be consistent in every CMSIS-RTOS.
*/
osMailQId osMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id)
{
 8016524:	b570      	push	{r4, r5, r6, lr}
#if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
  (void) thread_id;
  
  osPoolDef_t pool_def = {queue_def->queue_sz, queue_def->item_sz, NULL};
 8016526:	e9d0 2300 	ldrd	r2, r3, [r0]
{
 801652a:	b084      	sub	sp, #16
 801652c:	4605      	mov	r5, r0
  osPoolDef_t pool_def = {queue_def->queue_sz, queue_def->item_sz, NULL};
 801652e:	2600      	movs	r6, #0
  
  /* Create a mail queue control block */

  *(queue_def->cb) = pvPortMalloc(sizeof(struct os_mailQ_cb));
 8016530:	200c      	movs	r0, #12
 8016532:	68ac      	ldr	r4, [r5, #8]
  osPoolDef_t pool_def = {queue_def->queue_sz, queue_def->item_sz, NULL};
 8016534:	9302      	str	r3, [sp, #8]
 8016536:	9201      	str	r2, [sp, #4]
 8016538:	9603      	str	r6, [sp, #12]
  *(queue_def->cb) = pvPortMalloc(sizeof(struct os_mailQ_cb));
 801653a:	f000 f8ef 	bl	801671c <pvPortMalloc>

  if (*(queue_def->cb) == NULL) {
 801653e:	68ab      	ldr	r3, [r5, #8]
  *(queue_def->cb) = pvPortMalloc(sizeof(struct os_mailQ_cb));
 8016540:	6020      	str	r0, [r4, #0]
  if (*(queue_def->cb) == NULL) {
 8016542:	681c      	ldr	r4, [r3, #0]
 8016544:	b1a4      	cbz	r4, 8016570 <osMailCreate+0x4c>
    return NULL;
  }
  (*(queue_def->cb))->queue_def = queue_def;
 8016546:	6025      	str	r5, [r4, #0]
  
  /* Create a queue in FreeRTOS */
  (*(queue_def->cb))->handle = xQueueCreate(queue_def->queue_sz, sizeof(void *));
 8016548:	4632      	mov	r2, r6
 801654a:	2104      	movs	r1, #4
 801654c:	6828      	ldr	r0, [r5, #0]
 801654e:	f000 fc65 	bl	8016e1c <xQueueGenericCreate>


  if ((*(queue_def->cb))->handle == NULL) {
 8016552:	68ab      	ldr	r3, [r5, #8]
  (*(queue_def->cb))->handle = xQueueCreate(queue_def->queue_sz, sizeof(void *));
 8016554:	6060      	str	r0, [r4, #4]
  if ((*(queue_def->cb))->handle == NULL) {
 8016556:	681e      	ldr	r6, [r3, #0]
 8016558:	6874      	ldr	r4, [r6, #4]
 801655a:	b15c      	cbz	r4, 8016574 <osMailCreate+0x50>
    vPortFree(*(queue_def->cb));
    return NULL;
  }
  
  /* Create a mail pool */
  (*(queue_def->cb))->pool = osPoolCreate(&pool_def);
 801655c:	a801      	add	r0, sp, #4
 801655e:	f7ff ff5f 	bl	8016420 <osPoolCreate>
  if ((*(queue_def->cb))->pool == NULL) {
 8016562:	68ab      	ldr	r3, [r5, #8]
  (*(queue_def->cb))->pool = osPoolCreate(&pool_def);
 8016564:	60b0      	str	r0, [r6, #8]
  if ((*(queue_def->cb))->pool == NULL) {
 8016566:	6818      	ldr	r0, [r3, #0]
 8016568:	6884      	ldr	r4, [r0, #8]
 801656a:	b144      	cbz	r4, 801657e <osMailCreate+0x5a>
  
  return *(queue_def->cb);
#else
  return NULL;
#endif
}
 801656c:	b004      	add	sp, #16
 801656e:	bd70      	pop	{r4, r5, r6, pc}
    return NULL;
 8016570:	4620      	mov	r0, r4
 8016572:	e7fb      	b.n	801656c <osMailCreate+0x48>
    vPortFree(*(queue_def->cb));
 8016574:	4630      	mov	r0, r6
 8016576:	f000 f951 	bl	801681c <vPortFree>
    return NULL;
 801657a:	4620      	mov	r0, r4
 801657c:	e7f6      	b.n	801656c <osMailCreate+0x48>
    vPortFree(*(queue_def->cb));
 801657e:	f000 f94d 	bl	801681c <vPortFree>
    return NULL;
 8016582:	4620      	mov	r0, r4
 8016584:	e7f2      	b.n	801656c <osMailCreate+0x48>
 8016586:	bf00      	nop

08016588 <osMailAlloc>:
{
  (void) millisec;
  void *p;
  
  
  if (queue_id == NULL) {
 8016588:	b110      	cbz	r0, 8016590 <osMailAlloc+0x8>
    return NULL;
  }
  
  p = osPoolAlloc(queue_id->pool);
 801658a:	6880      	ldr	r0, [r0, #8]
 801658c:	f7ff bf82 	b.w	8016494 <osPoolAlloc>
  
  return p;
}
 8016590:	4770      	bx	lr
 8016592:	bf00      	nop

08016594 <osMailPut>:
* @param  mail          memory block previously allocated with \ref osMailAlloc or \ref osMailCAlloc.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMailPut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMailPut (osMailQId queue_id, void *mail)
{
 8016594:	b510      	push	{r4, lr}
 8016596:	b084      	sub	sp, #16
 8016598:	9101      	str	r1, [sp, #4]
  portBASE_TYPE taskWoken;
  
  
  if (queue_id == NULL) {
 801659a:	b330      	cbz	r0, 80165ea <osMailPut+0x56>
    return osErrorParameter;
  }
  
  taskWoken = pdFALSE;
 801659c:	2400      	movs	r4, #0
 801659e:	9403      	str	r4, [sp, #12]
 80165a0:	f3ef 8305 	mrs	r3, IPSR
 80165a4:	6840      	ldr	r0, [r0, #4]
  
  if (inHandlerMode()) {
 80165a6:	b943      	cbnz	r3, 80165ba <osMailPut+0x26>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
  }
  else {
    if (xQueueSend(queue_id->handle, &mail, 0) != pdTRUE) { 
 80165a8:	461a      	mov	r2, r3
 80165aa:	a901      	add	r1, sp, #4
 80165ac:	f000 fc7e 	bl	8016eac <xQueueGenericSend>
 80165b0:	2801      	cmp	r0, #1
 80165b2:	d117      	bne.n	80165e4 <osMailPut+0x50>
      return osErrorOS;
    }
  }
  
  return osOK;
 80165b4:	2000      	movs	r0, #0
}
 80165b6:	b004      	add	sp, #16
 80165b8:	bd10      	pop	{r4, pc}
    if (xQueueSendFromISR(queue_id->handle, &mail, &taskWoken) != pdTRUE) {
 80165ba:	4623      	mov	r3, r4
 80165bc:	aa03      	add	r2, sp, #12
 80165be:	a901      	add	r1, sp, #4
 80165c0:	f000 fd32 	bl	8017028 <xQueueGenericSendFromISR>
 80165c4:	2801      	cmp	r0, #1
 80165c6:	d10d      	bne.n	80165e4 <osMailPut+0x50>
    portEND_SWITCHING_ISR(taskWoken);
 80165c8:	9b03      	ldr	r3, [sp, #12]
 80165ca:	2b00      	cmp	r3, #0
 80165cc:	d0f2      	beq.n	80165b4 <osMailPut+0x20>
 80165ce:	4b08      	ldr	r3, [pc, #32]	; (80165f0 <osMailPut+0x5c>)
 80165d0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80165d4:	601a      	str	r2, [r3, #0]
 80165d6:	f3bf 8f4f 	dsb	sy
 80165da:	f3bf 8f6f 	isb	sy
  return osOK;
 80165de:	4620      	mov	r0, r4
}
 80165e0:	b004      	add	sp, #16
 80165e2:	bd10      	pop	{r4, pc}
      return osErrorOS;
 80165e4:	20ff      	movs	r0, #255	; 0xff
}
 80165e6:	b004      	add	sp, #16
 80165e8:	bd10      	pop	{r4, pc}
    return osErrorParameter;
 80165ea:	2080      	movs	r0, #128	; 0x80
}
 80165ec:	b004      	add	sp, #16
 80165ee:	bd10      	pop	{r4, pc}
 80165f0:	e000ed04 	.word	0xe000ed04

080165f4 <osMailGet>:
* @param millisec    timeout value or 0 in case of no time-out
* @retval event that contains mail information or error code.
* @note   MUST REMAIN UNCHANGED: \b osMailGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMailGet (osMailQId queue_id, uint32_t millisec)
{
 80165f4:	b570      	push	{r4, r5, r6, lr}
 80165f6:	b084      	sub	sp, #16
 80165f8:	4604      	mov	r4, r0
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.mail_id = queue_id;
 80165fa:	9103      	str	r1, [sp, #12]
  
  if (queue_id == NULL) {
 80165fc:	2900      	cmp	r1, #0
 80165fe:	d02e      	beq.n	801665e <osMailGet+0x6a>
    event.status = osErrorParameter;
    return event;
  }
  
  taskWoken = pdFALSE;
 8016600:	2500      	movs	r5, #0
 8016602:	9500      	str	r5, [sp, #0]
 8016604:	f3ef 8305 	mrs	r3, IPSR
 8016608:	6848      	ldr	r0, [r1, #4]
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 801660a:	b993      	cbnz	r3, 8016632 <osMailGet+0x3e>
      event.status = osOK;
    }
    portEND_SWITCHING_ISR(taskWoken);
  }
  else {
    if (xQueueReceive(queue_id->handle, &event.value.p, ticks) == pdTRUE) {
 801660c:	a902      	add	r1, sp, #8
 801660e:	4616      	mov	r6, r2
 8016610:	f000 fdc6 	bl	80171a0 <xQueueGenericReceive>
 8016614:	2801      	cmp	r0, #1
 8016616:	d02d      	beq.n	8016674 <osMailGet+0x80>
      /* We have mail */
      event.status = osEventMail;
    }
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 8016618:	2e00      	cmp	r6, #0
 801661a:	bf14      	ite	ne
 801661c:	2340      	movne	r3, #64	; 0x40
 801661e:	2300      	moveq	r3, #0
 8016620:	9301      	str	r3, [sp, #4]
    }
  }
  
  return event;
 8016622:	ab04      	add	r3, sp, #16
 8016624:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 8016628:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 801662c:	4620      	mov	r0, r4
 801662e:	b004      	add	sp, #16
 8016630:	bd70      	pop	{r4, r5, r6, pc}
    if (xQueueReceiveFromISR(queue_id->handle, &event.value.p, &taskWoken) == pdTRUE) {
 8016632:	466a      	mov	r2, sp
 8016634:	a902      	add	r1, sp, #8
 8016636:	f000 fe8f 	bl	8017358 <xQueueReceiveFromISR>
 801663a:	2801      	cmp	r0, #1
      event.status = osEventMail;
 801663c:	bf04      	itt	eq
 801663e:	2320      	moveq	r3, #32
 8016640:	9301      	streq	r3, [sp, #4]
    portEND_SWITCHING_ISR(taskWoken);
 8016642:	9b00      	ldr	r3, [sp, #0]
      event.status = osOK;
 8016644:	bf18      	it	ne
 8016646:	9501      	strne	r5, [sp, #4]
    portEND_SWITCHING_ISR(taskWoken);
 8016648:	2b00      	cmp	r3, #0
 801664a:	d0ea      	beq.n	8016622 <osMailGet+0x2e>
 801664c:	4b0b      	ldr	r3, [pc, #44]	; (801667c <osMailGet+0x88>)
 801664e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8016652:	601a      	str	r2, [r3, #0]
 8016654:	f3bf 8f4f 	dsb	sy
 8016658:	f3bf 8f6f 	isb	sy
 801665c:	e7e1      	b.n	8016622 <osMailGet+0x2e>
    event.status = osErrorParameter;
 801665e:	ab04      	add	r3, sp, #16
 8016660:	2280      	movs	r2, #128	; 0x80
 8016662:	f843 2d0c 	str.w	r2, [r3, #-12]!
    return event;
 8016666:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 801666a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 801666e:	4620      	mov	r0, r4
 8016670:	b004      	add	sp, #16
 8016672:	bd70      	pop	{r4, r5, r6, pc}
      event.status = osEventMail;
 8016674:	2320      	movs	r3, #32
 8016676:	9301      	str	r3, [sp, #4]
 8016678:	e7d3      	b.n	8016622 <osMailGet+0x2e>
 801667a:	bf00      	nop
 801667c:	e000ed04 	.word	0xe000ed04

08016680 <osMailFree>:
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMailFree shall be consistent in every CMSIS-RTOS.
*/
osStatus osMailFree (osMailQId queue_id, void *mail)
{
  if (queue_id == NULL) {
 8016680:	b1b0      	cbz	r0, 80166b0 <osMailFree+0x30>
    return osErrorParameter;
  }
  
  return osPoolFree(queue_id->pool, mail);
 8016682:	6883      	ldr	r3, [r0, #8]
  if (pool_id == NULL) {
 8016684:	b1a3      	cbz	r3, 80166b0 <osMailFree+0x30>
  if (block == NULL) {
 8016686:	b199      	cbz	r1, 80166b0 <osMailFree+0x30>
  if (block < pool_id->pool) {
 8016688:	6818      	ldr	r0, [r3, #0]
 801668a:	4281      	cmp	r1, r0
 801668c:	d310      	bcc.n	80166b0 <osMailFree+0x30>
  if (index % pool_id->item_sz) {
 801668e:	68da      	ldr	r2, [r3, #12]
  index = (uint32_t)block - (uint32_t)(pool_id->pool);
 8016690:	1a09      	subs	r1, r1, r0
{
 8016692:	b410      	push	{r4}
  if (index % pool_id->item_sz) {
 8016694:	fbb1 f4f2 	udiv	r4, r1, r2
 8016698:	fb02 1114 	mls	r1, r2, r4, r1
 801669c:	b951      	cbnz	r1, 80166b4 <osMailFree+0x34>
  if (index >= pool_id->pool_sz) {
 801669e:	689a      	ldr	r2, [r3, #8]
 80166a0:	4294      	cmp	r4, r2
 80166a2:	d207      	bcs.n	80166b4 <osMailFree+0x34>
  pool_id->markers[index] = 0;
 80166a4:	685b      	ldr	r3, [r3, #4]
 80166a6:	5519      	strb	r1, [r3, r4]
  return osOK;
 80166a8:	4608      	mov	r0, r1
}
 80166aa:	f85d 4b04 	ldr.w	r4, [sp], #4
 80166ae:	4770      	bx	lr
    return osErrorParameter;
 80166b0:	2080      	movs	r0, #128	; 0x80
}
 80166b2:	4770      	bx	lr
    return osErrorParameter;
 80166b4:	2080      	movs	r0, #128	; 0x80
}
 80166b6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80166ba:	4770      	bx	lr

080166bc <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 80166bc:	b508      	push	{r3, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 80166be:	f001 fb37 	bl	8017d30 <xTaskGetSchedulerState>
 80166c2:	2801      	cmp	r0, #1
 80166c4:	d003      	beq.n	80166ce <osSystickHandler+0x12>
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 80166c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    xPortSysTickHandler();
 80166ca:	f000 b9a3 	b.w	8016a14 <xPortSysTickHandler>
}
 80166ce:	bd08      	pop	{r3, pc}

080166d0 <prvInsertBlockIntoFreeList>:
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80166d0:	4b11      	ldr	r3, [pc, #68]	; (8016718 <prvInsertBlockIntoFreeList+0x48>)
{
 80166d2:	b430      	push	{r4, r5}
 80166d4:	461d      	mov	r5, r3
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80166d6:	681a      	ldr	r2, [r3, #0]
 80166d8:	4282      	cmp	r2, r0
 80166da:	d201      	bcs.n	80166e0 <prvInsertBlockIntoFreeList+0x10>
 80166dc:	4613      	mov	r3, r2
 80166de:	e7fa      	b.n	80166d6 <prvInsertBlockIntoFreeList+0x6>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80166e0:	685c      	ldr	r4, [r3, #4]
 80166e2:	1919      	adds	r1, r3, r4
 80166e4:	4288      	cmp	r0, r1
 80166e6:	d103      	bne.n	80166f0 <prvInsertBlockIntoFreeList+0x20>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 80166e8:	6841      	ldr	r1, [r0, #4]
 80166ea:	4421      	add	r1, r4
 80166ec:	6059      	str	r1, [r3, #4]
 80166ee:	4618      	mov	r0, r3
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80166f0:	6844      	ldr	r4, [r0, #4]
 80166f2:	1901      	adds	r1, r0, r4
 80166f4:	428a      	cmp	r2, r1
 80166f6:	d108      	bne.n	801670a <prvInsertBlockIntoFreeList+0x3a>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 80166f8:	68a9      	ldr	r1, [r5, #8]
 80166fa:	428a      	cmp	r2, r1
 80166fc:	d005      	beq.n	801670a <prvInsertBlockIntoFreeList+0x3a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 80166fe:	e9d2 2100 	ldrd	r2, r1, [r2]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8016702:	4421      	add	r1, r4
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8016704:	6002      	str	r2, [r0, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8016706:	6041      	str	r1, [r0, #4]
 8016708:	e000      	b.n	801670c <prvInsertBlockIntoFreeList+0x3c>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 801670a:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 801670c:	4298      	cmp	r0, r3
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 801670e:	bf18      	it	ne
 8016710:	6018      	strne	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8016712:	bc30      	pop	{r4, r5}
 8016714:	4770      	bx	lr
 8016716:	bf00      	nop
 8016718:	2000b6c4 	.word	0x2000b6c4

0801671c <pvPortMalloc>:
{
 801671c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if( pxEnd == NULL )
 8016720:	4d3b      	ldr	r5, [pc, #236]	; (8016810 <pvPortMalloc+0xf4>)
{
 8016722:	4604      	mov	r4, r0
	vTaskSuspendAll();
 8016724:	f001 f816 	bl	8017754 <vTaskSuspendAll>
		if( pxEnd == NULL )
 8016728:	68ab      	ldr	r3, [r5, #8]
 801672a:	2b00      	cmp	r3, #0
 801672c:	d056      	beq.n	80167dc <pvPortMalloc+0xc0>
 801672e:	68ee      	ldr	r6, [r5, #12]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8016730:	4234      	tst	r4, r6
 8016732:	d14c      	bne.n	80167ce <pvPortMalloc+0xb2>
			if( xWantedSize > 0 )
 8016734:	2c00      	cmp	r4, #0
 8016736:	d04a      	beq.n	80167ce <pvPortMalloc+0xb2>
				xWantedSize += xHeapStructSize;
 8016738:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 801673c:	0759      	lsls	r1, r3, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 801673e:	bf1c      	itt	ne
 8016740:	f023 0307 	bicne.w	r3, r3, #7
 8016744:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8016746:	2b00      	cmp	r3, #0
 8016748:	d041      	beq.n	80167ce <pvPortMalloc+0xb2>
 801674a:	696f      	ldr	r7, [r5, #20]
 801674c:	429f      	cmp	r7, r3
 801674e:	d33e      	bcc.n	80167ce <pvPortMalloc+0xb2>
				pxBlock = xStart.pxNextFreeBlock;
 8016750:	682c      	ldr	r4, [r5, #0]
				pxPreviousBlock = &xStart;
 8016752:	482f      	ldr	r0, [pc, #188]	; (8016810 <pvPortMalloc+0xf4>)
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8016754:	e003      	b.n	801675e <pvPortMalloc+0x42>
 8016756:	6821      	ldr	r1, [r4, #0]
 8016758:	b121      	cbz	r1, 8016764 <pvPortMalloc+0x48>
 801675a:	4620      	mov	r0, r4
 801675c:	460c      	mov	r4, r1
 801675e:	6862      	ldr	r2, [r4, #4]
 8016760:	429a      	cmp	r2, r3
 8016762:	d3f8      	bcc.n	8016756 <pvPortMalloc+0x3a>
				if( pxBlock != pxEnd )
 8016764:	68a9      	ldr	r1, [r5, #8]
 8016766:	42a1      	cmp	r1, r4
 8016768:	d031      	beq.n	80167ce <pvPortMalloc+0xb2>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 801676a:	6821      	ldr	r1, [r4, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 801676c:	f8d0 8000 	ldr.w	r8, [r0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8016770:	6001      	str	r1, [r0, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8016772:	1ad1      	subs	r1, r2, r3
 8016774:	2910      	cmp	r1, #16
 8016776:	d910      	bls.n	801679a <pvPortMalloc+0x7e>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8016778:	18e0      	adds	r0, r4, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 801677a:	0742      	lsls	r2, r0, #29
 801677c:	d008      	beq.n	8016790 <pvPortMalloc+0x74>
	__asm volatile
 801677e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016782:	f383 8811 	msr	BASEPRI, r3
 8016786:	f3bf 8f6f 	isb	sy
 801678a:	f3bf 8f4f 	dsb	sy
 801678e:	e7fe      	b.n	801678e <pvPortMalloc+0x72>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8016790:	6041      	str	r1, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8016792:	6063      	str	r3, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8016794:	f7ff ff9c 	bl	80166d0 <prvInsertBlockIntoFreeList>
 8016798:	6862      	ldr	r2, [r4, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 801679a:	6929      	ldr	r1, [r5, #16]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 801679c:	1abf      	subs	r7, r7, r2
					pxBlock->pxNextFreeBlock = NULL;
 801679e:	2300      	movs	r3, #0
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80167a0:	4332      	orrs	r2, r6
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80167a2:	428f      	cmp	r7, r1
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80167a4:	6062      	str	r2, [r4, #4]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80167a6:	f108 0808 	add.w	r8, r8, #8
					pxBlock->pxNextFreeBlock = NULL;
 80167aa:	6023      	str	r3, [r4, #0]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 80167ac:	bf38      	it	cc
 80167ae:	612f      	strcc	r7, [r5, #16]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80167b0:	616f      	str	r7, [r5, #20]
	( void ) xTaskResumeAll();
 80167b2:	f001 f887 	bl	80178c4 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 80167b6:	f018 0f07 	tst.w	r8, #7
 80167ba:	d00c      	beq.n	80167d6 <pvPortMalloc+0xba>
 80167bc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80167c0:	f383 8811 	msr	BASEPRI, r3
 80167c4:	f3bf 8f6f 	isb	sy
 80167c8:	f3bf 8f4f 	dsb	sy
 80167cc:	e7fe      	b.n	80167cc <pvPortMalloc+0xb0>
	( void ) xTaskResumeAll();
 80167ce:	f001 f879 	bl	80178c4 <xTaskResumeAll>
 80167d2:	f04f 0800 	mov.w	r8, #0
}
 80167d6:	4640      	mov	r0, r8
 80167d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uxAddress = ( size_t ) ucHeap;
 80167dc:	4b0d      	ldr	r3, [pc, #52]	; (8016814 <pvPortMalloc+0xf8>)
	uxAddress -= xHeapStructSize;
 80167de:	4a0e      	ldr	r2, [pc, #56]	; (8016818 <pvPortMalloc+0xfc>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 80167e0:	0758      	lsls	r0, r3, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 80167e2:	bf18      	it	ne
 80167e4:	3307      	addne	r3, #7
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80167e6:	f022 0207 	bic.w	r2, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80167ea:	bf18      	it	ne
 80167ec:	f023 0307 	bicne.w	r3, r3, #7
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80167f0:	602b      	str	r3, [r5, #0]
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 80167f2:	4619      	mov	r1, r3
	xStart.xBlockSize = ( size_t ) 0;
 80167f4:	2000      	movs	r0, #0
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 80167f6:	1ad3      	subs	r3, r2, r3
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80167f8:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
	xStart.xBlockSize = ( size_t ) 0;
 80167fc:	e9c5 0201 	strd	r0, r2, [r5, #4]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8016800:	e9c5 3304 	strd	r3, r3, [r5, #16]
	pxEnd->pxNextFreeBlock = NULL;
 8016804:	e9c2 0000 	strd	r0, r0, [r2]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8016808:	60ee      	str	r6, [r5, #12]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 801680a:	e9c1 2300 	strd	r2, r3, [r1]
 801680e:	e78f      	b.n	8016730 <pvPortMalloc+0x14>
 8016810:	2000b6c4 	.word	0x2000b6c4
 8016814:	2000b6dc 	.word	0x2000b6dc
 8016818:	2000dea2 	.word	0x2000dea2

0801681c <vPortFree>:
	if( pv != NULL )
 801681c:	b1d8      	cbz	r0, 8016856 <vPortFree+0x3a>
{
 801681e:	b538      	push	{r3, r4, r5, lr}
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8016820:	4d17      	ldr	r5, [pc, #92]	; (8016880 <vPortFree+0x64>)
 8016822:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8016826:	68ea      	ldr	r2, [r5, #12]
 8016828:	4213      	tst	r3, r2
 801682a:	d108      	bne.n	801683e <vPortFree+0x22>
 801682c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016830:	f383 8811 	msr	BASEPRI, r3
 8016834:	f3bf 8f6f 	isb	sy
 8016838:	f3bf 8f4f 	dsb	sy
 801683c:	e7fe      	b.n	801683c <vPortFree+0x20>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 801683e:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8016842:	b149      	cbz	r1, 8016858 <vPortFree+0x3c>
 8016844:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016848:	f383 8811 	msr	BASEPRI, r3
 801684c:	f3bf 8f6f 	isb	sy
 8016850:	f3bf 8f4f 	dsb	sy
 8016854:	e7fe      	b.n	8016854 <vPortFree+0x38>
 8016856:	4770      	bx	lr
 8016858:	4604      	mov	r4, r0
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 801685a:	ea23 0302 	bic.w	r3, r3, r2
 801685e:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8016862:	f000 ff77 	bl	8017754 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8016866:	696a      	ldr	r2, [r5, #20]
 8016868:	f854 3c04 	ldr.w	r3, [r4, #-4]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 801686c:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 8016870:	4413      	add	r3, r2
 8016872:	616b      	str	r3, [r5, #20]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8016874:	f7ff ff2c 	bl	80166d0 <prvInsertBlockIntoFreeList>
}
 8016878:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				( void ) xTaskResumeAll();
 801687c:	f001 b822 	b.w	80178c4 <xTaskResumeAll>
 8016880:	2000b6c4 	.word	0x2000b6c4

08016884 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8016884:	4b0a      	ldr	r3, [pc, #40]	; (80168b0 <prvTaskExitError+0x2c>)
 8016886:	681b      	ldr	r3, [r3, #0]
 8016888:	3301      	adds	r3, #1
 801688a:	d008      	beq.n	801689e <prvTaskExitError+0x1a>
 801688c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016890:	f383 8811 	msr	BASEPRI, r3
 8016894:	f3bf 8f6f 	isb	sy
 8016898:	f3bf 8f4f 	dsb	sy
 801689c:	e7fe      	b.n	801689c <prvTaskExitError+0x18>
 801689e:	f04f 0350 	mov.w	r3, #80	; 0x50
 80168a2:	f383 8811 	msr	BASEPRI, r3
 80168a6:	f3bf 8f6f 	isb	sy
 80168aa:	f3bf 8f4f 	dsb	sy
 80168ae:	e7fe      	b.n	80168ae <prvTaskExitError+0x2a>
 80168b0:	200011d8 	.word	0x200011d8

080168b4 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 80168b4:	4806      	ldr	r0, [pc, #24]	; (80168d0 <prvPortStartFirstTask+0x1c>)
 80168b6:	6800      	ldr	r0, [r0, #0]
 80168b8:	6800      	ldr	r0, [r0, #0]
 80168ba:	f380 8808 	msr	MSP, r0
 80168be:	b662      	cpsie	i
 80168c0:	b661      	cpsie	f
 80168c2:	f3bf 8f4f 	dsb	sy
 80168c6:	f3bf 8f6f 	isb	sy
 80168ca:	df00      	svc	0
 80168cc:	bf00      	nop
 80168ce:	0000      	.short	0x0000
 80168d0:	e000ed08 	.word	0xe000ed08

080168d4 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 80168d4:	f8df 000c 	ldr.w	r0, [pc, #12]	; 80168e4 <vPortEnableVFP+0x10>
 80168d8:	6801      	ldr	r1, [r0, #0]
 80168da:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80168de:	6001      	str	r1, [r0, #0]
 80168e0:	4770      	bx	lr
 80168e2:	0000      	.short	0x0000
 80168e4:	e000ed88 	.word	0xe000ed88

080168e8 <pxPortInitialiseStack>:
{
 80168e8:	b430      	push	{r4, r5}
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80168ea:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80168ee:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80168f2:	4c07      	ldr	r4, [pc, #28]	; (8016910 <pxPortInitialiseStack+0x28>)
 80168f4:	f840 4c0c 	str.w	r4, [r0, #-12]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 80168f8:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80168fc:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8016900:	e940 1502 	strd	r1, r5, [r0, #-8]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 8016904:	f840 3c24 	str.w	r3, [r0, #-36]
}
 8016908:	bc30      	pop	{r4, r5}
 801690a:	3844      	subs	r0, #68	; 0x44
 801690c:	4770      	bx	lr
 801690e:	bf00      	nop
 8016910:	08016885 	.word	0x08016885
	...

08016920 <SVC_Handler>:
	__asm volatile (
 8016920:	4b07      	ldr	r3, [pc, #28]	; (8016940 <pxCurrentTCBConst2>)
 8016922:	6819      	ldr	r1, [r3, #0]
 8016924:	6808      	ldr	r0, [r1, #0]
 8016926:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801692a:	f380 8809 	msr	PSP, r0
 801692e:	f3bf 8f6f 	isb	sy
 8016932:	f04f 0000 	mov.w	r0, #0
 8016936:	f380 8811 	msr	BASEPRI, r0
 801693a:	4770      	bx	lr
 801693c:	f3af 8000 	nop.w

08016940 <pxCurrentTCBConst2>:
 8016940:	2000dec4 	.word	0x2000dec4

08016944 <vPortEnterCritical>:
 8016944:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016948:	f383 8811 	msr	BASEPRI, r3
 801694c:	f3bf 8f6f 	isb	sy
 8016950:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8016954:	4a0a      	ldr	r2, [pc, #40]	; (8016980 <vPortEnterCritical+0x3c>)
 8016956:	6813      	ldr	r3, [r2, #0]
 8016958:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 801695a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 801695c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 801695e:	d000      	beq.n	8016962 <vPortEnterCritical+0x1e>
}
 8016960:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8016962:	4b08      	ldr	r3, [pc, #32]	; (8016984 <vPortEnterCritical+0x40>)
 8016964:	681b      	ldr	r3, [r3, #0]
 8016966:	f013 0fff 	tst.w	r3, #255	; 0xff
 801696a:	d0f9      	beq.n	8016960 <vPortEnterCritical+0x1c>
 801696c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016970:	f383 8811 	msr	BASEPRI, r3
 8016974:	f3bf 8f6f 	isb	sy
 8016978:	f3bf 8f4f 	dsb	sy
 801697c:	e7fe      	b.n	801697c <vPortEnterCritical+0x38>
 801697e:	bf00      	nop
 8016980:	200011d8 	.word	0x200011d8
 8016984:	e000ed04 	.word	0xe000ed04

08016988 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8016988:	4a08      	ldr	r2, [pc, #32]	; (80169ac <vPortExitCritical+0x24>)
 801698a:	6813      	ldr	r3, [r2, #0]
 801698c:	b943      	cbnz	r3, 80169a0 <vPortExitCritical+0x18>
 801698e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016992:	f383 8811 	msr	BASEPRI, r3
 8016996:	f3bf 8f6f 	isb	sy
 801699a:	f3bf 8f4f 	dsb	sy
 801699e:	e7fe      	b.n	801699e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 80169a0:	3b01      	subs	r3, #1
 80169a2:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 80169a4:	b90b      	cbnz	r3, 80169aa <vPortExitCritical+0x22>
	__asm volatile
 80169a6:	f383 8811 	msr	BASEPRI, r3
}
 80169aa:	4770      	bx	lr
 80169ac:	200011d8 	.word	0x200011d8

080169b0 <PendSV_Handler>:
	__asm volatile
 80169b0:	f3ef 8009 	mrs	r0, PSP
 80169b4:	f3bf 8f6f 	isb	sy
 80169b8:	4b15      	ldr	r3, [pc, #84]	; (8016a10 <pxCurrentTCBConst>)
 80169ba:	681a      	ldr	r2, [r3, #0]
 80169bc:	f01e 0f10 	tst.w	lr, #16
 80169c0:	bf08      	it	eq
 80169c2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 80169c6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80169ca:	6010      	str	r0, [r2, #0]
 80169cc:	f84d 3d04 	str.w	r3, [sp, #-4]!
 80169d0:	f04f 0050 	mov.w	r0, #80	; 0x50
 80169d4:	f380 8811 	msr	BASEPRI, r0
 80169d8:	f3bf 8f4f 	dsb	sy
 80169dc:	f3bf 8f6f 	isb	sy
 80169e0:	f001 f868 	bl	8017ab4 <vTaskSwitchContext>
 80169e4:	f04f 0000 	mov.w	r0, #0
 80169e8:	f380 8811 	msr	BASEPRI, r0
 80169ec:	bc08      	pop	{r3}
 80169ee:	6819      	ldr	r1, [r3, #0]
 80169f0:	6808      	ldr	r0, [r1, #0]
 80169f2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80169f6:	f01e 0f10 	tst.w	lr, #16
 80169fa:	bf08      	it	eq
 80169fc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8016a00:	f380 8809 	msr	PSP, r0
 8016a04:	f3bf 8f6f 	isb	sy
 8016a08:	4770      	bx	lr
 8016a0a:	bf00      	nop
 8016a0c:	f3af 8000 	nop.w

08016a10 <pxCurrentTCBConst>:
 8016a10:	2000dec4 	.word	0x2000dec4

08016a14 <xPortSysTickHandler>:
{
 8016a14:	b508      	push	{r3, lr}
	__asm volatile
 8016a16:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016a1a:	f383 8811 	msr	BASEPRI, r3
 8016a1e:	f3bf 8f6f 	isb	sy
 8016a22:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 8016a26:	f000 febf 	bl	80177a8 <xTaskIncrementTick>
 8016a2a:	b118      	cbz	r0, 8016a34 <xPortSysTickHandler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8016a2c:	4b03      	ldr	r3, [pc, #12]	; (8016a3c <xPortSysTickHandler+0x28>)
 8016a2e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8016a32:	601a      	str	r2, [r3, #0]
	__asm volatile
 8016a34:	2300      	movs	r3, #0
 8016a36:	f383 8811 	msr	BASEPRI, r3
}
 8016a3a:	bd08      	pop	{r3, pc}
 8016a3c:	e000ed04 	.word	0xe000ed04

08016a40 <vPortSetupTimerInterrupt>:
		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
 8016a40:	4b0b      	ldr	r3, [pc, #44]	; (8016a70 <vPortSetupTimerInterrupt+0x30>)
 8016a42:	490c      	ldr	r1, [pc, #48]	; (8016a74 <vPortSetupTimerInterrupt+0x34>)
 8016a44:	681b      	ldr	r3, [r3, #0]
 8016a46:	4a0c      	ldr	r2, [pc, #48]	; (8016a78 <vPortSetupTimerInterrupt+0x38>)
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8016a48:	480c      	ldr	r0, [pc, #48]	; (8016a7c <vPortSetupTimerInterrupt+0x3c>)
{
 8016a4a:	b430      	push	{r4, r5}
		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
 8016a4c:	fba1 1303 	umull	r1, r3, r1, r3
 8016a50:	099b      	lsrs	r3, r3, #6
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8016a52:	4c0b      	ldr	r4, [pc, #44]	; (8016a80 <vPortSetupTimerInterrupt+0x40>)
		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
 8016a54:	6053      	str	r3, [r2, #4]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8016a56:	1e5d      	subs	r5, r3, #1
		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
 8016a58:	f06f 417f 	mvn.w	r1, #4278190080	; 0xff000000
 8016a5c:	fbb1 f3f3 	udiv	r3, r1, r3
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
 8016a60:	212d      	movs	r1, #45	; 0x2d
		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
 8016a62:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8016a64:	2307      	movs	r3, #7
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8016a66:	6025      	str	r5, [r4, #0]
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
 8016a68:	6091      	str	r1, [r2, #8]
}
 8016a6a:	bc30      	pop	{r4, r5}
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8016a6c:	6003      	str	r3, [r0, #0]
}
 8016a6e:	4770      	bx	lr
 8016a70:	20000400 	.word	0x20000400
 8016a74:	10624dd3 	.word	0x10624dd3
 8016a78:	2000deac 	.word	0x2000deac
 8016a7c:	e000e010 	.word	0xe000e010
 8016a80:	e000e014 	.word	0xe000e014

08016a84 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8016a84:	4b32      	ldr	r3, [pc, #200]	; (8016b50 <xPortStartScheduler+0xcc>)
 8016a86:	4a33      	ldr	r2, [pc, #204]	; (8016b54 <xPortStartScheduler+0xd0>)
 8016a88:	6819      	ldr	r1, [r3, #0]
 8016a8a:	4291      	cmp	r1, r2
 8016a8c:	d04d      	beq.n	8016b2a <xPortStartScheduler+0xa6>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8016a8e:	681a      	ldr	r2, [r3, #0]
 8016a90:	4b31      	ldr	r3, [pc, #196]	; (8016b58 <xPortStartScheduler+0xd4>)
 8016a92:	429a      	cmp	r2, r3
 8016a94:	d052      	beq.n	8016b3c <xPortStartScheduler+0xb8>
{
 8016a96:	b510      	push	{r4, lr}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8016a98:	4a30      	ldr	r2, [pc, #192]	; (8016b5c <xPortStartScheduler+0xd8>)
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8016a9a:	4b31      	ldr	r3, [pc, #196]	; (8016b60 <xPortStartScheduler+0xdc>)
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8016a9c:	7811      	ldrb	r1, [r2, #0]
{
 8016a9e:	b082      	sub	sp, #8
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8016aa0:	20ff      	movs	r0, #255	; 0xff
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8016aa2:	b2c9      	uxtb	r1, r1
 8016aa4:	9101      	str	r1, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8016aa6:	7010      	strb	r0, [r2, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8016aa8:	7812      	ldrb	r2, [r2, #0]
 8016aaa:	b2d2      	uxtb	r2, r2
 8016aac:	f88d 2003 	strb.w	r2, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8016ab0:	f89d 2003 	ldrb.w	r2, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8016ab4:	f89d 1003 	ldrb.w	r1, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8016ab8:	f002 0250 	and.w	r2, r2, #80	; 0x50
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8016abc:	2007      	movs	r0, #7
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8016abe:	0609      	lsls	r1, r1, #24
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8016ac0:	731a      	strb	r2, [r3, #12]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8016ac2:	6118      	str	r0, [r3, #16]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8016ac4:	d50f      	bpl.n	8016ae6 <xPortStartScheduler+0x62>
 8016ac6:	2106      	movs	r1, #6
 8016ac8:	e000      	b.n	8016acc <xPortStartScheduler+0x48>
 8016aca:	4601      	mov	r1, r0
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8016acc:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8016ad0:	0052      	lsls	r2, r2, #1
 8016ad2:	b2d2      	uxtb	r2, r2
 8016ad4:	f88d 2003 	strb.w	r2, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8016ad8:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8016adc:	0612      	lsls	r2, r2, #24
 8016ade:	f101 30ff 	add.w	r0, r1, #4294967295
 8016ae2:	d4f2      	bmi.n	8016aca <xPortStartScheduler+0x46>
 8016ae4:	6119      	str	r1, [r3, #16]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8016ae6:	9801      	ldr	r0, [sp, #4]
 8016ae8:	4c1c      	ldr	r4, [pc, #112]	; (8016b5c <xPortStartScheduler+0xd8>)
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8016aea:	491e      	ldr	r1, [pc, #120]	; (8016b64 <xPortStartScheduler+0xe0>)
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8016aec:	691a      	ldr	r2, [r3, #16]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8016aee:	b2c0      	uxtb	r0, r0
 8016af0:	7020      	strb	r0, [r4, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8016af2:	6808      	ldr	r0, [r1, #0]
 8016af4:	f440 0070 	orr.w	r0, r0, #15728640	; 0xf00000
 8016af8:	6008      	str	r0, [r1, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8016afa:	6808      	ldr	r0, [r1, #0]
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8016afc:	0212      	lsls	r2, r2, #8
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8016afe:	f040 4070 	orr.w	r0, r0, #4026531840	; 0xf0000000
 8016b02:	6008      	str	r0, [r1, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8016b04:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8016b08:	611a      	str	r2, [r3, #16]
	vPortSetupTimerInterrupt();
 8016b0a:	f7ff ff99 	bl	8016a40 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8016b0e:	4b16      	ldr	r3, [pc, #88]	; (8016b68 <xPortStartScheduler+0xe4>)
 8016b10:	2200      	movs	r2, #0
 8016b12:	601a      	str	r2, [r3, #0]
	vPortEnableVFP();
 8016b14:	f7ff fede 	bl	80168d4 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8016b18:	4a14      	ldr	r2, [pc, #80]	; (8016b6c <xPortStartScheduler+0xe8>)
 8016b1a:	6813      	ldr	r3, [r2, #0]
 8016b1c:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8016b20:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
 8016b22:	f7ff fec7 	bl	80168b4 <prvPortStartFirstTask>
	prvTaskExitError();
 8016b26:	f7ff fead 	bl	8016884 <prvTaskExitError>
	__asm volatile
 8016b2a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016b2e:	f383 8811 	msr	BASEPRI, r3
 8016b32:	f3bf 8f6f 	isb	sy
 8016b36:	f3bf 8f4f 	dsb	sy
 8016b3a:	e7fe      	b.n	8016b3a <xPortStartScheduler+0xb6>
 8016b3c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016b40:	f383 8811 	msr	BASEPRI, r3
 8016b44:	f3bf 8f6f 	isb	sy
 8016b48:	f3bf 8f4f 	dsb	sy
 8016b4c:	e7fe      	b.n	8016b4c <xPortStartScheduler+0xc8>
 8016b4e:	bf00      	nop
 8016b50:	e000ed00 	.word	0xe000ed00
 8016b54:	410fc271 	.word	0x410fc271
 8016b58:	410fc270 	.word	0x410fc270
 8016b5c:	e000e400 	.word	0xe000e400
 8016b60:	2000deac 	.word	0x2000deac
 8016b64:	e000ed20 	.word	0xe000ed20
 8016b68:	200011d8 	.word	0x200011d8
 8016b6c:	e000ef34 	.word	0xe000ef34

08016b70 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8016b70:	f3ef 8205 	mrs	r2, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8016b74:	2a0f      	cmp	r2, #15
 8016b76:	d811      	bhi.n	8016b9c <vPortValidateInterruptPriority+0x2c>
 8016b78:	4b10      	ldr	r3, [pc, #64]	; (8016bbc <vPortValidateInterruptPriority+0x4c>)
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8016b7a:	4911      	ldr	r1, [pc, #68]	; (8016bc0 <vPortValidateInterruptPriority+0x50>)
 8016b7c:	691a      	ldr	r2, [r3, #16]
 8016b7e:	680b      	ldr	r3, [r1, #0]
 8016b80:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8016b84:	4293      	cmp	r3, r2
 8016b86:	d908      	bls.n	8016b9a <vPortValidateInterruptPriority+0x2a>
 8016b88:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016b8c:	f383 8811 	msr	BASEPRI, r3
 8016b90:	f3bf 8f6f 	isb	sy
 8016b94:	f3bf 8f4f 	dsb	sy
 8016b98:	e7fe      	b.n	8016b98 <vPortValidateInterruptPriority+0x28>
	}
 8016b9a:	4770      	bx	lr
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8016b9c:	4909      	ldr	r1, [pc, #36]	; (8016bc4 <vPortValidateInterruptPriority+0x54>)
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8016b9e:	4b07      	ldr	r3, [pc, #28]	; (8016bbc <vPortValidateInterruptPriority+0x4c>)
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8016ba0:	5c52      	ldrb	r2, [r2, r1]
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8016ba2:	7b19      	ldrb	r1, [r3, #12]
 8016ba4:	4291      	cmp	r1, r2
 8016ba6:	d9e8      	bls.n	8016b7a <vPortValidateInterruptPriority+0xa>
 8016ba8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016bac:	f383 8811 	msr	BASEPRI, r3
 8016bb0:	f3bf 8f6f 	isb	sy
 8016bb4:	f3bf 8f4f 	dsb	sy
 8016bb8:	e7fe      	b.n	8016bb8 <vPortValidateInterruptPriority+0x48>
 8016bba:	bf00      	nop
 8016bbc:	2000deac 	.word	0x2000deac
 8016bc0:	e000ed0c 	.word	0xe000ed0c
 8016bc4:	e000e3f0 	.word	0xe000e3f0

08016bc8 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8016bc8:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8016bcc:	f04f 31ff 	mov.w	r1, #4294967295
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8016bd0:	2200      	movs	r2, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8016bd2:	6081      	str	r1, [r0, #8]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8016bd4:	e9c0 2300 	strd	r2, r3, [r0]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8016bd8:	e9c0 3303 	strd	r3, r3, [r0, #12]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8016bdc:	4770      	bx	lr
 8016bde:	bf00      	nop

08016be0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8016be0:	2300      	movs	r3, #0
 8016be2:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8016be4:	4770      	bx	lr
 8016be6:	bf00      	nop

08016be8 <vListInsertEnd>:
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8016be8:	e9d0 2300 	ldrd	r2, r3, [r0]
{
 8016bec:	b410      	push	{r4}
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8016bee:	689c      	ldr	r4, [r3, #8]
 8016bf0:	608c      	str	r4, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8016bf2:	689c      	ldr	r4, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 8016bf4:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
 8016bf6:	3201      	adds	r2, #1
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8016bf8:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8016bfa:	6099      	str	r1, [r3, #8]
}
 8016bfc:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxNewListItem->pvContainer = ( void * ) pxList;
 8016c00:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8016c02:	6002      	str	r2, [r0, #0]
}
 8016c04:	4770      	bx	lr
 8016c06:	bf00      	nop

08016c08 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8016c08:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8016c0a:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8016c0c:	1c6b      	adds	r3, r5, #1
 8016c0e:	d011      	beq.n	8016c34 <vListInsert+0x2c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8016c10:	f100 0208 	add.w	r2, r0, #8
 8016c14:	e000      	b.n	8016c18 <vListInsert+0x10>
 8016c16:	461a      	mov	r2, r3
 8016c18:	6853      	ldr	r3, [r2, #4]
 8016c1a:	681c      	ldr	r4, [r3, #0]
 8016c1c:	42ac      	cmp	r4, r5
 8016c1e:	d9fa      	bls.n	8016c16 <vListInsert+0xe>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8016c20:	6804      	ldr	r4, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
 8016c22:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
 8016c24:	3401      	adds	r4, #1
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8016c26:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8016c28:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8016c2a:	6051      	str	r1, [r2, #4]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8016c2c:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8016c2e:	6004      	str	r4, [r0, #0]
}
 8016c30:	bc30      	pop	{r4, r5}
 8016c32:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 8016c34:	6902      	ldr	r2, [r0, #16]
 8016c36:	6853      	ldr	r3, [r2, #4]
 8016c38:	e7f2      	b.n	8016c20 <vListInsert+0x18>
 8016c3a:	bf00      	nop

08016c3c <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8016c3c:	6843      	ldr	r3, [r0, #4]
 8016c3e:	6881      	ldr	r1, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8016c40:	6902      	ldr	r2, [r0, #16]
{
 8016c42:	b410      	push	{r4}
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8016c44:	6099      	str	r1, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8016c46:	6881      	ldr	r1, [r0, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8016c48:	6854      	ldr	r4, [r2, #4]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8016c4a:	604b      	str	r3, [r1, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
 8016c4c:	6813      	ldr	r3, [r2, #0]
	if( pxList->pxIndex == pxItemToRemove )
 8016c4e:	4284      	cmp	r4, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8016c50:	bf08      	it	eq
 8016c52:	6051      	streq	r1, [r2, #4]
	( pxList->uxNumberOfItems )--;
 8016c54:	3b01      	subs	r3, #1
	pxItemToRemove->pvContainer = NULL;
 8016c56:	2100      	movs	r1, #0
 8016c58:	6101      	str	r1, [r0, #16]

	return pxList->uxNumberOfItems;
}
 8016c5a:	f85d 4b04 	ldr.w	r4, [sp], #4
	( pxList->uxNumberOfItems )--;
 8016c5e:	6013      	str	r3, [r2, #0]
}
 8016c60:	4618      	mov	r0, r3
 8016c62:	4770      	bx	lr

08016c64 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8016c64:	b570      	push	{r4, r5, r6, lr}
 8016c66:	4616      	mov	r6, r2

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8016c68:	6c02      	ldr	r2, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8016c6a:	6b85      	ldr	r5, [r0, #56]	; 0x38
{
 8016c6c:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8016c6e:	b932      	cbnz	r2, 8016c7e <prvCopyDataToQueue+0x1a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8016c70:	6806      	ldr	r6, [r0, #0]
 8016c72:	3501      	adds	r5, #1
 8016c74:	2e00      	cmp	r6, #0
 8016c76:	d02d      	beq.n	8016cd4 <prvCopyDataToQueue+0x70>
BaseType_t xReturn = pdFALSE;
 8016c78:	2000      	movs	r0, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 8016c7a:	63a5      	str	r5, [r4, #56]	; 0x38

	return xReturn;
}
 8016c7c:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
 8016c7e:	b986      	cbnz	r6, 8016ca2 <prvCopyDataToQueue+0x3e>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8016c80:	6880      	ldr	r0, [r0, #8]
 8016c82:	f007 ff4a 	bl	801eb1a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8016c86:	68a3      	ldr	r3, [r4, #8]
 8016c88:	6c21      	ldr	r1, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8016c8a:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8016c8c:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8016c8e:	4293      	cmp	r3, r2
 8016c90:	f105 0501 	add.w	r5, r5, #1
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8016c94:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8016c96:	d3ef      	bcc.n	8016c78 <prvCopyDataToQueue+0x14>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8016c98:	6823      	ldr	r3, [r4, #0]
 8016c9a:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
 8016c9c:	4630      	mov	r0, r6
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 8016c9e:	63a5      	str	r5, [r4, #56]	; 0x38
}
 8016ca0:	bd70      	pop	{r4, r5, r6, pc}
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8016ca2:	68c0      	ldr	r0, [r0, #12]
 8016ca4:	f007 ff39 	bl	801eb1a <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8016ca8:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8016caa:	68e3      	ldr	r3, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8016cac:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8016cae:	4252      	negs	r2, r2
 8016cb0:	4413      	add	r3, r2
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8016cb2:	428b      	cmp	r3, r1
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8016cb4:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8016cb6:	d202      	bcs.n	8016cbe <prvCopyDataToQueue+0x5a>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8016cb8:	6863      	ldr	r3, [r4, #4]
 8016cba:	441a      	add	r2, r3
 8016cbc:	60e2      	str	r2, [r4, #12]
		if( xPosition == queueOVERWRITE )
 8016cbe:	2e02      	cmp	r6, #2
 8016cc0:	d003      	beq.n	8016cca <prvCopyDataToQueue+0x66>
 8016cc2:	3501      	adds	r5, #1
BaseType_t xReturn = pdFALSE;
 8016cc4:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 8016cc6:	63a5      	str	r5, [r4, #56]	; 0x38
}
 8016cc8:	bd70      	pop	{r4, r5, r6, pc}
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8016cca:	2d00      	cmp	r5, #0
 8016ccc:	d1d4      	bne.n	8016c78 <prvCopyDataToQueue+0x14>
 8016cce:	2501      	movs	r5, #1
BaseType_t xReturn = pdFALSE;
 8016cd0:	2000      	movs	r0, #0
 8016cd2:	e7d2      	b.n	8016c7a <prvCopyDataToQueue+0x16>
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8016cd4:	6840      	ldr	r0, [r0, #4]
 8016cd6:	f001 f881 	bl	8017ddc <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8016cda:	6066      	str	r6, [r4, #4]
 8016cdc:	e7cd      	b.n	8016c7a <prvCopyDataToQueue+0x16>
 8016cde:	bf00      	nop

08016ce0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8016ce0:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8016ce2:	b172      	cbz	r2, 8016d02 <prvCopyDataFromQueue+0x22>
 8016ce4:	460b      	mov	r3, r1
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8016ce6:	68c1      	ldr	r1, [r0, #12]
{
 8016ce8:	b410      	push	{r4}
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8016cea:	6844      	ldr	r4, [r0, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8016cec:	4411      	add	r1, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8016cee:	42a1      	cmp	r1, r4
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8016cf0:	60c1      	str	r1, [r0, #12]
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8016cf2:	bf24      	itt	cs
 8016cf4:	6801      	ldrcs	r1, [r0, #0]
 8016cf6:	60c1      	strcs	r1, [r0, #12]
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
	}
}
 8016cf8:	f85d 4b04 	ldr.w	r4, [sp], #4
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8016cfc:	4618      	mov	r0, r3
 8016cfe:	f007 bf0c 	b.w	801eb1a <memcpy>
 8016d02:	4770      	bx	lr

08016d04 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8016d04:	b570      	push	{r4, r5, r6, lr}
 8016d06:	4605      	mov	r5, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8016d08:	f7ff fe1c 	bl	8016944 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 8016d0c:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
 8016d10:	b264      	sxtb	r4, r4

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8016d12:	2c00      	cmp	r4, #0
 8016d14:	dd16      	ble.n	8016d44 <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8016d16:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8016d18:	b1a3      	cbz	r3, 8016d44 <prvUnlockQueue+0x40>
 8016d1a:	f105 0624 	add.w	r6, r5, #36	; 0x24
 8016d1e:	e005      	b.n	8016d2c <prvUnlockQueue+0x28>
 8016d20:	3c01      	subs	r4, #1
 8016d22:	b2e3      	uxtb	r3, r4
 8016d24:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8016d26:	b16b      	cbz	r3, 8016d44 <prvUnlockQueue+0x40>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8016d28:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8016d2a:	b15b      	cbz	r3, 8016d44 <prvUnlockQueue+0x40>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8016d2c:	4630      	mov	r0, r6
 8016d2e:	f000 ff47 	bl	8017bc0 <xTaskRemoveFromEventList>
 8016d32:	2800      	cmp	r0, #0
 8016d34:	d0f4      	beq.n	8016d20 <prvUnlockQueue+0x1c>
 8016d36:	3c01      	subs	r4, #1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 8016d38:	f000 ffdc 	bl	8017cf4 <vTaskMissedYield>
 8016d3c:	b2e3      	uxtb	r3, r4
 8016d3e:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8016d40:	2b00      	cmp	r3, #0
 8016d42:	d1f1      	bne.n	8016d28 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 8016d44:	23ff      	movs	r3, #255	; 0xff
 8016d46:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 8016d4a:	f7ff fe1d 	bl	8016988 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8016d4e:	f7ff fdf9 	bl	8016944 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8016d52:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
 8016d56:	b264      	sxtb	r4, r4

		while( cRxLock > queueLOCKED_UNMODIFIED )
 8016d58:	2c00      	cmp	r4, #0
 8016d5a:	dd16      	ble.n	8016d8a <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8016d5c:	692b      	ldr	r3, [r5, #16]
 8016d5e:	b1a3      	cbz	r3, 8016d8a <prvUnlockQueue+0x86>
 8016d60:	f105 0610 	add.w	r6, r5, #16
 8016d64:	e005      	b.n	8016d72 <prvUnlockQueue+0x6e>
 8016d66:	3c01      	subs	r4, #1
 8016d68:	b2e3      	uxtb	r3, r4
 8016d6a:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8016d6c:	b16b      	cbz	r3, 8016d8a <prvUnlockQueue+0x86>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8016d6e:	692b      	ldr	r3, [r5, #16]
 8016d70:	b15b      	cbz	r3, 8016d8a <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8016d72:	4630      	mov	r0, r6
 8016d74:	f000 ff24 	bl	8017bc0 <xTaskRemoveFromEventList>
 8016d78:	2800      	cmp	r0, #0
 8016d7a:	d0f4      	beq.n	8016d66 <prvUnlockQueue+0x62>
 8016d7c:	3c01      	subs	r4, #1
				{
					vTaskMissedYield();
 8016d7e:	f000 ffb9 	bl	8017cf4 <vTaskMissedYield>
 8016d82:	b2e3      	uxtb	r3, r4
 8016d84:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8016d86:	2b00      	cmp	r3, #0
 8016d88:	d1f1      	bne.n	8016d6e <prvUnlockQueue+0x6a>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 8016d8a:	23ff      	movs	r3, #255	; 0xff
 8016d8c:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 8016d90:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
 8016d94:	f7ff bdf8 	b.w	8016988 <vPortExitCritical>

08016d98 <xQueueGenericReset>:
{
 8016d98:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxQueue );
 8016d9a:	b1e0      	cbz	r0, 8016dd6 <xQueueGenericReset+0x3e>
 8016d9c:	4604      	mov	r4, r0
 8016d9e:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
 8016da0:	f7ff fdd0 	bl	8016944 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8016da4:	e9d4 130f 	ldrd	r1, r3, [r4, #60]	; 0x3c
 8016da8:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8016daa:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8016dac:	fb01 f103 	mul.w	r1, r1, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8016db0:	1acb      	subs	r3, r1, r3
 8016db2:	4413      	add	r3, r2
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8016db4:	2000      	movs	r0, #0
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8016db6:	440a      	add	r2, r1
		pxQueue->cRxLock = queueUNLOCKED;
 8016db8:	21ff      	movs	r1, #255	; 0xff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8016dba:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8016dbc:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 8016dbe:	f884 1044 	strb.w	r1, [r4, #68]	; 0x44
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8016dc2:	6062      	str	r2, [r4, #4]
		pxQueue->cTxLock = queueUNLOCKED;
 8016dc4:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
 8016dc8:	b975      	cbnz	r5, 8016de8 <xQueueGenericReset+0x50>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8016dca:	6923      	ldr	r3, [r4, #16]
 8016dcc:	b9ab      	cbnz	r3, 8016dfa <xQueueGenericReset+0x62>
	taskEXIT_CRITICAL();
 8016dce:	f7ff fddb 	bl	8016988 <vPortExitCritical>
}
 8016dd2:	2001      	movs	r0, #1
 8016dd4:	bd38      	pop	{r3, r4, r5, pc}
 8016dd6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016dda:	f383 8811 	msr	BASEPRI, r3
 8016dde:	f3bf 8f6f 	isb	sy
 8016de2:	f3bf 8f4f 	dsb	sy
 8016de6:	e7fe      	b.n	8016de6 <xQueueGenericReset+0x4e>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8016de8:	f104 0010 	add.w	r0, r4, #16
 8016dec:	f7ff feec 	bl	8016bc8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8016df0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8016df4:	f7ff fee8 	bl	8016bc8 <vListInitialise>
 8016df8:	e7e9      	b.n	8016dce <xQueueGenericReset+0x36>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8016dfa:	f104 0010 	add.w	r0, r4, #16
 8016dfe:	f000 fedf 	bl	8017bc0 <xTaskRemoveFromEventList>
 8016e02:	2800      	cmp	r0, #0
 8016e04:	d0e3      	beq.n	8016dce <xQueueGenericReset+0x36>
					queueYIELD_IF_USING_PREEMPTION();
 8016e06:	4b04      	ldr	r3, [pc, #16]	; (8016e18 <xQueueGenericReset+0x80>)
 8016e08:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8016e0c:	601a      	str	r2, [r3, #0]
 8016e0e:	f3bf 8f4f 	dsb	sy
 8016e12:	f3bf 8f6f 	isb	sy
 8016e16:	e7da      	b.n	8016dce <xQueueGenericReset+0x36>
 8016e18:	e000ed04 	.word	0xe000ed04

08016e1c <xQueueGenericCreate>:
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8016e1c:	b940      	cbnz	r0, 8016e30 <xQueueGenericCreate+0x14>
 8016e1e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016e22:	f383 8811 	msr	BASEPRI, r3
 8016e26:	f3bf 8f6f 	isb	sy
 8016e2a:	f3bf 8f4f 	dsb	sy
 8016e2e:	e7fe      	b.n	8016e2e <xQueueGenericCreate+0x12>
	{
 8016e30:	b570      	push	{r4, r5, r6, lr}
 8016e32:	4606      	mov	r6, r0
 8016e34:	460d      	mov	r5, r1
		if( uxItemSize == ( UBaseType_t ) 0 )
 8016e36:	b151      	cbz	r1, 8016e4e <xQueueGenericCreate+0x32>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8016e38:	fb01 f000 	mul.w	r0, r1, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8016e3c:	3048      	adds	r0, #72	; 0x48
 8016e3e:	f7ff fc6d 	bl	801671c <pvPortMalloc>
		if( pxNewQueue != NULL )
 8016e42:	4604      	mov	r4, r0
 8016e44:	b188      	cbz	r0, 8016e6a <xQueueGenericCreate+0x4e>
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 8016e46:	f100 0348 	add.w	r3, r0, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 8016e4a:	6003      	str	r3, [r0, #0]
 8016e4c:	e005      	b.n	8016e5a <xQueueGenericCreate+0x3e>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8016e4e:	2048      	movs	r0, #72	; 0x48
 8016e50:	f7ff fc64 	bl	801671c <pvPortMalloc>
		if( pxNewQueue != NULL )
 8016e54:	4604      	mov	r4, r0
 8016e56:	b140      	cbz	r0, 8016e6a <xQueueGenericCreate+0x4e>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8016e58:	6024      	str	r4, [r4, #0]
	pxNewQueue->uxItemSize = uxItemSize;
 8016e5a:	e9c4 650f 	strd	r6, r5, [r4, #60]	; 0x3c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8016e5e:	2101      	movs	r1, #1
 8016e60:	4620      	mov	r0, r4
 8016e62:	f7ff ff99 	bl	8016d98 <xQueueGenericReset>
	}
 8016e66:	4620      	mov	r0, r4
 8016e68:	bd70      	pop	{r4, r5, r6, pc}
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8016e6a:	2400      	movs	r4, #0
	}
 8016e6c:	4620      	mov	r0, r4
 8016e6e:	bd70      	pop	{r4, r5, r6, pc}

08016e70 <xQueueCreateCountingSemaphore>:
		configASSERT( uxMaxCount != 0 );
 8016e70:	b940      	cbnz	r0, 8016e84 <xQueueCreateCountingSemaphore+0x14>
 8016e72:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016e76:	f383 8811 	msr	BASEPRI, r3
 8016e7a:	f3bf 8f6f 	isb	sy
 8016e7e:	f3bf 8f4f 	dsb	sy
 8016e82:	e7fe      	b.n	8016e82 <xQueueCreateCountingSemaphore+0x12>
		configASSERT( uxInitialCount <= uxMaxCount );
 8016e84:	4288      	cmp	r0, r1
 8016e86:	d208      	bcs.n	8016e9a <xQueueCreateCountingSemaphore+0x2a>
 8016e88:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016e8c:	f383 8811 	msr	BASEPRI, r3
 8016e90:	f3bf 8f6f 	isb	sy
 8016e94:	f3bf 8f4f 	dsb	sy
 8016e98:	e7fe      	b.n	8016e98 <xQueueCreateCountingSemaphore+0x28>
	{
 8016e9a:	b510      	push	{r4, lr}
		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 8016e9c:	2202      	movs	r2, #2
 8016e9e:	460c      	mov	r4, r1
 8016ea0:	2100      	movs	r1, #0
 8016ea2:	f7ff ffbb 	bl	8016e1c <xQueueGenericCreate>
		if( xHandle != NULL )
 8016ea6:	b100      	cbz	r0, 8016eaa <xQueueCreateCountingSemaphore+0x3a>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 8016ea8:	6384      	str	r4, [r0, #56]	; 0x38
	}
 8016eaa:	bd10      	pop	{r4, pc}

08016eac <xQueueGenericSend>:
{
 8016eac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8016eb0:	b084      	sub	sp, #16
 8016eb2:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
 8016eb4:	2800      	cmp	r0, #0
 8016eb6:	f000 8099 	beq.w	8016fec <xQueueGenericSend+0x140>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8016eba:	2900      	cmp	r1, #0
 8016ebc:	f000 8089 	beq.w	8016fd2 <xQueueGenericSend+0x126>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8016ec0:	2b02      	cmp	r3, #2
 8016ec2:	d10b      	bne.n	8016edc <xQueueGenericSend+0x30>
 8016ec4:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 8016ec6:	2a01      	cmp	r2, #1
 8016ec8:	d008      	beq.n	8016edc <xQueueGenericSend+0x30>
 8016eca:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016ece:	f383 8811 	msr	BASEPRI, r3
 8016ed2:	f3bf 8f6f 	isb	sy
 8016ed6:	f3bf 8f4f 	dsb	sy
 8016eda:	e7fe      	b.n	8016eda <xQueueGenericSend+0x2e>
 8016edc:	4604      	mov	r4, r0
 8016ede:	461f      	mov	r7, r3
 8016ee0:	4689      	mov	r9, r1
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8016ee2:	f000 ff25 	bl	8017d30 <xTaskGetSchedulerState>
 8016ee6:	b950      	cbnz	r0, 8016efe <xQueueGenericSend+0x52>
 8016ee8:	9e01      	ldr	r6, [sp, #4]
 8016eea:	b14e      	cbz	r6, 8016f00 <xQueueGenericSend+0x54>
 8016eec:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016ef0:	f383 8811 	msr	BASEPRI, r3
 8016ef4:	f3bf 8f6f 	isb	sy
 8016ef8:	f3bf 8f4f 	dsb	sy
 8016efc:	e7fe      	b.n	8016efc <xQueueGenericSend+0x50>
 8016efe:	2600      	movs	r6, #0
					portYIELD_WITHIN_API();
 8016f00:	f8df a120 	ldr.w	sl, [pc, #288]	; 8017024 <xQueueGenericSend+0x178>
		prvLockQueue( pxQueue );
 8016f04:	f04f 0800 	mov.w	r8, #0
 8016f08:	e007      	b.n	8016f1a <xQueueGenericSend+0x6e>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8016f0a:	f7ff fd3d 	bl	8016988 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 8016f0e:	4620      	mov	r0, r4
 8016f10:	f7ff fef8 	bl	8016d04 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8016f14:	f000 fcd6 	bl	80178c4 <xTaskResumeAll>
 8016f18:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 8016f1a:	f7ff fd13 	bl	8016944 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8016f1e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8016f20:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8016f22:	429a      	cmp	r2, r3
 8016f24:	d33f      	bcc.n	8016fa6 <xQueueGenericSend+0xfa>
 8016f26:	2f02      	cmp	r7, #2
 8016f28:	d03d      	beq.n	8016fa6 <xQueueGenericSend+0xfa>
				if( xTicksToWait == ( TickType_t ) 0 )
 8016f2a:	9d01      	ldr	r5, [sp, #4]
 8016f2c:	2d00      	cmp	r5, #0
 8016f2e:	d066      	beq.n	8016ffe <xQueueGenericSend+0x152>
				else if( xEntryTimeSet == pdFALSE )
 8016f30:	b916      	cbnz	r6, 8016f38 <xQueueGenericSend+0x8c>
					vTaskSetTimeOutState( &xTimeOut );
 8016f32:	a802      	add	r0, sp, #8
 8016f34:	f000 fe8c 	bl	8017c50 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 8016f38:	f7ff fd26 	bl	8016988 <vPortExitCritical>
		vTaskSuspendAll();
 8016f3c:	f000 fc0a 	bl	8017754 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8016f40:	f7ff fd00 	bl	8016944 <vPortEnterCritical>
 8016f44:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8016f48:	2bff      	cmp	r3, #255	; 0xff
 8016f4a:	bf08      	it	eq
 8016f4c:	f884 8044 	strbeq.w	r8, [r4, #68]	; 0x44
 8016f50:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8016f54:	2bff      	cmp	r3, #255	; 0xff
 8016f56:	bf08      	it	eq
 8016f58:	f884 8045 	strbeq.w	r8, [r4, #69]	; 0x45
 8016f5c:	f7ff fd14 	bl	8016988 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8016f60:	a901      	add	r1, sp, #4
 8016f62:	a802      	add	r0, sp, #8
 8016f64:	f000 fe88 	bl	8017c78 <xTaskCheckForTimeOut>
 8016f68:	2800      	cmp	r0, #0
 8016f6a:	d153      	bne.n	8017014 <xQueueGenericSend+0x168>
	taskENTER_CRITICAL();
 8016f6c:	f7ff fcea 	bl	8016944 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8016f70:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8016f72:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8016f74:	429a      	cmp	r2, r3
 8016f76:	d1c8      	bne.n	8016f0a <xQueueGenericSend+0x5e>
	taskEXIT_CRITICAL();
 8016f78:	f7ff fd06 	bl	8016988 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8016f7c:	9901      	ldr	r1, [sp, #4]
 8016f7e:	f104 0010 	add.w	r0, r4, #16
 8016f82:	f000 fde3 	bl	8017b4c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8016f86:	4620      	mov	r0, r4
 8016f88:	f7ff febc 	bl	8016d04 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8016f8c:	f000 fc9a 	bl	80178c4 <xTaskResumeAll>
 8016f90:	2800      	cmp	r0, #0
 8016f92:	d1c1      	bne.n	8016f18 <xQueueGenericSend+0x6c>
					portYIELD_WITHIN_API();
 8016f94:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8016f98:	f8ca 3000 	str.w	r3, [sl]
 8016f9c:	f3bf 8f4f 	dsb	sy
 8016fa0:	f3bf 8f6f 	isb	sy
 8016fa4:	e7b8      	b.n	8016f18 <xQueueGenericSend+0x6c>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8016fa6:	463a      	mov	r2, r7
 8016fa8:	4649      	mov	r1, r9
 8016faa:	4620      	mov	r0, r4
 8016fac:	f7ff fe5a 	bl	8016c64 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8016fb0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8016fb2:	bb43      	cbnz	r3, 8017006 <xQueueGenericSend+0x15a>
					else if( xYieldRequired != pdFALSE )
 8016fb4:	b138      	cbz	r0, 8016fc6 <xQueueGenericSend+0x11a>
						queueYIELD_IF_USING_PREEMPTION();
 8016fb6:	4b1b      	ldr	r3, [pc, #108]	; (8017024 <xQueueGenericSend+0x178>)
 8016fb8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8016fbc:	601a      	str	r2, [r3, #0]
 8016fbe:	f3bf 8f4f 	dsb	sy
 8016fc2:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 8016fc6:	f7ff fcdf 	bl	8016988 <vPortExitCritical>
				return pdPASS;
 8016fca:	2001      	movs	r0, #1
}
 8016fcc:	b004      	add	sp, #16
 8016fce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8016fd2:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8016fd4:	2a00      	cmp	r2, #0
 8016fd6:	f43f af73 	beq.w	8016ec0 <xQueueGenericSend+0x14>
 8016fda:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016fde:	f383 8811 	msr	BASEPRI, r3
 8016fe2:	f3bf 8f6f 	isb	sy
 8016fe6:	f3bf 8f4f 	dsb	sy
 8016fea:	e7fe      	b.n	8016fea <xQueueGenericSend+0x13e>
 8016fec:	f04f 0350 	mov.w	r3, #80	; 0x50
 8016ff0:	f383 8811 	msr	BASEPRI, r3
 8016ff4:	f3bf 8f6f 	isb	sy
 8016ff8:	f3bf 8f4f 	dsb	sy
 8016ffc:	e7fe      	b.n	8016ffc <xQueueGenericSend+0x150>
					taskEXIT_CRITICAL();
 8016ffe:	f7ff fcc3 	bl	8016988 <vPortExitCritical>
					return errQUEUE_FULL;
 8017002:	4628      	mov	r0, r5
 8017004:	e7e2      	b.n	8016fcc <xQueueGenericSend+0x120>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8017006:	f104 0024 	add.w	r0, r4, #36	; 0x24
 801700a:	f000 fdd9 	bl	8017bc0 <xTaskRemoveFromEventList>
 801700e:	2800      	cmp	r0, #0
 8017010:	d1d1      	bne.n	8016fb6 <xQueueGenericSend+0x10a>
 8017012:	e7d8      	b.n	8016fc6 <xQueueGenericSend+0x11a>
			prvUnlockQueue( pxQueue );
 8017014:	4620      	mov	r0, r4
 8017016:	f7ff fe75 	bl	8016d04 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 801701a:	f000 fc53 	bl	80178c4 <xTaskResumeAll>
			return errQUEUE_FULL;
 801701e:	2000      	movs	r0, #0
 8017020:	e7d4      	b.n	8016fcc <xQueueGenericSend+0x120>
 8017022:	bf00      	nop
 8017024:	e000ed04 	.word	0xe000ed04

08017028 <xQueueGenericSendFromISR>:
{
 8017028:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 801702c:	2800      	cmp	r0, #0
 801702e:	d035      	beq.n	801709c <xQueueGenericSendFromISR+0x74>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8017030:	b341      	cbz	r1, 8017084 <xQueueGenericSendFromISR+0x5c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8017032:	2b02      	cmp	r3, #2
 8017034:	d10b      	bne.n	801704e <xQueueGenericSendFromISR+0x26>
 8017036:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8017038:	2c01      	cmp	r4, #1
 801703a:	d008      	beq.n	801704e <xQueueGenericSendFromISR+0x26>
 801703c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017040:	f383 8811 	msr	BASEPRI, r3
 8017044:	f3bf 8f6f 	isb	sy
 8017048:	f3bf 8f4f 	dsb	sy
 801704c:	e7fe      	b.n	801704c <xQueueGenericSendFromISR+0x24>
 801704e:	4604      	mov	r4, r0
 8017050:	461f      	mov	r7, r3
 8017052:	4690      	mov	r8, r2
 8017054:	4689      	mov	r9, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8017056:	f7ff fd8b 	bl	8016b70 <vPortValidateInterruptPriority>
	__asm volatile
 801705a:	f3ef 8611 	mrs	r6, BASEPRI
 801705e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017062:	f383 8811 	msr	BASEPRI, r3
 8017066:	f3bf 8f6f 	isb	sy
 801706a:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 801706e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8017070:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8017072:	429a      	cmp	r2, r3
 8017074:	d31b      	bcc.n	80170ae <xQueueGenericSendFromISR+0x86>
 8017076:	2f02      	cmp	r7, #2
 8017078:	d019      	beq.n	80170ae <xQueueGenericSendFromISR+0x86>
			xReturn = errQUEUE_FULL;
 801707a:	2000      	movs	r0, #0
	__asm volatile
 801707c:	f386 8811 	msr	BASEPRI, r6
}
 8017080:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8017084:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8017086:	2c00      	cmp	r4, #0
 8017088:	d0d3      	beq.n	8017032 <xQueueGenericSendFromISR+0xa>
	__asm volatile
 801708a:	f04f 0350 	mov.w	r3, #80	; 0x50
 801708e:	f383 8811 	msr	BASEPRI, r3
 8017092:	f3bf 8f6f 	isb	sy
 8017096:	f3bf 8f4f 	dsb	sy
 801709a:	e7fe      	b.n	801709a <xQueueGenericSendFromISR+0x72>
 801709c:	f04f 0350 	mov.w	r3, #80	; 0x50
 80170a0:	f383 8811 	msr	BASEPRI, r3
 80170a4:	f3bf 8f6f 	isb	sy
 80170a8:	f3bf 8f4f 	dsb	sy
 80170ac:	e7fe      	b.n	80170ac <xQueueGenericSendFromISR+0x84>
			const int8_t cTxLock = pxQueue->cTxLock;
 80170ae:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80170b2:	463a      	mov	r2, r7
 80170b4:	4649      	mov	r1, r9
			const int8_t cTxLock = pxQueue->cTxLock;
 80170b6:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80170b8:	4620      	mov	r0, r4
 80170ba:	f7ff fdd3 	bl	8016c64 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 80170be:	1c6b      	adds	r3, r5, #1
 80170c0:	d008      	beq.n	80170d4 <xQueueGenericSendFromISR+0xac>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 80170c2:	1c6b      	adds	r3, r5, #1
 80170c4:	b25b      	sxtb	r3, r3
 80170c6:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
 80170ca:	2001      	movs	r0, #1
	__asm volatile
 80170cc:	f386 8811 	msr	BASEPRI, r6
}
 80170d0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80170d4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80170d6:	2b00      	cmp	r3, #0
 80170d8:	d0f7      	beq.n	80170ca <xQueueGenericSendFromISR+0xa2>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80170da:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80170de:	f000 fd6f 	bl	8017bc0 <xTaskRemoveFromEventList>
 80170e2:	2800      	cmp	r0, #0
 80170e4:	d0f1      	beq.n	80170ca <xQueueGenericSendFromISR+0xa2>
							if( pxHigherPriorityTaskWoken != NULL )
 80170e6:	f1b8 0f00 	cmp.w	r8, #0
 80170ea:	d0ee      	beq.n	80170ca <xQueueGenericSendFromISR+0xa2>
								*pxHigherPriorityTaskWoken = pdTRUE;
 80170ec:	2001      	movs	r0, #1
 80170ee:	f8c8 0000 	str.w	r0, [r8]
 80170f2:	e7c3      	b.n	801707c <xQueueGenericSendFromISR+0x54>

080170f4 <xQueueGiveFromISR>:
	configASSERT( pxQueue );
 80170f4:	b370      	cbz	r0, 8017154 <xQueueGiveFromISR+0x60>
	configASSERT( pxQueue->uxItemSize == 0 );
 80170f6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80170f8:	b143      	cbz	r3, 801710c <xQueueGiveFromISR+0x18>
	__asm volatile
 80170fa:	f04f 0350 	mov.w	r3, #80	; 0x50
 80170fe:	f383 8811 	msr	BASEPRI, r3
 8017102:	f3bf 8f6f 	isb	sy
 8017106:	f3bf 8f4f 	dsb	sy
 801710a:	e7fe      	b.n	801710a <xQueueGiveFromISR+0x16>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 801710c:	6803      	ldr	r3, [r0, #0]
 801710e:	b353      	cbz	r3, 8017166 <xQueueGiveFromISR+0x72>
{
 8017110:	b570      	push	{r4, r5, r6, lr}
 8017112:	4604      	mov	r4, r0
 8017114:	460d      	mov	r5, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8017116:	f7ff fd2b 	bl	8016b70 <vPortValidateInterruptPriority>
	__asm volatile
 801711a:	f3ef 8611 	mrs	r6, BASEPRI
 801711e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017122:	f383 8811 	msr	BASEPRI, r3
 8017126:	f3bf 8f6f 	isb	sy
 801712a:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 801712e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 8017130:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8017132:	4293      	cmp	r3, r2
 8017134:	d931      	bls.n	801719a <xQueueGiveFromISR+0xa6>
			const int8_t cTxLock = pxQueue->cTxLock;
 8017136:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 801713a:	3201      	adds	r2, #1
			const int8_t cTxLock = pxQueue->cTxLock;
 801713c:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 801713e:	63a2      	str	r2, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
 8017140:	1c5a      	adds	r2, r3, #1
 8017142:	d01c      	beq.n	801717e <xQueueGiveFromISR+0x8a>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8017144:	3301      	adds	r3, #1
 8017146:	b25b      	sxtb	r3, r3
 8017148:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
 801714c:	2001      	movs	r0, #1
	__asm volatile
 801714e:	f386 8811 	msr	BASEPRI, r6
}
 8017152:	bd70      	pop	{r4, r5, r6, pc}
	__asm volatile
 8017154:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017158:	f383 8811 	msr	BASEPRI, r3
 801715c:	f3bf 8f6f 	isb	sy
 8017160:	f3bf 8f4f 	dsb	sy
 8017164:	e7fe      	b.n	8017164 <xQueueGiveFromISR+0x70>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 8017166:	6843      	ldr	r3, [r0, #4]
 8017168:	2b00      	cmp	r3, #0
 801716a:	d0d1      	beq.n	8017110 <xQueueGiveFromISR+0x1c>
 801716c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017170:	f383 8811 	msr	BASEPRI, r3
 8017174:	f3bf 8f6f 	isb	sy
 8017178:	f3bf 8f4f 	dsb	sy
 801717c:	e7fe      	b.n	801717c <xQueueGiveFromISR+0x88>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801717e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8017180:	2b00      	cmp	r3, #0
 8017182:	d0e3      	beq.n	801714c <xQueueGiveFromISR+0x58>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8017184:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8017188:	f000 fd1a 	bl	8017bc0 <xTaskRemoveFromEventList>
 801718c:	2800      	cmp	r0, #0
 801718e:	d0dd      	beq.n	801714c <xQueueGiveFromISR+0x58>
							if( pxHigherPriorityTaskWoken != NULL )
 8017190:	2d00      	cmp	r5, #0
 8017192:	d0db      	beq.n	801714c <xQueueGiveFromISR+0x58>
								*pxHigherPriorityTaskWoken = pdTRUE;
 8017194:	2001      	movs	r0, #1
 8017196:	6028      	str	r0, [r5, #0]
 8017198:	e7d9      	b.n	801714e <xQueueGiveFromISR+0x5a>
			xReturn = errQUEUE_FULL;
 801719a:	2000      	movs	r0, #0
 801719c:	e7d7      	b.n	801714e <xQueueGiveFromISR+0x5a>
 801719e:	bf00      	nop

080171a0 <xQueueGenericReceive>:
{
 80171a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80171a4:	b084      	sub	sp, #16
 80171a6:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
 80171a8:	2800      	cmp	r0, #0
 80171aa:	f000 80ad 	beq.w	8017308 <xQueueGenericReceive+0x168>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80171ae:	2900      	cmp	r1, #0
 80171b0:	f000 809d 	beq.w	80172ee <xQueueGenericReceive+0x14e>
 80171b4:	4604      	mov	r4, r0
 80171b6:	4698      	mov	r8, r3
 80171b8:	460f      	mov	r7, r1
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80171ba:	f000 fdb9 	bl	8017d30 <xTaskGetSchedulerState>
 80171be:	b950      	cbnz	r0, 80171d6 <xQueueGenericReceive+0x36>
 80171c0:	9b01      	ldr	r3, [sp, #4]
 80171c2:	b143      	cbz	r3, 80171d6 <xQueueGenericReceive+0x36>
 80171c4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80171c8:	f383 8811 	msr	BASEPRI, r3
 80171cc:	f3bf 8f6f 	isb	sy
 80171d0:	f3bf 8f4f 	dsb	sy
 80171d4:	e7fe      	b.n	80171d4 <xQueueGenericReceive+0x34>
		taskENTER_CRITICAL();
 80171d6:	f7ff fbb5 	bl	8016944 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80171da:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80171dc:	2d00      	cmp	r5, #0
 80171de:	d149      	bne.n	8017274 <xQueueGenericReceive+0xd4>
				if( xTicksToWait == ( TickType_t ) 0 )
 80171e0:	9b01      	ldr	r3, [sp, #4]
 80171e2:	2b00      	cmp	r3, #0
 80171e4:	d07d      	beq.n	80172e2 <xQueueGenericReceive+0x142>
					vTaskSetTimeOutState( &xTimeOut );
 80171e6:	a802      	add	r0, sp, #8
 80171e8:	f000 fd32 	bl	8017c50 <vTaskSetTimeOutState>
					portYIELD_WITHIN_API();
 80171ec:	f8df a164 	ldr.w	sl, [pc, #356]	; 8017354 <xQueueGenericReceive+0x1b4>
		prvLockQueue( pxQueue );
 80171f0:	462e      	mov	r6, r5
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80171f2:	f104 0924 	add.w	r9, r4, #36	; 0x24
 80171f6:	e012      	b.n	801721e <xQueueGenericReceive+0x7e>
	taskENTER_CRITICAL();
 80171f8:	f7ff fba4 	bl	8016944 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 80171fc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80171fe:	2b00      	cmp	r3, #0
 8017200:	d057      	beq.n	80172b2 <xQueueGenericReceive+0x112>
	taskEXIT_CRITICAL();
 8017202:	f7ff fbc1 	bl	8016988 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 8017206:	4620      	mov	r0, r4
 8017208:	f7ff fd7c 	bl	8016d04 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 801720c:	f000 fb5a 	bl	80178c4 <xTaskResumeAll>
		taskENTER_CRITICAL();
 8017210:	f7ff fb98 	bl	8016944 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8017214:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8017216:	bb6d      	cbnz	r5, 8017274 <xQueueGenericReceive+0xd4>
				if( xTicksToWait == ( TickType_t ) 0 )
 8017218:	9b01      	ldr	r3, [sp, #4]
 801721a:	2b00      	cmp	r3, #0
 801721c:	d061      	beq.n	80172e2 <xQueueGenericReceive+0x142>
		taskEXIT_CRITICAL();
 801721e:	f7ff fbb3 	bl	8016988 <vPortExitCritical>
		vTaskSuspendAll();
 8017222:	f000 fa97 	bl	8017754 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8017226:	f7ff fb8d 	bl	8016944 <vPortEnterCritical>
 801722a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 801722e:	2bff      	cmp	r3, #255	; 0xff
 8017230:	bf08      	it	eq
 8017232:	f884 6044 	strbeq.w	r6, [r4, #68]	; 0x44
 8017236:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 801723a:	2bff      	cmp	r3, #255	; 0xff
 801723c:	bf08      	it	eq
 801723e:	f884 6045 	strbeq.w	r6, [r4, #69]	; 0x45
 8017242:	f7ff fba1 	bl	8016988 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8017246:	a901      	add	r1, sp, #4
 8017248:	a802      	add	r0, sp, #8
 801724a:	f000 fd15 	bl	8017c78 <xTaskCheckForTimeOut>
 801724e:	2800      	cmp	r0, #0
 8017250:	d0d2      	beq.n	80171f8 <xQueueGenericReceive+0x58>
			prvUnlockQueue( pxQueue );
 8017252:	4620      	mov	r0, r4
 8017254:	f7ff fd56 	bl	8016d04 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8017258:	f000 fb34 	bl	80178c4 <xTaskResumeAll>
	taskENTER_CRITICAL();
 801725c:	f7ff fb72 	bl	8016944 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8017260:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8017262:	2b00      	cmp	r3, #0
 8017264:	d03d      	beq.n	80172e2 <xQueueGenericReceive+0x142>
	taskEXIT_CRITICAL();
 8017266:	f7ff fb8f 	bl	8016988 <vPortExitCritical>
		taskENTER_CRITICAL();
 801726a:	f7ff fb6b 	bl	8016944 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 801726e:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8017270:	2d00      	cmp	r5, #0
 8017272:	d0d1      	beq.n	8017218 <xQueueGenericReceive+0x78>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8017274:	4639      	mov	r1, r7
 8017276:	4620      	mov	r0, r4
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 8017278:	68e6      	ldr	r6, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 801727a:	f7ff fd31 	bl	8016ce0 <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
 801727e:	f1b8 0f00 	cmp.w	r8, #0
 8017282:	d152      	bne.n	801732a <xQueueGenericReceive+0x18a>
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8017284:	6823      	ldr	r3, [r4, #0]
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 8017286:	3d01      	subs	r5, #1
 8017288:	63a5      	str	r5, [r4, #56]	; 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 801728a:	2b00      	cmp	r3, #0
 801728c:	d056      	beq.n	801733c <xQueueGenericReceive+0x19c>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801728e:	6923      	ldr	r3, [r4, #16]
 8017290:	2b00      	cmp	r3, #0
 8017292:	d04d      	beq.n	8017330 <xQueueGenericReceive+0x190>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8017294:	f104 0010 	add.w	r0, r4, #16
 8017298:	f000 fc92 	bl	8017bc0 <xTaskRemoveFromEventList>
 801729c:	2800      	cmp	r0, #0
 801729e:	d047      	beq.n	8017330 <xQueueGenericReceive+0x190>
							queueYIELD_IF_USING_PREEMPTION();
 80172a0:	4b2c      	ldr	r3, [pc, #176]	; (8017354 <xQueueGenericReceive+0x1b4>)
 80172a2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80172a6:	601a      	str	r2, [r3, #0]
 80172a8:	f3bf 8f4f 	dsb	sy
 80172ac:	f3bf 8f6f 	isb	sy
 80172b0:	e03e      	b.n	8017330 <xQueueGenericReceive+0x190>
	taskEXIT_CRITICAL();
 80172b2:	f7ff fb69 	bl	8016988 <vPortExitCritical>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80172b6:	6823      	ldr	r3, [r4, #0]
 80172b8:	b37b      	cbz	r3, 801731a <xQueueGenericReceive+0x17a>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80172ba:	9901      	ldr	r1, [sp, #4]
 80172bc:	4648      	mov	r0, r9
 80172be:	f000 fc45 	bl	8017b4c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80172c2:	4620      	mov	r0, r4
 80172c4:	f7ff fd1e 	bl	8016d04 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80172c8:	f000 fafc 	bl	80178c4 <xTaskResumeAll>
 80172cc:	2800      	cmp	r0, #0
 80172ce:	d1cc      	bne.n	801726a <xQueueGenericReceive+0xca>
					portYIELD_WITHIN_API();
 80172d0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80172d4:	f8ca 3000 	str.w	r3, [sl]
 80172d8:	f3bf 8f4f 	dsb	sy
 80172dc:	f3bf 8f6f 	isb	sy
 80172e0:	e7c3      	b.n	801726a <xQueueGenericReceive+0xca>
					taskEXIT_CRITICAL();
 80172e2:	f7ff fb51 	bl	8016988 <vPortExitCritical>
					return errQUEUE_EMPTY;
 80172e6:	2000      	movs	r0, #0
}
 80172e8:	b004      	add	sp, #16
 80172ea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80172ee:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80172f0:	2a00      	cmp	r2, #0
 80172f2:	f43f af5f 	beq.w	80171b4 <xQueueGenericReceive+0x14>
 80172f6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80172fa:	f383 8811 	msr	BASEPRI, r3
 80172fe:	f3bf 8f6f 	isb	sy
 8017302:	f3bf 8f4f 	dsb	sy
 8017306:	e7fe      	b.n	8017306 <xQueueGenericReceive+0x166>
 8017308:	f04f 0350 	mov.w	r3, #80	; 0x50
 801730c:	f383 8811 	msr	BASEPRI, r3
 8017310:	f3bf 8f6f 	isb	sy
 8017314:	f3bf 8f4f 	dsb	sy
 8017318:	e7fe      	b.n	8017318 <xQueueGenericReceive+0x178>
						taskENTER_CRITICAL();
 801731a:	f7ff fb13 	bl	8016944 <vPortEnterCritical>
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 801731e:	6860      	ldr	r0, [r4, #4]
 8017320:	f000 fd16 	bl	8017d50 <vTaskPriorityInherit>
						taskEXIT_CRITICAL();
 8017324:	f7ff fb30 	bl	8016988 <vPortExitCritical>
 8017328:	e7c7      	b.n	80172ba <xQueueGenericReceive+0x11a>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801732a:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 801732c:	60e6      	str	r6, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801732e:	b94b      	cbnz	r3, 8017344 <xQueueGenericReceive+0x1a4>
				taskEXIT_CRITICAL();
 8017330:	f7ff fb2a 	bl	8016988 <vPortExitCritical>
				return pdPASS;
 8017334:	2001      	movs	r0, #1
}
 8017336:	b004      	add	sp, #16
 8017338:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 801733c:	f000 fda0 	bl	8017e80 <pvTaskIncrementMutexHeldCount>
 8017340:	6060      	str	r0, [r4, #4]
 8017342:	e7a4      	b.n	801728e <xQueueGenericReceive+0xee>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8017344:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8017348:	f000 fc3a 	bl	8017bc0 <xTaskRemoveFromEventList>
 801734c:	2800      	cmp	r0, #0
 801734e:	d1a7      	bne.n	80172a0 <xQueueGenericReceive+0x100>
 8017350:	e7ee      	b.n	8017330 <xQueueGenericReceive+0x190>
 8017352:	bf00      	nop
 8017354:	e000ed04 	.word	0xe000ed04

08017358 <xQueueReceiveFromISR>:
{
 8017358:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 801735c:	b1b0      	cbz	r0, 801738c <xQueueReceiveFromISR+0x34>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 801735e:	b371      	cbz	r1, 80173be <xQueueReceiveFromISR+0x66>
 8017360:	4605      	mov	r5, r0
 8017362:	4690      	mov	r8, r2
 8017364:	4689      	mov	r9, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8017366:	f7ff fc03 	bl	8016b70 <vPortValidateInterruptPriority>
	__asm volatile
 801736a:	f3ef 8711 	mrs	r7, BASEPRI
 801736e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017372:	f383 8811 	msr	BASEPRI, r3
 8017376:	f3bf 8f6f 	isb	sy
 801737a:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 801737e:	6bac      	ldr	r4, [r5, #56]	; 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8017380:	b96c      	cbnz	r4, 801739e <xQueueReceiveFromISR+0x46>
			xReturn = pdFAIL;
 8017382:	4620      	mov	r0, r4
	__asm volatile
 8017384:	f387 8811 	msr	BASEPRI, r7
}
 8017388:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__asm volatile
 801738c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017390:	f383 8811 	msr	BASEPRI, r3
 8017394:	f3bf 8f6f 	isb	sy
 8017398:	f3bf 8f4f 	dsb	sy
 801739c:	e7fe      	b.n	801739c <xQueueReceiveFromISR+0x44>
			const int8_t cRxLock = pxQueue->cRxLock;
 801739e:	f895 6044 	ldrb.w	r6, [r5, #68]	; 0x44
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 80173a2:	4649      	mov	r1, r9
 80173a4:	4628      	mov	r0, r5
			const int8_t cRxLock = pxQueue->cRxLock;
 80173a6:	b276      	sxtb	r6, r6
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 80173a8:	f7ff fc9a 	bl	8016ce0 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 80173ac:	3c01      	subs	r4, #1
			if( cRxLock == queueUNLOCKED )
 80173ae:	1c73      	adds	r3, r6, #1
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 80173b0:	63ac      	str	r4, [r5, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 80173b2:	d010      	beq.n	80173d6 <xQueueReceiveFromISR+0x7e>
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 80173b4:	1c73      	adds	r3, r6, #1
 80173b6:	b25b      	sxtb	r3, r3
 80173b8:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 80173bc:	e00d      	b.n	80173da <xQueueReceiveFromISR+0x82>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80173be:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80173c0:	2b00      	cmp	r3, #0
 80173c2:	d0cd      	beq.n	8017360 <xQueueReceiveFromISR+0x8>
 80173c4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80173c8:	f383 8811 	msr	BASEPRI, r3
 80173cc:	f3bf 8f6f 	isb	sy
 80173d0:	f3bf 8f4f 	dsb	sy
 80173d4:	e7fe      	b.n	80173d4 <xQueueReceiveFromISR+0x7c>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80173d6:	692b      	ldr	r3, [r5, #16]
 80173d8:	b90b      	cbnz	r3, 80173de <xQueueReceiveFromISR+0x86>
			xReturn = pdPASS;
 80173da:	2001      	movs	r0, #1
 80173dc:	e7d2      	b.n	8017384 <xQueueReceiveFromISR+0x2c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80173de:	f105 0010 	add.w	r0, r5, #16
 80173e2:	f000 fbed 	bl	8017bc0 <xTaskRemoveFromEventList>
 80173e6:	2800      	cmp	r0, #0
 80173e8:	d0f7      	beq.n	80173da <xQueueReceiveFromISR+0x82>
						if( pxHigherPriorityTaskWoken != NULL )
 80173ea:	f1b8 0f00 	cmp.w	r8, #0
 80173ee:	d0f4      	beq.n	80173da <xQueueReceiveFromISR+0x82>
							*pxHigherPriorityTaskWoken = pdTRUE;
 80173f0:	2001      	movs	r0, #1
 80173f2:	f8c8 0000 	str.w	r0, [r8]
 80173f6:	e7c5      	b.n	8017384 <xQueueReceiveFromISR+0x2c>

080173f8 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 80173f8:	b430      	push	{r4, r5}
 80173fa:	4a08      	ldr	r2, [pc, #32]	; (801741c <vQueueAddToRegistry+0x24>)
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80173fc:	2300      	movs	r3, #0
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 80173fe:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
 8017402:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
 8017406:	b124      	cbz	r4, 8017412 <vQueueAddToRegistry+0x1a>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8017408:	3301      	adds	r3, #1
 801740a:	2b08      	cmp	r3, #8
 801740c:	d1f7      	bne.n	80173fe <vQueueAddToRegistry+0x6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 801740e:	bc30      	pop	{r4, r5}
 8017410:	4770      	bx	lr
				xQueueRegistry[ ux ].xHandle = xQueue;
 8017412:	6068      	str	r0, [r5, #4]
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8017414:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
	}
 8017418:	bc30      	pop	{r4, r5}
 801741a:	4770      	bx	lr
 801741c:	2001140c 	.word	0x2001140c

08017420 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 8017420:	b570      	push	{r4, r5, r6, lr}
 8017422:	4604      	mov	r4, r0
 8017424:	460d      	mov	r5, r1
 8017426:	4616      	mov	r6, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 8017428:	f7ff fa8c 	bl	8016944 <vPortEnterCritical>
 801742c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8017430:	2bff      	cmp	r3, #255	; 0xff
 8017432:	bf04      	itt	eq
 8017434:	2300      	moveq	r3, #0
 8017436:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 801743a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 801743e:	2bff      	cmp	r3, #255	; 0xff
 8017440:	bf04      	itt	eq
 8017442:	2300      	moveq	r3, #0
 8017444:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 8017448:	f7ff fa9e 	bl	8016988 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 801744c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 801744e:	b92b      	cbnz	r3, 801745c <vQueueWaitForMessageRestricted+0x3c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8017450:	4632      	mov	r2, r6
 8017452:	4629      	mov	r1, r5
 8017454:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8017458:	f000 fb92 	bl	8017b80 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 801745c:	4620      	mov	r0, r4
	}
 801745e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		prvUnlockQueue( pxQueue );
 8017462:	f7ff bc4f 	b.w	8016d04 <prvUnlockQueue>
 8017466:	bf00      	nop

08017468 <prvGetExpectedIdleTime>:
			/* When port optimised task selection is used the uxTopReadyPriority
			variable is used as a bit map.  If bits other than the least
			significant bit are set then there are tasks that have a priority
			above the idle priority that are in the Ready state.  This takes
			care of the case where the co-operative scheduler is in use. */
			if( uxTopReadyPriority > uxLeastSignificantBit )
 8017468:	4b0a      	ldr	r3, [pc, #40]	; (8017494 <prvGetExpectedIdleTime+0x2c>)
 801746a:	681a      	ldr	r2, [r3, #0]
 801746c:	2a01      	cmp	r2, #1
 801746e:	d902      	bls.n	8017476 <prvGetExpectedIdleTime+0xe>
				uxHigherPriorityReadyTasks = pdTRUE;
			}
		}
		#endif

		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
 8017470:	685b      	ldr	r3, [r3, #4]
		{
			xReturn = 0;
 8017472:	2000      	movs	r0, #0
 8017474:	4770      	bx	lr
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
 8017476:	685a      	ldr	r2, [r3, #4]
 8017478:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 801747a:	b918      	cbnz	r0, 8017484 <prvGetExpectedIdleTime+0x1c>
		}
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
 801747c:	689a      	ldr	r2, [r3, #8]
 801747e:	2a01      	cmp	r2, #1
 8017480:	d902      	bls.n	8017488 <prvGetExpectedIdleTime+0x20>
		{
			xReturn = xNextTaskUnblockTime - xTickCount;
		}

		return xReturn;
	}
 8017482:	4770      	bx	lr
			xReturn = 0;
 8017484:	2000      	movs	r0, #0
	}
 8017486:	4770      	bx	lr
			xReturn = xNextTaskUnblockTime - xTickCount;
 8017488:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
 801748c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8017490:	1ac0      	subs	r0, r0, r3
 8017492:	4770      	bx	lr
 8017494:	2000dec0 	.word	0x2000dec0

08017498 <prvResetNextTaskUnblockTime.part.2>:
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8017498:	4b04      	ldr	r3, [pc, #16]	; (80174ac <prvResetNextTaskUnblockTime.part.2+0x14>)
 801749a:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 801749e:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80174a0:	68d2      	ldr	r2, [r2, #12]
 80174a2:	6852      	ldr	r2, [r2, #4]
 80174a4:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
	}
}
 80174a8:	4770      	bx	lr
 80174aa:	bf00      	nop
 80174ac:	2000dec0 	.word	0x2000dec0

080174b0 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 80174b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 80174b2:	4c1b      	ldr	r4, [pc, #108]	; (8017520 <prvAddCurrentTaskToDelayedList+0x70>)
 80174b4:	f8d4 5098 	ldr.w	r5, [r4, #152]	; 0x98
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80174b8:	6863      	ldr	r3, [r4, #4]
{
 80174ba:	4606      	mov	r6, r0
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80174bc:	1d18      	adds	r0, r3, #4
{
 80174be:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80174c0:	f7ff fbbc 	bl	8016c3c <uxListRemove>
 80174c4:	b938      	cbnz	r0, 80174d6 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 80174c6:	6862      	ldr	r2, [r4, #4]
 80174c8:	6823      	ldr	r3, [r4, #0]
 80174ca:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 80174cc:	2201      	movs	r2, #1
 80174ce:	408a      	lsls	r2, r1
 80174d0:	ea23 0302 	bic.w	r3, r3, r2
 80174d4:	6023      	str	r3, [r4, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80174d6:	1c73      	adds	r3, r6, #1
 80174d8:	d018      	beq.n	801750c <prvAddCurrentTaskToDelayedList+0x5c>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80174da:	6863      	ldr	r3, [r4, #4]
 80174dc:	19ad      	adds	r5, r5, r6
 80174de:	605d      	str	r5, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 80174e0:	d20c      	bcs.n	80174fc <prvAddCurrentTaskToDelayedList+0x4c>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80174e2:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
 80174e6:	6861      	ldr	r1, [r4, #4]
 80174e8:	3104      	adds	r1, #4
 80174ea:	f7ff fb8d 	bl	8016c08 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 80174ee:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 80174f2:	42ab      	cmp	r3, r5
				{
					xNextTaskUnblockTime = xTimeToWake;
 80174f4:	bf88      	it	hi
 80174f6:	f8c4 5094 	strhi.w	r5, [r4, #148]	; 0x94

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 80174fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80174fc:	f8d4 00b4 	ldr.w	r0, [r4, #180]	; 0xb4
 8017500:	6861      	ldr	r1, [r4, #4]
}
 8017502:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8017506:	3104      	adds	r1, #4
 8017508:	f7ff bb7e 	b.w	8016c08 <vListInsert>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 801750c:	2f00      	cmp	r7, #0
 801750e:	d0e4      	beq.n	80174da <prvAddCurrentTaskToDelayedList+0x2a>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8017510:	6861      	ldr	r1, [r4, #4]
 8017512:	4804      	ldr	r0, [pc, #16]	; (8017524 <prvAddCurrentTaskToDelayedList+0x74>)
 8017514:	3104      	adds	r1, #4
}
 8017516:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 801751a:	f7ff bb65 	b.w	8016be8 <vListInsertEnd>
 801751e:	bf00      	nop
 8017520:	2000dec0 	.word	0x2000dec0
 8017524:	2000df60 	.word	0x2000df60

08017528 <xTaskCreate>:
	{
 8017528:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801752c:	ea4f 0882 	mov.w	r8, r2, lsl #2
	{
 8017530:	4606      	mov	r6, r0
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8017532:	4640      	mov	r0, r8
	{
 8017534:	4689      	mov	r9, r1
 8017536:	461f      	mov	r7, r3
 8017538:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801753a:	f7ff f8ef 	bl	801671c <pvPortMalloc>
			if( pxStack != NULL )
 801753e:	2800      	cmp	r0, #0
 8017540:	f000 80c3 	beq.w	80176ca <xTaskCreate+0x1a2>
 8017544:	4682      	mov	sl, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8017546:	2054      	movs	r0, #84	; 0x54
 8017548:	f7ff f8e8 	bl	801671c <pvPortMalloc>
				if( pxNewTCB != NULL )
 801754c:	4604      	mov	r4, r0
 801754e:	2800      	cmp	r0, #0
 8017550:	f000 808e 	beq.w	8017670 <xTaskCreate+0x148>
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8017554:	4642      	mov	r2, r8
					pxNewTCB->pxStack = pxStack;
 8017556:	f8c0 a030 	str.w	sl, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 801755a:	21a5      	movs	r1, #165	; 0xa5
 801755c:	4650      	mov	r0, sl
 801755e:	f007 fae7 	bl	801eb30 <memset>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8017562:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8017564:	f1a8 0804 	sub.w	r8, r8, #4
 8017568:	4498      	add	r8, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 801756a:	f028 0807 	bic.w	r8, r8, #7
 801756e:	f109 33ff 	add.w	r3, r9, #4294967295
 8017572:	f109 010f 	add.w	r1, r9, #15
 8017576:	f104 0233 	add.w	r2, r4, #51	; 0x33
 801757a:	e001      	b.n	8017580 <xTaskCreate+0x58>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 801757c:	428b      	cmp	r3, r1
 801757e:	d006      	beq.n	801758e <xTaskCreate+0x66>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8017580:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8017584:	f802 0f01 	strb.w	r0, [r2, #1]!
		if( pcName[ x ] == 0x00 )
 8017588:	7818      	ldrb	r0, [r3, #0]
 801758a:	2800      	cmp	r0, #0
 801758c:	d1f6      	bne.n	801757c <xTaskCreate+0x54>
 801758e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8017590:	2b06      	cmp	r3, #6
 8017592:	bf28      	it	cs
 8017594:	2306      	movcs	r3, #6
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8017596:	f04f 0b00 	mov.w	fp, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 801759a:	f104 0a04 	add.w	sl, r4, #4
	pxNewTCB->uxPriority = uxPriority;
 801759e:	62e3      	str	r3, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 80175a0:	6463      	str	r3, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80175a2:	4650      	mov	r0, sl
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80175a4:	f884 b043 	strb.w	fp, [r4, #67]	; 0x43
		pxNewTCB->uxMutexesHeld = 0;
 80175a8:	f8c4 b048 	str.w	fp, [r4, #72]	; 0x48
 80175ac:	4699      	mov	r9, r3
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80175ae:	f7ff fb17 	bl	8016be0 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 80175b2:	f104 0018 	add.w	r0, r4, #24
 80175b6:	f7ff fb13 	bl	8016be0 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80175ba:	f1c9 0307 	rsb	r3, r9, #7
		pxNewTCB->ulNotifiedValue = 0;
 80175be:	f8c4 b04c 	str.w	fp, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80175c2:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 80175c4:	6124      	str	r4, [r4, #16]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 80175c6:	f884 b050 	strb.w	fp, [r4, #80]	; 0x50
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 80175ca:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80175cc:	463a      	mov	r2, r7
 80175ce:	4631      	mov	r1, r6
 80175d0:	4640      	mov	r0, r8
 80175d2:	f7ff f989 	bl	80168e8 <pxPortInitialiseStack>
 80175d6:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 80175d8:	b105      	cbz	r5, 80175dc <xTaskCreate+0xb4>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 80175da:	602c      	str	r4, [r5, #0]
		uxCurrentNumberOfTasks++;
 80175dc:	4d3c      	ldr	r5, [pc, #240]	; (80176d0 <xTaskCreate+0x1a8>)
	taskENTER_CRITICAL();
 80175de:	f7ff f9b1 	bl	8016944 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 80175e2:	f8d5 30b8 	ldr.w	r3, [r5, #184]	; 0xb8
 80175e6:	3301      	adds	r3, #1
 80175e8:	f8c5 30b8 	str.w	r3, [r5, #184]	; 0xb8
		if( pxCurrentTCB == NULL )
 80175ec:	686b      	ldr	r3, [r5, #4]
 80175ee:	2b00      	cmp	r3, #0
 80175f0:	d035      	beq.n	801765e <xTaskCreate+0x136>
			if( xSchedulerRunning == pdFALSE )
 80175f2:	f8d5 210c 	ldr.w	r2, [r5, #268]	; 0x10c
 80175f6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80175f8:	b35a      	cbz	r2, 8017652 <xTaskCreate+0x12a>
 80175fa:	f105 0808 	add.w	r8, r5, #8
		prvAddTaskToReadyList( pxNewTCB );
 80175fe:	2601      	movs	r6, #1
 8017600:	fa06 f703 	lsl.w	r7, r6, r3
 8017604:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8017608:	682a      	ldr	r2, [r5, #0]
 801760a:	eb08 0083 	add.w	r0, r8, r3, lsl #2
		uxTaskNumber++;
 801760e:	f8d5 3110 	ldr.w	r3, [r5, #272]	; 0x110
		prvAddTaskToReadyList( pxNewTCB );
 8017612:	4651      	mov	r1, sl
 8017614:	4317      	orrs	r7, r2
		uxTaskNumber++;
 8017616:	199a      	adds	r2, r3, r6
 8017618:	f8c5 2110 	str.w	r2, [r5, #272]	; 0x110
		prvAddTaskToReadyList( pxNewTCB );
 801761c:	602f      	str	r7, [r5, #0]
 801761e:	f7ff fae3 	bl	8016be8 <vListInsertEnd>
	taskEXIT_CRITICAL();
 8017622:	f7ff f9b1 	bl	8016988 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8017626:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
 801762a:	b17b      	cbz	r3, 801764c <xTaskCreate+0x124>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 801762c:	686a      	ldr	r2, [r5, #4]
 801762e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8017630:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8017632:	429a      	cmp	r2, r3
 8017634:	d20a      	bcs.n	801764c <xTaskCreate+0x124>
			taskYIELD_IF_USING_PREEMPTION();
 8017636:	4b27      	ldr	r3, [pc, #156]	; (80176d4 <xTaskCreate+0x1ac>)
 8017638:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 801763c:	601a      	str	r2, [r3, #0]
 801763e:	f3bf 8f4f 	dsb	sy
 8017642:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
 8017646:	4630      	mov	r0, r6
	}
 8017648:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			xReturn = pdPASS;
 801764c:	4630      	mov	r0, r6
	}
 801764e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8017652:	686a      	ldr	r2, [r5, #4]
 8017654:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8017656:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 8017658:	bf98      	it	ls
 801765a:	606c      	strls	r4, [r5, #4]
 801765c:	e7cd      	b.n	80175fa <xTaskCreate+0xd2>
			pxCurrentTCB = pxNewTCB;
 801765e:	606c      	str	r4, [r5, #4]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8017660:	f8d5 30b8 	ldr.w	r3, [r5, #184]	; 0xb8
 8017664:	2b01      	cmp	r3, #1
 8017666:	d00a      	beq.n	801767e <xTaskCreate+0x156>
 8017668:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 801766a:	f105 0808 	add.w	r8, r5, #8
 801766e:	e7c6      	b.n	80175fe <xTaskCreate+0xd6>
					vPortFree( pxStack );
 8017670:	4650      	mov	r0, sl
 8017672:	f7ff f8d3 	bl	801681c <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8017676:	f04f 30ff 	mov.w	r0, #4294967295
	}
 801767a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801767e:	f105 0808 	add.w	r8, r5, #8
 8017682:	4646      	mov	r6, r8
 8017684:	f105 0794 	add.w	r7, r5, #148	; 0x94
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8017688:	4630      	mov	r0, r6
 801768a:	3614      	adds	r6, #20
 801768c:	f7ff fa9c 	bl	8016bc8 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8017690:	42b7      	cmp	r7, r6
 8017692:	d1f9      	bne.n	8017688 <xTaskCreate+0x160>
	vListInitialise( &xDelayedTaskList1 );
 8017694:	4e10      	ldr	r6, [pc, #64]	; (80176d8 <xTaskCreate+0x1b0>)
 8017696:	4630      	mov	r0, r6
	vListInitialise( &xDelayedTaskList2 );
 8017698:	f106 0714 	add.w	r7, r6, #20
	vListInitialise( &xDelayedTaskList1 );
 801769c:	f7ff fa94 	bl	8016bc8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 80176a0:	4638      	mov	r0, r7
 80176a2:	f7ff fa91 	bl	8016bc8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 80176a6:	f106 0028 	add.w	r0, r6, #40	; 0x28
 80176aa:	f7ff fa8d 	bl	8016bc8 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 80176ae:	f106 003c 	add.w	r0, r6, #60	; 0x3c
 80176b2:	f7ff fa89 	bl	8016bc8 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 80176b6:	f1a6 001c 	sub.w	r0, r6, #28
 80176ba:	f7ff fa85 	bl	8016bc8 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 80176be:	f8c5 609c 	str.w	r6, [r5, #156]	; 0x9c
 80176c2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80176c4:	f8c5 70b4 	str.w	r7, [r5, #180]	; 0xb4
 80176c8:	e799      	b.n	80175fe <xTaskCreate+0xd6>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80176ca:	f04f 30ff 	mov.w	r0, #4294967295
 80176ce:	e7be      	b.n	801764e <xTaskCreate+0x126>
 80176d0:	2000dec0 	.word	0x2000dec0
 80176d4:	e000ed04 	.word	0xe000ed04
 80176d8:	2000df7c 	.word	0x2000df7c

080176dc <vTaskStartScheduler>:
{
 80176dc:	b530      	push	{r4, r5, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 80176de:	4c1a      	ldr	r4, [pc, #104]	; (8017748 <vTaskStartScheduler+0x6c>)
 80176e0:	491a      	ldr	r1, [pc, #104]	; (801774c <vTaskStartScheduler+0x70>)
 80176e2:	481b      	ldr	r0, [pc, #108]	; (8017750 <vTaskStartScheduler+0x74>)
{
 80176e4:	b083      	sub	sp, #12
		xReturn = xTaskCreate(	prvIdleTask,
 80176e6:	f504 738e 	add.w	r3, r4, #284	; 0x11c
 80176ea:	2500      	movs	r5, #0
 80176ec:	e9cd 5300 	strd	r5, r3, [sp]
 80176f0:	2280      	movs	r2, #128	; 0x80
 80176f2:	462b      	mov	r3, r5
 80176f4:	f7ff ff18 	bl	8017528 <xTaskCreate>
		if( xReturn == pdPASS )
 80176f8:	2801      	cmp	r0, #1
 80176fa:	d003      	beq.n	8017704 <vTaskStartScheduler+0x28>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 80176fc:	3001      	adds	r0, #1
 80176fe:	d01a      	beq.n	8017736 <vTaskStartScheduler+0x5a>
}
 8017700:	b003      	add	sp, #12
 8017702:	bd30      	pop	{r4, r5, pc}
			xReturn = xTimerCreateTimerTask();
 8017704:	f000 fc10 	bl	8017f28 <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
 8017708:	2801      	cmp	r0, #1
 801770a:	d1f7      	bne.n	80176fc <vTaskStartScheduler+0x20>
 801770c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017710:	f383 8811 	msr	BASEPRI, r3
 8017714:	f3bf 8f6f 	isb	sy
 8017718:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 801771c:	f04f 33ff 	mov.w	r3, #4294967295
 8017720:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
		xSchedulerRunning = pdTRUE;
 8017724:	f8c4 010c 	str.w	r0, [r4, #268]	; 0x10c
		xTickCount = ( TickType_t ) 0U;
 8017728:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
}
 801772c:	b003      	add	sp, #12
 801772e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		if( xPortStartScheduler() != pdFALSE )
 8017732:	f7ff b9a7 	b.w	8016a84 <xPortStartScheduler>
 8017736:	f04f 0350 	mov.w	r3, #80	; 0x50
 801773a:	f383 8811 	msr	BASEPRI, r3
 801773e:	f3bf 8f6f 	isb	sy
 8017742:	f3bf 8f4f 	dsb	sy
 8017746:	e7fe      	b.n	8017746 <vTaskStartScheduler+0x6a>
 8017748:	2000dec0 	.word	0x2000dec0
 801774c:	080754f4 	.word	0x080754f4
 8017750:	080179f9 	.word	0x080179f9

08017754 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8017754:	4a03      	ldr	r2, [pc, #12]	; (8017764 <vTaskSuspendAll+0x10>)
 8017756:	f8d2 3118 	ldr.w	r3, [r2, #280]	; 0x118
 801775a:	3301      	adds	r3, #1
 801775c:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
}
 8017760:	4770      	bx	lr
 8017762:	bf00      	nop
 8017764:	2000dec0 	.word	0x2000dec0

08017768 <xTaskGetTickCount>:
		xTicks = xTickCount;
 8017768:	4b01      	ldr	r3, [pc, #4]	; (8017770 <xTaskGetTickCount+0x8>)
 801776a:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
}
 801776e:	4770      	bx	lr
 8017770:	2000dec0 	.word	0x2000dec0

08017774 <vTaskStepTick>:
		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
 8017774:	4b0b      	ldr	r3, [pc, #44]	; (80177a4 <vTaskStepTick+0x30>)
 8017776:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 801777a:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 801777e:	4402      	add	r2, r0
 8017780:	428a      	cmp	r2, r1
 8017782:	d908      	bls.n	8017796 <vTaskStepTick+0x22>
 8017784:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017788:	f383 8811 	msr	BASEPRI, r3
 801778c:	f3bf 8f6f 	isb	sy
 8017790:	f3bf 8f4f 	dsb	sy
 8017794:	e7fe      	b.n	8017794 <vTaskStepTick+0x20>
		xTickCount += xTicksToJump;
 8017796:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 801779a:	4402      	add	r2, r0
 801779c:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
	}
 80177a0:	4770      	bx	lr
 80177a2:	bf00      	nop
 80177a4:	2000dec0 	.word	0x2000dec0

080177a8 <xTaskIncrementTick>:
{
 80177a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80177ac:	4c43      	ldr	r4, [pc, #268]	; (80178bc <xTaskIncrementTick+0x114>)
 80177ae:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 80177b2:	b9ab      	cbnz	r3, 80177e0 <xTaskIncrementTick+0x38>
		const TickType_t xConstTickCount = xTickCount + 1;
 80177b4:	f8d4 6098 	ldr.w	r6, [r4, #152]	; 0x98
 80177b8:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
 80177ba:	f8c4 6098 	str.w	r6, [r4, #152]	; 0x98
		if( xConstTickCount == ( TickType_t ) 0U )
 80177be:	b1ee      	cbz	r6, 80177fc <xTaskIncrementTick+0x54>
		if( xConstTickCount >= xNextTaskUnblockTime )
 80177c0:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 80177c4:	42b3      	cmp	r3, r6
 80177c6:	d927      	bls.n	8017818 <xTaskIncrementTick+0x70>
BaseType_t xSwitchRequired = pdFALSE;
 80177c8:	2500      	movs	r5, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80177ca:	6863      	ldr	r3, [r4, #4]
 80177cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80177ce:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80177d2:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 80177d6:	689b      	ldr	r3, [r3, #8]
				xSwitchRequired = pdTRUE;
 80177d8:	2b02      	cmp	r3, #2
 80177da:	bf28      	it	cs
 80177dc:	2501      	movcs	r5, #1
 80177de:	e005      	b.n	80177ec <xTaskIncrementTick+0x44>
		++uxPendedTicks;
 80177e0:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
 80177e4:	3301      	adds	r3, #1
 80177e6:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
BaseType_t xSwitchRequired = pdFALSE;
 80177ea:	2500      	movs	r5, #0
		if( xYieldPending != pdFALSE )
 80177ec:	f8d4 3128 	ldr.w	r3, [r4, #296]	; 0x128
			xSwitchRequired = pdTRUE;
 80177f0:	2b00      	cmp	r3, #0
}
 80177f2:	bf0c      	ite	eq
 80177f4:	4628      	moveq	r0, r5
 80177f6:	2001      	movne	r0, #1
 80177f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			taskSWITCH_DELAYED_LISTS();
 80177fc:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 8017800:	681b      	ldr	r3, [r3, #0]
 8017802:	2b00      	cmp	r3, #0
 8017804:	d040      	beq.n	8017888 <xTaskIncrementTick+0xe0>
 8017806:	f04f 0350 	mov.w	r3, #80	; 0x50
 801780a:	f383 8811 	msr	BASEPRI, r3
 801780e:	f3bf 8f6f 	isb	sy
 8017812:	f3bf 8f4f 	dsb	sy
 8017816:	e7fe      	b.n	8017816 <xTaskIncrementTick+0x6e>
					prvAddTaskToReadyList( pxTCB );
 8017818:	f8df a0a4 	ldr.w	sl, [pc, #164]	; 80178c0 <xTaskIncrementTick+0x118>
BaseType_t xSwitchRequired = pdFALSE;
 801781c:	2500      	movs	r5, #0
					prvAddTaskToReadyList( pxTCB );
 801781e:	f04f 0901 	mov.w	r9, #1
 8017822:	e024      	b.n	801786e <xTaskIncrementTick+0xc6>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8017824:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 8017828:	68db      	ldr	r3, [r3, #12]
 801782a:	68df      	ldr	r7, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 801782c:	687b      	ldr	r3, [r7, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801782e:	f107 0804 	add.w	r8, r7, #4
					if( xConstTickCount < xItemValue )
 8017832:	429e      	cmp	r6, r3
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8017834:	4640      	mov	r0, r8
					if( xConstTickCount < xItemValue )
 8017836:	d324      	bcc.n	8017882 <xTaskIncrementTick+0xda>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8017838:	f7ff fa00 	bl	8016c3c <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 801783c:	6abb      	ldr	r3, [r7, #40]	; 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 801783e:	f107 0018 	add.w	r0, r7, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8017842:	b10b      	cbz	r3, 8017848 <xTaskIncrementTick+0xa0>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8017844:	f7ff f9fa 	bl	8016c3c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8017848:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801784a:	6822      	ldr	r2, [r4, #0]
 801784c:	fa09 f300 	lsl.w	r3, r9, r0
 8017850:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8017854:	4313      	orrs	r3, r2
 8017856:	4641      	mov	r1, r8
 8017858:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
 801785c:	6023      	str	r3, [r4, #0]
 801785e:	f7ff f9c3 	bl	8016be8 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8017862:	6863      	ldr	r3, [r4, #4]
 8017864:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8017866:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 8017868:	429a      	cmp	r2, r3
 801786a:	bf28      	it	cs
 801786c:	2501      	movcs	r5, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801786e:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 8017872:	681b      	ldr	r3, [r3, #0]
 8017874:	2b00      	cmp	r3, #0
 8017876:	d1d5      	bne.n	8017824 <xTaskIncrementTick+0x7c>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8017878:	f04f 33ff 	mov.w	r3, #4294967295
 801787c:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
					break;
 8017880:	e7a3      	b.n	80177ca <xTaskIncrementTick+0x22>
						xNextTaskUnblockTime = xItemValue;
 8017882:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
						break;
 8017886:	e7a0      	b.n	80177ca <xTaskIncrementTick+0x22>
			taskSWITCH_DELAYED_LISTS();
 8017888:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 801788c:	f8d4 20b4 	ldr.w	r2, [r4, #180]	; 0xb4
 8017890:	f8c4 209c 	str.w	r2, [r4, #156]	; 0x9c
 8017894:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
 8017898:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
 801789c:	3301      	adds	r3, #1
 801789e:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80178a2:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 80178a6:	681b      	ldr	r3, [r3, #0]
 80178a8:	b923      	cbnz	r3, 80178b4 <xTaskIncrementTick+0x10c>
		xNextTaskUnblockTime = portMAX_DELAY;
 80178aa:	f04f 33ff 	mov.w	r3, #4294967295
 80178ae:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
 80178b2:	e785      	b.n	80177c0 <xTaskIncrementTick+0x18>
 80178b4:	f7ff fdf0 	bl	8017498 <prvResetNextTaskUnblockTime.part.2>
 80178b8:	e782      	b.n	80177c0 <xTaskIncrementTick+0x18>
 80178ba:	bf00      	nop
 80178bc:	2000dec0 	.word	0x2000dec0
 80178c0:	2000dec8 	.word	0x2000dec8

080178c4 <xTaskResumeAll>:
{
 80178c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	configASSERT( uxSchedulerSuspended );
 80178c8:	4c36      	ldr	r4, [pc, #216]	; (80179a4 <xTaskResumeAll+0xe0>)
 80178ca:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 80178ce:	b943      	cbnz	r3, 80178e2 <xTaskResumeAll+0x1e>
 80178d0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80178d4:	f383 8811 	msr	BASEPRI, r3
 80178d8:	f3bf 8f6f 	isb	sy
 80178dc:	f3bf 8f4f 	dsb	sy
 80178e0:	e7fe      	b.n	80178e0 <xTaskResumeAll+0x1c>
	taskENTER_CRITICAL();
 80178e2:	f7ff f82f 	bl	8016944 <vPortEnterCritical>
		--uxSchedulerSuspended;
 80178e6:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 80178ea:	3b01      	subs	r3, #1
 80178ec:	f8c4 3118 	str.w	r3, [r4, #280]	; 0x118
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80178f0:	f8d4 5118 	ldr.w	r5, [r4, #280]	; 0x118
 80178f4:	bb4d      	cbnz	r5, 801794a <xTaskResumeAll+0x86>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 80178f6:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
 80178fa:	b333      	cbz	r3, 801794a <xTaskResumeAll+0x86>
					prvAddTaskToReadyList( pxTCB );
 80178fc:	2601      	movs	r6, #1
 80178fe:	f104 0708 	add.w	r7, r4, #8
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8017902:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
 8017906:	b333      	cbz	r3, 8017956 <xTaskResumeAll+0x92>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8017908:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
 801790c:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801790e:	f105 0804 	add.w	r8, r5, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8017912:	f105 0018 	add.w	r0, r5, #24
 8017916:	f7ff f991 	bl	8016c3c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801791a:	4640      	mov	r0, r8
 801791c:	f7ff f98e 	bl	8016c3c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8017920:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8017922:	6822      	ldr	r2, [r4, #0]
 8017924:	fa06 f300 	lsl.w	r3, r6, r0
 8017928:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801792c:	4313      	orrs	r3, r2
 801792e:	4641      	mov	r1, r8
 8017930:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 8017934:	6023      	str	r3, [r4, #0]
 8017936:	f7ff f957 	bl	8016be8 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801793a:	6863      	ldr	r3, [r4, #4]
 801793c:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 801793e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017940:	429a      	cmp	r2, r3
 8017942:	d3de      	bcc.n	8017902 <xTaskResumeAll+0x3e>
						xYieldPending = pdTRUE;
 8017944:	f8c4 6128 	str.w	r6, [r4, #296]	; 0x128
 8017948:	e7db      	b.n	8017902 <xTaskResumeAll+0x3e>
BaseType_t xAlreadyYielded = pdFALSE;
 801794a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 801794c:	f7ff f81c 	bl	8016988 <vPortExitCritical>
}
 8017950:	4620      	mov	r0, r4
 8017952:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if( pxTCB != NULL )
 8017956:	b13d      	cbz	r5, 8017968 <xTaskResumeAll+0xa4>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8017958:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 801795c:	681b      	ldr	r3, [r3, #0]
 801795e:	b9f3      	cbnz	r3, 801799e <xTaskResumeAll+0xda>
		xNextTaskUnblockTime = portMAX_DELAY;
 8017960:	f04f 33ff 	mov.w	r3, #4294967295
 8017964:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8017968:	f8d4 5124 	ldr.w	r5, [r4, #292]	; 0x124
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 801796c:	b14d      	cbz	r5, 8017982 <xTaskResumeAll+0xbe>
								xYieldPending = pdTRUE;
 801796e:	2601      	movs	r6, #1
							if( xTaskIncrementTick() != pdFALSE )
 8017970:	f7ff ff1a 	bl	80177a8 <xTaskIncrementTick>
 8017974:	b108      	cbz	r0, 801797a <xTaskResumeAll+0xb6>
								xYieldPending = pdTRUE;
 8017976:	f8c4 6128 	str.w	r6, [r4, #296]	; 0x128
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 801797a:	3d01      	subs	r5, #1
 801797c:	d1f8      	bne.n	8017970 <xTaskResumeAll+0xac>
						uxPendedTicks = 0;
 801797e:	f8c4 5124 	str.w	r5, [r4, #292]	; 0x124
				if( xYieldPending != pdFALSE )
 8017982:	f8d4 3128 	ldr.w	r3, [r4, #296]	; 0x128
 8017986:	2b00      	cmp	r3, #0
 8017988:	d0df      	beq.n	801794a <xTaskResumeAll+0x86>
					taskYIELD_IF_USING_PREEMPTION();
 801798a:	4b07      	ldr	r3, [pc, #28]	; (80179a8 <xTaskResumeAll+0xe4>)
 801798c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8017990:	601a      	str	r2, [r3, #0]
 8017992:	f3bf 8f4f 	dsb	sy
 8017996:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 801799a:	2401      	movs	r4, #1
 801799c:	e7d6      	b.n	801794c <xTaskResumeAll+0x88>
 801799e:	f7ff fd7b 	bl	8017498 <prvResetNextTaskUnblockTime.part.2>
 80179a2:	e7e1      	b.n	8017968 <xTaskResumeAll+0xa4>
 80179a4:	2000dec0 	.word	0x2000dec0
 80179a8:	e000ed04 	.word	0xe000ed04

080179ac <vTaskDelay>:
	{
 80179ac:	b508      	push	{r3, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 80179ae:	b1b0      	cbz	r0, 80179de <vTaskDelay+0x32>
			configASSERT( uxSchedulerSuspended == 0 );
 80179b0:	4b0f      	ldr	r3, [pc, #60]	; (80179f0 <vTaskDelay+0x44>)
 80179b2:	f8d3 1118 	ldr.w	r1, [r3, #280]	; 0x118
 80179b6:	b141      	cbz	r1, 80179ca <vTaskDelay+0x1e>
 80179b8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80179bc:	f383 8811 	msr	BASEPRI, r3
 80179c0:	f3bf 8f6f 	isb	sy
 80179c4:	f3bf 8f4f 	dsb	sy
 80179c8:	e7fe      	b.n	80179c8 <vTaskDelay+0x1c>
	++uxSchedulerSuspended;
 80179ca:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80179ce:	3201      	adds	r2, #1
 80179d0:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 80179d4:	f7ff fd6c 	bl	80174b0 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 80179d8:	f7ff ff74 	bl	80178c4 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 80179dc:	b938      	cbnz	r0, 80179ee <vTaskDelay+0x42>
			portYIELD_WITHIN_API();
 80179de:	4b05      	ldr	r3, [pc, #20]	; (80179f4 <vTaskDelay+0x48>)
 80179e0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80179e4:	601a      	str	r2, [r3, #0]
 80179e6:	f3bf 8f4f 	dsb	sy
 80179ea:	f3bf 8f6f 	isb	sy
	}
 80179ee:	bd08      	pop	{r3, pc}
 80179f0:	2000dec0 	.word	0x2000dec0
 80179f4:	e000ed04 	.word	0xe000ed04

080179f8 <prvIdleTask>:
{
 80179f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80179fa:	4c2c      	ldr	r4, [pc, #176]	; (8017aac <prvIdleTask+0xb4>)
				taskYIELD();
 80179fc:	4f2c      	ldr	r7, [pc, #176]	; (8017ab0 <prvIdleTask+0xb8>)
 80179fe:	f04f 5680 	mov.w	r6, #268435456	; 0x10000000
 8017a02:	e009      	b.n	8017a18 <prvIdleTask+0x20>
	++uxSchedulerSuspended;
 8017a04:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8017a08:	f8d4 50f8 	ldr.w	r5, [r4, #248]	; 0xf8
	++uxSchedulerSuspended;
 8017a0c:	3301      	adds	r3, #1
 8017a0e:	f8c4 3118 	str.w	r3, [r4, #280]	; 0x118
			( void ) xTaskResumeAll();
 8017a12:	f7ff ff57 	bl	80178c4 <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 8017a16:	bb2d      	cbnz	r5, 8017a64 <prvIdleTask+0x6c>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8017a18:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
 8017a1c:	2b00      	cmp	r3, #0
 8017a1e:	d1f1      	bne.n	8017a04 <prvIdleTask+0xc>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8017a20:	68a3      	ldr	r3, [r4, #8]
 8017a22:	2b01      	cmp	r3, #1
 8017a24:	d904      	bls.n	8017a30 <prvIdleTask+0x38>
				taskYIELD();
 8017a26:	603e      	str	r6, [r7, #0]
 8017a28:	f3bf 8f4f 	dsb	sy
 8017a2c:	f3bf 8f6f 	isb	sy
			vApplicationIdleHook();
 8017a30:	f002 fcf2 	bl	801a418 <vApplicationIdleHook>
			xExpectedIdleTime = prvGetExpectedIdleTime();
 8017a34:	f7ff fd18 	bl	8017468 <prvGetExpectedIdleTime>
			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
 8017a38:	2802      	cmp	r0, #2
 8017a3a:	d9ed      	bls.n	8017a18 <prvIdleTask+0x20>
	++uxSchedulerSuspended;
 8017a3c:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 8017a40:	3301      	adds	r3, #1
 8017a42:	f8c4 3118 	str.w	r3, [r4, #280]	; 0x118
					configASSERT( xNextTaskUnblockTime >= xTickCount );
 8017a46:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 8017a4a:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8017a4e:	429a      	cmp	r2, r3
 8017a50:	d323      	bcc.n	8017a9a <prvIdleTask+0xa2>
					xExpectedIdleTime = prvGetExpectedIdleTime();
 8017a52:	f7ff fd09 	bl	8017468 <prvGetExpectedIdleTime>
					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
 8017a56:	2802      	cmp	r0, #2
 8017a58:	d901      	bls.n	8017a5e <prvIdleTask+0x66>
						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
 8017a5a:	f002 fd57 	bl	801a50c <vPortSuppressTicksAndSleep>
				( void ) xTaskResumeAll();
 8017a5e:	f7ff ff31 	bl	80178c4 <xTaskResumeAll>
 8017a62:	e7d9      	b.n	8017a18 <prvIdleTask+0x20>
				taskENTER_CRITICAL();
 8017a64:	f7fe ff6e 	bl	8016944 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8017a68:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
 8017a6c:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8017a6e:	1d28      	adds	r0, r5, #4
 8017a70:	f7ff f8e4 	bl	8016c3c <uxListRemove>
					--uxCurrentNumberOfTasks;
 8017a74:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
 8017a78:	3b01      	subs	r3, #1
 8017a7a:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
					--uxDeletedTasksWaitingCleanUp;
 8017a7e:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
 8017a82:	3b01      	subs	r3, #1
 8017a84:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
				taskEXIT_CRITICAL();
 8017a88:	f7fe ff7e 	bl	8016988 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 8017a8c:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8017a8e:	f7fe fec5 	bl	801681c <vPortFree>
			vPortFree( pxTCB );
 8017a92:	4628      	mov	r0, r5
 8017a94:	f7fe fec2 	bl	801681c <vPortFree>
 8017a98:	e7be      	b.n	8017a18 <prvIdleTask+0x20>
 8017a9a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017a9e:	f383 8811 	msr	BASEPRI, r3
 8017aa2:	f3bf 8f6f 	isb	sy
 8017aa6:	f3bf 8f4f 	dsb	sy
 8017aaa:	e7fe      	b.n	8017aaa <prvIdleTask+0xb2>
 8017aac:	2000dec0 	.word	0x2000dec0
 8017ab0:	e000ed04 	.word	0xe000ed04

08017ab4 <vTaskSwitchContext>:
{
 8017ab4:	b538      	push	{r3, r4, r5, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8017ab6:	4c23      	ldr	r4, [pc, #140]	; (8017b44 <vTaskSwitchContext+0x90>)
 8017ab8:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 8017abc:	bb73      	cbnz	r3, 8017b1c <vTaskSwitchContext+0x68>
		xYieldPending = pdFALSE;
 8017abe:	f8c4 3128 	str.w	r3, [r4, #296]	; 0x128
		taskCHECK_FOR_STACK_OVERFLOW();
 8017ac2:	6863      	ldr	r3, [r4, #4]
 8017ac4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8017ac6:	681a      	ldr	r2, [r3, #0]
 8017ac8:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8017acc:	d10b      	bne.n	8017ae6 <vTaskSwitchContext+0x32>
 8017ace:	685a      	ldr	r2, [r3, #4]
 8017ad0:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8017ad4:	d107      	bne.n	8017ae6 <vTaskSwitchContext+0x32>
 8017ad6:	689a      	ldr	r2, [r3, #8]
 8017ad8:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8017adc:	d103      	bne.n	8017ae6 <vTaskSwitchContext+0x32>
 8017ade:	68db      	ldr	r3, [r3, #12]
 8017ae0:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
 8017ae4:	d004      	beq.n	8017af0 <vTaskSwitchContext+0x3c>
 8017ae6:	6860      	ldr	r0, [r4, #4]
 8017ae8:	6861      	ldr	r1, [r4, #4]
 8017aea:	3134      	adds	r1, #52	; 0x34
 8017aec:	f003 ff28 	bl	801b940 <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8017af0:	6823      	ldr	r3, [r4, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 8017af2:	fab3 f383 	clz	r3, r3
 8017af6:	b2db      	uxtb	r3, r3
 8017af8:	f1c3 031f 	rsb	r3, r3, #31
 8017afc:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8017b00:	0089      	lsls	r1, r1, #2
 8017b02:	1860      	adds	r0, r4, r1
 8017b04:	6882      	ldr	r2, [r0, #8]
 8017b06:	b16a      	cbz	r2, 8017b24 <vTaskSwitchContext+0x70>
 8017b08:	68c2      	ldr	r2, [r0, #12]
 8017b0a:	4d0f      	ldr	r5, [pc, #60]	; (8017b48 <vTaskSwitchContext+0x94>)
 8017b0c:	6852      	ldr	r2, [r2, #4]
 8017b0e:	60c2      	str	r2, [r0, #12]
 8017b10:	4429      	add	r1, r5
 8017b12:	428a      	cmp	r2, r1
 8017b14:	d00f      	beq.n	8017b36 <vTaskSwitchContext+0x82>
 8017b16:	68d3      	ldr	r3, [r2, #12]
 8017b18:	6063      	str	r3, [r4, #4]
}
 8017b1a:	bd38      	pop	{r3, r4, r5, pc}
		xYieldPending = pdTRUE;
 8017b1c:	2301      	movs	r3, #1
 8017b1e:	f8c4 3128 	str.w	r3, [r4, #296]	; 0x128
}
 8017b22:	bd38      	pop	{r3, r4, r5, pc}
	__asm volatile
 8017b24:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017b28:	f383 8811 	msr	BASEPRI, r3
 8017b2c:	f3bf 8f6f 	isb	sy
 8017b30:	f3bf 8f4f 	dsb	sy
 8017b34:	e7fe      	b.n	8017b34 <vTaskSwitchContext+0x80>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8017b36:	2114      	movs	r1, #20
 8017b38:	fb01 4303 	mla	r3, r1, r3, r4
 8017b3c:	6852      	ldr	r2, [r2, #4]
 8017b3e:	60da      	str	r2, [r3, #12]
 8017b40:	e7e9      	b.n	8017b16 <vTaskSwitchContext+0x62>
 8017b42:	bf00      	nop
 8017b44:	2000dec0 	.word	0x2000dec0
 8017b48:	2000ded0 	.word	0x2000ded0

08017b4c <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
 8017b4c:	b940      	cbnz	r0, 8017b60 <vTaskPlaceOnEventList+0x14>
 8017b4e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017b52:	f383 8811 	msr	BASEPRI, r3
 8017b56:	f3bf 8f6f 	isb	sy
 8017b5a:	f3bf 8f4f 	dsb	sy
 8017b5e:	e7fe      	b.n	8017b5e <vTaskPlaceOnEventList+0x12>
{
 8017b60:	b510      	push	{r4, lr}
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8017b62:	4b06      	ldr	r3, [pc, #24]	; (8017b7c <vTaskPlaceOnEventList+0x30>)
 8017b64:	460c      	mov	r4, r1
 8017b66:	6859      	ldr	r1, [r3, #4]
 8017b68:	3118      	adds	r1, #24
 8017b6a:	f7ff f84d 	bl	8016c08 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8017b6e:	4620      	mov	r0, r4
 8017b70:	2101      	movs	r1, #1
}
 8017b72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8017b76:	f7ff bc9b 	b.w	80174b0 <prvAddCurrentTaskToDelayedList>
 8017b7a:	bf00      	nop
 8017b7c:	2000dec0 	.word	0x2000dec0

08017b80 <vTaskPlaceOnEventListRestricted>:
	{
 8017b80:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxEventList );
 8017b82:	b188      	cbz	r0, 8017ba8 <vTaskPlaceOnEventListRestricted+0x28>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8017b84:	4b0d      	ldr	r3, [pc, #52]	; (8017bbc <vTaskPlaceOnEventListRestricted+0x3c>)
 8017b86:	460d      	mov	r5, r1
 8017b88:	6859      	ldr	r1, [r3, #4]
 8017b8a:	4614      	mov	r4, r2
 8017b8c:	3118      	adds	r1, #24
 8017b8e:	f7ff f82b 	bl	8016be8 <vListInsertEnd>
			xTicksToWait = portMAX_DELAY;
 8017b92:	2c00      	cmp	r4, #0
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8017b94:	bf08      	it	eq
 8017b96:	4628      	moveq	r0, r5
 8017b98:	4621      	mov	r1, r4
 8017b9a:	bf18      	it	ne
 8017b9c:	f04f 30ff 	movne.w	r0, #4294967295
	}
 8017ba0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8017ba4:	f7ff bc84 	b.w	80174b0 <prvAddCurrentTaskToDelayedList>
 8017ba8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017bac:	f383 8811 	msr	BASEPRI, r3
 8017bb0:	f3bf 8f6f 	isb	sy
 8017bb4:	f3bf 8f4f 	dsb	sy
 8017bb8:	e7fe      	b.n	8017bb8 <vTaskPlaceOnEventListRestricted+0x38>
 8017bba:	bf00      	nop
 8017bbc:	2000dec0 	.word	0x2000dec0

08017bc0 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8017bc0:	68c3      	ldr	r3, [r0, #12]
{
 8017bc2:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8017bc4:	68dd      	ldr	r5, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8017bc6:	b3a5      	cbz	r5, 8017c32 <xTaskRemoveFromEventList+0x72>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8017bc8:	f105 0618 	add.w	r6, r5, #24
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8017bcc:	4c1f      	ldr	r4, [pc, #124]	; (8017c4c <xTaskRemoveFromEventList+0x8c>)
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8017bce:	4630      	mov	r0, r6
 8017bd0:	f7ff f834 	bl	8016c3c <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8017bd4:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 8017bd8:	bb2b      	cbnz	r3, 8017c26 <xTaskRemoveFromEventList+0x66>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8017bda:	1d2e      	adds	r6, r5, #4
 8017bdc:	4630      	mov	r0, r6
 8017bde:	f7ff f82d 	bl	8016c3c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8017be2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8017be4:	6821      	ldr	r1, [r4, #0]
 8017be6:	2201      	movs	r2, #1
 8017be8:	409a      	lsls	r2, r3
 8017bea:	4620      	mov	r0, r4
 8017bec:	430a      	orrs	r2, r1
 8017bee:	f840 2b08 	str.w	r2, [r0], #8
 8017bf2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8017bf6:	4631      	mov	r1, r6
 8017bf8:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8017bfc:	f7fe fff4 	bl	8016be8 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8017c00:	6863      	ldr	r3, [r4, #4]
 8017c02:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8017c04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017c06:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 8017c08:	bf84      	itt	hi
 8017c0a:	2001      	movhi	r0, #1
 8017c0c:	f8c4 0128 	strhi.w	r0, [r4, #296]	; 0x128
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8017c10:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 8017c14:	681b      	ldr	r3, [r3, #0]
		xReturn = pdFALSE;
 8017c16:	bf98      	it	ls
 8017c18:	2000      	movls	r0, #0
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8017c1a:	b99b      	cbnz	r3, 8017c44 <xTaskRemoveFromEventList+0x84>
		xNextTaskUnblockTime = portMAX_DELAY;
 8017c1c:	f04f 33ff 	mov.w	r3, #4294967295
 8017c20:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
}
 8017c24:	bd70      	pop	{r4, r5, r6, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8017c26:	4631      	mov	r1, r6
 8017c28:	f104 00e4 	add.w	r0, r4, #228	; 0xe4
 8017c2c:	f7fe ffdc 	bl	8016be8 <vListInsertEnd>
 8017c30:	e7e6      	b.n	8017c00 <xTaskRemoveFromEventList+0x40>
 8017c32:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017c36:	f383 8811 	msr	BASEPRI, r3
 8017c3a:	f3bf 8f6f 	isb	sy
 8017c3e:	f3bf 8f4f 	dsb	sy
 8017c42:	e7fe      	b.n	8017c42 <xTaskRemoveFromEventList+0x82>
 8017c44:	f7ff fc28 	bl	8017498 <prvResetNextTaskUnblockTime.part.2>
}
 8017c48:	bd70      	pop	{r4, r5, r6, pc}
 8017c4a:	bf00      	nop
 8017c4c:	2000dec0 	.word	0x2000dec0

08017c50 <vTaskSetTimeOutState>:
	configASSERT( pxTimeOut );
 8017c50:	b138      	cbz	r0, 8017c62 <vTaskSetTimeOutState+0x12>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8017c52:	4b08      	ldr	r3, [pc, #32]	; (8017c74 <vTaskSetTimeOutState+0x24>)
 8017c54:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
	pxTimeOut->xTimeOnEntering = xTickCount;
 8017c58:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8017c5c:	e9c0 2300 	strd	r2, r3, [r0]
}
 8017c60:	4770      	bx	lr
 8017c62:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017c66:	f383 8811 	msr	BASEPRI, r3
 8017c6a:	f3bf 8f6f 	isb	sy
 8017c6e:	f3bf 8f4f 	dsb	sy
 8017c72:	e7fe      	b.n	8017c72 <vTaskSetTimeOutState+0x22>
 8017c74:	2000dec0 	.word	0x2000dec0

08017c78 <xTaskCheckForTimeOut>:
{
 8017c78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( pxTimeOut );
 8017c7a:	b360      	cbz	r0, 8017cd6 <xTaskCheckForTimeOut+0x5e>
	configASSERT( pxTicksToWait );
 8017c7c:	b311      	cbz	r1, 8017cc4 <xTaskCheckForTimeOut+0x4c>
 8017c7e:	460d      	mov	r5, r1
 8017c80:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8017c82:	f7fe fe5f 	bl	8016944 <vPortEnterCritical>
			if( *pxTicksToWait == portMAX_DELAY )
 8017c86:	682b      	ldr	r3, [r5, #0]
		const TickType_t xConstTickCount = xTickCount;
 8017c88:	4a19      	ldr	r2, [pc, #100]	; (8017cf0 <xTaskCheckForTimeOut+0x78>)
			if( *pxTicksToWait == portMAX_DELAY )
 8017c8a:	1c59      	adds	r1, r3, #1
		const TickType_t xConstTickCount = xTickCount;
 8017c8c:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
			if( *pxTicksToWait == portMAX_DELAY )
 8017c90:	d02a      	beq.n	8017ce8 <xTaskCheckForTimeOut+0x70>
 8017c92:	e9d4 7100 	ldrd	r7, r1, [r4]
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8017c96:	f8d2 6120 	ldr.w	r6, [r2, #288]	; 0x120
 8017c9a:	42b7      	cmp	r7, r6
 8017c9c:	d001      	beq.n	8017ca2 <xTaskCheckForTimeOut+0x2a>
 8017c9e:	4288      	cmp	r0, r1
 8017ca0:	d224      	bcs.n	8017cec <xTaskCheckForTimeOut+0x74>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8017ca2:	1a46      	subs	r6, r0, r1
 8017ca4:	42b3      	cmp	r3, r6
 8017ca6:	d921      	bls.n	8017cec <xTaskCheckForTimeOut+0x74>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 8017ca8:	1a1b      	subs	r3, r3, r0
 8017caa:	440b      	add	r3, r1
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8017cac:	f8d2 1120 	ldr.w	r1, [r2, #288]	; 0x120
	pxTimeOut->xTimeOnEntering = xTickCount;
 8017cb0:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 8017cb4:	602b      	str	r3, [r5, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8017cb6:	e9c4 1200 	strd	r1, r2, [r4]
			xReturn = pdFALSE;
 8017cba:	2500      	movs	r5, #0
	taskEXIT_CRITICAL();
 8017cbc:	f7fe fe64 	bl	8016988 <vPortExitCritical>
}
 8017cc0:	4628      	mov	r0, r5
 8017cc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8017cc4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017cc8:	f383 8811 	msr	BASEPRI, r3
 8017ccc:	f3bf 8f6f 	isb	sy
 8017cd0:	f3bf 8f4f 	dsb	sy
 8017cd4:	e7fe      	b.n	8017cd4 <xTaskCheckForTimeOut+0x5c>
 8017cd6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017cda:	f383 8811 	msr	BASEPRI, r3
 8017cde:	f3bf 8f6f 	isb	sy
 8017ce2:	f3bf 8f4f 	dsb	sy
 8017ce6:	e7fe      	b.n	8017ce6 <xTaskCheckForTimeOut+0x6e>
				xReturn = pdFALSE;
 8017ce8:	2500      	movs	r5, #0
 8017cea:	e7e7      	b.n	8017cbc <xTaskCheckForTimeOut+0x44>
			xReturn = pdTRUE;
 8017cec:	2501      	movs	r5, #1
 8017cee:	e7e5      	b.n	8017cbc <xTaskCheckForTimeOut+0x44>
 8017cf0:	2000dec0 	.word	0x2000dec0

08017cf4 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 8017cf4:	4b02      	ldr	r3, [pc, #8]	; (8017d00 <vTaskMissedYield+0xc>)
 8017cf6:	2201      	movs	r2, #1
 8017cf8:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
}
 8017cfc:	4770      	bx	lr
 8017cfe:	bf00      	nop
 8017d00:	2000dec0 	.word	0x2000dec0

08017d04 <eTaskConfirmSleepModeStatus>:
		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
 8017d04:	4b09      	ldr	r3, [pc, #36]	; (8017d2c <eTaskConfirmSleepModeStatus+0x28>)
 8017d06:	f8d3 00e4 	ldr.w	r0, [r3, #228]	; 0xe4
 8017d0a:	b960      	cbnz	r0, 8017d26 <eTaskConfirmSleepModeStatus+0x22>
		else if( xYieldPending != pdFALSE )
 8017d0c:	f8d3 2128 	ldr.w	r2, [r3, #296]	; 0x128
 8017d10:	b952      	cbnz	r2, 8017d28 <eTaskConfirmSleepModeStatus+0x24>
			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
 8017d12:	f8d3 20b8 	ldr.w	r2, [r3, #184]	; 0xb8
 8017d16:	f8d3 00a0 	ldr.w	r0, [r3, #160]	; 0xa0
 8017d1a:	1e53      	subs	r3, r2, #1
				eReturn = eNoTasksWaitingTimeout;
 8017d1c:	4298      	cmp	r0, r3
 8017d1e:	bf14      	ite	ne
 8017d20:	2001      	movne	r0, #1
 8017d22:	2002      	moveq	r0, #2
 8017d24:	4770      	bx	lr
			eReturn = eAbortSleep;
 8017d26:	2000      	movs	r0, #0
	}
 8017d28:	4770      	bx	lr
 8017d2a:	bf00      	nop
 8017d2c:	2000dec0 	.word	0x2000dec0

08017d30 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8017d30:	4b06      	ldr	r3, [pc, #24]	; (8017d4c <xTaskGetSchedulerState+0x1c>)
 8017d32:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 8017d36:	b132      	cbz	r2, 8017d46 <xTaskGetSchedulerState+0x16>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8017d38:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 8017d3c:	2b00      	cmp	r3, #0
				xReturn = taskSCHEDULER_SUSPENDED;
 8017d3e:	bf0c      	ite	eq
 8017d40:	2002      	moveq	r0, #2
 8017d42:	2000      	movne	r0, #0
 8017d44:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 8017d46:	2001      	movs	r0, #1
	}
 8017d48:	4770      	bx	lr
 8017d4a:	bf00      	nop
 8017d4c:	2000dec0 	.word	0x2000dec0

08017d50 <vTaskPriorityInherit>:
		if( pxMutexHolder != NULL )
 8017d50:	b1d0      	cbz	r0, 8017d88 <vTaskPriorityInherit+0x38>
	{
 8017d52:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 8017d54:	4c1f      	ldr	r4, [pc, #124]	; (8017dd4 <vTaskPriorityInherit+0x84>)
 8017d56:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8017d58:	6862      	ldr	r2, [r4, #4]
 8017d5a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8017d5c:	4293      	cmp	r3, r2
 8017d5e:	d212      	bcs.n	8017d86 <vTaskPriorityInherit+0x36>
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8017d60:	6982      	ldr	r2, [r0, #24]
 8017d62:	2a00      	cmp	r2, #0
 8017d64:	db04      	blt.n	8017d70 <vTaskPriorityInherit+0x20>
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8017d66:	6862      	ldr	r2, [r4, #4]
 8017d68:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8017d6a:	f1c2 0207 	rsb	r2, r2, #7
 8017d6e:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8017d70:	4d19      	ldr	r5, [pc, #100]	; (8017dd8 <vTaskPriorityInherit+0x88>)
 8017d72:	6942      	ldr	r2, [r0, #20]
 8017d74:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8017d78:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8017d7c:	429a      	cmp	r2, r3
 8017d7e:	d004      	beq.n	8017d8a <vTaskPriorityInherit+0x3a>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8017d80:	6863      	ldr	r3, [r4, #4]
 8017d82:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017d84:	62c3      	str	r3, [r0, #44]	; 0x2c
	}
 8017d86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8017d88:	4770      	bx	lr
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8017d8a:	1d07      	adds	r7, r0, #4
 8017d8c:	4606      	mov	r6, r0
 8017d8e:	4638      	mov	r0, r7
 8017d90:	f7fe ff54 	bl	8016c3c <uxListRemove>
 8017d94:	b968      	cbnz	r0, 8017db2 <vTaskPriorityInherit+0x62>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8017d96:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8017d98:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 8017d9c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8017da0:	689b      	ldr	r3, [r3, #8]
 8017da2:	b933      	cbnz	r3, 8017db2 <vTaskPriorityInherit+0x62>
 8017da4:	6823      	ldr	r3, [r4, #0]
 8017da6:	2101      	movs	r1, #1
 8017da8:	fa01 f202 	lsl.w	r2, r1, r2
 8017dac:	ea23 0202 	bic.w	r2, r3, r2
 8017db0:	6022      	str	r2, [r4, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8017db2:	6863      	ldr	r3, [r4, #4]
					prvAddTaskToReadyList( pxTCB );
 8017db4:	6822      	ldr	r2, [r4, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8017db6:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8017db8:	62f0      	str	r0, [r6, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 8017dba:	2301      	movs	r3, #1
 8017dbc:	4083      	lsls	r3, r0
 8017dbe:	4313      	orrs	r3, r2
 8017dc0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8017dc4:	4639      	mov	r1, r7
 8017dc6:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 8017dca:	6023      	str	r3, [r4, #0]
	}
 8017dcc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
					prvAddTaskToReadyList( pxTCB );
 8017dd0:	f7fe bf0a 	b.w	8016be8 <vListInsertEnd>
 8017dd4:	2000dec0 	.word	0x2000dec0
 8017dd8:	2000dec8 	.word	0x2000dec8

08017ddc <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 8017ddc:	b168      	cbz	r0, 8017dfa <xTaskPriorityDisinherit+0x1e>
	{
 8017dde:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			configASSERT( pxTCB == pxCurrentTCB );
 8017de0:	4d25      	ldr	r5, [pc, #148]	; (8017e78 <xTaskPriorityDisinherit+0x9c>)
 8017de2:	686b      	ldr	r3, [r5, #4]
 8017de4:	4283      	cmp	r3, r0
 8017de6:	d00a      	beq.n	8017dfe <xTaskPriorityDisinherit+0x22>
 8017de8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017dec:	f383 8811 	msr	BASEPRI, r3
 8017df0:	f3bf 8f6f 	isb	sy
 8017df4:	f3bf 8f4f 	dsb	sy
 8017df8:	e7fe      	b.n	8017df8 <xTaskPriorityDisinherit+0x1c>
	BaseType_t xReturn = pdFALSE;
 8017dfa:	2000      	movs	r0, #0
	}
 8017dfc:	4770      	bx	lr
			configASSERT( pxTCB->uxMutexesHeld );
 8017dfe:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8017e00:	b943      	cbnz	r3, 8017e14 <xTaskPriorityDisinherit+0x38>
 8017e02:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017e06:	f383 8811 	msr	BASEPRI, r3
 8017e0a:	f3bf 8f6f 	isb	sy
 8017e0e:	f3bf 8f4f 	dsb	sy
 8017e12:	e7fe      	b.n	8017e12 <xTaskPriorityDisinherit+0x36>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8017e14:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8017e16:	6c42      	ldr	r2, [r0, #68]	; 0x44
			( pxTCB->uxMutexesHeld )--;
 8017e18:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8017e1a:	4291      	cmp	r1, r2
			( pxTCB->uxMutexesHeld )--;
 8017e1c:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8017e1e:	d000      	beq.n	8017e22 <xTaskPriorityDisinherit+0x46>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8017e20:	b10b      	cbz	r3, 8017e26 <xTaskPriorityDisinherit+0x4a>
	BaseType_t xReturn = pdFALSE;
 8017e22:	2000      	movs	r0, #0
	}
 8017e24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8017e26:	1d07      	adds	r7, r0, #4
 8017e28:	4604      	mov	r4, r0
 8017e2a:	4638      	mov	r0, r7
 8017e2c:	f7fe ff06 	bl	8016c3c <uxListRemove>
 8017e30:	b958      	cbnz	r0, 8017e4a <xTaskPriorityDisinherit+0x6e>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8017e32:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8017e34:	2314      	movs	r3, #20
 8017e36:	fb03 5301 	mla	r3, r3, r1, r5
 8017e3a:	689b      	ldr	r3, [r3, #8]
 8017e3c:	b92b      	cbnz	r3, 8017e4a <xTaskPriorityDisinherit+0x6e>
 8017e3e:	682b      	ldr	r3, [r5, #0]
 8017e40:	2201      	movs	r2, #1
 8017e42:	408a      	lsls	r2, r1
 8017e44:	ea23 0302 	bic.w	r3, r3, r2
 8017e48:	602b      	str	r3, [r5, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8017e4a:	6c63      	ldr	r3, [r4, #68]	; 0x44
					prvAddTaskToReadyList( pxTCB );
 8017e4c:	4a0b      	ldr	r2, [pc, #44]	; (8017e7c <xTaskPriorityDisinherit+0xa0>)
 8017e4e:	f8d5 c000 	ldr.w	ip, [r5]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8017e52:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 8017e54:	2601      	movs	r6, #1
 8017e56:	2014      	movs	r0, #20
 8017e58:	fb00 2003 	mla	r0, r0, r3, r2
 8017e5c:	fa06 f203 	lsl.w	r2, r6, r3
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8017e60:	f1c3 0307 	rsb	r3, r3, #7
					prvAddTaskToReadyList( pxTCB );
 8017e64:	ea42 020c 	orr.w	r2, r2, ip
 8017e68:	4639      	mov	r1, r7
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8017e6a:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8017e6c:	602a      	str	r2, [r5, #0]
 8017e6e:	f7fe febb 	bl	8016be8 <vListInsertEnd>
					xReturn = pdTRUE;
 8017e72:	4630      	mov	r0, r6
	}
 8017e74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8017e76:	bf00      	nop
 8017e78:	2000dec0 	.word	0x2000dec0
 8017e7c:	2000dec8 	.word	0x2000dec8

08017e80 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 8017e80:	4b04      	ldr	r3, [pc, #16]	; (8017e94 <pvTaskIncrementMutexHeldCount+0x14>)
 8017e82:	685a      	ldr	r2, [r3, #4]
 8017e84:	b11a      	cbz	r2, 8017e8e <pvTaskIncrementMutexHeldCount+0xe>
			( pxCurrentTCB->uxMutexesHeld )++;
 8017e86:	6859      	ldr	r1, [r3, #4]
 8017e88:	6c8a      	ldr	r2, [r1, #72]	; 0x48
 8017e8a:	3201      	adds	r2, #1
 8017e8c:	648a      	str	r2, [r1, #72]	; 0x48
		return pxCurrentTCB;
 8017e8e:	6858      	ldr	r0, [r3, #4]
	}
 8017e90:	4770      	bx	lr
 8017e92:	bf00      	nop
 8017e94:	2000dec0 	.word	0x2000dec0

08017e98 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 8017e98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 8017e9a:	4c11      	ldr	r4, [pc, #68]	; (8017ee0 <prvCheckForValidListAndQueue+0x48>)
	taskENTER_CRITICAL();
 8017e9c:	f7fe fd52 	bl	8016944 <vPortEnterCritical>
		if( xTimerQueue == NULL )
 8017ea0:	6825      	ldr	r5, [r4, #0]
 8017ea2:	b11d      	cbz	r5, 8017eac <prvCheckForValidListAndQueue+0x14>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
 8017ea4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	taskEXIT_CRITICAL();
 8017ea8:	f7fe bd6e 	b.w	8016988 <vPortExitCritical>
			vListInitialise( &xActiveTimerList1 );
 8017eac:	1d27      	adds	r7, r4, #4
 8017eae:	4638      	mov	r0, r7
			vListInitialise( &xActiveTimerList2 );
 8017eb0:	f104 0618 	add.w	r6, r4, #24
			vListInitialise( &xActiveTimerList1 );
 8017eb4:	f7fe fe88 	bl	8016bc8 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8017eb8:	4630      	mov	r0, r6
 8017eba:	f7fe fe85 	bl	8016bc8 <vListInitialise>
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8017ebe:	462a      	mov	r2, r5
 8017ec0:	210c      	movs	r1, #12
 8017ec2:	200a      	movs	r0, #10
			pxOverflowTimerList = &xActiveTimerList2;
 8017ec4:	e9c4 760b 	strd	r7, r6, [r4, #44]	; 0x2c
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8017ec8:	f7fe ffa8 	bl	8016e1c <xQueueGenericCreate>
 8017ecc:	6020      	str	r0, [r4, #0]
				if( xTimerQueue != NULL )
 8017ece:	2800      	cmp	r0, #0
 8017ed0:	d0e8      	beq.n	8017ea4 <prvCheckForValidListAndQueue+0xc>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 8017ed2:	4904      	ldr	r1, [pc, #16]	; (8017ee4 <prvCheckForValidListAndQueue+0x4c>)
 8017ed4:	f7ff fa90 	bl	80173f8 <vQueueAddToRegistry>
}
 8017ed8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	taskEXIT_CRITICAL();
 8017edc:	f7fe bd54 	b.w	8016988 <vPortExitCritical>
 8017ee0:	2000dfec 	.word	0x2000dfec
 8017ee4:	080754fc 	.word	0x080754fc

08017ee8 <prvInsertTimerInActiveList>:
	if( xNextExpiryTime <= xTimeNow )
 8017ee8:	4291      	cmp	r1, r2
{
 8017eea:	b508      	push	{r3, lr}
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8017eec:	6100      	str	r0, [r0, #16]
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8017eee:	6041      	str	r1, [r0, #4]
	if( xNextExpiryTime <= xTimeNow )
 8017ef0:	d805      	bhi.n	8017efe <prvInsertTimerInActiveList+0x16>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8017ef2:	6981      	ldr	r1, [r0, #24]
 8017ef4:	1ad2      	subs	r2, r2, r3
 8017ef6:	428a      	cmp	r2, r1
 8017ef8:	d30c      	bcc.n	8017f14 <prvInsertTimerInActiveList+0x2c>
			xProcessTimerNow = pdTRUE;
 8017efa:	2001      	movs	r0, #1
}
 8017efc:	bd08      	pop	{r3, pc}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8017efe:	429a      	cmp	r2, r3
 8017f00:	d201      	bcs.n	8017f06 <prvInsertTimerInActiveList+0x1e>
 8017f02:	4299      	cmp	r1, r3
 8017f04:	d2f9      	bcs.n	8017efa <prvInsertTimerInActiveList+0x12>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8017f06:	4b07      	ldr	r3, [pc, #28]	; (8017f24 <prvInsertTimerInActiveList+0x3c>)
 8017f08:	1d01      	adds	r1, r0, #4
 8017f0a:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8017f0c:	f7fe fe7c 	bl	8016c08 <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
 8017f10:	2000      	movs	r0, #0
}
 8017f12:	bd08      	pop	{r3, pc}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8017f14:	4b03      	ldr	r3, [pc, #12]	; (8017f24 <prvInsertTimerInActiveList+0x3c>)
 8017f16:	1d01      	adds	r1, r0, #4
 8017f18:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8017f1a:	f7fe fe75 	bl	8016c08 <vListInsert>
 8017f1e:	2000      	movs	r0, #0
}
 8017f20:	bd08      	pop	{r3, pc}
 8017f22:	bf00      	nop
 8017f24:	2000dfec 	.word	0x2000dfec

08017f28 <xTimerCreateTimerTask>:
{
 8017f28:	b500      	push	{lr}
 8017f2a:	b083      	sub	sp, #12
	prvCheckForValidListAndQueue();
 8017f2c:	f7ff ffb4 	bl	8017e98 <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
 8017f30:	4b0d      	ldr	r3, [pc, #52]	; (8017f68 <xTimerCreateTimerTask+0x40>)
 8017f32:	681a      	ldr	r2, [r3, #0]
 8017f34:	b15a      	cbz	r2, 8017f4e <xTimerCreateTimerTask+0x26>
			xReturn = xTaskCreate(	prvTimerTask,
 8017f36:	3334      	adds	r3, #52	; 0x34
 8017f38:	2202      	movs	r2, #2
 8017f3a:	e9cd 2300 	strd	r2, r3, [sp]
 8017f3e:	490b      	ldr	r1, [pc, #44]	; (8017f6c <xTimerCreateTimerTask+0x44>)
 8017f40:	480b      	ldr	r0, [pc, #44]	; (8017f70 <xTimerCreateTimerTask+0x48>)
 8017f42:	2300      	movs	r3, #0
 8017f44:	f44f 7280 	mov.w	r2, #256	; 0x100
 8017f48:	f7ff faee 	bl	8017528 <xTaskCreate>
	configASSERT( xReturn );
 8017f4c:	b940      	cbnz	r0, 8017f60 <xTimerCreateTimerTask+0x38>
 8017f4e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017f52:	f383 8811 	msr	BASEPRI, r3
 8017f56:	f3bf 8f6f 	isb	sy
 8017f5a:	f3bf 8f4f 	dsb	sy
 8017f5e:	e7fe      	b.n	8017f5e <xTimerCreateTimerTask+0x36>
}
 8017f60:	b003      	add	sp, #12
 8017f62:	f85d fb04 	ldr.w	pc, [sp], #4
 8017f66:	bf00      	nop
 8017f68:	2000dfec 	.word	0x2000dfec
 8017f6c:	08075504 	.word	0x08075504
 8017f70:	080180a5 	.word	0x080180a5

08017f74 <xTimerCreate>:
	{
 8017f74:	e92d 42f0 	stmdb	sp!, {r4, r5, r6, r7, r9, lr}
 8017f78:	4681      	mov	r9, r0
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 8017f7a:	2028      	movs	r0, #40	; 0x28
	{
 8017f7c:	460d      	mov	r5, r1
 8017f7e:	4616      	mov	r6, r2
 8017f80:	461f      	mov	r7, r3
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 8017f82:	f7fe fbcb 	bl	801671c <pvPortMalloc>
		if( pxNewTimer != NULL )
 8017f86:	4604      	mov	r4, r0
 8017f88:	b1a8      	cbz	r0, 8017fb6 <xTimerCreate+0x42>
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 8017f8a:	b945      	cbnz	r5, 8017f9e <xTimerCreate+0x2a>
 8017f8c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017f90:	f383 8811 	msr	BASEPRI, r3
 8017f94:	f3bf 8f6f 	isb	sy
 8017f98:	f3bf 8f4f 	dsb	sy
 8017f9c:	e7fe      	b.n	8017f9c <xTimerCreate+0x28>
		prvCheckForValidListAndQueue();
 8017f9e:	f7ff ff7b 	bl	8017e98 <prvCheckForValidListAndQueue>
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8017fa2:	9b06      	ldr	r3, [sp, #24]
		pxNewTimer->pcTimerName = pcTimerName;
 8017fa4:	f8c4 9000 	str.w	r9, [r4]
		pxNewTimer->uxAutoReload = uxAutoReload;
 8017fa8:	e9c4 5606 	strd	r5, r6, [r4, #24]
		pxNewTimer->pvTimerID = pvTimerID;
 8017fac:	6227      	str	r7, [r4, #32]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8017fae:	6263      	str	r3, [r4, #36]	; 0x24
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8017fb0:	1d20      	adds	r0, r4, #4
 8017fb2:	f7fe fe15 	bl	8016be0 <vListInitialiseItem>
	}
 8017fb6:	4620      	mov	r0, r4
 8017fb8:	e8bd 82f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, pc}

08017fbc <xTimerGenericCommand>:
	configASSERT( xTimer );
 8017fbc:	b1c0      	cbz	r0, 8017ff0 <xTimerGenericCommand+0x34>
{
 8017fbe:	b570      	push	{r4, r5, r6, lr}
	if( xTimerQueue != NULL )
 8017fc0:	4d16      	ldr	r5, [pc, #88]	; (801801c <xTimerGenericCommand+0x60>)
 8017fc2:	4604      	mov	r4, r0
 8017fc4:	6828      	ldr	r0, [r5, #0]
{
 8017fc6:	b084      	sub	sp, #16
	if( xTimerQueue != NULL )
 8017fc8:	b180      	cbz	r0, 8017fec <xTimerGenericCommand+0x30>
 8017fca:	4616      	mov	r6, r2
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8017fcc:	2905      	cmp	r1, #5
 8017fce:	461a      	mov	r2, r3
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8017fd0:	e9cd 1601 	strd	r1, r6, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 8017fd4:	9403      	str	r4, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8017fd6:	dc14      	bgt.n	8018002 <xTimerGenericCommand+0x46>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8017fd8:	f7ff feaa 	bl	8017d30 <xTaskGetSchedulerState>
 8017fdc:	2802      	cmp	r0, #2
 8017fde:	d016      	beq.n	801800e <xTimerGenericCommand+0x52>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8017fe0:	2300      	movs	r3, #0
 8017fe2:	6828      	ldr	r0, [r5, #0]
 8017fe4:	461a      	mov	r2, r3
 8017fe6:	a901      	add	r1, sp, #4
 8017fe8:	f7fe ff60 	bl	8016eac <xQueueGenericSend>
}
 8017fec:	b004      	add	sp, #16
 8017fee:	bd70      	pop	{r4, r5, r6, pc}
 8017ff0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8017ff4:	f383 8811 	msr	BASEPRI, r3
 8017ff8:	f3bf 8f6f 	isb	sy
 8017ffc:	f3bf 8f4f 	dsb	sy
 8018000:	e7fe      	b.n	8018000 <xTimerGenericCommand+0x44>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8018002:	2300      	movs	r3, #0
 8018004:	a901      	add	r1, sp, #4
 8018006:	f7ff f80f 	bl	8017028 <xQueueGenericSendFromISR>
}
 801800a:	b004      	add	sp, #16
 801800c:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 801800e:	6828      	ldr	r0, [r5, #0]
 8018010:	9a08      	ldr	r2, [sp, #32]
 8018012:	2300      	movs	r3, #0
 8018014:	a901      	add	r1, sp, #4
 8018016:	f7fe ff49 	bl	8016eac <xQueueGenericSend>
 801801a:	e7e7      	b.n	8017fec <xTimerGenericCommand+0x30>
 801801c:	2000dfec 	.word	0x2000dfec

08018020 <prvSwitchTimerLists>:
{
 8018020:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8018024:	4e1e      	ldr	r6, [pc, #120]	; (80180a0 <prvSwitchTimerLists+0x80>)
 8018026:	b083      	sub	sp, #12
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8018028:	f04f 0800 	mov.w	r8, #0
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 801802c:	e00d      	b.n	801804a <prvSwitchTimerLists+0x2a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 801802e:	68db      	ldr	r3, [r3, #12]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8018030:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8018032:	f8d3 9000 	ldr.w	r9, [r3]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8018036:	1d25      	adds	r5, r4, #4
 8018038:	4628      	mov	r0, r5
 801803a:	f7fe fdff 	bl	8016c3c <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 801803e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8018040:	4620      	mov	r0, r4
 8018042:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8018044:	69e3      	ldr	r3, [r4, #28]
 8018046:	2b01      	cmp	r3, #1
 8018048:	d009      	beq.n	801805e <prvSwitchTimerLists+0x3e>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 801804a:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 801804c:	681a      	ldr	r2, [r3, #0]
 801804e:	2a00      	cmp	r2, #0
 8018050:	d1ed      	bne.n	801802e <prvSwitchTimerLists+0xe>
	pxCurrentTimerList = pxOverflowTimerList;
 8018052:	6b32      	ldr	r2, [r6, #48]	; 0x30
	pxOverflowTimerList = pxTemp;
 8018054:	e9c6 230b 	strd	r2, r3, [r6, #44]	; 0x2c
}
 8018058:	b003      	add	sp, #12
 801805a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 801805e:	69a7      	ldr	r7, [r4, #24]
 8018060:	eb09 0c07 	add.w	ip, r9, r7
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8018064:	2300      	movs	r3, #0
			if( xReloadTime > xNextExpireTime )
 8018066:	45e1      	cmp	r9, ip
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8018068:	464a      	mov	r2, r9
 801806a:	4619      	mov	r1, r3
 801806c:	4620      	mov	r0, r4
			if( xReloadTime > xNextExpireTime )
 801806e:	d207      	bcs.n	8018080 <prvSwitchTimerLists+0x60>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8018070:	f8c4 c004 	str.w	ip, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8018074:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8018076:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 8018078:	4629      	mov	r1, r5
 801807a:	f7fe fdc5 	bl	8016c08 <vListInsert>
 801807e:	e7e4      	b.n	801804a <prvSwitchTimerLists+0x2a>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8018080:	f8cd 8000 	str.w	r8, [sp]
 8018084:	f7ff ff9a 	bl	8017fbc <xTimerGenericCommand>
				configASSERT( xResult );
 8018088:	2800      	cmp	r0, #0
 801808a:	d1de      	bne.n	801804a <prvSwitchTimerLists+0x2a>
 801808c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8018090:	f383 8811 	msr	BASEPRI, r3
 8018094:	f3bf 8f6f 	isb	sy
 8018098:	f3bf 8f4f 	dsb	sy
 801809c:	e7fe      	b.n	801809c <prvSwitchTimerLists+0x7c>
 801809e:	bf00      	nop
 80180a0:	2000dfec 	.word	0x2000dfec

080180a4 <prvTimerTask>:
{
 80180a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80180a8:	4c6a      	ldr	r4, [pc, #424]	; (8018254 <prvTimerTask+0x1b0>)
					portYIELD_WITHIN_API();
 80180aa:	4f6b      	ldr	r7, [pc, #428]	; (8018258 <prvTimerTask+0x1b4>)
{
 80180ac:	b087      	sub	sp, #28
 80180ae:	2601      	movs	r6, #1
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 80180b0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	if( *pxListWasEmpty == pdFALSE )
 80180b2:	681d      	ldr	r5, [r3, #0]
 80180b4:	2d00      	cmp	r5, #0
 80180b6:	d048      	beq.n	801814a <prvTimerTask+0xa6>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 80180b8:	68db      	ldr	r3, [r3, #12]
 80180ba:	681d      	ldr	r5, [r3, #0]
	vTaskSuspendAll();
 80180bc:	f7ff fb4a 	bl	8017754 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 80180c0:	f7ff fb52 	bl	8017768 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 80180c4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80180c6:	4283      	cmp	r3, r0
	xTimeNow = xTaskGetTickCount();
 80180c8:	4680      	mov	r8, r0
	if( xTimeNow < xLastTime )
 80180ca:	d84e      	bhi.n	801816a <prvTimerTask+0xc6>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 80180cc:	4285      	cmp	r5, r0
	xLastTime = xTimeNow;
 80180ce:	63a0      	str	r0, [r4, #56]	; 0x38
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 80180d0:	d955      	bls.n	801817e <prvTimerTask+0xda>
 80180d2:	2200      	movs	r2, #0
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 80180d4:	eba5 0108 	sub.w	r1, r5, r8
 80180d8:	6820      	ldr	r0, [r4, #0]
 80180da:	f7ff f9a1 	bl	8017420 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 80180de:	f7ff fbf1 	bl	80178c4 <xTaskResumeAll>
 80180e2:	b930      	cbnz	r0, 80180f2 <prvTimerTask+0x4e>
					portYIELD_WITHIN_API();
 80180e4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80180e8:	603b      	str	r3, [r7, #0]
 80180ea:	f3bf 8f4f 	dsb	sy
 80180ee:	f3bf 8f6f 	isb	sy
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 80180f2:	2300      	movs	r3, #0
 80180f4:	461a      	mov	r2, r3
 80180f6:	a903      	add	r1, sp, #12
 80180f8:	6820      	ldr	r0, [r4, #0]
 80180fa:	f7ff f851 	bl	80171a0 <xQueueGenericReceive>
 80180fe:	2800      	cmp	r0, #0
 8018100:	d0d6      	beq.n	80180b0 <prvTimerTask+0xc>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8018102:	9b03      	ldr	r3, [sp, #12]
 8018104:	2b00      	cmp	r3, #0
 8018106:	dbf4      	blt.n	80180f2 <prvTimerTask+0x4e>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8018108:	f8dd 8014 	ldr.w	r8, [sp, #20]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 801810c:	f8d8 3014 	ldr.w	r3, [r8, #20]
 8018110:	b11b      	cbz	r3, 801811a <prvTimerTask+0x76>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8018112:	f108 0004 	add.w	r0, r8, #4
 8018116:	f7fe fd91 	bl	8016c3c <uxListRemove>
	xTimeNow = xTaskGetTickCount();
 801811a:	f7ff fb25 	bl	8017768 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 801811e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8018120:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
 8018122:	4605      	mov	r5, r0
	if( xTimeNow < xLastTime )
 8018124:	d328      	bcc.n	8018178 <prvTimerTask+0xd4>
 8018126:	9b03      	ldr	r3, [sp, #12]
	xLastTime = xTimeNow;
 8018128:	63a5      	str	r5, [r4, #56]	; 0x38
 801812a:	2b09      	cmp	r3, #9
 801812c:	d8e1      	bhi.n	80180f2 <prvTimerTask+0x4e>
 801812e:	fa06 f303 	lsl.w	r3, r6, r3
 8018132:	f413 7904 	ands.w	r9, r3, #528	; 0x210
 8018136:	d15d      	bne.n	80181f4 <prvTimerTask+0x150>
 8018138:	f013 0fc7 	tst.w	r3, #199	; 0xc7
 801813c:	d132      	bne.n	80181a4 <prvTimerTask+0x100>
 801813e:	069b      	lsls	r3, r3, #26
 8018140:	d5d7      	bpl.n	80180f2 <prvTimerTask+0x4e>
						vPortFree( pxTimer );
 8018142:	4640      	mov	r0, r8
 8018144:	f7fe fb6a 	bl	801681c <vPortFree>
 8018148:	e7d3      	b.n	80180f2 <prvTimerTask+0x4e>
	vTaskSuspendAll();
 801814a:	f7ff fb03 	bl	8017754 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 801814e:	f7ff fb0b 	bl	8017768 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 8018152:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8018154:	4283      	cmp	r3, r0
	xTimeNow = xTaskGetTickCount();
 8018156:	4680      	mov	r8, r0
	if( xTimeNow < xLastTime )
 8018158:	d807      	bhi.n	801816a <prvTimerTask+0xc6>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 801815a:	6b23      	ldr	r3, [r4, #48]	; 0x30
	xLastTime = xTimeNow;
 801815c:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8018160:	681a      	ldr	r2, [r3, #0]
 8018162:	fab2 f282 	clz	r2, r2
 8018166:	0952      	lsrs	r2, r2, #5
 8018168:	e7b4      	b.n	80180d4 <prvTimerTask+0x30>
		prvSwitchTimerLists();
 801816a:	f7ff ff59 	bl	8018020 <prvSwitchTimerLists>
	xLastTime = xTimeNow;
 801816e:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
			( void ) xTaskResumeAll();
 8018172:	f7ff fba7 	bl	80178c4 <xTaskResumeAll>
 8018176:	e7bc      	b.n	80180f2 <prvTimerTask+0x4e>
		prvSwitchTimerLists();
 8018178:	f7ff ff52 	bl	8018020 <prvSwitchTimerLists>
 801817c:	e7d3      	b.n	8018126 <prvTimerTask+0x82>
				( void ) xTaskResumeAll();
 801817e:	f7ff fba1 	bl	80178c4 <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8018182:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8018184:	68db      	ldr	r3, [r3, #12]
 8018186:	f8d3 900c 	ldr.w	r9, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 801818a:	f109 0004 	add.w	r0, r9, #4
 801818e:	f7fe fd55 	bl	8016c3c <uxListRemove>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8018192:	f8d9 301c 	ldr.w	r3, [r9, #28]
 8018196:	2b01      	cmp	r3, #1
 8018198:	d037      	beq.n	801820a <prvTimerTask+0x166>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 801819a:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 801819e:	4648      	mov	r0, r9
 80181a0:	4798      	blx	r3
 80181a2:	e7a6      	b.n	80180f2 <prvTimerTask+0x4e>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 80181a4:	9b04      	ldr	r3, [sp, #16]
 80181a6:	f8d8 1018 	ldr.w	r1, [r8, #24]
 80181aa:	462a      	mov	r2, r5
 80181ac:	4419      	add	r1, r3
 80181ae:	4640      	mov	r0, r8
 80181b0:	f7ff fe9a 	bl	8017ee8 <prvInsertTimerInActiveList>
 80181b4:	2800      	cmp	r0, #0
 80181b6:	d09c      	beq.n	80180f2 <prvTimerTask+0x4e>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80181b8:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80181bc:	4640      	mov	r0, r8
 80181be:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 80181c0:	f8d8 301c 	ldr.w	r3, [r8, #28]
 80181c4:	2b01      	cmp	r3, #1
 80181c6:	d194      	bne.n	80180f2 <prvTimerTask+0x4e>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 80181c8:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80181cc:	9a04      	ldr	r2, [sp, #16]
 80181ce:	f8cd 9000 	str.w	r9, [sp]
 80181d2:	441a      	add	r2, r3
 80181d4:	4640      	mov	r0, r8
 80181d6:	464b      	mov	r3, r9
 80181d8:	4649      	mov	r1, r9
 80181da:	f7ff feef 	bl	8017fbc <xTimerGenericCommand>
							configASSERT( xResult );
 80181de:	2800      	cmp	r0, #0
 80181e0:	d187      	bne.n	80180f2 <prvTimerTask+0x4e>
 80181e2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80181e6:	f383 8811 	msr	BASEPRI, r3
 80181ea:	f3bf 8f6f 	isb	sy
 80181ee:	f3bf 8f4f 	dsb	sy
 80181f2:	e7fe      	b.n	80181f2 <prvTimerTask+0x14e>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 80181f4:	9904      	ldr	r1, [sp, #16]
 80181f6:	f8c8 1018 	str.w	r1, [r8, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 80181fa:	b311      	cbz	r1, 8018242 <prvTimerTask+0x19e>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 80181fc:	4429      	add	r1, r5
 80181fe:	4640      	mov	r0, r8
 8018200:	462b      	mov	r3, r5
 8018202:	462a      	mov	r2, r5
 8018204:	f7ff fe70 	bl	8017ee8 <prvInsertTimerInActiveList>
 8018208:	e773      	b.n	80180f2 <prvTimerTask+0x4e>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 801820a:	f8d9 1018 	ldr.w	r1, [r9, #24]
 801820e:	4642      	mov	r2, r8
 8018210:	4429      	add	r1, r5
 8018212:	462b      	mov	r3, r5
 8018214:	4648      	mov	r0, r9
 8018216:	f7ff fe67 	bl	8017ee8 <prvInsertTimerInActiveList>
 801821a:	2800      	cmp	r0, #0
 801821c:	d0bd      	beq.n	801819a <prvTimerTask+0xf6>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 801821e:	2300      	movs	r3, #0
 8018220:	462a      	mov	r2, r5
 8018222:	9300      	str	r3, [sp, #0]
 8018224:	4619      	mov	r1, r3
 8018226:	4648      	mov	r0, r9
 8018228:	f7ff fec8 	bl	8017fbc <xTimerGenericCommand>
			configASSERT( xResult );
 801822c:	2800      	cmp	r0, #0
 801822e:	d1b4      	bne.n	801819a <prvTimerTask+0xf6>
 8018230:	f04f 0350 	mov.w	r3, #80	; 0x50
 8018234:	f383 8811 	msr	BASEPRI, r3
 8018238:	f3bf 8f6f 	isb	sy
 801823c:	f3bf 8f4f 	dsb	sy
 8018240:	e7fe      	b.n	8018240 <prvTimerTask+0x19c>
 8018242:	f04f 0350 	mov.w	r3, #80	; 0x50
 8018246:	f383 8811 	msr	BASEPRI, r3
 801824a:	f3bf 8f6f 	isb	sy
 801824e:	f3bf 8f4f 	dsb	sy
 8018252:	e7fe      	b.n	8018252 <prvTimerTask+0x1ae>
 8018254:	2000dfec 	.word	0x2000dfec
 8018258:	e000ed04 	.word	0xe000ed04

0801825c <InitMetaDataManager>:
/**
  * @brief  Initialize the MetaData manager
  * @param  void *Ptr list to the couple of MetaData&MetaDataType
  * @retval None
  */
void InitMetaDataManager(void *Ptr,...) {
 801825c:	b40f      	push	{r0, r1, r2, r3}
 801825e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * @retval uint32_t Success/Not Success
 */
static uint32_t ReCallMetaDataManager(void)
{
  uint32_t Address = MDM_FLASH_ADD;
  __IO uint32_t data32 = *(__IO uint32_t*) Address;
 8018262:	4bb4      	ldr	r3, [pc, #720]	; (8018534 <InitMetaDataManager+0x2d8>)
  puint8_RW_MetaData = ((uint8_t *) uint64_MetaDataVector)+8;
 8018264:	4fb4      	ldr	r7, [pc, #720]	; (8018538 <InitMetaDataManager+0x2dc>)
  __IO uint32_t data32 = *(__IO uint32_t*) Address;
 8018266:	681b      	ldr	r3, [r3, #0]
  puint8_RW_MetaData = ((uint8_t *) uint64_MetaDataVector)+8;
 8018268:	49b4      	ldr	r1, [pc, #720]	; (801853c <InitMetaDataManager+0x2e0>)
 801826a:	6039      	str	r1, [r7, #0]
void InitMetaDataManager(void *Ptr,...) {
 801826c:	b087      	sub	sp, #28
  __IO uint32_t data32 = *(__IO uint32_t*) Address;
 801826e:	9305      	str	r3, [sp, #20]
  uint32_t RetValue=0;

  if(data32== MDM_VALID_META_DATA_MANAGER){
 8018270:	9a05      	ldr	r2, [sp, #20]
 8018272:	4bb3      	ldr	r3, [pc, #716]	; (8018540 <InitMetaDataManager+0x2e4>)
void InitMetaDataManager(void *Ptr,...) {
 8018274:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
  if(data32== MDM_VALID_META_DATA_MANAGER){
 8018278:	429a      	cmp	r2, r3
 801827a:	f000 8169 	beq.w	8018550 <InitMetaDataManager+0x2f4>
 801827e:	f1a1 0308 	sub.w	r3, r1, #8
 8018282:	9303      	str	r3, [sp, #12]
  MDM_OsxLicenseType_t osxLic;
  MDM_GenericMetaDataType_t GMD;

  NecessityToSaveMetaDataManager=1;
  puint8_RW_MetaData = ((uint8_t *) uint64_MetaDataVector)+8;
  pMetaDataManagerHeader->IsIntialized = MDM_VALID_META_DATA_MANAGER;
 8018284:	9c03      	ldr	r4, [sp, #12]
  NecessityToSaveMetaDataManager=1;
 8018286:	49af      	ldr	r1, [pc, #700]	; (8018544 <InitMetaDataManager+0x2e8>)
  pMetaDataManagerHeader->IsIntialized = MDM_VALID_META_DATA_MANAGER;
 8018288:	4aad      	ldr	r2, [pc, #692]	; (8018540 <InitMetaDataManager+0x2e4>)
 801828a:	4baf      	ldr	r3, [pc, #700]	; (8018548 <InitMetaDataManager+0x2ec>)
 801828c:	6022      	str	r2, [r4, #0]
  NecessityToSaveMetaDataManager=1;
 801828e:	2001      	movs	r0, #1
  pMetaDataManagerHeader->Version = MDM_VERSION;
 8018290:	f44f 6240 	mov.w	r2, #3072	; 0xc00
  NecessityToSaveMetaDataManager=1;
 8018294:	6008      	str	r0, [r1, #0]
  pMetaDataManagerHeader->Version = MDM_VERSION;
 8018296:	6062      	str	r2, [r4, #4]
  /* add the MetaData Teminitation */
  *((uint32_t *) puint8_RW_MetaData)     = MDM_DATA_TYPE_END;
 8018298:	20ff      	movs	r0, #255	; 0xff
  *((uint32_t *) (puint8_RW_MetaData+4)) = 0; /* No Payload */
 801829a:	2200      	movs	r2, #0
 801829c:	f503 7190 	add.w	r1, r3, #288	; 0x120
  *((uint32_t *) puint8_RW_MetaData)     = MDM_DATA_TYPE_END;
 80182a0:	60a0      	str	r0, [r4, #8]
  *((uint32_t *) (puint8_RW_MetaData+4)) = 0; /* No Payload */
 80182a2:	60e2      	str	r2, [r4, #12]

  /* Reset all the Payload pointers */
  for(osxLic=OSX_MOTION_FX;osxLic<OSX_LICENSE_NUM;osxLic++) {
    MDM_LicTable[osxLic].Address =0;
 80182a4:	63da      	str	r2, [r3, #60]	; 0x3c
 80182a6:	3320      	adds	r3, #32
  for(osxLic=OSX_MOTION_FX;osxLic<OSX_LICENSE_NUM;osxLic++) {
 80182a8:	428b      	cmp	r3, r1
 80182aa:	d1fb      	bne.n	80182a4 <InitMetaDataManager+0x48>
 80182ac:	4ba7      	ldr	r3, [pc, #668]	; (801854c <InitMetaDataManager+0x2f0>)
  }
  for(GMD=GMD_WIFI;GMD<GMD_NUM;GMD++){
    MDM_GMDTable[GMD].Address =0;
 80182ae:	2100      	movs	r1, #0
 80182b0:	f503 729a 	add.w	r2, r3, #308	; 0x134
 80182b4:	6359      	str	r1, [r3, #52]	; 0x34
 80182b6:	331c      	adds	r3, #28
  for(GMD=GMD_WIFI;GMD<GMD_NUM;GMD++){
 80182b8:	4293      	cmp	r3, r2
 80182ba:	d1fb      	bne.n	80182b4 <InitMetaDataManager+0x58>
  va_start (ap, Ptr);
 80182bc:	ab11      	add	r3, sp, #68	; 0x44
 80182be:	9304      	str	r3, [sp, #16]
  while(KnownMetaDataTable!=NULL) {
 80182c0:	f1bc 0f00 	cmp.w	ip, #0
 80182c4:	d051      	beq.n	801836a <InitMetaDataManager+0x10e>
 80182c6:	f04f 0a00 	mov.w	sl, #0
 80182ca:	ab13      	add	r3, sp, #76	; 0x4c
 80182cc:	f8df b274 	ldr.w	fp, [pc, #628]	; 8018544 <InitMetaDataManager+0x2e8>
 80182d0:	9300      	str	r3, [sp, #0]
 80182d2:	46d0      	mov	r8, sl
    switch(MetaDataType) {
 80182d4:	9b00      	ldr	r3, [sp, #0]
 80182d6:	f813 2c08 	ldrb.w	r2, [r3, #-8]
 80182da:	9202      	str	r2, [sp, #8]
    MDM_MetaDataType_t  MetaDataType = (MDM_MetaDataType_t) va_arg(ap,int);
 80182dc:	3b04      	subs	r3, #4
 80182de:	9304      	str	r3, [sp, #16]
    switch(MetaDataType) {
 80182e0:	2a00      	cmp	r2, #0
 80182e2:	f000 8117 	beq.w	8018514 <InitMetaDataManager+0x2b8>
 80182e6:	2a01      	cmp	r2, #1
 80182e8:	d147      	bne.n	801837a <InitMetaDataManager+0x11e>
        for(Index =0; known_GMD[Index].GMDType!=GMD_END ;Index++) {
 80182ea:	f89c 3000 	ldrb.w	r3, [ip]
 80182ee:	2b00      	cmp	r3, #0
 80182f0:	f000 81c6 	beq.w	8018680 <InitMetaDataManager+0x424>
 80182f4:	f8db 1008 	ldr.w	r1, [fp, #8]
 80182f8:	ebc1 7041 	rsb	r0, r1, r1, lsl #29
 80182fc:	00c0      	lsls	r0, r0, #3
 80182fe:	3101      	adds	r1, #1
 8018300:	e000      	b.n	8018304 <InitMetaDataManager+0xa8>
 8018302:	4611      	mov	r1, r2
 8018304:	1c4a      	adds	r2, r1, #1
 8018306:	eb00 03c2 	add.w	r3, r0, r2, lsl #3
 801830a:	4463      	add	r3, ip
 801830c:	f813 3c08 	ldrb.w	r3, [r3, #-8]
 8018310:	2b00      	cmp	r3, #0
 8018312:	d1f6      	bne.n	8018302 <InitMetaDataManager+0xa6>
 8018314:	4665      	mov	r5, ip
 8018316:	f8cb 1008 	str.w	r1, [fp, #8]
    MDM_knownOsxLicense_t *known_OsxLic=NULL;
 801831a:	469c      	mov	ip, r3
    while(pMetaDataHeader->Type!=MDM_DATA_TYPE_END) {
 801831c:	9b03      	ldr	r3, [sp, #12]
 801831e:	689a      	ldr	r2, [r3, #8]
 8018320:	2aff      	cmp	r2, #255	; 0xff
 8018322:	d011      	beq.n	8018348 <InitMetaDataManager+0xec>
        for(Index =0; ((Index<NumberOfKnownGMD) & (found==0));Index++) {
 8018324:	e9db 9e01 	ldrd	r9, lr, [fp, #4]
 8018328:	eb09 0649 	add.w	r6, r9, r9, lsl #1
 801832c:	ebc6 1606 	rsb	r6, r6, r6, lsl #4
    pMetaDataHeader = (MDM_MetaDataHeader_t *) pMetaDataManagerHeader->puint8_MetaData;
 8018330:	4b82      	ldr	r3, [pc, #520]	; (801853c <InitMetaDataManager+0x2e0>)
 8018332:	f8cd 9004 	str.w	r9, [sp, #4]
 8018336:	4466      	add	r6, ip
      if(pMetaDataHeader->Type == MDM_DATA_TYPE_LIC) {
 8018338:	b322      	cbz	r2, 8018384 <InitMetaDataManager+0x128>
      } else if(pMetaDataHeader->Type == MDM_DATA_TYPE_GMD) {
 801833a:	2a01      	cmp	r2, #1
 801833c:	d03b      	beq.n	80183b6 <InitMetaDataManager+0x15a>
      pMetaDataHeader = (MDM_MetaDataHeader_t *) (((uint32_t) pMetaDataHeader)+pMetaDataHeader->Lenght);
 801833e:	685a      	ldr	r2, [r3, #4]
 8018340:	4413      	add	r3, r2
    while(pMetaDataHeader->Type!=MDM_DATA_TYPE_END) {
 8018342:	681a      	ldr	r2, [r3, #0]
 8018344:	2aff      	cmp	r2, #255	; 0xff
 8018346:	d1f7      	bne.n	8018338 <InitMetaDataManager+0xdc>
    if(MetaDataType==MDM_DATA_TYPE_LIC) {
 8018348:	9b02      	ldr	r3, [sp, #8]
 801834a:	2b00      	cmp	r3, #0
 801834c:	d17d      	bne.n	801844a <InitMetaDataManager+0x1ee>
      if(NumberofFoundedLic<NumberOfKnownLic) {
 801834e:	f8db 2004 	ldr.w	r2, [fp, #4]
 8018352:	4542      	cmp	r2, r8
 8018354:	f200 8141 	bhi.w	80185da <InitMetaDataManager+0x37e>
    KnownMetaDataTable= va_arg(ap,void *);
 8018358:	9b00      	ldr	r3, [sp, #0]
 801835a:	9304      	str	r3, [sp, #16]
 801835c:	3308      	adds	r3, #8
 801835e:	f853 cc0c 	ldr.w	ip, [r3, #-12]
 8018362:	9300      	str	r3, [sp, #0]
  while(KnownMetaDataTable!=NULL) {
 8018364:	f1bc 0f00 	cmp.w	ip, #0
 8018368:	d1b4      	bne.n	80182d4 <InitMetaDataManager+0x78>
  if(NecessityToSaveMetaDataManager) {
 801836a:	4c76      	ldr	r4, [pc, #472]	; (8018544 <InitMetaDataManager+0x2e8>)
 801836c:	6823      	ldr	r3, [r4, #0]
 801836e:	b123      	cbz	r3, 801837a <InitMetaDataManager+0x11e>
 * @brief Erase the Meta Data Manager in FLASH
 * @param uint32_t Success/NotSuccess [1/0]
 * @retval None
 */
uint32_t EraseMetaDataManager(void) {
  uint32_t Success = UserFunctionForErasingFlash();
 8018370:	f002 fa48 	bl	801a804 <UserFunctionForErasingFlash>
    if(Success) {
 8018374:	2800      	cmp	r0, #0
 8018376:	f040 8188 	bne.w	801868a <InitMetaDataManager+0x42e>
}
 801837a:	b007      	add	sp, #28
 801837c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018380:	b004      	add	sp, #16
 8018382:	4770      	bx	lr
        for(Index =0; ((Index<NumberOfKnownLic) & (found==0));Index++) {
 8018384:	9a01      	ldr	r2, [sp, #4]
        MDM_PayLoadLic_t *PayLoad = (MDM_PayLoadLic_t *) pMetaDataHeader->puint8_PayLoad;
 8018386:	f103 0008 	add.w	r0, r3, #8
        for(Index =0; ((Index<NumberOfKnownLic) & (found==0));Index++) {
 801838a:	2a00      	cmp	r2, #0
 801838c:	d0d7      	beq.n	801833e <InitMetaDataManager+0xe2>
          if(known_OsxLic[Index].LicEnum==PayLoad->LicEnum) {
 801838e:	4662      	mov	r2, ip
 8018390:	6899      	ldr	r1, [r3, #8]
 8018392:	7814      	ldrb	r4, [r2, #0]
 8018394:	428c      	cmp	r4, r1
 8018396:	f102 022d 	add.w	r2, r2, #45	; 0x2d
 801839a:	d006      	beq.n	80183aa <InitMetaDataManager+0x14e>
        for(Index =0; ((Index<NumberOfKnownLic) & (found==0));Index++) {
 801839c:	42b2      	cmp	r2, r6
 801839e:	d0ce      	beq.n	801833e <InitMetaDataManager+0xe2>
          if(known_OsxLic[Index].LicEnum==PayLoad->LicEnum) {
 80183a0:	7814      	ldrb	r4, [r2, #0]
 80183a2:	428c      	cmp	r4, r1
 80183a4:	f102 022d 	add.w	r2, r2, #45	; 0x2d
 80183a8:	d1f8      	bne.n	801839c <InitMetaDataManager+0x140>
            MDM_LicTable[PayLoad->LicEnum].Address = (uint32_t)PayLoad;
 80183aa:	eb07 1141 	add.w	r1, r7, r1, lsl #5
            NumberofFoundedLic++;
 80183ae:	f108 0801 	add.w	r8, r8, #1
            MDM_LicTable[PayLoad->LicEnum].Address = (uint32_t)PayLoad;
 80183b2:	6208      	str	r0, [r1, #32]
 80183b4:	e7c3      	b.n	801833e <InitMetaDataManager+0xe2>
        MDM_PayLoadGMD_t *PayLoad = (MDM_PayLoadGMD_t *) pMetaDataHeader->puint8_PayLoad;
 80183b6:	f103 0908 	add.w	r9, r3, #8
        for(Index =0; ((Index<NumberOfKnownGMD) & (found==0));Index++) {
 80183ba:	f1be 0f00 	cmp.w	lr, #0
 80183be:	d0be      	beq.n	801833e <InitMetaDataManager+0xe2>
 80183c0:	2200      	movs	r2, #0
          if(known_GMD[Index].GMDType==PayLoad->GMDTypeEnum) {
 80183c2:	6899      	ldr	r1, [r3, #8]
 80183c4:	f815 0032 	ldrb.w	r0, [r5, r2, lsl #3]
 80183c8:	4288      	cmp	r0, r1
 80183ca:	462c      	mov	r4, r5
        for(Index =0; ((Index<NumberOfKnownGMD) & (found==0));Index++) {
 80183cc:	f102 0201 	add.w	r2, r2, #1
          if(known_GMD[Index].GMDType==PayLoad->GMDTypeEnum) {
 80183d0:	d009      	beq.n	80183e6 <InitMetaDataManager+0x18a>
        for(Index =0; ((Index<NumberOfKnownGMD) & (found==0));Index++) {
 80183d2:	4572      	cmp	r2, lr
 80183d4:	f104 0408 	add.w	r4, r4, #8
 80183d8:	d0b1      	beq.n	801833e <InitMetaDataManager+0xe2>
          if(known_GMD[Index].GMDType==PayLoad->GMDTypeEnum) {
 80183da:	f815 0032 	ldrb.w	r0, [r5, r2, lsl #3]
 80183de:	4288      	cmp	r0, r1
        for(Index =0; ((Index<NumberOfKnownGMD) & (found==0));Index++) {
 80183e0:	f102 0201 	add.w	r2, r2, #1
          if(known_GMD[Index].GMDType==PayLoad->GMDTypeEnum) {
 80183e4:	d1f5      	bne.n	80183d2 <InitMetaDataManager+0x176>
            if(known_GMD[Index].GMDSize!=PayLoad->GMDSize) {
 80183e6:	6860      	ldr	r0, [r4, #4]
            MDM_GMDTable[PayLoad->GMDTypeEnum].GMDSize = PayLoad->GMDSize;
 80183e8:	68da      	ldr	r2, [r3, #12]
            MDM_GMDTable[PayLoad->GMDTypeEnum].Address = (uint32_t)PayLoad;
 80183ea:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 80183ee:	eb07 0181 	add.w	r1, r7, r1, lsl #2
            if(known_GMD[Index].GMDSize!=PayLoad->GMDSize) {
 80183f2:	4282      	cmp	r2, r0
            MDM_GMDTable[PayLoad->GMDTypeEnum].Address = (uint32_t)PayLoad;
 80183f4:	f8c1 915c 	str.w	r9, [r1, #348]	; 0x15c
            NumberofFoundedGMD++;
 80183f8:	f10a 0a01 	add.w	sl, sl, #1
            MDM_GMDTable[PayLoad->GMDTypeEnum].GMDSize = PayLoad->GMDSize;
 80183fc:	f8c1 2158 	str.w	r2, [r1, #344]	; 0x158
            if(known_GMD[Index].GMDSize!=PayLoad->GMDSize) {
 8018400:	d09d      	beq.n	801833e <InitMetaDataManager+0xe2>
  puint8_RW_MetaData = ((uint8_t *) uint64_MetaDataVector)+8;
 8018402:	4c4e      	ldr	r4, [pc, #312]	; (801853c <InitMetaDataManager+0x2e0>)
 8018404:	603c      	str	r4, [r7, #0]
  NecessityToSaveMetaDataManager=1;
 8018406:	2301      	movs	r3, #1
  pMetaDataManagerHeader->IsIntialized = MDM_VALID_META_DATA_MANAGER;
 8018408:	9c03      	ldr	r4, [sp, #12]
 801840a:	4e4d      	ldr	r6, [pc, #308]	; (8018540 <InitMetaDataManager+0x2e4>)
  NecessityToSaveMetaDataManager=1;
 801840c:	f8cb 3000 	str.w	r3, [fp]
  *((uint32_t *) puint8_RW_MetaData)     = MDM_DATA_TYPE_END;
 8018410:	21ff      	movs	r1, #255	; 0xff
  pMetaDataManagerHeader->Version = MDM_VERSION;
 8018412:	f44f 6040 	mov.w	r0, #3072	; 0xc00
  *((uint32_t *) (puint8_RW_MetaData+4)) = 0; /* No Payload */
 8018416:	2200      	movs	r2, #0
 8018418:	4b4b      	ldr	r3, [pc, #300]	; (8018548 <InitMetaDataManager+0x2ec>)
  *((uint32_t *) puint8_RW_MetaData)     = MDM_DATA_TYPE_END;
 801841a:	60a1      	str	r1, [r4, #8]
  pMetaDataManagerHeader->IsIntialized = MDM_VALID_META_DATA_MANAGER;
 801841c:	6026      	str	r6, [r4, #0]
  pMetaDataManagerHeader->Version = MDM_VERSION;
 801841e:	6060      	str	r0, [r4, #4]
  *((uint32_t *) (puint8_RW_MetaData+4)) = 0; /* No Payload */
 8018420:	60e2      	str	r2, [r4, #12]
 8018422:	f507 7192 	add.w	r1, r7, #292	; 0x124
    MDM_LicTable[osxLic].Address =0;
 8018426:	63da      	str	r2, [r3, #60]	; 0x3c
 8018428:	3320      	adds	r3, #32
  for(osxLic=OSX_MOTION_FX;osxLic<OSX_LICENSE_NUM;osxLic++) {
 801842a:	428b      	cmp	r3, r1
 801842c:	d1fb      	bne.n	8018426 <InitMetaDataManager+0x1ca>
 801842e:	4b47      	ldr	r3, [pc, #284]	; (801854c <InitMetaDataManager+0x2f0>)
    MDM_GMDTable[GMD].Address =0;
 8018430:	2100      	movs	r1, #0
 8018432:	f503 729a 	add.w	r2, r3, #308	; 0x134
 8018436:	6359      	str	r1, [r3, #52]	; 0x34
 8018438:	331c      	adds	r3, #28
  for(GMD=GMD_WIFI;GMD<GMD_NUM;GMD++){
 801843a:	429a      	cmp	r2, r3
 801843c:	d1fb      	bne.n	8018436 <InitMetaDataManager+0x1da>
    if(MetaDataType==MDM_DATA_TYPE_LIC) {
 801843e:	9b02      	ldr	r3, [sp, #8]
              NumberofFoundedGMD=0;
 8018440:	f04f 0a00 	mov.w	sl, #0
              NumberofFoundedLic=0;
 8018444:	46d0      	mov	r8, sl
    if(MetaDataType==MDM_DATA_TYPE_LIC) {
 8018446:	2b00      	cmp	r3, #0
 8018448:	d081      	beq.n	801834e <InitMetaDataManager+0xf2>
    } else if(MetaDataType==MDM_DATA_TYPE_GMD){
 801844a:	9b02      	ldr	r3, [sp, #8]
 801844c:	2b01      	cmp	r3, #1
 801844e:	d183      	bne.n	8018358 <InitMetaDataManager+0xfc>
      if(NumberofFoundedGMD<NumberOfKnownGMD) {
 8018450:	f8db 0008 	ldr.w	r0, [fp, #8]
 8018454:	4550      	cmp	r0, sl
 8018456:	f67f af7f 	bls.w	8018358 <InitMetaDataManager+0xfc>
 801845a:	f8d7 9000 	ldr.w	r9, [r7]
        NecessityToSaveMetaDataManager = 1;
 801845e:	f8cb 3000 	str.w	r3, [fp]
 8018462:	9b03      	ldr	r3, [sp, #12]
 8018464:	eba9 0303 	sub.w	r3, r9, r3
 8018468:	3308      	adds	r3, #8
 801846a:	9301      	str	r3, [sp, #4]
        for(Index =0; Index<NumberOfKnownGMD ;Index++) {
 801846c:	2800      	cmp	r0, #0
 801846e:	f000 8114 	beq.w	801869a <InitMetaDataManager+0x43e>
 8018472:	ea4f 0cc0 	mov.w	ip, r0, lsl #3
 8018476:	f10c 0404 	add.w	r4, ip, #4
 801847a:	f105 0e04 	add.w	lr, r5, #4
 801847e:	442c      	add	r4, r5
 8018480:	4672      	mov	r2, lr
        uint32_t HowManyExtraSpaceINeed =0;
 8018482:	2600      	movs	r6, #0
          if(MDM_GMDTable[known_GMD[Index].GMDType].Address==0) {
 8018484:	f812 3c04 	ldrb.w	r3, [r2, #-4]
 8018488:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 801848c:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 8018490:	f106 0110 	add.w	r1, r6, #16
 8018494:	f8d3 315c 	ldr.w	r3, [r3, #348]	; 0x15c
 8018498:	b923      	cbnz	r3, 80184a4 <InitMetaDataManager+0x248>
            HowManyExtraSpaceINeed += (((known_GMD[Index].GMDSize+7)>>3)<<3) /* Round to Multiple of 8 bytes */ + 
 801849a:	6813      	ldr	r3, [r2, #0]
 801849c:	1dde      	adds	r6, r3, #7
 801849e:	f026 0607 	bic.w	r6, r6, #7
 80184a2:	440e      	add	r6, r1
 80184a4:	3208      	adds	r2, #8
        for(Index =0; Index<NumberOfKnownGMD ;Index++) {
 80184a6:	42a2      	cmp	r2, r4
 80184a8:	d1ec      	bne.n	8018484 <InitMetaDataManager+0x228>
             ((uint32_t)uint64_MetaDataVector) +
 80184aa:	9b01      	ldr	r3, [sp, #4]
 80184ac:	441e      	add	r6, r3
        if(((((uint32_t) puint8_RW_MetaData)+8/* for the MDM_DATA_TYPE_END */) -
 80184ae:	f5b6 5f80 	cmp.w	r6, #4096	; 0x1000
 80184b2:	f200 80f7 	bhi.w	80186a4 <InitMetaDataManager+0x448>
 80184b6:	f10c 0c04 	add.w	ip, ip, #4
 80184ba:	4465      	add	r5, ip
 80184bc:	4672      	mov	r2, lr
          NumberofFoundedGMD = 0;
 80184be:	4648      	mov	r0, r9
 80184c0:	2100      	movs	r1, #0
            pMetaDataHeader->Type = MDM_DATA_TYPE_GMD;
 80184c2:	f04f 0e01 	mov.w	lr, #1
 80184c6:	46ac      	mov	ip, r5
          if(MDM_GMDTable[known_GMD[Index].GMDType].Address==0) {
 80184c8:	f812 4c04 	ldrb.w	r4, [r2, #-4]
 80184cc:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 80184d0:	eb07 0383 	add.w	r3, r7, r3, lsl #2
            PayLoad = (MDM_PayLoadGMD_t *) pMetaDataHeader->puint8_PayLoad;
 80184d4:	f100 0508 	add.w	r5, r0, #8
          if(MDM_GMDTable[known_GMD[Index].GMDType].Address==0) {
 80184d8:	f8d3 615c 	ldr.w	r6, [r3, #348]	; 0x15c
 80184dc:	b97e      	cbnz	r6, 80184fe <InitMetaDataManager+0x2a2>
            pMetaDataHeader->Type = MDM_DATA_TYPE_GMD;
 80184de:	f8c0 e000 	str.w	lr, [r0]
            pMetaDataHeader->Lenght = (((known_GMD[Index].GMDSize+7)>>3)<<3) /* Round to Multiple of 8 bytes */ + 
 80184e2:	6816      	ldr	r6, [r2, #0]
            PayLoad->GMDSize     = known_GMD[Index].GMDSize;
 80184e4:	60c6      	str	r6, [r0, #12]
            pMetaDataHeader->Lenght = (((known_GMD[Index].GMDSize+7)>>3)<<3) /* Round to Multiple of 8 bytes */ + 
 80184e6:	1df1      	adds	r1, r6, #7
 80184e8:	f021 0107 	bic.w	r1, r1, #7
              8 + 8 /* For Meta Data Header */;
 80184ec:	3110      	adds	r1, #16
            pMetaDataHeader->Lenght = (((known_GMD[Index].GMDSize+7)>>3)<<3) /* Round to Multiple of 8 bytes */ + 
 80184ee:	e9c0 1401 	strd	r1, r4, [r0, #4]
            puint8_RW_MetaData +=pMetaDataHeader->Lenght;
 80184f2:	4408      	add	r0, r1
            MDM_GMDTable[known_GMD[Index].GMDType].GMDSize = PayLoad->GMDSize;
 80184f4:	f8c3 6158 	str.w	r6, [r3, #344]	; 0x158
            MDM_GMDTable[known_GMD[Index].GMDType].Address = (uint32_t)PayLoad;
 80184f8:	f8c3 515c 	str.w	r5, [r3, #348]	; 0x15c
            puint8_RW_MetaData +=pMetaDataHeader->Lenght;
 80184fc:	2101      	movs	r1, #1
 80184fe:	3208      	adds	r2, #8
        for(Index=0;Index<NumberOfKnownGMD; Index++) {
 8018500:	4562      	cmp	r2, ip
 8018502:	d1e1      	bne.n	80184c8 <InitMetaDataManager+0x26c>
 8018504:	2900      	cmp	r1, #0
 8018506:	f040 80e9 	bne.w	80186dc <InitMetaDataManager+0x480>
        *((uint32_t *) (puint8_RW_MetaData+4)) = 0; /* No Payload */
 801850a:	22ff      	movs	r2, #255	; 0xff
 801850c:	2300      	movs	r3, #0
 801850e:	e9c9 2300 	strd	r2, r3, [r9]
 8018512:	e721      	b.n	8018358 <InitMetaDataManager+0xfc>
        for(Index =0; known_OsxLic[Index].LicEnum!=OSX_END ;Index++) {
 8018514:	f89c 3000 	ldrb.w	r3, [ip]
 8018518:	2b00      	cmp	r3, #0
 801851a:	f000 80b4 	beq.w	8018686 <InitMetaDataManager+0x42a>
 801851e:	f8db 3004 	ldr.w	r3, [fp, #4]
 8018522:	4662      	mov	r2, ip
 8018524:	f812 5f2d 	ldrb.w	r5, [r2, #45]!
          NumberOfKnownLic++;
 8018528:	3301      	adds	r3, #1
        for(Index =0; known_OsxLic[Index].LicEnum!=OSX_END ;Index++) {
 801852a:	2d00      	cmp	r5, #0
 801852c:	d1fa      	bne.n	8018524 <InitMetaDataManager+0x2c8>
 801852e:	f8cb 3004 	str.w	r3, [fp, #4]
 8018532:	e6f3      	b.n	801831c <InitMetaDataManager+0xc0>
 8018534:	080ff000 	.word	0x080ff000
 8018538:	200011dc 	.word	0x200011dc
 801853c:	2000e078 	.word	0x2000e078
 8018540:	12345678 	.word	0x12345678
 8018544:	2000e028 	.word	0x2000e028
 8018548:	200011e0 	.word	0x200011e0
 801854c:	20001320 	.word	0x20001320
    pMetaDataManagerHeader->IsIntialized = data32;
 8018550:	4964      	ldr	r1, [pc, #400]	; (80186e4 <InitMetaDataManager+0x488>)
 8018552:	9a05      	ldr	r2, [sp, #20]
    data32 = *(__IO uint32_t*) Address;
 8018554:	4b64      	ldr	r3, [pc, #400]	; (80186e8 <InitMetaDataManager+0x48c>)
    pMetaDataManagerHeader->IsIntialized = data32;
 8018556:	f841 2c08 	str.w	r2, [r1, #-8]
    data32 = *(__IO uint32_t*) Address;
 801855a:	681b      	ldr	r3, [r3, #0]
 801855c:	9305      	str	r3, [sp, #20]
    pMetaDataManagerHeader->Version = data32;
 801855e:	9b05      	ldr	r3, [sp, #20]
 8018560:	f841 3c04 	str.w	r3, [r1, #-4]
    pMetaDataManagerHeader->IsIntialized = data32;
 8018564:	f1a1 0208 	sub.w	r2, r1, #8
    if(pMetaDataManagerHeader->Version !=  MDM_VERSION) {
 8018568:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
    pMetaDataManagerHeader->IsIntialized = data32;
 801856c:	9203      	str	r2, [sp, #12]
    if(pMetaDataManagerHeader->Version !=  MDM_VERSION) {
 801856e:	f47f ae89 	bne.w	8018284 <InitMetaDataManager+0x28>
    data32 = *(__IO uint32_t*) Address;
 8018572:	4b5e      	ldr	r3, [pc, #376]	; (80186ec <InitMetaDataManager+0x490>)
 8018574:	681a      	ldr	r2, [r3, #0]
 8018576:	9205      	str	r2, [sp, #20]
    while(data32!=MDM_DATA_TYPE_END) {
 8018578:	9a05      	ldr	r2, [sp, #20]
 801857a:	2aff      	cmp	r2, #255	; 0xff
 801857c:	f000 80a6 	beq.w	80186cc <InitMetaDataManager+0x470>
    Address+=4;
 8018580:	4698      	mov	r8, r3
    while(data32!=MDM_DATA_TYPE_END) {
 8018582:	468e      	mov	lr, r1
      Type = (MDM_MetaDataType_t) data32;
 8018584:	9b05      	ldr	r3, [sp, #20]
      data32 = *(__IO uint32_t*) Address;
 8018586:	f8d8 2004 	ldr.w	r2, [r8, #4]
 801858a:	9205      	str	r2, [sp, #20]
      Lenght = data32;
 801858c:	9e05      	ldr	r6, [sp, #20]
      pMetaDataHeader->Lenght =  Lenght;      
 801858e:	f8ce 6004 	str.w	r6, [lr, #4]
      pMetaDataHeader->Type = Type;
 8018592:	b2db      	uxtb	r3, r3
      for(Index=0;Index<(Lenght-8);Index+=4) {
 8018594:	f1b6 0408 	subs.w	r4, r6, #8
      pMetaDataHeader->Type = Type;
 8018598:	f8ce 3000 	str.w	r3, [lr]
      puint32_MetaData = (uint32_t *) pMetaDataHeader->puint8_PayLoad;
 801859c:	f10e 0008 	add.w	r0, lr, #8
      for(Index=0;Index<(Lenght-8);Index+=4) {
 80185a0:	d00b      	beq.n	80185ba <InitMetaDataManager+0x35e>
 80185a2:	2300      	movs	r3, #0
 80185a4:	f108 0508 	add.w	r5, r8, #8
        data32 = *(__IO uint32_t*) (Address+Index);
 80185a8:	58ea      	ldr	r2, [r5, r3]
 80185aa:	9205      	str	r2, [sp, #20]
        puint32_MetaData[Index>>2] = data32;
 80185ac:	089a      	lsrs	r2, r3, #2
      for(Index=0;Index<(Lenght-8);Index+=4) {
 80185ae:	3304      	adds	r3, #4
        puint32_MetaData[Index>>2] = data32;
 80185b0:	9905      	ldr	r1, [sp, #20]
 80185b2:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
      for(Index=0;Index<(Lenght-8);Index+=4) {
 80185b6:	42a3      	cmp	r3, r4
 80185b8:	d3f6      	bcc.n	80185a8 <InitMetaDataManager+0x34c>
      Address +=Lenght-8;
 80185ba:	44b0      	add	r8, r6
      puint8_RW_MetaData +=Lenght-8;
 80185bc:	44b6      	add	lr, r6
      data32 = *(__IO uint32_t*) Address;
 80185be:	f8d8 3000 	ldr.w	r3, [r8]
 80185c2:	9305      	str	r3, [sp, #20]
    while(data32!=MDM_DATA_TYPE_END) {
 80185c4:	9b05      	ldr	r3, [sp, #20]
 80185c6:	2bff      	cmp	r3, #255	; 0xff
 80185c8:	d1dc      	bne.n	8018584 <InitMetaDataManager+0x328>
    *(((uint32_t *) puint8_RW_MetaData)+4) = 0; /* No Payload */
 80185ca:	2200      	movs	r2, #0
 80185cc:	f8c7 e000 	str.w	lr, [r7]
    *((uint32_t *) puint8_RW_MetaData)     = MDM_DATA_TYPE_END;
 80185d0:	f8ce 3000 	str.w	r3, [lr]
    *(((uint32_t *) puint8_RW_MetaData)+4) = 0; /* No Payload */
 80185d4:	f8ce 2010 	str.w	r2, [lr, #16]
 80185d8:	e670      	b.n	80182bc <InitMetaDataManager+0x60>
        if(((((uint32_t) puint8_RW_MetaData)+8/* for the MDM_DATA_TYPE_END */) -
 80185da:	683c      	ldr	r4, [r7, #0]
             ((uint32_t)uint64_MetaDataVector) +
 80185dc:	9b03      	ldr	r3, [sp, #12]
 80185de:	1ae3      	subs	r3, r4, r3
 80185e0:	f103 0108 	add.w	r1, r3, #8
             (NumberOfKnownLic-NumberofFoundedLic)*(sizeof(MDM_PayLoadLic_t) + 8 /* MetaDataHeader */))>(MDM_MAX_DATASIZE_64<<3)) {
 80185e4:	20a4      	movs	r0, #164	; 0xa4
 80185e6:	eba2 0308 	sub.w	r3, r2, r8
             ((uint32_t)uint64_MetaDataVector) +
 80185ea:	fb00 1303 	mla	r3, r0, r3, r1
        if(((((uint32_t) puint8_RW_MetaData)+8/* for the MDM_DATA_TYPE_END */) -
 80185ee:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
        NecessityToSaveMetaDataManager = 1;
 80185f2:	f04f 0101 	mov.w	r1, #1
 80185f6:	f8cb 1000 	str.w	r1, [fp]
        if(((((uint32_t) puint8_RW_MetaData)+8/* for the MDM_DATA_TYPE_END */) -
 80185fa:	d833      	bhi.n	8018664 <InitMetaDataManager+0x408>
        for(Index=0;Index<NumberOfKnownLic; Index++) {
 80185fc:	b36a      	cbz	r2, 801865a <InitMetaDataManager+0x3fe>
 80185fe:	f10c 0509 	add.w	r5, ip, #9
 8018602:	f04f 0900 	mov.w	r9, #0
 8018606:	e005      	b.n	8018614 <InitMetaDataManager+0x3b8>
 8018608:	f8db 3004 	ldr.w	r3, [fp, #4]
 801860c:	454b      	cmp	r3, r9
 801860e:	f105 052d 	add.w	r5, r5, #45	; 0x2d
 8018612:	d922      	bls.n	801865a <InitMetaDataManager+0x3fe>
          if(MDM_LicTable[known_OsxLic[Index].LicEnum].Address==0) {
 8018614:	f815 2c09 	ldrb.w	r2, [r5, #-9]
 8018618:	eb07 1342 	add.w	r3, r7, r2, lsl #5
        for(Index=0;Index<NumberOfKnownLic; Index++) {
 801861c:	f109 0901 	add.w	r9, r9, #1
          if(MDM_LicTable[known_OsxLic[Index].LicEnum].Address==0) {
 8018620:	6a1b      	ldr	r3, [r3, #32]
 8018622:	2b00      	cmp	r3, #0
 8018624:	d1f0      	bne.n	8018608 <InitMetaDataManager+0x3ac>
            pMetaDataHeader->Lenght = sizeof(MDM_PayLoadLic_t) + 8 /* For Meta Data Header */;
 8018626:	21a4      	movs	r1, #164	; 0xa4
            PayLoad->LicEnum = known_OsxLic[Index].LicEnum;
 8018628:	e9c4 1201 	strd	r1, r2, [r4, #4]
            pMetaDataHeader->Type = MDM_DATA_TYPE_LIC;
 801862c:	6023      	str	r3, [r4, #0]
            PayLoad->osxLicenseInitialized = 0;
 801862e:	60e3      	str	r3, [r4, #12]
            sprintf((char *)PayLoad->osxLibVersion,known_OsxLic[Index].osxLibVersion);
 8018630:	f104 0010 	add.w	r0, r4, #16
 8018634:	4629      	mov	r1, r5
 8018636:	f006 ffaf 	bl	801f598 <siprintf>
            puint8_RW_MetaData +=pMetaDataHeader->Lenght;
 801863a:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
            MDM_LicTable[PayLoad->LicEnum].Address = (uint32_t)PayLoad;
 801863e:	eb07 1343 	add.w	r3, r7, r3, lsl #5
            sprintf((char *)PayLoad->osxLibVersion,known_OsxLic[Index].osxLibVersion);
 8018642:	f104 0608 	add.w	r6, r4, #8
            MDM_LicTable[PayLoad->LicEnum].Address = (uint32_t)PayLoad;
 8018646:	621e      	str	r6, [r3, #32]
            puint8_RW_MetaData +=pMetaDataHeader->Lenght;
 8018648:	683c      	ldr	r4, [r7, #0]
        for(Index=0;Index<NumberOfKnownLic; Index++) {
 801864a:	f8db 3004 	ldr.w	r3, [fp, #4]
            puint8_RW_MetaData +=pMetaDataHeader->Lenght;
 801864e:	4414      	add	r4, r2
        for(Index=0;Index<NumberOfKnownLic; Index++) {
 8018650:	454b      	cmp	r3, r9
            puint8_RW_MetaData +=pMetaDataHeader->Lenght;
 8018652:	603c      	str	r4, [r7, #0]
 8018654:	f105 052d 	add.w	r5, r5, #45	; 0x2d
        for(Index=0;Index<NumberOfKnownLic; Index++) {
 8018658:	d8dc      	bhi.n	8018614 <InitMetaDataManager+0x3b8>
        *((uint32_t *) (puint8_RW_MetaData+4)) = 0; /* No Payload */
 801865a:	22ff      	movs	r2, #255	; 0xff
 801865c:	2300      	movs	r3, #0
 801865e:	e9c4 2300 	strd	r2, r3, [r4]
 8018662:	e679      	b.n	8018358 <InitMetaDataManager+0xfc>
 8018664:	4b22      	ldr	r3, [pc, #136]	; (80186f0 <InitMetaDataManager+0x494>)
          puint8_RW_MetaData = ((uint8_t *) uint64_MetaDataVector)+8;
 8018666:	491f      	ldr	r1, [pc, #124]	; (80186e4 <InitMetaDataManager+0x488>)
            MDM_LicTable[Index].Address =0;
 8018668:	9802      	ldr	r0, [sp, #8]
          puint8_RW_MetaData = ((uint8_t *) uint64_MetaDataVector)+8;
 801866a:	6039      	str	r1, [r7, #0]
 801866c:	f503 7190 	add.w	r1, r3, #288	; 0x120
            MDM_LicTable[Index].Address =0;
 8018670:	63d8      	str	r0, [r3, #60]	; 0x3c
 8018672:	3320      	adds	r3, #32
          for(Index=1;Index<OSX_LICENSE_NUM;Index++) {
 8018674:	428b      	cmp	r3, r1
 8018676:	d1fb      	bne.n	8018670 <InitMetaDataManager+0x414>
 8018678:	4c1a      	ldr	r4, [pc, #104]	; (80186e4 <InitMetaDataManager+0x488>)
          NumberofFoundedLic = 0;
 801867a:	f04f 0800 	mov.w	r8, #0
 801867e:	e7bd      	b.n	80185fc <InitMetaDataManager+0x3a0>
        for(Index =0; known_GMD[Index].GMDType!=GMD_END ;Index++) {
 8018680:	4665      	mov	r5, ip
    MDM_knownOsxLicense_t *known_OsxLic=NULL;
 8018682:	469c      	mov	ip, r3
 8018684:	e64a      	b.n	801831c <InitMetaDataManager+0xc0>
    MDM_knownGMD_t *known_GMD=NULL;
 8018686:	9d02      	ldr	r5, [sp, #8]
 8018688:	e648      	b.n	801831c <InitMetaDataManager+0xc0>
 * @param None
 * @retval None
 */
void SaveMetaDataManager(void)
{
  uint32_t Success = UserFunctionForSavingFlash((void *)uint64_MetaDataVector,(void *)(puint8_RW_MetaData +8));
 801868a:	6839      	ldr	r1, [r7, #0]
 801868c:	4819      	ldr	r0, [pc, #100]	; (80186f4 <InitMetaDataManager+0x498>)
 801868e:	3108      	adds	r1, #8
 8018690:	f002 f912 	bl	801a8b8 <UserFunctionForSavingFlash>

  if(Success) {
    MDM_PRINTF("Meta Data Manager Saved in FLASH\r\n");
  }
  NecessityToSaveMetaDataManager=0;
 8018694:	2300      	movs	r3, #0
 8018696:	6023      	str	r3, [r4, #0]
 8018698:	e66f      	b.n	801837a <InitMetaDataManager+0x11e>
        if(((((uint32_t) puint8_RW_MetaData)+8/* for the MDM_DATA_TYPE_END */) -
 801869a:	9b01      	ldr	r3, [sp, #4]
 801869c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80186a0:	f67f af33 	bls.w	801850a <InitMetaDataManager+0x2ae>
 80186a4:	4b14      	ldr	r3, [pc, #80]	; (80186f8 <InitMetaDataManager+0x49c>)
          puint8_RW_MetaData = ((uint8_t *) uint64_MetaDataVector)+8;
 80186a6:	4a0f      	ldr	r2, [pc, #60]	; (80186e4 <InitMetaDataManager+0x488>)
 80186a8:	603a      	str	r2, [r7, #0]
 80186aa:	f503 719a 	add.w	r1, r3, #308	; 0x134
            MDM_GMDTable[Index].Address =0;
 80186ae:	2200      	movs	r2, #0
 80186b0:	635a      	str	r2, [r3, #52]	; 0x34
 80186b2:	331c      	adds	r3, #28
          for(Index=1;Index<GMD_NUM;Index++) {
 80186b4:	4299      	cmp	r1, r3
 80186b6:	d1fb      	bne.n	80186b0 <InitMetaDataManager+0x454>
        for(Index=0;Index<NumberOfKnownGMD; Index++) {
 80186b8:	b160      	cbz	r0, 80186d4 <InitMetaDataManager+0x478>
 80186ba:	ea4f 0cc0 	mov.w	ip, r0, lsl #3
 80186be:	f8df 9024 	ldr.w	r9, [pc, #36]	; 80186e4 <InitMetaDataManager+0x488>
          NumberofFoundedGMD = 0;
 80186c2:	f04f 0a00 	mov.w	sl, #0
 80186c6:	f105 0e04 	add.w	lr, r5, #4
 80186ca:	e6f4      	b.n	80184b6 <InitMetaDataManager+0x25a>
    *(((uint32_t *) puint8_RW_MetaData)+4) = 0; /* No Payload */
 80186cc:	9a03      	ldr	r2, [sp, #12]
 80186ce:	2300      	movs	r3, #0
 80186d0:	6193      	str	r3, [r2, #24]
 80186d2:	e5d7      	b.n	8018284 <InitMetaDataManager+0x28>
          NumberofFoundedGMD = 0;
 80186d4:	4682      	mov	sl, r0
        for(Index=0;Index<NumberOfKnownGMD; Index++) {
 80186d6:	f8df 900c 	ldr.w	r9, [pc, #12]	; 80186e4 <InitMetaDataManager+0x488>
 80186da:	e716      	b.n	801850a <InitMetaDataManager+0x2ae>
 80186dc:	6038      	str	r0, [r7, #0]
 80186de:	4681      	mov	r9, r0
 80186e0:	e713      	b.n	801850a <InitMetaDataManager+0x2ae>
 80186e2:	bf00      	nop
 80186e4:	2000e078 	.word	0x2000e078
 80186e8:	080ff004 	.word	0x080ff004
 80186ec:	080ff008 	.word	0x080ff008
 80186f0:	200011e0 	.word	0x200011e0
 80186f4:	2000e070 	.word	0x2000e070
 80186f8:	20001320 	.word	0x20001320

080186fc <EraseMetaDataManager>:
  uint32_t Success = UserFunctionForErasingFlash();
 80186fc:	f002 b882 	b.w	801a804 <UserFunctionForErasingFlash>

08018700 <SaveMetaDataManager>:
{
 8018700:	b508      	push	{r3, lr}
  uint32_t Success = UserFunctionForSavingFlash((void *)uint64_MetaDataVector,(void *)(puint8_RW_MetaData +8));
 8018702:	4b05      	ldr	r3, [pc, #20]	; (8018718 <SaveMetaDataManager+0x18>)
 8018704:	4805      	ldr	r0, [pc, #20]	; (801871c <SaveMetaDataManager+0x1c>)
 8018706:	6819      	ldr	r1, [r3, #0]
 8018708:	3108      	adds	r1, #8
 801870a:	f002 f8d5 	bl	801a8b8 <UserFunctionForSavingFlash>
  NecessityToSaveMetaDataManager=0;
 801870e:	4b04      	ldr	r3, [pc, #16]	; (8018720 <SaveMetaDataManager+0x20>)
 8018710:	2200      	movs	r2, #0
 8018712:	601a      	str	r2, [r3, #0]
}
 8018714:	bd08      	pop	{r3, pc}
 8018716:	bf00      	nop
 8018718:	200011dc 	.word	0x200011dc
 801871c:	2000e070 	.word	0x2000e070
 8018720:	2000e028 	.word	0x2000e028

08018724 <MDM_SaveGMD>:
 * @param MDM_GenericMetaDataType_t GMDType Generic Meta Data type that we want to save
 * @param void *GMD Pointer where find the Generic Meta Data
 * @retval uin32_t Success/NotSuccess (1/0)
 */
uint32_t MDM_SaveGMD(MDM_GenericMetaDataType_t GMDType,void *GMD)
{
 8018724:	b508      	push	{r3, lr}
  uint32_t RetValue=1;
  if(MDM_GMDTable[GMDType].Address!=0) {
 8018726:	4b08      	ldr	r3, [pc, #32]	; (8018748 <MDM_SaveGMD+0x24>)
 8018728:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 801872c:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8018730:	f8d3 015c 	ldr.w	r0, [r3, #348]	; 0x15c
 8018734:	b900      	cbnz	r0, 8018738 <MDM_SaveGMD+0x14>
  } else {
    MDM_PRINTF("ERROR before saving one Generic Meta Datait's necessary Initializes the MDM with the same type=%d\r\n",GMDType);
    RetValue=0;
  }
  return RetValue;
}
 8018736:	bd08      	pop	{r3, pc}
    memcpy((void *)MDMPayLoad->puint8_GMD,GMD,MDMPayLoad->GMDSize);
 8018738:	6842      	ldr	r2, [r0, #4]
 801873a:	3008      	adds	r0, #8
 801873c:	f006 f9ed 	bl	801eb1a <memcpy>
    NecessityToSaveMetaDataManager=1;
 8018740:	4b02      	ldr	r3, [pc, #8]	; (801874c <MDM_SaveGMD+0x28>)
 8018742:	2001      	movs	r0, #1
 8018744:	6018      	str	r0, [r3, #0]
}
 8018746:	bd08      	pop	{r3, pc}
 8018748:	200011dc 	.word	0x200011dc
 801874c:	2000e028 	.word	0x2000e028

08018750 <MDM_ReCallGMD>:
 * @param MDM_GenericMetaDataType_t GMDType Generic Meta Data type that we want to retrieve
 * @param void *GMD Pointer where to save the Generic Meta Data
 * @retval uin32_t Success/NotSuccess (1/0)
 */
uint32_t MDM_ReCallGMD(MDM_GenericMetaDataType_t GMDType,void *GMD)
{
 8018750:	b508      	push	{r3, lr}
  uint32_t RetValue=1;
  if(MDM_GMDTable[GMDType].Address!=0) {
 8018752:	4b08      	ldr	r3, [pc, #32]	; (8018774 <MDM_ReCallGMD+0x24>)
 8018754:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 8018758:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 801875c:	f8d3 315c 	ldr.w	r3, [r3, #348]	; 0x15c
 8018760:	b133      	cbz	r3, 8018770 <MDM_ReCallGMD+0x20>
 8018762:	4608      	mov	r0, r1
    MDM_PayLoadGMD_t *MDMPayLoad = (MDM_PayLoadGMD_t *)MDM_GMDTable[GMDType].Address;
    memcpy(GMD,(void *)MDMPayLoad->puint8_GMD,MDMPayLoad->GMDSize);
 8018764:	685a      	ldr	r2, [r3, #4]
 8018766:	f103 0108 	add.w	r1, r3, #8
 801876a:	f006 f9d6 	bl	801eb1a <memcpy>
  uint32_t RetValue=1;
 801876e:	2301      	movs	r3, #1
  } else {
    MDM_PRINTF("ERROR there is not a Generic Meta Data type=%d inside the MDM\r\n",GMDType);
    RetValue=0;
  }
  return RetValue;
}
 8018770:	4618      	mov	r0, r3
 8018772:	bd08      	pop	{r3, pc}
 8018774:	200011dc 	.word	0x200011dc

08018778 <aci_gatt_init>:
#define MIN(a,b)            ((a) < (b) )? (a) : (b)
#define MAX(a,b)            ((a) > (b) )? (a) : (b)


tBleStatus aci_gatt_init(void)
{
 8018778:	b500      	push	{lr}
 801877a:	b089      	sub	sp, #36	; 0x24
  struct hci_request rq;
  uint8_t status;

  Osal_MemSet(&rq, 0, sizeof(rq));
 801877c:	a802      	add	r0, sp, #8
 801877e:	2218      	movs	r2, #24
 8018780:	2100      	movs	r1, #0
 8018782:	f000 fa5f 	bl	8018c44 <Osal_MemSet>
  rq.ogf = OGF_VENDOR_CMD;
 8018786:	4b09      	ldr	r3, [pc, #36]	; (80187ac <aci_gatt_init+0x34>)
 8018788:	9302      	str	r3, [sp, #8]
  rq.ocf = OCF_GATT_INIT;
  rq.rparam = &status;
 801878a:	f10d 0207 	add.w	r2, sp, #7
  rq.rlen = 1;
 801878e:	2301      	movs	r3, #1

  if (hci_send_req(&rq, FALSE) < 0)
 8018790:	a802      	add	r0, sp, #8
 8018792:	2100      	movs	r1, #0
  rq.rlen = 1;
 8018794:	e9cd 2306 	strd	r2, r3, [sp, #24]
  if (hci_send_req(&rq, FALSE) < 0)
 8018798:	f006 f85a 	bl	801e850 <hci_send_req>
 801879c:	2800      	cmp	r0, #0
    return BLE_STATUS_TIMEOUT;

  return status;
 801879e:	bfac      	ite	ge
 80187a0:	f89d 0007 	ldrbge.w	r0, [sp, #7]
    return BLE_STATUS_TIMEOUT;
 80187a4:	20ff      	movlt	r0, #255	; 0xff
}
 80187a6:	b009      	add	sp, #36	; 0x24
 80187a8:	f85d fb04 	ldr.w	pc, [sp], #4
 80187ac:	0101003f 	.word	0x0101003f

080187b0 <aci_gatt_add_serv>:

tBleStatus aci_gatt_add_serv(uint8_t service_uuid_type, const uint8_t* service_uuid, uint8_t service_type, uint8_t max_attr_records, uint16_t *serviceHandle)
{
 80187b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80187b4:	b08d      	sub	sp, #52	; 0x34
  uint8_t indx = 0;
    
  buffer[indx] = service_uuid_type;
  indx++;
    
  if(service_uuid_type == UUID_TYPE_16){
 80187b6:	2801      	cmp	r0, #1
  buffer[indx] = service_uuid_type;
 80187b8:	ac0c      	add	r4, sp, #48	; 0x30
{
 80187ba:	4607      	mov	r7, r0
 80187bc:	4690      	mov	r8, r2
    uuid_len = 2;
  }
  else {
    uuid_len = 16;
  }        
  Osal_MemCpy(buffer + indx, service_uuid, uuid_len);
 80187be:	f10d 0005 	add.w	r0, sp, #5
 80187c2:	bf15      	itete	ne
 80187c4:	2210      	movne	r2, #16
 80187c6:	2202      	moveq	r2, #2
  if(service_uuid_type == UUID_TYPE_16){
 80187c8:	2512      	movne	r5, #18
 80187ca:	2504      	moveq	r5, #4
 80187cc:	bf14      	ite	ne
 80187ce:	2611      	movne	r6, #17
 80187d0:	2603      	moveq	r6, #3
  buffer[indx] = service_uuid_type;
 80187d2:	f804 7d2c 	strb.w	r7, [r4, #-44]!
{
 80187d6:	4699      	mov	r9, r3
  if(service_uuid_type == UUID_TYPE_16){
 80187d8:	bf14      	ite	ne
 80187da:	2713      	movne	r7, #19
 80187dc:	2705      	moveq	r7, #5
  Osal_MemCpy(buffer + indx, service_uuid, uuid_len);
 80187de:	f000 fa2f 	bl	8018c40 <Osal_MemCpy>
  indx +=  uuid_len;
    
  buffer[indx] = service_type;
 80187e2:	ab0c      	add	r3, sp, #48	; 0x30
 80187e4:	441e      	add	r6, r3
  indx++;
    
  buffer[indx] = max_attr_records;
 80187e6:	441d      	add	r5, r3
  indx++;
    
    
  Osal_MemSet(&resp, 0, sizeof(resp));
 80187e8:	2203      	movs	r2, #3
 80187ea:	2100      	movs	r1, #0
 80187ec:	4668      	mov	r0, sp
  buffer[indx] = service_type;
 80187ee:	f806 8c2c 	strb.w	r8, [r6, #-44]
  buffer[indx] = max_attr_records;
 80187f2:	f805 9c2c 	strb.w	r9, [r5, #-44]
  Osal_MemSet(&resp, 0, sizeof(resp));
 80187f6:	f000 fa25 	bl	8018c44 <Osal_MemSet>

  Osal_MemSet(&rq, 0, sizeof(rq));
 80187fa:	2218      	movs	r2, #24
 80187fc:	2100      	movs	r1, #0
 80187fe:	a806      	add	r0, sp, #24
 8018800:	f000 fa20 	bl	8018c44 <Osal_MemSet>
  rq.ogf = OGF_VENDOR_CMD;
 8018804:	4a0e      	ldr	r2, [pc, #56]	; (8018840 <aci_gatt_add_serv+0x90>)
  rq.ocf = OCF_GATT_ADD_SERV;
  rq.cparam = (void *)buffer;
  rq.clen = indx;
 8018806:	9709      	str	r7, [sp, #36]	; 0x24
  rq.rparam = &resp;
  rq.rlen = GATT_ADD_SERV_RP_SIZE;
 8018808:	2303      	movs	r3, #3

  if (hci_send_req(&rq, FALSE) < 0)
 801880a:	a806      	add	r0, sp, #24
 801880c:	2100      	movs	r1, #0
  rq.cparam = (void *)buffer;
 801880e:	9408      	str	r4, [sp, #32]
  rq.rparam = &resp;
 8018810:	f8cd d028 	str.w	sp, [sp, #40]	; 0x28
  rq.ogf = OGF_VENDOR_CMD;
 8018814:	9206      	str	r2, [sp, #24]
  rq.rlen = GATT_ADD_SERV_RP_SIZE;
 8018816:	930b      	str	r3, [sp, #44]	; 0x2c
  if (hci_send_req(&rq, FALSE) < 0)
 8018818:	f006 f81a 	bl	801e850 <hci_send_req>
 801881c:	2800      	cmp	r0, #0
 801881e:	db0a      	blt.n	8018836 <aci_gatt_add_serv+0x86>
    return BLE_STATUS_TIMEOUT;

  if (resp.status) {
 8018820:	f89d 0000 	ldrb.w	r0, [sp]
 8018824:	b920      	cbnz	r0, 8018830 <aci_gatt_add_serv+0x80>
    return resp.status;
  }
    
  *serviceHandle = btohs(resp.handle);
 8018826:	9b00      	ldr	r3, [sp, #0]
 8018828:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801882a:	f3c3 230f 	ubfx	r3, r3, #8, #16
 801882e:	8013      	strh	r3, [r2, #0]

  return 0;
}
 8018830:	b00d      	add	sp, #52	; 0x34
 8018832:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return BLE_STATUS_TIMEOUT;
 8018836:	20ff      	movs	r0, #255	; 0xff
}
 8018838:	b00d      	add	sp, #52	; 0x34
 801883a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801883e:	bf00      	nop
 8018840:	0102003f 	.word	0x0102003f

08018844 <aci_gatt_add_char>:
			     uint8_t secPermissions,
			     uint8_t gattEvtMask,
			     uint8_t encryKeySize,
			     uint8_t isVariable,
			     uint16_t* charHandle)                     
{
 8018844:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018848:	b097      	sub	sp, #92	; 0x5c
 801884a:	ad16      	add	r5, sp, #88	; 0x58
 801884c:	468a      	mov	sl, r1
 801884e:	f825 0d3a 	strh.w	r0, [r5, #-58]!
  uint8_t buffer[25];
  uint8_t uuid_len;
  uint8_t indx = 0;
    
  serviceHandle = htobs(serviceHandle);
  Osal_MemCpy(buffer + indx, &serviceHandle, 2);
 8018852:	f10d 0b3c 	add.w	fp, sp, #60	; 0x3c
 8018856:	4629      	mov	r1, r5
{
 8018858:	f89d 5084 	ldrb.w	r5, [sp, #132]	; 0x84
 801885c:	f89d 6088 	ldrb.w	r6, [sp, #136]	; 0x88
 8018860:	f89d 708c 	ldrb.w	r7, [sp, #140]	; 0x8c
 8018864:	9306      	str	r3, [sp, #24]
 8018866:	4614      	mov	r4, r2
 8018868:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
 801886c:	9502      	str	r5, [sp, #8]
  Osal_MemCpy(buffer + indx, &serviceHandle, 2);
 801886e:	2202      	movs	r2, #2
{
 8018870:	f89d 5090 	ldrb.w	r5, [sp, #144]	; 0x90
 8018874:	9603      	str	r6, [sp, #12]
  Osal_MemCpy(buffer + indx, &serviceHandle, 2);
 8018876:	4658      	mov	r0, fp
{
 8018878:	9704      	str	r7, [sp, #16]
 801887a:	9505      	str	r5, [sp, #20]
 801887c:	9301      	str	r3, [sp, #4]
  Osal_MemCpy(buffer + indx, &serviceHandle, 2);
 801887e:	f000 f9df 	bl	8018c40 <Osal_MemCpy>
  indx += 2;
    
  buffer[indx] = charUuidType;
  indx++;
    
  if(charUuidType == UUID_TYPE_16){
 8018882:	f1ba 0f01 	cmp.w	sl, #1
    uuid_len = 2;
  }
  else {
    uuid_len = 16;
  }        
  Osal_MemCpy(buffer + indx, charUuid, uuid_len);
 8018886:	bf15      	itete	ne
 8018888:	2210      	movne	r2, #16
 801888a:	2202      	moveq	r2, #2
  if(charUuidType == UUID_TYPE_16){
 801888c:	f04f 0c19 	movne.w	ip, #25
 8018890:	f04f 0c0b 	moveq.w	ip, #11
  Osal_MemCpy(buffer + indx, charUuid, uuid_len);
 8018894:	4621      	mov	r1, r4
 8018896:	f10d 003f 	add.w	r0, sp, #63	; 0x3f
  if(charUuidType == UUID_TYPE_16){
 801889a:	bf15      	itete	ne
 801889c:	2418      	movne	r4, #24
 801889e:	240a      	moveq	r4, #10
 80188a0:	2517      	movne	r5, #23
 80188a2:	2509      	moveq	r5, #9
 80188a4:	bf15      	itete	ne
 80188a6:	2616      	movne	r6, #22
 80188a8:	2608      	moveq	r6, #8
 80188aa:	2715      	movne	r7, #21
 80188ac:	2707      	moveq	r7, #7
 80188ae:	bf15      	itete	ne
 80188b0:	f04f 0814 	movne.w	r8, #20
 80188b4:	f04f 0806 	moveq.w	r8, #6
 80188b8:	f04f 0913 	movne.w	r9, #19
 80188bc:	f04f 0905 	moveq.w	r9, #5
 80188c0:	f8cd c000 	str.w	ip, [sp]
  buffer[indx] = charUuidType;
 80188c4:	f88d a03e 	strb.w	sl, [sp, #62]	; 0x3e
  Osal_MemCpy(buffer + indx, charUuid, uuid_len);
 80188c8:	f000 f9ba 	bl	8018c40 <Osal_MemCpy>
  indx +=  uuid_len;
    
  buffer[indx] = charValueLen;
 80188cc:	aa16      	add	r2, sp, #88	; 0x58
 80188ce:	4491      	add	r9, r2
 80188d0:	9b06      	ldr	r3, [sp, #24]
 80188d2:	f809 3c1c 	strb.w	r3, [r9, #-28]
  indx++;
    
  buffer[indx] = charProperties;
 80188d6:	4490      	add	r8, r2
  indx++;
    
  buffer[indx] = secPermissions;
 80188d8:	4417      	add	r7, r2
  buffer[indx] = charProperties;
 80188da:	9b01      	ldr	r3, [sp, #4]
 80188dc:	f808 3c1c 	strb.w	r3, [r8, #-28]
  indx++;
    
  buffer[indx] = gattEvtMask;
  indx++;
    
  buffer[indx] = encryKeySize;
 80188e0:	4415      	add	r5, r2
  buffer[indx] = secPermissions;
 80188e2:	9b02      	ldr	r3, [sp, #8]
 80188e4:	f807 3c1c 	strb.w	r3, [r7, #-28]
  buffer[indx] = gattEvtMask;
 80188e8:	4416      	add	r6, r2
 80188ea:	9b03      	ldr	r3, [sp, #12]
  buffer[indx] = encryKeySize;
 80188ec:	9f04      	ldr	r7, [sp, #16]
  buffer[indx] = gattEvtMask;
 80188ee:	f806 3c1c 	strb.w	r3, [r6, #-28]
  indx++;
    
  buffer[indx] = isVariable;
  indx++;
    
  Osal_MemSet(&resp, 0, sizeof(resp));
 80188f2:	f10d 0a20 	add.w	sl, sp, #32
  buffer[indx] = isVariable;
 80188f6:	4414      	add	r4, r2
  buffer[indx] = encryKeySize;
 80188f8:	f805 7c1c 	strb.w	r7, [r5, #-28]
  Osal_MemSet(&resp, 0, sizeof(resp));
 80188fc:	2203      	movs	r2, #3
 80188fe:	2100      	movs	r1, #0
  buffer[indx] = isVariable;
 8018900:	9d05      	ldr	r5, [sp, #20]
 8018902:	f804 5c1c 	strb.w	r5, [r4, #-28]
  Osal_MemSet(&resp, 0, sizeof(resp));
 8018906:	4650      	mov	r0, sl
 8018908:	f000 f99c 	bl	8018c44 <Osal_MemSet>

  Osal_MemSet(&rq, 0, sizeof(rq));
 801890c:	2218      	movs	r2, #24
 801890e:	2100      	movs	r1, #0
 8018910:	a809      	add	r0, sp, #36	; 0x24
 8018912:	f000 f997 	bl	8018c44 <Osal_MemSet>
  rq.ogf = OGF_VENDOR_CMD;
  rq.ocf = OCF_GATT_ADD_CHAR;
  rq.cparam = (void *)buffer;
  rq.clen = indx;
 8018916:	9b00      	ldr	r3, [sp, #0]
  rq.ogf = OGF_VENDOR_CMD;
 8018918:	4a0e      	ldr	r2, [pc, #56]	; (8018954 <aci_gatt_add_char+0x110>)
  rq.clen = indx;
 801891a:	930c      	str	r3, [sp, #48]	; 0x30
  rq.rparam = &resp;
  rq.rlen = GATT_ADD_CHAR_RP_SIZE;

  if (hci_send_req(&rq, FALSE) < 0)
 801891c:	a809      	add	r0, sp, #36	; 0x24
  rq.rlen = GATT_ADD_CHAR_RP_SIZE;
 801891e:	2303      	movs	r3, #3
  if (hci_send_req(&rq, FALSE) < 0)
 8018920:	2100      	movs	r1, #0
  rq.cparam = (void *)buffer;
 8018922:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
  rq.rparam = &resp;
 8018926:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
  rq.ogf = OGF_VENDOR_CMD;
 801892a:	9209      	str	r2, [sp, #36]	; 0x24
  rq.rlen = GATT_ADD_CHAR_RP_SIZE;
 801892c:	930e      	str	r3, [sp, #56]	; 0x38
  if (hci_send_req(&rq, FALSE) < 0)
 801892e:	f005 ff8f 	bl	801e850 <hci_send_req>
 8018932:	2800      	cmp	r0, #0
 8018934:	db0a      	blt.n	801894c <aci_gatt_add_char+0x108>
    return BLE_STATUS_TIMEOUT;

  if (resp.status) {
 8018936:	f89d 0020 	ldrb.w	r0, [sp, #32]
 801893a:	b920      	cbnz	r0, 8018946 <aci_gatt_add_char+0x102>
    return resp.status;
  }
    
  *charHandle = btohs(resp.handle);
 801893c:	9b08      	ldr	r3, [sp, #32]
 801893e:	9a25      	ldr	r2, [sp, #148]	; 0x94
 8018940:	f3c3 230f 	ubfx	r3, r3, #8, #16
 8018944:	8013      	strh	r3, [r2, #0]

  return 0;
}
 8018946:	b017      	add	sp, #92	; 0x5c
 8018948:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return BLE_STATUS_TIMEOUT;
 801894c:	20ff      	movs	r0, #255	; 0xff
}
 801894e:	b017      	add	sp, #92	; 0x5c
 8018950:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8018954:	0104003f 	.word	0x0104003f

08018958 <aci_gatt_update_char_value>:
tBleStatus aci_gatt_update_char_value(uint16_t servHandle, 
				      uint16_t charHandle,
				      uint8_t charValOffset,
				      uint8_t charValueLen,   
                                      const void *charValue)
{
 8018958:	b570      	push	{r4, r5, r6, lr}
 801895a:	b0aa      	sub	sp, #168	; 0xa8
  struct hci_request rq;
  uint8_t status;
  uint8_t buffer[HCI_MAX_PAYLOAD_SIZE];
  uint8_t indx = 0;
    
  if ((charValueLen+6) > HCI_MAX_PAYLOAD_SIZE)
 801895c:	2b7a      	cmp	r3, #122	; 0x7a
{
 801895e:	f8ad 0006 	strh.w	r0, [sp, #6]
 8018962:	f8ad 1004 	strh.w	r1, [sp, #4]
  if ((charValueLen+6) > HCI_MAX_PAYLOAD_SIZE)
 8018966:	d832      	bhi.n	80189ce <aci_gatt_update_char_value+0x76>
    return BLE_STATUS_INVALID_PARAMS;

  servHandle = htobs(servHandle);
  Osal_MemCpy(buffer + indx, &servHandle, 2);
 8018968:	ae0a      	add	r6, sp, #40	; 0x28
 801896a:	4615      	mov	r5, r2
 801896c:	f10d 0106 	add.w	r1, sp, #6
 8018970:	2202      	movs	r2, #2
 8018972:	4630      	mov	r0, r6
 8018974:	461c      	mov	r4, r3
 8018976:	f000 f963 	bl	8018c40 <Osal_MemCpy>
  indx += 2;
    
  charHandle = htobs(charHandle);
  Osal_MemCpy(buffer + indx, &charHandle, 2);
 801897a:	2202      	movs	r2, #2
 801897c:	a901      	add	r1, sp, #4
 801897e:	f10d 002a 	add.w	r0, sp, #42	; 0x2a
 8018982:	f000 f95d 	bl	8018c40 <Osal_MemCpy>
  indx++;
    
  buffer[indx] = charValueLen;
  indx++;
        
  Osal_MemCpy(buffer + indx, charValue, charValueLen);
 8018986:	4622      	mov	r2, r4
 8018988:	992e      	ldr	r1, [sp, #184]	; 0xb8
  buffer[indx] = charValOffset;
 801898a:	f88d 502c 	strb.w	r5, [sp, #44]	; 0x2c
  Osal_MemCpy(buffer + indx, charValue, charValueLen);
 801898e:	f10d 002e 	add.w	r0, sp, #46	; 0x2e
  buffer[indx] = charValueLen;
 8018992:	f88d 402d 	strb.w	r4, [sp, #45]	; 0x2d
  Osal_MemCpy(buffer + indx, charValue, charValueLen);
 8018996:	f000 f953 	bl	8018c40 <Osal_MemCpy>
  indx +=  charValueLen;

  Osal_MemSet(&rq, 0, sizeof(rq));
 801899a:	2218      	movs	r2, #24
 801899c:	2100      	movs	r1, #0
 801899e:	a804      	add	r0, sp, #16
 80189a0:	f000 f950 	bl	8018c44 <Osal_MemSet>
  indx +=  charValueLen;
 80189a4:	1da3      	adds	r3, r4, #6
  rq.ogf = OGF_VENDOR_CMD;
  rq.ocf = OCF_GATT_UPD_CHAR_VAL;
  rq.cparam = (void *)buffer;
  rq.clen = indx;
 80189a6:	b2db      	uxtb	r3, r3
  rq.rparam = &status;
  rq.rlen = 1;
 80189a8:	2201      	movs	r2, #1

  if (hci_send_req(&rq, FALSE) < 0)
 80189aa:	a804      	add	r0, sp, #16
  rq.ogf = OGF_VENDOR_CMD;
 80189ac:	4d0b      	ldr	r5, [pc, #44]	; (80189dc <aci_gatt_update_char_value+0x84>)
  rq.cparam = (void *)buffer;
 80189ae:	9606      	str	r6, [sp, #24]
  rq.rparam = &status;
 80189b0:	f10d 040f 	add.w	r4, sp, #15
  if (hci_send_req(&rq, FALSE) < 0)
 80189b4:	2100      	movs	r1, #0
  rq.clen = indx;
 80189b6:	9307      	str	r3, [sp, #28]
  rq.ogf = OGF_VENDOR_CMD;
 80189b8:	9504      	str	r5, [sp, #16]
  rq.rlen = 1;
 80189ba:	e9cd 4208 	strd	r4, r2, [sp, #32]
  if (hci_send_req(&rq, FALSE) < 0)
 80189be:	f005 ff47 	bl	801e850 <hci_send_req>
 80189c2:	2800      	cmp	r0, #0
 80189c4:	db06      	blt.n	80189d4 <aci_gatt_update_char_value+0x7c>
    return BLE_STATUS_TIMEOUT;

  if (status) {
 80189c6:	f89d 000f 	ldrb.w	r0, [sp, #15]
    return status;
  }

  return 0;
}
 80189ca:	b02a      	add	sp, #168	; 0xa8
 80189cc:	bd70      	pop	{r4, r5, r6, pc}
    return BLE_STATUS_INVALID_PARAMS;
 80189ce:	2042      	movs	r0, #66	; 0x42
}
 80189d0:	b02a      	add	sp, #168	; 0xa8
 80189d2:	bd70      	pop	{r4, r5, r6, pc}
    return BLE_STATUS_TIMEOUT;
 80189d4:	20ff      	movs	r0, #255	; 0xff
}
 80189d6:	b02a      	add	sp, #168	; 0xa8
 80189d8:	bd70      	pop	{r4, r5, r6, pc}
 80189da:	bf00      	nop
 80189dc:	0106003f 	.word	0x0106003f

080189e0 <aci_gatt_allow_read>:

  return 0;
}

tBleStatus aci_gatt_allow_read(uint16_t conn_handle)
{
 80189e0:	b530      	push	{r4, r5, lr}
 80189e2:	b089      	sub	sp, #36	; 0x24
    gatt_allow_read_cp cp;
    uint8_t status;
    
    cp.conn_handle = htobs(conn_handle);

    Osal_MemSet(&rq, 0, sizeof(rq));
 80189e4:	2218      	movs	r2, #24
    cp.conn_handle = htobs(conn_handle);
 80189e6:	f8ad 0004 	strh.w	r0, [sp, #4]
    Osal_MemSet(&rq, 0, sizeof(rq));
 80189ea:	2100      	movs	r1, #0
 80189ec:	a802      	add	r0, sp, #8
 80189ee:	f000 f929 	bl	8018c44 <Osal_MemSet>
    rq.ogf = OGF_VENDOR_CMD;
 80189f2:	4b0b      	ldr	r3, [pc, #44]	; (8018a20 <aci_gatt_allow_read+0x40>)
 80189f4:	9302      	str	r3, [sp, #8]
    rq.ocf = OCF_GATT_ALLOW_READ;
    rq.cparam = &cp;
    rq.clen = GATT_ALLOW_READ_CP_SIZE;
    rq.rparam = &status;
 80189f6:	f10d 0203 	add.w	r2, sp, #3
    rq.rlen = 1;
 80189fa:	2301      	movs	r3, #1

    if (hci_send_req(&rq, FALSE) < 0)
 80189fc:	a802      	add	r0, sp, #8
    rq.cparam = &cp;
 80189fe:	ad01      	add	r5, sp, #4
    rq.clen = GATT_ALLOW_READ_CP_SIZE;
 8018a00:	2402      	movs	r4, #2
    if (hci_send_req(&rq, FALSE) < 0)
 8018a02:	2100      	movs	r1, #0
    rq.clen = GATT_ALLOW_READ_CP_SIZE;
 8018a04:	e9cd 5404 	strd	r5, r4, [sp, #16]
    rq.rlen = 1;
 8018a08:	e9cd 2306 	strd	r2, r3, [sp, #24]
    if (hci_send_req(&rq, FALSE) < 0)
 8018a0c:	f005 ff20 	bl	801e850 <hci_send_req>
 8018a10:	2800      	cmp	r0, #0
      return BLE_STATUS_TIMEOUT;

    return status;
 8018a12:	bfac      	ite	ge
 8018a14:	f89d 0003 	ldrbge.w	r0, [sp, #3]
      return BLE_STATUS_TIMEOUT;
 8018a18:	20ff      	movlt	r0, #255	; 0xff
}
 8018a1a:	b009      	add	sp, #36	; 0x24
 8018a1c:	bd30      	pop	{r4, r5, pc}
 8018a1e:	bf00      	nop
 8018a20:	0127003f 	.word	0x0127003f

08018a24 <aci_l2cap_connection_parameter_update_request>:
#define MAX(a,b)            ((a) > (b) )? (a) : (b)

tBleStatus aci_l2cap_connection_parameter_update_request(uint16_t conn_handle, uint16_t interval_min,
							 uint16_t interval_max, uint16_t slave_latency,
							 uint16_t timeout_multiplier)
{
 8018a24:	b530      	push	{r4, r5, lr}
 8018a26:	b08b      	sub	sp, #44	; 0x2c
  cp.interval_max = htobs(interval_max);
  cp.slave_latency = htobs(slave_latency);
  cp.timeout_multiplier = htobs(timeout_multiplier);

  Osal_MemSet(&rq, 0, sizeof(rq));
  rq.ogf = OGF_VENDOR_CMD;
 8018a28:	4d14      	ldr	r5, [pc, #80]	; (8018a7c <aci_l2cap_connection_parameter_update_request+0x58>)
{
 8018a2a:	f8bd 4038 	ldrh.w	r4, [sp, #56]	; 0x38
  cp.conn_handle = htobs(conn_handle);
 8018a2e:	f8ad 0004 	strh.w	r0, [sp, #4]
  cp.interval_min = htobs(interval_min);
 8018a32:	f8ad 1006 	strh.w	r1, [sp, #6]
  cp.interval_max = htobs(interval_max);
 8018a36:	f8ad 2008 	strh.w	r2, [sp, #8]
  Osal_MemSet(&rq, 0, sizeof(rq));
 8018a3a:	a804      	add	r0, sp, #16
 8018a3c:	2218      	movs	r2, #24
 8018a3e:	2100      	movs	r1, #0
  cp.slave_latency = htobs(slave_latency);
 8018a40:	f8ad 300a 	strh.w	r3, [sp, #10]
  cp.timeout_multiplier = htobs(timeout_multiplier);
 8018a44:	f8ad 400c 	strh.w	r4, [sp, #12]
  Osal_MemSet(&rq, 0, sizeof(rq));
 8018a48:	f000 f8fc 	bl	8018c44 <Osal_MemSet>
  rq.ocf = OCF_L2CAP_CONN_PARAM_UPDATE_REQ;
  rq.cparam = &cp;
 8018a4c:	ab01      	add	r3, sp, #4
  rq.clen = L2CAP_CONN_PARAM_UPDATE_REQ_CP_SIZE;
 8018a4e:	210a      	movs	r1, #10
  rq.cparam = &cp;
 8018a50:	9306      	str	r3, [sp, #24]
  rq.event = EVT_CMD_STATUS;
  rq.rparam = &status;
 8018a52:	f10d 0203 	add.w	r2, sp, #3
  rq.rlen = 1;
 8018a56:	2301      	movs	r3, #1
  rq.clen = L2CAP_CONN_PARAM_UPDATE_REQ_CP_SIZE;
 8018a58:	9107      	str	r1, [sp, #28]

  if (hci_send_req(&rq, FALSE) < 0)
 8018a5a:	a804      	add	r0, sp, #16
  rq.ocf = OCF_L2CAP_CONN_PARAM_UPDATE_REQ;
 8018a5c:	240f      	movs	r4, #15
  if (hci_send_req(&rq, FALSE) < 0)
 8018a5e:	2100      	movs	r1, #0
  rq.ocf = OCF_L2CAP_CONN_PARAM_UPDATE_REQ;
 8018a60:	e9cd 5404 	strd	r5, r4, [sp, #16]
  rq.rlen = 1;
 8018a64:	e9cd 2308 	strd	r2, r3, [sp, #32]
  if (hci_send_req(&rq, FALSE) < 0)
 8018a68:	f005 fef2 	bl	801e850 <hci_send_req>
 8018a6c:	2800      	cmp	r0, #0
    return BLE_STATUS_TIMEOUT;
  
  return status;  
 8018a6e:	bfac      	ite	ge
 8018a70:	f89d 0003 	ldrbge.w	r0, [sp, #3]
    return BLE_STATUS_TIMEOUT;
 8018a74:	20ff      	movlt	r0, #255	; 0xff
}
 8018a76:	b00b      	add	sp, #44	; 0x2c
 8018a78:	bd30      	pop	{r4, r5, pc}
 8018a7a:	bf00      	nop
 8018a7c:	0181003f 	.word	0x0181003f

08018a80 <hci_le_set_scan_resp_data>:
  
  return 0;
}

int hci_le_set_scan_resp_data(uint8_t length, const uint8_t data[])
{
 8018a80:	b570      	push	{r4, r5, r6, lr}
 8018a82:	b090      	sub	sp, #64	; 0x40
  struct hci_request rq;
  le_set_scan_response_data_cp scan_resp_cp;
  uint8_t status;
  
  Osal_MemSet(&scan_resp_cp, 0, sizeof(scan_resp_cp));
 8018a84:	ac08      	add	r4, sp, #32
{
 8018a86:	4605      	mov	r5, r0
 8018a88:	460e      	mov	r6, r1
  Osal_MemSet(&scan_resp_cp, 0, sizeof(scan_resp_cp));
 8018a8a:	4620      	mov	r0, r4
 8018a8c:	2220      	movs	r2, #32
 8018a8e:	2100      	movs	r1, #0
 8018a90:	f000 f8d8 	bl	8018c44 <Osal_MemSet>
  scan_resp_cp.length = length;
  Osal_MemCpy(scan_resp_cp.data, data, MIN(31,length));
 8018a94:	2d1f      	cmp	r5, #31
 8018a96:	462a      	mov	r2, r5
 8018a98:	4631      	mov	r1, r6
 8018a9a:	bf28      	it	cs
 8018a9c:	221f      	movcs	r2, #31
 8018a9e:	f10d 0021 	add.w	r0, sp, #33	; 0x21
  scan_resp_cp.length = length;
 8018aa2:	f88d 5020 	strb.w	r5, [sp, #32]
  Osal_MemCpy(scan_resp_cp.data, data, MIN(31,length));
 8018aa6:	f000 f8cb 	bl	8018c40 <Osal_MemCpy>
  
  Osal_MemSet(&rq, 0, sizeof(rq));
 8018aaa:	a802      	add	r0, sp, #8
 8018aac:	2218      	movs	r2, #24
 8018aae:	2100      	movs	r1, #0
 8018ab0:	f000 f8c8 	bl	8018c44 <Osal_MemSet>
  rq.ogf = OGF_LE_CTL;
 8018ab4:	4d0a      	ldr	r5, [pc, #40]	; (8018ae0 <hci_le_set_scan_resp_data+0x60>)
  rq.ocf = OCF_LE_SET_SCAN_RESPONSE_DATA;
  rq.cparam = &scan_resp_cp;
 8018ab6:	9404      	str	r4, [sp, #16]
  rq.clen = LE_SET_SCAN_RESPONSE_DATA_CP_SIZE;
  rq.rparam = &status;
 8018ab8:	f10d 0207 	add.w	r2, sp, #7
  rq.rlen = 1;
 8018abc:	2301      	movs	r3, #1
  
  if (hci_send_req(&rq, FALSE) < 0)
 8018abe:	a802      	add	r0, sp, #8
  rq.clen = LE_SET_SCAN_RESPONSE_DATA_CP_SIZE;
 8018ac0:	2420      	movs	r4, #32
  if (hci_send_req(&rq, FALSE) < 0)
 8018ac2:	2100      	movs	r1, #0
  rq.ogf = OGF_LE_CTL;
 8018ac4:	9502      	str	r5, [sp, #8]
  rq.rparam = &status;
 8018ac6:	e9cd 4205 	strd	r4, r2, [sp, #20]
  rq.rlen = 1;
 8018aca:	9307      	str	r3, [sp, #28]
  if (hci_send_req(&rq, FALSE) < 0)
 8018acc:	f005 fec0 	bl	801e850 <hci_send_req>
 8018ad0:	2800      	cmp	r0, #0
    return BLE_STATUS_TIMEOUT;
  
  return status;
 8018ad2:	bfac      	ite	ge
 8018ad4:	f89d 0007 	ldrbge.w	r0, [sp, #7]
    return BLE_STATUS_TIMEOUT;
 8018ad8:	20ff      	movlt	r0, #255	; 0xff
}
 8018ada:	b010      	add	sp, #64	; 0x40
 8018adc:	bd70      	pop	{r4, r5, r6, pc}
 8018ade:	bf00      	nop
 8018ae0:	00090008 	.word	0x00090008

08018ae4 <hci_le_set_random_address>:
  
  return 0;
}

int hci_le_set_random_address(tBDAddr bdaddr)
{
 8018ae4:	b530      	push	{r4, r5, lr}
 8018ae6:	b08b      	sub	sp, #44	; 0x2c
  struct hci_request rq;
  le_set_random_address_cp set_rand_addr_cp;
  uint8_t status;
  
  Osal_MemSet(&set_rand_addr_cp, 0, sizeof(set_rand_addr_cp));
 8018ae8:	ac02      	add	r4, sp, #8
{
 8018aea:	4605      	mov	r5, r0
  Osal_MemSet(&set_rand_addr_cp, 0, sizeof(set_rand_addr_cp));
 8018aec:	2206      	movs	r2, #6
 8018aee:	4620      	mov	r0, r4
 8018af0:	2100      	movs	r1, #0
 8018af2:	f000 f8a7 	bl	8018c44 <Osal_MemSet>
  Osal_MemCpy(set_rand_addr_cp.bdaddr, bdaddr, sizeof(tBDAddr));
 8018af6:	4629      	mov	r1, r5
 8018af8:	4620      	mov	r0, r4
 8018afa:	2206      	movs	r2, #6
 8018afc:	f000 f8a0 	bl	8018c40 <Osal_MemCpy>
  
  Osal_MemSet(&rq, 0, sizeof(rq));
 8018b00:	a804      	add	r0, sp, #16
 8018b02:	2218      	movs	r2, #24
 8018b04:	2100      	movs	r1, #0
 8018b06:	f000 f89d 	bl	8018c44 <Osal_MemSet>
  rq.ogf = OGF_LE_CTL;
 8018b0a:	4d0a      	ldr	r5, [pc, #40]	; (8018b34 <hci_le_set_random_address+0x50>)
  rq.ocf = OCF_LE_SET_RANDOM_ADDRESS;
  rq.cparam = &set_rand_addr_cp;
 8018b0c:	9406      	str	r4, [sp, #24]
  rq.clen = LE_SET_RANDOM_ADDRESS_CP_SIZE;
  rq.rparam = &status;
 8018b0e:	f10d 0207 	add.w	r2, sp, #7
  rq.rlen = 1;
 8018b12:	2301      	movs	r3, #1
  
  if (hci_send_req(&rq, FALSE) < 0)
 8018b14:	a804      	add	r0, sp, #16
  rq.clen = LE_SET_RANDOM_ADDRESS_CP_SIZE;
 8018b16:	2406      	movs	r4, #6
  if (hci_send_req(&rq, FALSE) < 0)
 8018b18:	2100      	movs	r1, #0
  rq.ogf = OGF_LE_CTL;
 8018b1a:	9504      	str	r5, [sp, #16]
  rq.rparam = &status;
 8018b1c:	e9cd 4207 	strd	r4, r2, [sp, #28]
  rq.rlen = 1;
 8018b20:	9309      	str	r3, [sp, #36]	; 0x24
  if (hci_send_req(&rq, FALSE) < 0)
 8018b22:	f005 fe95 	bl	801e850 <hci_send_req>
 8018b26:	2800      	cmp	r0, #0
    return BLE_STATUS_TIMEOUT;
  
  return status;
 8018b28:	bfac      	ite	ge
 8018b2a:	f89d 0007 	ldrbge.w	r0, [sp, #7]
    return BLE_STATUS_TIMEOUT;
 8018b2e:	20ff      	movlt	r0, #255	; 0xff
}
 8018b30:	b00b      	add	sp, #44	; 0x2c
 8018b32:	bd30      	pop	{r4, r5, pc}
 8018b34:	00050008 	.word	0x00050008

08018b38 <list_init_head>:
 * Function Definitions 
******************************************************************************/
void list_init_head (tListNode * listHead)
{
  listHead->next = listHead;
  listHead->prev = listHead;	
 8018b38:	e9c0 0000 	strd	r0, r0, [r0]
}
 8018b3c:	4770      	bx	lr
 8018b3e:	bf00      	nop

08018b40 <list_is_empty>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8018b40:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8018b44:	b672      	cpsid	i
  uint32_t uwPRIMASK_Bit;
  uint8_t return_value;

  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  if(listHead->next == listHead)
 8018b46:	6803      	ldr	r3, [r0, #0]
  {
    return_value = TRUE;
 8018b48:	1a18      	subs	r0, r3, r0
 8018b4a:	fab0 f080 	clz	r0, r0
 8018b4e:	0940      	lsrs	r0, r0, #5
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8018b50:	f382 8810 	msr	PRIMASK, r2
    return_value = FALSE;
  }
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/

  return return_value;
}
 8018b54:	4770      	bx	lr
 8018b56:	bf00      	nop

08018b58 <list_insert_head>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8018b58:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8018b5c:	b672      	cpsid	i
  uint32_t uwPRIMASK_Bit;

  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  
  node->next = listHead->next;
 8018b5e:	6802      	ldr	r2, [r0, #0]
  node->prev = listHead;
 8018b60:	e9c1 2000 	strd	r2, r0, [r1]
  listHead->next = node;
 8018b64:	6001      	str	r1, [r0, #0]
  (node->next)->prev = node;
 8018b66:	680a      	ldr	r2, [r1, #0]
 8018b68:	6051      	str	r1, [r2, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8018b6a:	f383 8810 	msr	PRIMASK, r3
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}
 8018b6e:	4770      	bx	lr

08018b70 <list_insert_tail>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8018b70:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8018b74:	b672      	cpsid	i

  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  
  node->next = listHead;
  node->prev = listHead->prev;
 8018b76:	6842      	ldr	r2, [r0, #4]
 8018b78:	e9c1 0200 	strd	r0, r2, [r1]
  listHead->prev = node;
 8018b7c:	6041      	str	r1, [r0, #4]
  (node->prev)->next = node;
 8018b7e:	684a      	ldr	r2, [r1, #4]
 8018b80:	6011      	str	r1, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8018b82:	f383 8810 	msr	PRIMASK, r3
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}
 8018b86:	4770      	bx	lr

08018b88 <list_remove_head>:
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}

void list_remove_head (tListNode * listHead, tListNode ** node )
{
 8018b88:	b430      	push	{r4, r5}
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8018b8a:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8018b8e:	b672      	cpsid	i
  uint32_t uwPRIMASK_Bit;

  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  
  *node = listHead->next;
 8018b90:	6803      	ldr	r3, [r0, #0]
 8018b92:	600b      	str	r3, [r1, #0]
  list_remove_node (listHead->next);
 8018b94:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8018b96:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8018b9a:	b672      	cpsid	i
  (node->prev)->next = node->next;
 8018b9c:	e9d3 5200 	ldrd	r5, r2, [r3]
 8018ba0:	6015      	str	r5, [r2, #0]
  (node->next)->prev = node->prev;
 8018ba2:	681b      	ldr	r3, [r3, #0]
 8018ba4:	605a      	str	r2, [r3, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8018ba6:	f380 8810 	msr	PRIMASK, r0
  (*node)->next = NULL;
 8018baa:	680a      	ldr	r2, [r1, #0]
 8018bac:	2300      	movs	r3, #0
 8018bae:	6013      	str	r3, [r2, #0]
  (*node)->prev = NULL;
 8018bb0:	680a      	ldr	r2, [r1, #0]
 8018bb2:	6053      	str	r3, [r2, #4]
 8018bb4:	f384 8810 	msr	PRIMASK, r4
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}
 8018bb8:	bc30      	pop	{r4, r5}
 8018bba:	4770      	bx	lr

08018bbc <list_remove_tail>:

void list_remove_tail (tListNode * listHead, tListNode ** node )
{
 8018bbc:	b430      	push	{r4, r5}
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8018bbe:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8018bc2:	b672      	cpsid	i
  uint32_t uwPRIMASK_Bit;

  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  
  *node = listHead->prev;
 8018bc4:	6843      	ldr	r3, [r0, #4]
 8018bc6:	600b      	str	r3, [r1, #0]
  list_remove_node (listHead->prev);
 8018bc8:	6843      	ldr	r3, [r0, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8018bca:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8018bce:	b672      	cpsid	i
  (node->prev)->next = node->next;
 8018bd0:	e9d3 5200 	ldrd	r5, r2, [r3]
 8018bd4:	6015      	str	r5, [r2, #0]
  (node->next)->prev = node->prev;
 8018bd6:	681b      	ldr	r3, [r3, #0]
 8018bd8:	605a      	str	r2, [r3, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8018bda:	f380 8810 	msr	PRIMASK, r0
  (*node)->next = NULL;
 8018bde:	680a      	ldr	r2, [r1, #0]
 8018be0:	2300      	movs	r3, #0
 8018be2:	6013      	str	r3, [r2, #0]
  (*node)->prev = NULL;
 8018be4:	680a      	ldr	r2, [r1, #0]
 8018be6:	6053      	str	r3, [r2, #4]
 8018be8:	f384 8810 	msr	PRIMASK, r4
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}
 8018bec:	bc30      	pop	{r4, r5}
 8018bee:	4770      	bx	lr

08018bf0 <list_get_size>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8018bf0:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8018bf4:	b672      	cpsid	i
  uint32_t uwPRIMASK_Bit;

  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  temp = listHead->next;
 8018bf6:	6803      	ldr	r3, [r0, #0]
  while (temp != listHead)
 8018bf8:	4298      	cmp	r0, r3
  int size = 0;
 8018bfa:	f04f 0200 	mov.w	r2, #0
  while (temp != listHead)
 8018bfe:	d004      	beq.n	8018c0a <list_get_size+0x1a>
  {
    size++;
    temp = temp->next;		
 8018c00:	681b      	ldr	r3, [r3, #0]
  while (temp != listHead)
 8018c02:	4298      	cmp	r0, r3
    size++;
 8018c04:	f102 0201 	add.w	r2, r2, #1
  while (temp != listHead)
 8018c08:	d1fa      	bne.n	8018c00 <list_get_size+0x10>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8018c0a:	f381 8810 	msr	PRIMASK, r1
  }
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
  return (size);
}
 8018c0e:	4610      	mov	r0, r2
 8018c10:	4770      	bx	lr
 8018c12:	bf00      	nop

08018c14 <Timer_Set>:
 * @param[in] interval  The interval before the timer expires.
 *
 */
void
Timer_Set(struct timer *t, tClockTime interval)
{
 8018c14:	b510      	push	{r4, lr}
  t->interval = interval;
 8018c16:	6041      	str	r1, [r0, #4]
{
 8018c18:	4604      	mov	r4, r0
  t->start = Clock_Time();
 8018c1a:	f7f7 fc67 	bl	80104ec <HAL_GetTick>
 8018c1e:	6020      	str	r0, [r4, #0]
}
 8018c20:	bd10      	pop	{r4, pc}
 8018c22:	bf00      	nop

08018c24 <Timer_Expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
Timer_Expired(struct timer *t)
{
 8018c24:	b510      	push	{r4, lr}
 8018c26:	4604      	mov	r4, r0
  /* Note: Can not return diff >= t->interval so we add 1 to diff and return
     t->interval < diff - required to avoid an internal error in mspgcc. */
  tClockTime diff = (Clock_Time() - t->start) + 1;
 8018c28:	f7f7 fc60 	bl	80104ec <HAL_GetTick>
  return t->interval < diff;
 8018c2c:	e9d4 3200 	ldrd	r3, r2, [r4]
  tClockTime diff = (Clock_Time() - t->start) + 1;
 8018c30:	f1c3 0301 	rsb	r3, r3, #1
 8018c34:	4418      	add	r0, r3

}
 8018c36:	4282      	cmp	r2, r0
 8018c38:	bf2c      	ite	cs
 8018c3a:	2000      	movcs	r0, #0
 8018c3c:	2001      	movcc	r0, #1
 8018c3e:	bd10      	pop	{r4, pc}

08018c40 <Osal_MemCpy>:
 * Osal_MemCpy
 * 
 */
void* Osal_MemCpy(void *dest, const void *src, unsigned int size)
{
    return(memcpy(dest,src,size)); 
 8018c40:	f005 bf6b 	b.w	801eb1a <memcpy>

08018c44 <Osal_MemSet>:
 * Osal_MemSet
 * 
 */
void* Osal_MemSet(void *ptr, int value, unsigned int size)
{
    return(memset(ptr,value,size));
 8018c44:	f005 bf74 	b.w	801eb30 <memset>

08018c48 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8018c48:	f8df d034 	ldr.w	sp, [pc, #52]	; 8018c80 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8018c4c:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8018c4e:	e003      	b.n	8018c58 <LoopCopyDataInit>

08018c50 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8018c50:	4b0c      	ldr	r3, [pc, #48]	; (8018c84 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 8018c52:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8018c54:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8018c56:	3104      	adds	r1, #4

08018c58 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 8018c58:	480b      	ldr	r0, [pc, #44]	; (8018c88 <LoopForever+0xa>)
	ldr	r3, =_edata
 8018c5a:	4b0c      	ldr	r3, [pc, #48]	; (8018c8c <LoopForever+0xe>)
	adds	r2, r0, r1
 8018c5c:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8018c5e:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8018c60:	d3f6      	bcc.n	8018c50 <CopyDataInit>
	ldr	r2, =_sbss
 8018c62:	4a0b      	ldr	r2, [pc, #44]	; (8018c90 <LoopForever+0x12>)
	b	LoopFillZerobss
 8018c64:	e002      	b.n	8018c6c <LoopFillZerobss>

08018c66 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8018c66:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8018c68:	f842 3b04 	str.w	r3, [r2], #4

08018c6c <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8018c6c:	4b09      	ldr	r3, [pc, #36]	; (8018c94 <LoopForever+0x16>)
	cmp	r2, r3
 8018c6e:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8018c70:	d3f9      	bcc.n	8018c66 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8018c72:	f7f7 fbe7 	bl	8010444 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8018c76:	f005 ff0d 	bl	801ea94 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8018c7a:	f002 f91f 	bl	801aebc <main>

08018c7e <LoopForever>:

LoopForever:
    b LoopForever
 8018c7e:	e7fe      	b.n	8018c7e <LoopForever>
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8018c80:	20018000 	.word	0x20018000
	ldr	r3, =_sidata
 8018c84:	08076190 	.word	0x08076190
	ldr	r0, =_sdata
 8018c88:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8018c8c:	20001730 	.word	0x20001730
	ldr	r2, =_sbss
 8018c90:	20001730 	.word	0x20001730
	ldr	r3, = _ebss
 8018c94:	20013320 	.word	0x20013320

08018c98 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8018c98:	e7fe      	b.n	8018c98 <ADC1_2_IRQHandler>
	...

08018c9c <_sbrk>:
{
	extern char end /*asm("end")*/;
	static char *heap_end;
	char *prev_heap_end,*min_stack_ptr;

	if (heap_end == 0)
 8018c9c:	490c      	ldr	r1, [pc, #48]	; (8018cd0 <_sbrk+0x34>)
{
 8018c9e:	b508      	push	{r3, lr}
	if (heap_end == 0)
 8018ca0:	680b      	ldr	r3, [r1, #0]
 8018ca2:	b153      	cbz	r3, 8018cba <_sbrk+0x1e>

	prev_heap_end = heap_end;

#ifdef FreeRTOS
	/* Use the NVIC offset register to locate the main stack pointer. */
	min_stack_ptr = (char*)(*(unsigned int *)*(unsigned int *)0xE000ED08);
 8018ca4:	4a0b      	ldr	r2, [pc, #44]	; (8018cd4 <_sbrk+0x38>)
 8018ca6:	6812      	ldr	r2, [r2, #0]
 8018ca8:	6812      	ldr	r2, [r2, #0]
	/* Locate the STACK bottom address */
	min_stack_ptr -= MAX_STACK_SIZE;

	if (heap_end + incr > min_stack_ptr)
 8018caa:	4418      	add	r0, r3
	min_stack_ptr -= MAX_STACK_SIZE;
 8018cac:	f5a2 7200 	sub.w	r2, r2, #512	; 0x200
	if (heap_end + incr > min_stack_ptr)
 8018cb0:	4290      	cmp	r0, r2
 8018cb2:	d805      	bhi.n	8018cc0 <_sbrk+0x24>
//		abort();
		errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 8018cb4:	6008      	str	r0, [r1, #0]

	return (caddr_t) prev_heap_end;
}
 8018cb6:	4618      	mov	r0, r3
 8018cb8:	bd08      	pop	{r3, pc}
		heap_end = &end;
 8018cba:	4b07      	ldr	r3, [pc, #28]	; (8018cd8 <_sbrk+0x3c>)
 8018cbc:	600b      	str	r3, [r1, #0]
 8018cbe:	e7f1      	b.n	8018ca4 <_sbrk+0x8>
		errno = ENOMEM;
 8018cc0:	f005 fee2 	bl	801ea88 <__errno>
 8018cc4:	230c      	movs	r3, #12
 8018cc6:	6003      	str	r3, [r0, #0]
		return (caddr_t) -1;
 8018cc8:	f04f 33ff 	mov.w	r3, #4294967295
}
 8018ccc:	4618      	mov	r0, r3
 8018cce:	bd08      	pop	{r3, pc}
 8018cd0:	2000f070 	.word	0x2000f070
 8018cd4:	e000ed08 	.word	0xe000ed08
 8018cd8:	20013320 	.word	0x20013320

08018cdc <_write>:
	_kill(status, -1);
	while (1) {}
}

int _write(int file, char *ptr, int len)
{
 8018cdc:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

		for (DataIdx = 0; DataIdx < len; DataIdx++)
 8018cde:	1e16      	subs	r6, r2, #0
 8018ce0:	dd07      	ble.n	8018cf2 <_write+0x16>
 8018ce2:	460c      	mov	r4, r1
 8018ce4:	198d      	adds	r5, r1, r6
		{
		   __io_putchar( *ptr++ );
 8018ce6:	f814 0b01 	ldrb.w	r0, [r4], #1
 8018cea:	f3af 8000 	nop.w
		for (DataIdx = 0; DataIdx < len; DataIdx++)
 8018cee:	42a5      	cmp	r5, r4
 8018cf0:	d1f9      	bne.n	8018ce6 <_write+0xa>
		}
	return len;
}
 8018cf2:	4630      	mov	r0, r6
 8018cf4:	bd70      	pop	{r4, r5, r6, pc}
 8018cf6:	bf00      	nop

08018cf8 <_close>:

int _close(int file)
{
	return -1;
}
 8018cf8:	f04f 30ff 	mov.w	r0, #4294967295
 8018cfc:	4770      	bx	lr
 8018cfe:	bf00      	nop

08018d00 <_fstat>:

int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8018d00:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8018d04:	604b      	str	r3, [r1, #4]
	return 0;
}
 8018d06:	2000      	movs	r0, #0
 8018d08:	4770      	bx	lr
 8018d0a:	bf00      	nop

08018d0c <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8018d0c:	2001      	movs	r0, #1
 8018d0e:	4770      	bx	lr

08018d10 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8018d10:	2000      	movs	r0, #0
 8018d12:	4770      	bx	lr

08018d14 <_read>:

int _read(int file, char *ptr, int len)
{
 8018d14:	b510      	push	{r4, lr}
 8018d16:	460c      	mov	r4, r1
	/* scanf calls _read() with len=1024, so eat one character at time */
	*ptr = __io_getchar();
 8018d18:	f3af 8000 	nop.w
 8018d1c:	7020      	strb	r0, [r4, #0]
	return 1;
}
 8018d1e:	2001      	movs	r0, #1
 8018d20:	bd10      	pop	{r4, pc}
 8018d22:	bf00      	nop

08018d24 <DATALOG_SD_LogAudio_Disable>:
  * @brief  Disable SDCard Log
  * @param  uint32_t SomethingAlreadyRecording System already Initialized for SD recording
  * @retval None
  */
static void DATALOG_SD_LogAudio_Disable(uint32_t SomethingAlreadyRecording)
{
 8018d24:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t len;
  uint32_t byteswritten;

  if(SD_LogAudio_Enabled) {
 8018d26:	4c21      	ldr	r4, [pc, #132]	; (8018dac <DATALOG_SD_LogAudio_Disable+0x88>)
 8018d28:	6823      	ldr	r3, [r4, #0]
{
 8018d2a:	b083      	sub	sp, #12
 8018d2c:	4605      	mov	r5, r0
  if(SD_LogAudio_Enabled) {
 8018d2e:	b943      	cbnz	r3, 8018d42 <DATALOG_SD_LogAudio_Disable+0x1e>
    /* Close file */
    f_close(&MyFileAudio);
    SD_LogAudio_Enabled=0;
  }
  
  if(SomethingAlreadyRecording==0 ) {
 8018d30:	b92d      	cbnz	r5, 8018d3e <DATALOG_SD_LogAudio_Disable+0x1a>
    NoSDFlag =0;
 8018d32:	f8c4 5260 	str.w	r5, [r4, #608]	; 0x260
    SD_IO_CS_DeInit();
 8018d36:	f7f5 fd29 	bl	800e78c <SD_IO_CS_DeInit>
    LedOffTargetPlatform();
 8018d3a:	f001 fd5b 	bl	801a7f4 <LedOffTargetPlatform>
  }
}
 8018d3e:	b003      	add	sp, #12
 8018d40:	bdf0      	pop	{r4, r5, r6, r7, pc}
    len = f_size(&MyFileAudio);
 8018d42:	6923      	ldr	r3, [r4, #16]
static uint32_t WavProcess_HeaderUpdate(uint32_t len)
{
  /* Write the file length ----------------------------------------------------*/
  /* The sampling time: this value will be be written back at the end of the 
     recording opearation.  Example: 661500 Btyes = 0x000A17FC, byte[7]=0x00, byte[4]=0xFC */
  pAudioHeader[4] = (uint8_t)(len);
 8018d44:	f884 3238 	strb.w	r3, [r4, #568]	; 0x238
  pAudioHeader[5] = (uint8_t)(len >> 8);
  pAudioHeader[6] = (uint8_t)(len >> 16);
  pAudioHeader[7] = (uint8_t)(len >> 24);
  /* Write the number of sample data -----------------------------------------*/
  /* This variable will be written back at the end of the recording operation */
  len -=44;
 8018d48:	f1a3 022c 	sub.w	r2, r3, #44	; 0x2c
  pAudioHeader[40] = (uint8_t)(len); 
  pAudioHeader[41] = (uint8_t)(len >> 8);
  pAudioHeader[42] = (uint8_t)(len >> 16);
 8018d4c:	0c11      	lsrs	r1, r2, #16
  pAudioHeader[43] = (uint8_t)(len >> 24); 
 8018d4e:	0e10      	lsrs	r0, r2, #24
  pAudioHeader[41] = (uint8_t)(len >> 8);
 8018d50:	0a17      	lsrs	r7, r2, #8
  pAudioHeader[40] = (uint8_t)(len); 
 8018d52:	f884 225c 	strb.w	r2, [r4, #604]	; 0x25c
  pAudioHeader[5] = (uint8_t)(len >> 8);
 8018d56:	0a1e      	lsrs	r6, r3, #8
  pAudioHeader[6] = (uint8_t)(len >> 16);
 8018d58:	0c1a      	lsrs	r2, r3, #16
  pAudioHeader[42] = (uint8_t)(len >> 16);
 8018d5a:	f884 125e 	strb.w	r1, [r4, #606]	; 0x25e
  pAudioHeader[7] = (uint8_t)(len >> 24);
 8018d5e:	0e1b      	lsrs	r3, r3, #24
    f_lseek(&MyFileAudio, 0);
 8018d60:	2100      	movs	r1, #0
  pAudioHeader[43] = (uint8_t)(len >> 24); 
 8018d62:	f884 025f 	strb.w	r0, [r4, #607]	; 0x25f
    f_lseek(&MyFileAudio, 0);
 8018d66:	1d20      	adds	r0, r4, #4
  pAudioHeader[6] = (uint8_t)(len >> 16);
 8018d68:	f884 223a 	strb.w	r2, [r4, #570]	; 0x23a
  pAudioHeader[7] = (uint8_t)(len >> 24);
 8018d6c:	f884 323b 	strb.w	r3, [r4, #571]	; 0x23b
  pAudioHeader[41] = (uint8_t)(len >> 8);
 8018d70:	f884 725d 	strb.w	r7, [r4, #605]	; 0x25d
  pAudioHeader[5] = (uint8_t)(len >> 8);
 8018d74:	f884 6239 	strb.w	r6, [r4, #569]	; 0x239
    f_lseek(&MyFileAudio, 0);
 8018d78:	f7fd f82e 	bl	8015dd8 <f_lseek>
    if(f_write(&MyFileAudio, (uint8_t*)pAudioHeader,  sizeof(pAudioHeader), (void*)&byteswritten) != FR_OK) {
 8018d7c:	ab01      	add	r3, sp, #4
 8018d7e:	222c      	movs	r2, #44	; 0x2c
 8018d80:	f504 710d 	add.w	r1, r4, #564	; 0x234
 8018d84:	1d20      	adds	r0, r4, #4
 8018d86:	f7fc fead 	bl	8015ae4 <f_write>
 8018d8a:	b130      	cbz	r0, 8018d9a <DATALOG_SD_LogAudio_Disable+0x76>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 8018d8c:	4b08      	ldr	r3, [pc, #32]	; (8018db0 <DATALOG_SD_LogAudio_Disable+0x8c>)
 8018d8e:	681b      	ldr	r3, [r3, #0]
 8018d90:	055b      	lsls	r3, r3, #21
 8018d92:	d502      	bpl.n	8018d9a <DATALOG_SD_LogAudio_Disable+0x76>
        SDLog_Update(SD_CARD_LOGGING_IO_ERROR);
 8018d94:	2003      	movs	r0, #3
 8018d96:	f003 fcd1 	bl	801c73c <SDLog_Update>
    osDelay(100);
 8018d9a:	2064      	movs	r0, #100	; 0x64
 8018d9c:	f7fd fa48 	bl	8016230 <osDelay>
    f_close(&MyFileAudio);
 8018da0:	4804      	ldr	r0, [pc, #16]	; (8018db4 <DATALOG_SD_LogAudio_Disable+0x90>)
 8018da2:	f7fc ffed 	bl	8015d80 <f_close>
    SD_LogAudio_Enabled=0;
 8018da6:	2300      	movs	r3, #0
 8018da8:	6023      	str	r3, [r4, #0]
 8018daa:	e7c1      	b.n	8018d30 <DATALOG_SD_LogAudio_Disable+0xc>
 8018dac:	2000f074 	.word	0x2000f074
 8018db0:	20010030 	.word	0x20010030
 8018db4:	2000f078 	.word	0x2000f078

08018db8 <SD_CardLoggingMemsData>:
{
 8018db8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  CounterEnviromental++;
 8018dbc:	4dae      	ldr	r5, [pc, #696]	; (8019078 <SD_CardLoggingMemsData+0x2c0>)
                         CurrentTime.Minutes,
 8018dbe:	4caf      	ldr	r4, [pc, #700]	; (801907c <SD_CardLoggingMemsData+0x2c4>)
  CounterEnviromental++;
 8018dc0:	f8d5 3264 	ldr.w	r3, [r5, #612]	; 0x264
{
 8018dc4:	b0c6      	sub	sp, #280	; 0x118
  CounterEnviromental++;
 8018dc6:	3301      	adds	r3, #1
 8018dc8:	f8c5 3264 	str.w	r3, [r5, #612]	; 0x264
  RTC_GetCurrentDateTime();
 8018dcc:	f002 f986 	bl	801b0dc <RTC_GetCurrentDateTime>
                         999- (CurrentTime.SubSeconds*1000)/(CurrentTime.SecondFraction));
 8018dd0:	e9d4 6201 	ldrd	r6, r2, [r4, #4]
 8018dd4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8018dd8:	fb00 f006 	mul.w	r0, r0, r6
 8018ddc:	fbb0 f0f2 	udiv	r0, r0, r2
  CharPos = sprintf(myBuffer, "%02d:%02d:%02d.%03ld,",
 8018de0:	f5c0 7079 	rsb	r0, r0, #996	; 0x3e4
 8018de4:	7863      	ldrb	r3, [r4, #1]
 8018de6:	7822      	ldrb	r2, [r4, #0]
 8018de8:	78a4      	ldrb	r4, [r4, #2]
 8018dea:	9400      	str	r4, [sp, #0]
 8018dec:	3003      	adds	r0, #3
 8018dee:	9001      	str	r0, [sp, #4]
 8018df0:	49a3      	ldr	r1, [pc, #652]	; (8019080 <SD_CardLoggingMemsData+0x2c8>)
 8018df2:	a806      	add	r0, sp, #24
 8018df4:	f006 fbd0 	bl	801f598 <siprintf>
  if(SD_Card_FeaturesMask & FEATURE_MASK_ACC) {
 8018df8:	f8d5 3268 	ldr.w	r3, [r5, #616]	; 0x268
 8018dfc:	f413 0600 	ands.w	r6, r3, #8388608	; 0x800000
  CharPos = sprintf(myBuffer, "%02d:%02d:%02d.%03ld,",
 8018e00:	4604      	mov	r4, r0
  if(SD_Card_FeaturesMask & FEATURE_MASK_ACC) {
 8018e02:	f040 80a1 	bne.w	8018f48 <SD_CardLoggingMemsData+0x190>
  if(SD_Card_FeaturesMask & FEATURE_MASK_GRYO) {
 8018e06:	025f      	lsls	r7, r3, #9
 8018e08:	f100 808d 	bmi.w	8018f26 <SD_CardLoggingMemsData+0x16e>
  if(SD_Card_FeaturesMask & FEATURE_MASK_MAG) {
 8018e0c:	0298      	lsls	r0, r3, #10
 8018e0e:	d478      	bmi.n	8018f02 <SD_CardLoggingMemsData+0x14a>
  if(CounterEnviromental==RoundCounterEnvironmental) {
 8018e10:	4a9c      	ldr	r2, [pc, #624]	; (8019084 <SD_CardLoggingMemsData+0x2cc>)
 8018e12:	f8d5 0264 	ldr.w	r0, [r5, #612]	; 0x264
 8018e16:	6811      	ldr	r1, [r2, #0]
 8018e18:	4288      	cmp	r0, r1
 8018e1a:	f403 1280 	and.w	r2, r3, #1048576	; 0x100000
 8018e1e:	d051      	beq.n	8018ec4 <SD_CardLoggingMemsData+0x10c>
    if(SD_Card_FeaturesMask & FEATURE_MASK_PRESS) {
 8018e20:	2a00      	cmp	r2, #0
 8018e22:	d142      	bne.n	8018eaa <SD_CardLoggingMemsData+0xf2>
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP1) {
 8018e24:	0358      	lsls	r0, r3, #13
 8018e26:	d433      	bmi.n	8018e90 <SD_CardLoggingMemsData+0xd8>
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP2) {
 8018e28:	03d9      	lsls	r1, r3, #15
 8018e2a:	d424      	bmi.n	8018e76 <SD_CardLoggingMemsData+0xbe>
    if(SD_Card_FeaturesMask & FEATURE_MASK_HUM) {
 8018e2c:	031a      	lsls	r2, r3, #12
 8018e2e:	d41a      	bmi.n	8018e66 <SD_CardLoggingMemsData+0xae>
  if((SD_LogMems_Enabled!=0) & (NeedToSaveSomething==1)){
 8018e30:	f8d5 326c 	ldr.w	r3, [r5, #620]	; 0x26c
 8018e34:	b1a3      	cbz	r3, 8018e60 <SD_CardLoggingMemsData+0xa8>
 8018e36:	b19e      	cbz	r6, 8018e60 <SD_CardLoggingMemsData+0xa8>
    CharPos += sprintf(myBuffer+CharPos,"%c",'\n');
 8018e38:	ab06      	add	r3, sp, #24
 8018e3a:	220a      	movs	r2, #10
 8018e3c:	4992      	ldr	r1, [pc, #584]	; (8019088 <SD_CardLoggingMemsData+0x2d0>)
 8018e3e:	1918      	adds	r0, r3, r4
 8018e40:	f006 fbaa 	bl	801f598 <siprintf>
    if(f_write(&MyFileMems, (const void*)myBuffer, CharPos, (void *)&byteswritten) != FR_OK) {
 8018e44:	1c62      	adds	r2, r4, #1
 8018e46:	a906      	add	r1, sp, #24
 8018e48:	ab03      	add	r3, sp, #12
 8018e4a:	4890      	ldr	r0, [pc, #576]	; (801908c <SD_CardLoggingMemsData+0x2d4>)
 8018e4c:	f7fc fe4a 	bl	8015ae4 <f_write>
 8018e50:	b130      	cbz	r0, 8018e60 <SD_CardLoggingMemsData+0xa8>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 8018e52:	4b8f      	ldr	r3, [pc, #572]	; (8019090 <SD_CardLoggingMemsData+0x2d8>)
 8018e54:	681b      	ldr	r3, [r3, #0]
 8018e56:	055b      	lsls	r3, r3, #21
 8018e58:	d502      	bpl.n	8018e60 <SD_CardLoggingMemsData+0xa8>
        SDLog_Update(SD_CARD_LOGGING_IO_ERROR);
 8018e5a:	2003      	movs	r0, #3
 8018e5c:	f003 fc6e 	bl	801c73c <SDLog_Update>
}
 8018e60:	b046      	add	sp, #280	; 0x118
 8018e62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        CharPos += sprintf(myBuffer+CharPos,"%c",',');
 8018e66:	ab06      	add	r3, sp, #24
 8018e68:	1918      	adds	r0, r3, r4
 8018e6a:	222c      	movs	r2, #44	; 0x2c
 8018e6c:	4986      	ldr	r1, [pc, #536]	; (8019088 <SD_CardLoggingMemsData+0x2d0>)
 8018e6e:	f006 fb93 	bl	801f598 <siprintf>
 8018e72:	3401      	adds	r4, #1
 8018e74:	e7dc      	b.n	8018e30 <SD_CardLoggingMemsData+0x78>
      CharPos += sprintf(myBuffer+CharPos,"%c",',');
 8018e76:	ab06      	add	r3, sp, #24
 8018e78:	1918      	adds	r0, r3, r4
 8018e7a:	222c      	movs	r2, #44	; 0x2c
 8018e7c:	4982      	ldr	r1, [pc, #520]	; (8019088 <SD_CardLoggingMemsData+0x2d0>)
 8018e7e:	f006 fb8b 	bl	801f598 <siprintf>
 8018e82:	f8d5 3268 	ldr.w	r3, [r5, #616]	; 0x268
    if(SD_Card_FeaturesMask & FEATURE_MASK_HUM) {
 8018e86:	031a      	lsls	r2, r3, #12
      CharPos += sprintf(myBuffer+CharPos,"%c",',');
 8018e88:	f104 0401 	add.w	r4, r4, #1
    if(SD_Card_FeaturesMask & FEATURE_MASK_HUM) {
 8018e8c:	d5d0      	bpl.n	8018e30 <SD_CardLoggingMemsData+0x78>
 8018e8e:	e7ea      	b.n	8018e66 <SD_CardLoggingMemsData+0xae>
      CharPos += sprintf(myBuffer+CharPos,"%c",',');
 8018e90:	ab06      	add	r3, sp, #24
 8018e92:	1918      	adds	r0, r3, r4
 8018e94:	497c      	ldr	r1, [pc, #496]	; (8019088 <SD_CardLoggingMemsData+0x2d0>)
 8018e96:	222c      	movs	r2, #44	; 0x2c
 8018e98:	f006 fb7e 	bl	801f598 <siprintf>
 8018e9c:	f8d5 3268 	ldr.w	r3, [r5, #616]	; 0x268
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP2) {
 8018ea0:	03d9      	lsls	r1, r3, #15
      CharPos += sprintf(myBuffer+CharPos,"%c",',');
 8018ea2:	f104 0401 	add.w	r4, r4, #1
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP2) {
 8018ea6:	d5c1      	bpl.n	8018e2c <SD_CardLoggingMemsData+0x74>
 8018ea8:	e7e5      	b.n	8018e76 <SD_CardLoggingMemsData+0xbe>
      CharPos += sprintf(myBuffer+CharPos,"%c",',');
 8018eaa:	ab06      	add	r3, sp, #24
 8018eac:	1918      	adds	r0, r3, r4
 8018eae:	222c      	movs	r2, #44	; 0x2c
 8018eb0:	4975      	ldr	r1, [pc, #468]	; (8019088 <SD_CardLoggingMemsData+0x2d0>)
 8018eb2:	f006 fb71 	bl	801f598 <siprintf>
 8018eb6:	f8d5 3268 	ldr.w	r3, [r5, #616]	; 0x268
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP1) {
 8018eba:	0358      	lsls	r0, r3, #13
      CharPos += sprintf(myBuffer+CharPos,"%c",',');
 8018ebc:	f104 0401 	add.w	r4, r4, #1
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP1) {
 8018ec0:	d5b2      	bpl.n	8018e28 <SD_CardLoggingMemsData+0x70>
 8018ec2:	e7e5      	b.n	8018e90 <SD_CardLoggingMemsData+0xd8>
    CounterEnviromental=0;
 8018ec4:	2100      	movs	r1, #0
 8018ec6:	f8c5 1264 	str.w	r1, [r5, #612]	; 0x264
    if(SD_Card_FeaturesMask & FEATURE_MASK_PRESS) {
 8018eca:	2a00      	cmp	r2, #0
 8018ecc:	f040 8094 	bne.w	8018ff8 <SD_CardLoggingMemsData+0x240>
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP1) {
 8018ed0:	0359      	lsls	r1, r3, #13
 8018ed2:	d47d      	bmi.n	8018fd0 <SD_CardLoggingMemsData+0x218>
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP2) {
 8018ed4:	03da      	lsls	r2, r3, #15
 8018ed6:	d466      	bmi.n	8018fa6 <SD_CardLoggingMemsData+0x1ee>
    if(SD_Card_FeaturesMask & FEATURE_MASK_HUM) {
 8018ed8:	031f      	lsls	r7, r3, #12
 8018eda:	d5a9      	bpl.n	8018e30 <SD_CardLoggingMemsData+0x78>
      status = BSP_HUMIDITY_IsInitialized(TargetBoardFeatures.HandleHumSensor,&NotUsed);
 8018edc:	4e6d      	ldr	r6, [pc, #436]	; (8019094 <SD_CardLoggingMemsData+0x2dc>)
 8018ede:	f10d 010b 	add.w	r1, sp, #11
 8018ee2:	6970      	ldr	r0, [r6, #20]
 8018ee4:	f005 f89e 	bl	801e024 <BSP_HUMIDITY_IsInitialized>
 8018ee8:	ab06      	add	r3, sp, #24
 8018eea:	191f      	adds	r7, r3, r4
      if(status==COMPONENT_OK) {
 8018eec:	2800      	cmp	r0, #0
 8018eee:	f000 8096 	beq.w	801901e <SD_CardLoggingMemsData+0x266>
        CharPos += sprintf(myBuffer+CharPos,"%c",',');
 8018ef2:	4638      	mov	r0, r7
 8018ef4:	222c      	movs	r2, #44	; 0x2c
 8018ef6:	4964      	ldr	r1, [pc, #400]	; (8019088 <SD_CardLoggingMemsData+0x2d0>)
 8018ef8:	f006 fb4e 	bl	801f598 <siprintf>
 8018efc:	3401      	adds	r4, #1
 8018efe:	2601      	movs	r6, #1
 8018f00:	e796      	b.n	8018e30 <SD_CardLoggingMemsData+0x78>
    status= BSP_MAGNETO_Get_Axes( TargetBoardFeatures.HandleMagSensor, &Magnetometer );
 8018f02:	4b64      	ldr	r3, [pc, #400]	; (8019094 <SD_CardLoggingMemsData+0x2dc>)
 8018f04:	a903      	add	r1, sp, #12
 8018f06:	6a18      	ldr	r0, [r3, #32]
 8018f08:	f7f6 ffc0 	bl	800fe8c <BSP_MAGNETO_Get_Axes>
 8018f0c:	ab06      	add	r3, sp, #24
 8018f0e:	1919      	adds	r1, r3, r4
    if ( status == COMPONENT_OK ) {
 8018f10:	2800      	cmp	r0, #0
 8018f12:	d03e      	beq.n	8018f92 <SD_CardLoggingMemsData+0x1da>
      CharPos += sprintf(myBuffer+CharPos,"%s",",,,");
 8018f14:	4b60      	ldr	r3, [pc, #384]	; (8019098 <SD_CardLoggingMemsData+0x2e0>)
 8018f16:	6818      	ldr	r0, [r3, #0]
 8018f18:	ab06      	add	r3, sp, #24
 8018f1a:	5118      	str	r0, [r3, r4]
 8018f1c:	3403      	adds	r4, #3
 8018f1e:	f8d5 3268 	ldr.w	r3, [r5, #616]	; 0x268
    NeedToSaveSomething=1;
 8018f22:	2601      	movs	r6, #1
 8018f24:	e774      	b.n	8018e10 <SD_CardLoggingMemsData+0x58>
    status= BSP_GYRO_Get_Axes( TargetBoardFeatures.HandleGyroSensor, &AngularVelocity );
 8018f26:	4b5b      	ldr	r3, [pc, #364]	; (8019094 <SD_CardLoggingMemsData+0x2dc>)
 8018f28:	a903      	add	r1, sp, #12
 8018f2a:	69d8      	ldr	r0, [r3, #28]
 8018f2c:	f7f6 ff06 	bl	800fd3c <BSP_GYRO_Get_Axes>
 8018f30:	ab06      	add	r3, sp, #24
 8018f32:	1919      	adds	r1, r3, r4
    if (status == COMPONENT_OK) {
 8018f34:	b318      	cbz	r0, 8018f7e <SD_CardLoggingMemsData+0x1c6>
      CharPos += sprintf(myBuffer+CharPos,"%s",",,,");
 8018f36:	4b58      	ldr	r3, [pc, #352]	; (8019098 <SD_CardLoggingMemsData+0x2e0>)
 8018f38:	6818      	ldr	r0, [r3, #0]
 8018f3a:	ab06      	add	r3, sp, #24
 8018f3c:	5118      	str	r0, [r3, r4]
 8018f3e:	3403      	adds	r4, #3
 8018f40:	f8d5 3268 	ldr.w	r3, [r5, #616]	; 0x268
    NeedToSaveSomething=1;
 8018f44:	2601      	movs	r6, #1
 8018f46:	e761      	b.n	8018e0c <SD_CardLoggingMemsData+0x54>
    status= BSP_ACCELERO_Get_Axes(TargetBoardFeatures.HandleAccSensor, &Acceleration);
 8018f48:	4b52      	ldr	r3, [pc, #328]	; (8019094 <SD_CardLoggingMemsData+0x2dc>)
 8018f4a:	a903      	add	r1, sp, #12
 8018f4c:	6998      	ldr	r0, [r3, #24]
 8018f4e:	f7f5 fdcd 	bl	800eaec <BSP_ACCELERO_Get_Axes>
 8018f52:	ab06      	add	r3, sp, #24
 8018f54:	1919      	adds	r1, r3, r4
    if (status == COMPONENT_OK) {
 8018f56:	b140      	cbz	r0, 8018f6a <SD_CardLoggingMemsData+0x1b2>
      CharPos += sprintf(myBuffer+CharPos,"%s",",,,");
 8018f58:	4b4f      	ldr	r3, [pc, #316]	; (8019098 <SD_CardLoggingMemsData+0x2e0>)
 8018f5a:	6818      	ldr	r0, [r3, #0]
 8018f5c:	ab06      	add	r3, sp, #24
 8018f5e:	5118      	str	r0, [r3, r4]
 8018f60:	3403      	adds	r4, #3
 8018f62:	f8d5 3268 	ldr.w	r3, [r5, #616]	; 0x268
    NeedToSaveSomething=1;
 8018f66:	2601      	movs	r6, #1
 8018f68:	e74d      	b.n	8018e06 <SD_CardLoggingMemsData+0x4e>
      CharPos += sprintf(myBuffer+CharPos,",%ld,%ld,%ld",
 8018f6a:	9805      	ldr	r0, [sp, #20]
 8018f6c:	9000      	str	r0, [sp, #0]
 8018f6e:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 8018f72:	4608      	mov	r0, r1
 8018f74:	4949      	ldr	r1, [pc, #292]	; (801909c <SD_CardLoggingMemsData+0x2e4>)
 8018f76:	f006 fb0f 	bl	801f598 <siprintf>
 8018f7a:	4404      	add	r4, r0
 8018f7c:	e7f1      	b.n	8018f62 <SD_CardLoggingMemsData+0x1aa>
      CharPos += sprintf(myBuffer+CharPos,",%ld,%ld,%ld",
 8018f7e:	9805      	ldr	r0, [sp, #20]
 8018f80:	9000      	str	r0, [sp, #0]
 8018f82:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 8018f86:	4608      	mov	r0, r1
 8018f88:	4944      	ldr	r1, [pc, #272]	; (801909c <SD_CardLoggingMemsData+0x2e4>)
 8018f8a:	f006 fb05 	bl	801f598 <siprintf>
 8018f8e:	4404      	add	r4, r0
 8018f90:	e7d6      	b.n	8018f40 <SD_CardLoggingMemsData+0x188>
      CharPos += sprintf(myBuffer+CharPos,",%ld,%ld,%ld",
 8018f92:	9805      	ldr	r0, [sp, #20]
 8018f94:	9000      	str	r0, [sp, #0]
 8018f96:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 8018f9a:	4608      	mov	r0, r1
 8018f9c:	493f      	ldr	r1, [pc, #252]	; (801909c <SD_CardLoggingMemsData+0x2e4>)
 8018f9e:	f006 fafb 	bl	801f598 <siprintf>
 8018fa2:	4404      	add	r4, r0
 8018fa4:	e7bb      	b.n	8018f1e <SD_CardLoggingMemsData+0x166>
      status = BSP_TEMPERATURE_IsInitialized(TargetBoardFeatures.HandleTempSensors[1],&NotUsed);
 8018fa6:	4e3b      	ldr	r6, [pc, #236]	; (8019094 <SD_CardLoggingMemsData+0x2dc>)
 8018fa8:	f10d 010b 	add.w	r1, sp, #11
 8018fac:	68f0      	ldr	r0, [r6, #12]
 8018fae:	f005 fa21 	bl	801e3f4 <BSP_TEMPERATURE_IsInitialized>
 8018fb2:	ab06      	add	r3, sp, #24
 8018fb4:	191f      	adds	r7, r3, r4
      if(status==COMPONENT_OK) {
 8018fb6:	2800      	cmp	r0, #0
 8018fb8:	f000 808a 	beq.w	80190d0 <SD_CardLoggingMemsData+0x318>
        CharPos += sprintf(myBuffer+CharPos,"%c",',');
 8018fbc:	4638      	mov	r0, r7
 8018fbe:	222c      	movs	r2, #44	; 0x2c
 8018fc0:	4931      	ldr	r1, [pc, #196]	; (8019088 <SD_CardLoggingMemsData+0x2d0>)
 8018fc2:	f006 fae9 	bl	801f598 <siprintf>
 8018fc6:	3401      	adds	r4, #1
 8018fc8:	f8d5 3268 	ldr.w	r3, [r5, #616]	; 0x268
      NeedToSaveSomething=1;
 8018fcc:	2601      	movs	r6, #1
 8018fce:	e783      	b.n	8018ed8 <SD_CardLoggingMemsData+0x120>
      status = BSP_TEMPERATURE_IsInitialized(TargetBoardFeatures.HandleTempSensors[0],&NotUsed);
 8018fd0:	4e30      	ldr	r6, [pc, #192]	; (8019094 <SD_CardLoggingMemsData+0x2dc>)
 8018fd2:	f10d 010b 	add.w	r1, sp, #11
 8018fd6:	68b0      	ldr	r0, [r6, #8]
 8018fd8:	f005 fa0c 	bl	801e3f4 <BSP_TEMPERATURE_IsInitialized>
 8018fdc:	ab06      	add	r3, sp, #24
 8018fde:	191f      	adds	r7, r3, r4
      if(status==COMPONENT_OK) {
 8018fe0:	2800      	cmp	r0, #0
 8018fe2:	d05f      	beq.n	80190a4 <SD_CardLoggingMemsData+0x2ec>
        CharPos += sprintf(myBuffer+CharPos,"%c",',');
 8018fe4:	4638      	mov	r0, r7
 8018fe6:	222c      	movs	r2, #44	; 0x2c
 8018fe8:	4927      	ldr	r1, [pc, #156]	; (8019088 <SD_CardLoggingMemsData+0x2d0>)
 8018fea:	f006 fad5 	bl	801f598 <siprintf>
 8018fee:	3401      	adds	r4, #1
 8018ff0:	f8d5 3268 	ldr.w	r3, [r5, #616]	; 0x268
      NeedToSaveSomething=1;
 8018ff4:	2601      	movs	r6, #1
 8018ff6:	e76d      	b.n	8018ed4 <SD_CardLoggingMemsData+0x11c>
      status = BSP_PRESSURE_IsInitialized(TargetBoardFeatures.HandlePressSensor,&NotUsed);
 8018ff8:	4e26      	ldr	r6, [pc, #152]	; (8019094 <SD_CardLoggingMemsData+0x2dc>)
 8018ffa:	f10d 010b 	add.w	r1, sp, #11
 8018ffe:	6930      	ldr	r0, [r6, #16]
 8019000:	f005 f8de 	bl	801e1c0 <BSP_PRESSURE_IsInitialized>
 8019004:	ab06      	add	r3, sp, #24
 8019006:	191f      	adds	r7, r3, r4
      if(status==COMPONENT_OK) {
 8019008:	b300      	cbz	r0, 801904c <SD_CardLoggingMemsData+0x294>
        CharPos += sprintf(myBuffer+CharPos,"%c",',');
 801900a:	4638      	mov	r0, r7
 801900c:	222c      	movs	r2, #44	; 0x2c
 801900e:	491e      	ldr	r1, [pc, #120]	; (8019088 <SD_CardLoggingMemsData+0x2d0>)
 8019010:	f006 fac2 	bl	801f598 <siprintf>
 8019014:	3401      	adds	r4, #1
 8019016:	f8d5 3268 	ldr.w	r3, [r5, #616]	; 0x268
      NeedToSaveSomething=1;
 801901a:	2601      	movs	r6, #1
 801901c:	e758      	b.n	8018ed0 <SD_CardLoggingMemsData+0x118>
        status= BSP_HUMIDITY_Get_Hum( TargetBoardFeatures.HandleHumSensor, &Humidity );
 801901e:	a903      	add	r1, sp, #12
 8019020:	6970      	ldr	r0, [r6, #20]
 8019022:	f005 f807 	bl	801e034 <BSP_HUMIDITY_Get_Hum>
 8019026:	4680      	mov	r8, r0
        BSP_HUMIDITY_Set_One_Shot(TargetBoardFeatures.HandleHumSensor);
 8019028:	6970      	ldr	r0, [r6, #20]
 801902a:	f005 f815 	bl	801e058 <BSP_HUMIDITY_Set_One_Shot>
      if ( status == COMPONENT_OK ) {
 801902e:	f1b8 0f00 	cmp.w	r8, #0
 8019032:	f47f af5e 	bne.w	8018ef2 <SD_CardLoggingMemsData+0x13a>
        CharPos += sprintf(myBuffer+CharPos,",%.2f",Humidity);
 8019036:	9803      	ldr	r0, [sp, #12]
 8019038:	f7ee f98e 	bl	8007358 <__aeabi_f2d>
 801903c:	4602      	mov	r2, r0
 801903e:	460b      	mov	r3, r1
 8019040:	4638      	mov	r0, r7
 8019042:	4917      	ldr	r1, [pc, #92]	; (80190a0 <SD_CardLoggingMemsData+0x2e8>)
 8019044:	f006 faa8 	bl	801f598 <siprintf>
 8019048:	4404      	add	r4, r0
 801904a:	e758      	b.n	8018efe <SD_CardLoggingMemsData+0x146>
        status= BSP_PRESSURE_Get_Press( TargetBoardFeatures.HandlePressSensor, &Pressure );
 801904c:	a903      	add	r1, sp, #12
 801904e:	6930      	ldr	r0, [r6, #16]
 8019050:	f005 f8be 	bl	801e1d0 <BSP_PRESSURE_Get_Press>
 8019054:	4680      	mov	r8, r0
        BSP_PRESSURE_Set_One_Shot(TargetBoardFeatures.HandlePressSensor);
 8019056:	6930      	ldr	r0, [r6, #16]
 8019058:	f005 f8cc 	bl	801e1f4 <BSP_PRESSURE_Set_One_Shot>
      if ( status == COMPONENT_OK ) {
 801905c:	f1b8 0f00 	cmp.w	r8, #0
 8019060:	d1d3      	bne.n	801900a <SD_CardLoggingMemsData+0x252>
        CharPos += sprintf(myBuffer+CharPos,",%.2f",Pressure);
 8019062:	9803      	ldr	r0, [sp, #12]
 8019064:	f7ee f978 	bl	8007358 <__aeabi_f2d>
 8019068:	4602      	mov	r2, r0
 801906a:	460b      	mov	r3, r1
 801906c:	4638      	mov	r0, r7
 801906e:	490c      	ldr	r1, [pc, #48]	; (80190a0 <SD_CardLoggingMemsData+0x2e8>)
 8019070:	f006 fa92 	bl	801f598 <siprintf>
 8019074:	4404      	add	r4, r0
 8019076:	e7ce      	b.n	8019016 <SD_CardLoggingMemsData+0x25e>
 8019078:	2000f074 	.word	0x2000f074
 801907c:	20012f24 	.word	0x20012f24
 8019080:	0807550c 	.word	0x0807550c
 8019084:	200014a0 	.word	0x200014a0
 8019088:	08075540 	.word	0x08075540
 801908c:	2000f2e4 	.word	0x2000f2e4
 8019090:	20010030 	.word	0x20010030
 8019094:	20011458 	.word	0x20011458
 8019098:	08075534 	.word	0x08075534
 801909c:	08075524 	.word	0x08075524
 80190a0:	08075538 	.word	0x08075538
        status= BSP_TEMPERATURE_Get_Temp( TargetBoardFeatures.HandleTempSensors[0], &Temperature);
 80190a4:	a903      	add	r1, sp, #12
 80190a6:	68b0      	ldr	r0, [r6, #8]
 80190a8:	f005 f9ac 	bl	801e404 <BSP_TEMPERATURE_Get_Temp>
 80190ac:	4680      	mov	r8, r0
        BSP_TEMPERATURE_Set_One_Shot(TargetBoardFeatures.HandleTempSensors[0]);
 80190ae:	68b0      	ldr	r0, [r6, #8]
 80190b0:	f005 f9ba 	bl	801e428 <BSP_TEMPERATURE_Set_One_Shot>
      if ( status == COMPONENT_OK ) {
 80190b4:	f1b8 0f00 	cmp.w	r8, #0
 80190b8:	d194      	bne.n	8018fe4 <SD_CardLoggingMemsData+0x22c>
        CharPos += sprintf(myBuffer+CharPos,",%.2f",Temperature);
 80190ba:	9803      	ldr	r0, [sp, #12]
 80190bc:	f7ee f94c 	bl	8007358 <__aeabi_f2d>
 80190c0:	4602      	mov	r2, r0
 80190c2:	460b      	mov	r3, r1
 80190c4:	4638      	mov	r0, r7
 80190c6:	490e      	ldr	r1, [pc, #56]	; (8019100 <SD_CardLoggingMemsData+0x348>)
 80190c8:	f006 fa66 	bl	801f598 <siprintf>
 80190cc:	4404      	add	r4, r0
 80190ce:	e78f      	b.n	8018ff0 <SD_CardLoggingMemsData+0x238>
        status= BSP_TEMPERATURE_Get_Temp( TargetBoardFeatures.HandleTempSensors[1], &Temperature);
 80190d0:	a903      	add	r1, sp, #12
 80190d2:	68f0      	ldr	r0, [r6, #12]
 80190d4:	f005 f996 	bl	801e404 <BSP_TEMPERATURE_Get_Temp>
 80190d8:	4680      	mov	r8, r0
        BSP_TEMPERATURE_Set_One_Shot(TargetBoardFeatures.HandleTempSensors[1]);
 80190da:	68f0      	ldr	r0, [r6, #12]
 80190dc:	f005 f9a4 	bl	801e428 <BSP_TEMPERATURE_Set_One_Shot>
      if ( status == COMPONENT_OK ) {
 80190e0:	f1b8 0f00 	cmp.w	r8, #0
 80190e4:	f47f af6a 	bne.w	8018fbc <SD_CardLoggingMemsData+0x204>
        CharPos += sprintf(myBuffer+CharPos,",%.2f",Temperature);
 80190e8:	9803      	ldr	r0, [sp, #12]
 80190ea:	f7ee f935 	bl	8007358 <__aeabi_f2d>
 80190ee:	4602      	mov	r2, r0
 80190f0:	460b      	mov	r3, r1
 80190f2:	4638      	mov	r0, r7
 80190f4:	4902      	ldr	r1, [pc, #8]	; (8019100 <SD_CardLoggingMemsData+0x348>)
 80190f6:	f006 fa4f 	bl	801f598 <siprintf>
 80190fa:	4404      	add	r4, r0
 80190fc:	e764      	b.n	8018fc8 <SD_CardLoggingMemsData+0x210>
 80190fe:	bf00      	nop
 8019100:	08075538 	.word	0x08075538

08019104 <DATALOG_SD_LogMems_Disable>:
{
 8019104:	b538      	push	{r3, r4, r5, lr}
  if(SD_LogMems_Enabled) {
 8019106:	4c0c      	ldr	r4, [pc, #48]	; (8019138 <DATALOG_SD_LogMems_Disable+0x34>)
 8019108:	f8d4 326c 	ldr.w	r3, [r4, #620]	; 0x26c
{
 801910c:	4605      	mov	r5, r0
  if(SD_LogMems_Enabled) {
 801910e:	b90b      	cbnz	r3, 8019114 <DATALOG_SD_LogMems_Disable+0x10>
  if(SomethingAlreadyRecording==0) {
 8019110:	b14d      	cbz	r5, 8019126 <DATALOG_SD_LogMems_Disable+0x22>
}
 8019112:	bd38      	pop	{r3, r4, r5, pc}
    f_close(&MyFileMems);
 8019114:	f504 701c 	add.w	r0, r4, #624	; 0x270
 8019118:	f7fc fe32 	bl	8015d80 <f_close>
    SD_LogMems_Enabled =0;
 801911c:	2300      	movs	r3, #0
 801911e:	f8c4 326c 	str.w	r3, [r4, #620]	; 0x26c
  if(SomethingAlreadyRecording==0) {
 8019122:	2d00      	cmp	r5, #0
 8019124:	d1f5      	bne.n	8019112 <DATALOG_SD_LogMems_Disable+0xe>
    NoSDFlag =0;
 8019126:	f8c4 5260 	str.w	r5, [r4, #608]	; 0x260
    SD_IO_CS_DeInit();
 801912a:	f7f5 fb2f 	bl	800e78c <SD_IO_CS_DeInit>
}
 801912e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    LedOffTargetPlatform();
 8019132:	f001 bb5f 	b.w	801a7f4 <LedOffTargetPlatform>
 8019136:	bf00      	nop
 8019138:	2000f074 	.word	0x2000f074

0801913c <DATALOG_SD_LogMems_Enable>:
{
 801913c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8019140:	4689      	mov	r9, r1
 8019142:	f5ad 7d0b 	sub.w	sp, sp, #556	; 0x22c
  if(SomethingAlreadyRecording==0) {
 8019146:	2800      	cmp	r0, #0
 8019148:	f000 80f7 	beq.w	801933a <DATALOG_SD_LogMems_Enable+0x1fe>
  *   created only for Annotation purpose
  * @retval None
  */
static void CreateMemsFileName(char *FileName,uint32_t OnlyForAnnotation)
{
  RTC_GetCurrentDateTime();
 801914c:	f001 ffc6 	bl	801b0dc <RTC_GetCurrentDateTime>
  if(OnlyForAnnotation) {
    sprintf(FileName, "%s-Ann_%02d_%s_%02d_%02dh_%02dm_%02ds.csv",
                       DefaultDataFileName,
                       CurrentDate.Date,
 8019150:	48c1      	ldr	r0, [pc, #772]	; (8019458 <DATALOG_SD_LogMems_Enable+0x31c>)
                       MonthName[CurrentDate.Month-1],
                       CurrentDate.Year,
                       CurrentTime.Hours,
                       CurrentTime.Minutes,
                       CurrentTime.Seconds);
 8019152:	4ac2      	ldr	r2, [pc, #776]	; (801945c <DATALOG_SD_LogMems_Enable+0x320>)
                       MonthName[CurrentDate.Month-1],
 8019154:	7841      	ldrb	r1, [r0, #1]
    sprintf(FileName, "%s-Ann_%02d_%s_%02d_%02dh_%02dm_%02ds.csv",
 8019156:	7883      	ldrb	r3, [r0, #2]
 8019158:	4cc1      	ldr	r4, [pc, #772]	; (8019460 <DATALOG_SD_LogMems_Enable+0x324>)
 801915a:	78c0      	ldrb	r0, [r0, #3]
 801915c:	9001      	str	r0, [sp, #4]
 801915e:	3901      	subs	r1, #1
 8019160:	7890      	ldrb	r0, [r2, #2]
 8019162:	f854 4021 	ldr.w	r4, [r4, r1, lsl #2]
 8019166:	7851      	ldrb	r1, [r2, #1]
 8019168:	7812      	ldrb	r2, [r2, #0]
 801916a:	9202      	str	r2, [sp, #8]
 801916c:	9400      	str	r4, [sp, #0]
 801916e:	e9cd 1003 	strd	r1, r0, [sp, #12]
 8019172:	4abc      	ldr	r2, [pc, #752]	; (8019464 <DATALOG_SD_LogMems_Enable+0x328>)
  if(OnlyForAnnotation) {
 8019174:	f1b9 0f00 	cmp.w	r9, #0
 8019178:	f040 80da 	bne.w	8019330 <DATALOG_SD_LogMems_Enable+0x1f4>
  } else {
    sprintf(FileName, "%s-MemsAnn_%02d_%s_%02d_%02dh_%02dm_%02ds.csv",
 801917c:	49ba      	ldr	r1, [pc, #744]	; (8019468 <DATALOG_SD_LogMems_Enable+0x32c>)
 801917e:	48bb      	ldr	r0, [pc, #748]	; (801946c <DATALOG_SD_LogMems_Enable+0x330>)
 8019180:	f006 fa0a 	bl	801f598 <siprintf>
 8019184:	4eba      	ldr	r6, [pc, #744]	; (8019470 <DATALOG_SD_LogMems_Enable+0x334>)
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 8019186:	f8df 8300 	ldr.w	r8, [pc, #768]	; 8019488 <DATALOG_SD_LogMems_Enable+0x34c>
 801918a:	f8d6 526c 	ldr.w	r5, [r6, #620]	; 0x26c
        BytesToWrite =sprintf((char *)BufferToWrite, "FileName=%s\n",MemsDataFileName);
 801918e:	f8df a338 	ldr.w	sl, [pc, #824]	; 80194c8 <DATALOG_SD_LogMems_Enable+0x38c>
    if(f_open(&MyFileMems, (char const*)MemsDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 8019192:	f506 6794 	add.w	r7, r6, #1184	; 0x4a0
{
 8019196:	2400      	movs	r4, #0
    if(f_open(&MyFileMems, (char const*)MemsDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 8019198:	220a      	movs	r2, #10
 801919a:	4639      	mov	r1, r7
 801919c:	48b5      	ldr	r0, [pc, #724]	; (8019474 <DATALOG_SD_LogMems_Enable+0x338>)
    SDCardFileCount++;
 801919e:	3401      	adds	r4, #1
  while(SD_LogMems_Enabled==0) {
 80191a0:	b9a5      	cbnz	r5, 80191cc <DATALOG_SD_LogMems_Enable+0x90>
    if(f_open(&MyFileMems, (char const*)MemsDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 80191a2:	f7fc fb1f 	bl	80157e4 <f_open>
      SD_LogMems_Enabled=1;
 80191a6:	2301      	movs	r3, #1
    if(f_open(&MyFileMems, (char const*)MemsDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 80191a8:	2800      	cmp	r0, #0
 80191aa:	f000 8087 	beq.w	80192bc <DATALOG_SD_LogMems_Enable+0x180>
      if(SDCardFileCount > MAX_TRIALS_OPENS_SD) {
 80191ae:	2c0a      	cmp	r4, #10
      osDelay(100);
 80191b0:	f04f 0064 	mov.w	r0, #100	; 0x64
      if(SDCardFileCount > MAX_TRIALS_OPENS_SD) {
 80191b4:	f200 80c4 	bhi.w	8019340 <DATALOG_SD_LogMems_Enable+0x204>
      osDelay(100);
 80191b8:	f7fd f83a 	bl	8016230 <osDelay>
 80191bc:	f8d6 526c 	ldr.w	r5, [r6, #620]	; 0x26c
    if(f_open(&MyFileMems, (char const*)MemsDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 80191c0:	48ac      	ldr	r0, [pc, #688]	; (8019474 <DATALOG_SD_LogMems_Enable+0x338>)
 80191c2:	220a      	movs	r2, #10
 80191c4:	4639      	mov	r1, r7
    SDCardFileCount++;
 80191c6:	3401      	adds	r4, #1
  while(SD_LogMems_Enabled==0) {
 80191c8:	2d00      	cmp	r5, #0
 80191ca:	d0ea      	beq.n	80191a2 <DATALOG_SD_LogMems_Enable+0x66>
  if(OnlyForAnnotation) {
 80191cc:	f1b9 0f00 	cmp.w	r9, #0
 80191d0:	f040 8089 	bne.w	80192e6 <DATALOG_SD_LogMems_Enable+0x1aa>
    int32_t IneHz = SampleRateIneFeatures/10;
 80191d4:	4ba8      	ldr	r3, [pc, #672]	; (8019478 <DATALOG_SD_LogMems_Enable+0x33c>)
    CharPosHeader = sprintf(Header,"%s","hh:mm:ss.ms, Annotation ");
 80191d6:	4fa9      	ldr	r7, [pc, #676]	; (801947c <DATALOG_SD_LogMems_Enable+0x340>)
    int32_t IneHz = SampleRateIneFeatures/10;
 80191d8:	f8b3 a004 	ldrh.w	sl, [r3, #4]
    int32_t EnvHz = RoundedEnvironmentalFreq/10;
 80191dc:	f8d3 b008 	ldr.w	fp, [r3, #8]
    CharPosIntro = sprintf(Introduction,"%s","Sensors' Acquisition [Hz]: ");
 80191e0:	4da7      	ldr	r5, [pc, #668]	; (8019480 <DATALOG_SD_LogMems_Enable+0x344>)
    int32_t IneHz = SampleRateIneFeatures/10;
 80191e2:	f8df e2e8 	ldr.w	lr, [pc, #744]	; 80194cc <DATALOG_SD_LogMems_Enable+0x390>
    if(SD_Card_FeaturesMask&FEATURE_MASK_BLUEVOICE) {
 80191e6:	f8d6 c268 	ldr.w	ip, [r6, #616]	; 0x268
    CharPosHeader = sprintf(Header,"%s","hh:mm:ss.ms, Annotation ");
 80191ea:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 80191ec:	ac0a      	add	r4, sp, #40	; 0x28
 80191ee:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80191f0:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
 80191f4:	c403      	stmia	r4!, {r0, r1}
 80191f6:	7022      	strb	r2, [r4, #0]
    CharPosIntro = sprintf(Introduction,"%s","Sensors' Acquisition [Hz]: ");
 80191f8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80191fa:	ac4a      	add	r4, sp, #296	; 0x128
 80191fc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    int32_t IneHz = SampleRateIneFeatures/10;
 80191fe:	fbae 390a 	umull	r3, r9, lr, sl
    int32_t EnvHz = RoundedEnvironmentalFreq/10;
 8019202:	fbae 370b 	umull	r3, r7, lr, fp
    int32_t IneHz = SampleRateIneFeatures/10;
 8019206:	ea4f 09d9 	mov.w	r9, r9, lsr #3
    int32_t EnvHz = RoundedEnvironmentalFreq/10;
 801920a:	08fb      	lsrs	r3, r7, #3
 801920c:	9307      	str	r3, [sp, #28]
    CharPosIntro = sprintf(Introduction,"%s","Sensors' Acquisition [Hz]: ");
 801920e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
    int32_t IneSubHz = SampleRateIneFeatures%10;
 8019212:	eb09 0389 	add.w	r3, r9, r9, lsl #2
 8019216:	ebaa 0a43 	sub.w	sl, sl, r3, lsl #1
    int32_t EnvSubHz = RoundedEnvironmentalFreq%10;
 801921a:	9b07      	ldr	r3, [sp, #28]
    if(SD_Card_FeaturesMask&FEATURE_MASK_BLUEVOICE) {
 801921c:	f01c 6f00 	tst.w	ip, #134217728	; 0x8000000
    int32_t EnvSubHz = RoundedEnvironmentalFreq%10;
 8019220:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    int32_t IneSubHz = SampleRateIneFeatures%10;
 8019224:	fa1f fa8a 	uxth.w	sl, sl
    int32_t IneHz = SampleRateIneFeatures/10;
 8019228:	fa1f f989 	uxth.w	r9, r9
    int32_t EnvSubHz = RoundedEnvironmentalFreq%10;
 801922c:	ebab 0b43 	sub.w	fp, fp, r3, lsl #1
    CharPosIntro = sprintf(Introduction,"%s","Sensors' Acquisition [Hz]: ");
 8019230:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    if(SD_Card_FeaturesMask&FEATURE_MASK_BLUEVOICE) {
 8019234:	f040 818a 	bne.w	801954c <DATALOG_SD_LogMems_Enable+0x410>
    CharPosIntro = sprintf(Introduction,"%s","Sensors' Acquisition [Hz]: ");
 8019238:	251b      	movs	r5, #27
 801923a:	ab4a      	add	r3, sp, #296	; 0x128
    if(SD_Card_FeaturesMask&FEATURE_MASK_ACC) {
 801923c:	f41c 0f00 	tst.w	ip, #8388608	; 0x800000
 8019240:	eb03 0e05 	add.w	lr, r3, r5
 8019244:	f040 8169 	bne.w	801951a <DATALOG_SD_LogMems_Enable+0x3de>
    CharPosHeader = sprintf(Header,"%s","hh:mm:ss.ms, Annotation ");
 8019248:	f04f 0818 	mov.w	r8, #24
 801924c:	ab0a      	add	r3, sp, #40	; 0x28
    if(SD_Card_FeaturesMask&FEATURE_MASK_GRYO) {
 801924e:	f41c 0f80 	tst.w	ip, #4194304	; 0x400000
 8019252:	eb03 0408 	add.w	r4, r3, r8
 8019256:	f040 813d 	bne.w	80194d4 <DATALOG_SD_LogMems_Enable+0x398>
    if(SD_Card_FeaturesMask&FEATURE_MASK_MAG) {
 801925a:	f41c 1f00 	tst.w	ip, #2097152	; 0x200000
 801925e:	f040 80dc 	bne.w	801941a <DATALOG_SD_LogMems_Enable+0x2de>
    if(SD_Card_FeaturesMask&FEATURE_MASK_PRESS) {
 8019262:	f41c 1f80 	tst.w	ip, #1048576	; 0x100000
 8019266:	f040 80c0 	bne.w	80193ea <DATALOG_SD_LogMems_Enable+0x2ae>
    if(SD_Card_FeaturesMask&FEATURE_MASK_TEMP1) {
 801926a:	f41c 2f80 	tst.w	ip, #262144	; 0x40000
 801926e:	f040 80a4 	bne.w	80193ba <DATALOG_SD_LogMems_Enable+0x27e>
    if(SD_Card_FeaturesMask&FEATURE_MASK_TEMP2) {
 8019272:	f41c 3f80 	tst.w	ip, #65536	; 0x10000
 8019276:	f040 8088 	bne.w	801938a <DATALOG_SD_LogMems_Enable+0x24e>
    if(SD_Card_FeaturesMask&FEATURE_MASK_HUM) {
 801927a:	f41c 2f00 	tst.w	ip, #524288	; 0x80000
 801927e:	d170      	bne.n	8019362 <DATALOG_SD_LogMems_Enable+0x226>
    CharPosIntro += sprintf(Introduction+CharPosIntro,"%c",'\n');
 8019280:	4670      	mov	r0, lr
 8019282:	220a      	movs	r2, #10
 8019284:	497f      	ldr	r1, [pc, #508]	; (8019484 <DATALOG_SD_LogMems_Enable+0x348>)
 8019286:	f006 f987 	bl	801f598 <siprintf>
    CharPosHeader += sprintf(Header+CharPosHeader,"%c",'\n');
 801928a:	220a      	movs	r2, #10
 801928c:	497d      	ldr	r1, [pc, #500]	; (8019484 <DATALOG_SD_LogMems_Enable+0x348>)
 801928e:	4620      	mov	r0, r4
 8019290:	f006 f982 	bl	801f598 <siprintf>
    if(f_write(&MyFileMems, (const void*)Introduction, CharPosIntro, (void *)&byteswritten) != FR_OK) {
 8019294:	1c6a      	adds	r2, r5, #1
 8019296:	a94a      	add	r1, sp, #296	; 0x128
 8019298:	ab09      	add	r3, sp, #36	; 0x24
 801929a:	4876      	ldr	r0, [pc, #472]	; (8019474 <DATALOG_SD_LogMems_Enable+0x338>)
 801929c:	f7fc fc22 	bl	8015ae4 <f_write>
 80192a0:	2800      	cmp	r0, #0
 80192a2:	d054      	beq.n	801934e <DATALOG_SD_LogMems_Enable+0x212>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 80192a4:	4b78      	ldr	r3, [pc, #480]	; (8019488 <DATALOG_SD_LogMems_Enable+0x34c>)
 80192a6:	681b      	ldr	r3, [r3, #0]
 80192a8:	055b      	lsls	r3, r3, #21
 80192aa:	d502      	bpl.n	80192b2 <DATALOG_SD_LogMems_Enable+0x176>
        SDLog_Update(SD_CARD_LOGGING_IO_ERROR);
 80192ac:	2003      	movs	r0, #3
 80192ae:	f003 fa45 	bl	801c73c <SDLog_Update>
      return 0;
 80192b2:	2000      	movs	r0, #0
}
 80192b4:	f50d 7d0b 	add.w	sp, sp, #556	; 0x22c
 80192b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 80192bc:	f8d8 2000 	ldr.w	r2, [r8]
      SD_LogMems_Enabled=1;
 80192c0:	f8c6 326c 	str.w	r3, [r6, #620]	; 0x26c
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 80192c4:	0692      	lsls	r2, r2, #26
 80192c6:	d581      	bpl.n	80191cc <DATALOG_SD_LogMems_Enable+0x90>
        BytesToWrite =sprintf((char *)BufferToWrite, "FileName=%s\n",MemsDataFileName);
 80192c8:	463a      	mov	r2, r7
 80192ca:	4651      	mov	r1, sl
 80192cc:	486f      	ldr	r0, [pc, #444]	; (801948c <DATALOG_SD_LogMems_Enable+0x350>)
 80192ce:	f006 f963 	bl	801f598 <siprintf>
 80192d2:	4b6f      	ldr	r3, [pc, #444]	; (8019490 <DATALOG_SD_LogMems_Enable+0x354>)
 80192d4:	4601      	mov	r1, r0
 80192d6:	6019      	str	r1, [r3, #0]
        Term_Update(BufferToWrite,BytesToWrite);
 80192d8:	486c      	ldr	r0, [pc, #432]	; (801948c <DATALOG_SD_LogMems_Enable+0x350>)
 80192da:	b2c9      	uxtb	r1, r1
 80192dc:	f002 fdde 	bl	801be9c <Term_Update>
 80192e0:	f8d6 526c 	ldr.w	r5, [r6, #620]	; 0x26c
 80192e4:	e758      	b.n	8019198 <DATALOG_SD_LogMems_Enable+0x5c>
    uint8_t pHeader[]= "hh:mm:ss.ms, Annotation\n";
 80192e6:	4d6b      	ldr	r5, [pc, #428]	; (8019494 <DATALOG_SD_LogMems_Enable+0x358>)
    CharPos = sprintf(Introduction,"Sensors' Acquisition [Hz] setup: Mic@%d Volume=%ld\n",AUDIO_SAMPLING_FREQUENCY,TargetBoardFeatures.AudioVolume);
 80192e8:	4e6b      	ldr	r6, [pc, #428]	; (8019498 <DATALOG_SD_LogMems_Enable+0x35c>)
    uint8_t pHeader[]= "hh:mm:ss.ms, Annotation\n";
 80192ea:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80192ec:	ac0a      	add	r4, sp, #40	; 0x28
 80192ee:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80192f0:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80192f4:	c403      	stmia	r4!, {r0, r1}
    CharPos = sprintf(Introduction,"Sensors' Acquisition [Hz] setup: Mic@%d Volume=%ld\n",AUDIO_SAMPLING_FREQUENCY,TargetBoardFeatures.AudioVolume);
 80192f6:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
    uint8_t pHeader[]= "hh:mm:ss.ms, Annotation\n";
 80192f8:	7022      	strb	r2, [r4, #0]
    CharPos = sprintf(Introduction,"Sensors' Acquisition [Hz] setup: Mic@%d Volume=%ld\n",AUDIO_SAMPLING_FREQUENCY,TargetBoardFeatures.AudioVolume);
 80192fa:	4968      	ldr	r1, [pc, #416]	; (801949c <DATALOG_SD_LogMems_Enable+0x360>)
 80192fc:	f44f 527a 	mov.w	r2, #16000	; 0x3e80
 8019300:	a84a      	add	r0, sp, #296	; 0x128
 8019302:	f006 f949 	bl	801f598 <siprintf>
    if(f_write(&MyFileMems, (const void*)Introduction, CharPos, (void *)&byteswritten) != FR_OK) {
 8019306:	a94a      	add	r1, sp, #296	; 0x128
 8019308:	4602      	mov	r2, r0
 801930a:	ab09      	add	r3, sp, #36	; 0x24
 801930c:	4859      	ldr	r0, [pc, #356]	; (8019474 <DATALOG_SD_LogMems_Enable+0x338>)
 801930e:	f7fc fbe9 	bl	8015ae4 <f_write>
 8019312:	2800      	cmp	r0, #0
 8019314:	d1c6      	bne.n	80192a4 <DATALOG_SD_LogMems_Enable+0x168>
    if(f_write(&MyFileMems, (const void*)pHeader, sizeof(pHeader), (void *)&byteswritten) != FR_OK) {
 8019316:	ab09      	add	r3, sp, #36	; 0x24
 8019318:	a90a      	add	r1, sp, #40	; 0x28
 801931a:	2219      	movs	r2, #25
 801931c:	4855      	ldr	r0, [pc, #340]	; (8019474 <DATALOG_SD_LogMems_Enable+0x338>)
 801931e:	f7fc fbe1 	bl	8015ae4 <f_write>
 8019322:	2800      	cmp	r0, #0
 8019324:	d1be      	bne.n	80192a4 <DATALOG_SD_LogMems_Enable+0x168>
  return 1;
 8019326:	2001      	movs	r0, #1
}
 8019328:	f50d 7d0b 	add.w	sp, sp, #556	; 0x22c
 801932c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    sprintf(FileName, "%s-Ann_%02d_%s_%02d_%02dh_%02dm_%02ds.csv",
 8019330:	495b      	ldr	r1, [pc, #364]	; (80194a0 <DATALOG_SD_LogMems_Enable+0x364>)
 8019332:	484e      	ldr	r0, [pc, #312]	; (801946c <DATALOG_SD_LogMems_Enable+0x330>)
 8019334:	f006 f930 	bl	801f598 <siprintf>
 8019338:	e724      	b.n	8019184 <DATALOG_SD_LogMems_Enable+0x48>
    SD_IO_CS_Init();
 801933a:	f7f5 f9bb 	bl	800e6b4 <SD_IO_CS_Init>
 801933e:	e705      	b.n	801914c <DATALOG_SD_LogMems_Enable+0x10>
        return 0;
 8019340:	4628      	mov	r0, r5
        SD_LogMems_Enabled= 0;
 8019342:	f8c6 526c 	str.w	r5, [r6, #620]	; 0x26c
}
 8019346:	f50d 7d0b 	add.w	sp, sp, #556	; 0x22c
 801934a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(f_write(&MyFileMems, (const void*)Header, CharPosHeader, (void *)&byteswritten) != FR_OK) {
 801934e:	ab09      	add	r3, sp, #36	; 0x24
 8019350:	f108 0201 	add.w	r2, r8, #1
 8019354:	a90a      	add	r1, sp, #40	; 0x28
 8019356:	4847      	ldr	r0, [pc, #284]	; (8019474 <DATALOG_SD_LogMems_Enable+0x338>)
 8019358:	f7fc fbc4 	bl	8015ae4 <f_write>
 801935c:	2800      	cmp	r0, #0
 801935e:	d1a1      	bne.n	80192a4 <DATALOG_SD_LogMems_Enable+0x168>
 8019360:	e7e1      	b.n	8019326 <DATALOG_SD_LogMems_Enable+0x1ea>
      CharPosIntro += sprintf(Introduction+CharPosIntro,"H@%ld.%ld ",EnvHz,EnvSubHz);
 8019362:	465b      	mov	r3, fp
 8019364:	4670      	mov	r0, lr
 8019366:	494f      	ldr	r1, [pc, #316]	; (80194a4 <DATALOG_SD_LogMems_Enable+0x368>)
 8019368:	9a07      	ldr	r2, [sp, #28]
 801936a:	f006 f915 	bl	801f598 <siprintf>
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", H [%]");
 801936e:	4b4e      	ldr	r3, [pc, #312]	; (80194a8 <DATALOG_SD_LogMems_Enable+0x36c>)
      CharPosIntro += sprintf(Introduction+CharPosIntro,"H@%ld.%ld ",EnvHz,EnvSubHz);
 8019370:	4405      	add	r5, r0
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", H [%]");
 8019372:	cb03      	ldmia	r3!, {r0, r1}
 8019374:	ab4a      	add	r3, sp, #296	; 0x128
 8019376:	f108 0807 	add.w	r8, r8, #7
 801937a:	eb03 0e05 	add.w	lr, r3, r5
 801937e:	ab0a      	add	r3, sp, #40	; 0x28
 8019380:	6020      	str	r0, [r4, #0]
 8019382:	6061      	str	r1, [r4, #4]
 8019384:	eb03 0408 	add.w	r4, r3, r8
 8019388:	e77a      	b.n	8019280 <DATALOG_SD_LogMems_Enable+0x144>
      CharPosIntro += sprintf(Introduction+CharPosIntro,"T2@%ld.%ld ",EnvHz,EnvSubHz);
 801938a:	4670      	mov	r0, lr
 801938c:	465b      	mov	r3, fp
 801938e:	4947      	ldr	r1, [pc, #284]	; (80194ac <DATALOG_SD_LogMems_Enable+0x370>)
 8019390:	9a07      	ldr	r2, [sp, #28]
 8019392:	f006 f901 	bl	801f598 <siprintf>
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", T2 ['C]");
 8019396:	4b46      	ldr	r3, [pc, #280]	; (80194b0 <DATALOG_SD_LogMems_Enable+0x374>)
 8019398:	f8d6 c268 	ldr.w	ip, [r6, #616]	; 0x268
      CharPosIntro += sprintf(Introduction+CharPosIntro,"T2@%ld.%ld ",EnvHz,EnvSubHz);
 801939c:	4405      	add	r5, r0
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", T2 ['C]");
 801939e:	cb03      	ldmia	r3!, {r0, r1}
 80193a0:	881b      	ldrh	r3, [r3, #0]
 80193a2:	8123      	strh	r3, [r4, #8]
 80193a4:	ab4a      	add	r3, sp, #296	; 0x128
 80193a6:	f108 0809 	add.w	r8, r8, #9
 80193aa:	eb03 0e05 	add.w	lr, r3, r5
 80193ae:	ab0a      	add	r3, sp, #40	; 0x28
 80193b0:	6020      	str	r0, [r4, #0]
 80193b2:	6061      	str	r1, [r4, #4]
 80193b4:	eb03 0408 	add.w	r4, r3, r8
 80193b8:	e75f      	b.n	801927a <DATALOG_SD_LogMems_Enable+0x13e>
      CharPosIntro += sprintf(Introduction+CharPosIntro,"T1@%ld.%ld ",EnvHz,EnvSubHz);
 80193ba:	4670      	mov	r0, lr
 80193bc:	465b      	mov	r3, fp
 80193be:	493d      	ldr	r1, [pc, #244]	; (80194b4 <DATALOG_SD_LogMems_Enable+0x378>)
 80193c0:	9a07      	ldr	r2, [sp, #28]
 80193c2:	f006 f8e9 	bl	801f598 <siprintf>
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", T1 ['C]");
 80193c6:	4b3c      	ldr	r3, [pc, #240]	; (80194b8 <DATALOG_SD_LogMems_Enable+0x37c>)
 80193c8:	f8d6 c268 	ldr.w	ip, [r6, #616]	; 0x268
      CharPosIntro += sprintf(Introduction+CharPosIntro,"T1@%ld.%ld ",EnvHz,EnvSubHz);
 80193cc:	4405      	add	r5, r0
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", T1 ['C]");
 80193ce:	cb03      	ldmia	r3!, {r0, r1}
 80193d0:	881b      	ldrh	r3, [r3, #0]
 80193d2:	8123      	strh	r3, [r4, #8]
 80193d4:	ab4a      	add	r3, sp, #296	; 0x128
 80193d6:	f108 0809 	add.w	r8, r8, #9
 80193da:	eb03 0e05 	add.w	lr, r3, r5
 80193de:	ab0a      	add	r3, sp, #40	; 0x28
 80193e0:	6020      	str	r0, [r4, #0]
 80193e2:	6061      	str	r1, [r4, #4]
 80193e4:	eb03 0408 	add.w	r4, r3, r8
 80193e8:	e743      	b.n	8019272 <DATALOG_SD_LogMems_Enable+0x136>
      CharPosIntro += sprintf(Introduction+CharPosIntro,"P@%ld.%ld ",EnvHz,EnvSubHz);
 80193ea:	4670      	mov	r0, lr
 80193ec:	465b      	mov	r3, fp
 80193ee:	4933      	ldr	r1, [pc, #204]	; (80194bc <DATALOG_SD_LogMems_Enable+0x380>)
 80193f0:	9a07      	ldr	r2, [sp, #28]
 80193f2:	f006 f8d1 	bl	801f598 <siprintf>
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", P [mB]");
 80193f6:	4b32      	ldr	r3, [pc, #200]	; (80194c0 <DATALOG_SD_LogMems_Enable+0x384>)
 80193f8:	f8d6 c268 	ldr.w	ip, [r6, #616]	; 0x268
      CharPosIntro += sprintf(Introduction+CharPosIntro,"P@%ld.%ld ",EnvHz,EnvSubHz);
 80193fc:	4405      	add	r5, r0
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", P [mB]");
 80193fe:	cb03      	ldmia	r3!, {r0, r1}
 8019400:	781b      	ldrb	r3, [r3, #0]
 8019402:	7223      	strb	r3, [r4, #8]
 8019404:	ab4a      	add	r3, sp, #296	; 0x128
 8019406:	f108 0808 	add.w	r8, r8, #8
 801940a:	eb03 0e05 	add.w	lr, r3, r5
 801940e:	ab0a      	add	r3, sp, #40	; 0x28
 8019410:	6020      	str	r0, [r4, #0]
 8019412:	6061      	str	r1, [r4, #4]
 8019414:	eb03 0408 	add.w	r4, r3, r8
 8019418:	e727      	b.n	801926a <DATALOG_SD_LogMems_Enable+0x12e>
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Mag@%ld.%ld ",IneHz,IneSubHz);
 801941a:	4653      	mov	r3, sl
 801941c:	464a      	mov	r2, r9
 801941e:	4670      	mov	r0, lr
 8019420:	4928      	ldr	r1, [pc, #160]	; (80194c4 <DATALOG_SD_LogMems_Enable+0x388>)
 8019422:	f006 f8b9 	bl	801f598 <siprintf>
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", MagX [mgauss], MagY, MagZ");
 8019426:	f8df e0a8 	ldr.w	lr, [pc, #168]	; 80194d0 <DATALOG_SD_LogMems_Enable+0x394>
 801942a:	f8d6 c268 	ldr.w	ip, [r6, #616]	; 0x268
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Mag@%ld.%ld ",IneHz,IneSubHz);
 801942e:	4405      	add	r5, r0
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", MagX [mgauss], MagY, MagZ");
 8019430:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8019434:	6020      	str	r0, [r4, #0]
 8019436:	6061      	str	r1, [r4, #4]
 8019438:	60a2      	str	r2, [r4, #8]
 801943a:	e8be 0007 	ldmia.w	lr!, {r0, r1, r2}
 801943e:	60e3      	str	r3, [r4, #12]
 8019440:	ab4a      	add	r3, sp, #296	; 0x128
 8019442:	f108 081b 	add.w	r8, r8, #27
 8019446:	eb03 0e05 	add.w	lr, r3, r5
 801944a:	ab0a      	add	r3, sp, #40	; 0x28
 801944c:	6120      	str	r0, [r4, #16]
 801944e:	6161      	str	r1, [r4, #20]
 8019450:	61a2      	str	r2, [r4, #24]
 8019452:	eb03 0408 	add.w	r4, r3, r8
 8019456:	e704      	b.n	8019262 <DATALOG_SD_LogMems_Enable+0x126>
 8019458:	20013274 	.word	0x20013274
 801945c:	20012f24 	.word	0x20012f24
 8019460:	08075314 	.word	0x08075314
 8019464:	2001144c 	.word	0x2001144c
 8019468:	08075570 	.word	0x08075570
 801946c:	2000f514 	.word	0x2000f514
 8019470:	2000f074 	.word	0x2000f074
 8019474:	2000f2e4 	.word	0x2000f2e4
 8019478:	200014a0 	.word	0x200014a0
 801947c:	080755e4 	.word	0x080755e4
 8019480:	08075600 	.word	0x08075600
 8019484:	08075540 	.word	0x08075540
 8019488:	20010030 	.word	0x20010030
 801948c:	20013174 	.word	0x20013174
 8019490:	200132a0 	.word	0x200132a0
 8019494:	08075710 	.word	0x08075710
 8019498:	20011458 	.word	0x20011458
 801949c:	080755b0 	.word	0x080755b0
 80194a0:	08075544 	.word	0x08075544
 80194a4:	080756fc 	.word	0x080756fc
 80194a8:	08075708 	.word	0x08075708
 80194ac:	080756e4 	.word	0x080756e4
 80194b0:	080756f0 	.word	0x080756f0
 80194b4:	080756cc 	.word	0x080756cc
 80194b8:	080756d8 	.word	0x080756d8
 80194bc:	080756b4 	.word	0x080756b4
 80194c0:	080756c0 	.word	0x080756c0
 80194c4:	08075688 	.word	0x08075688
 80194c8:	080755a0 	.word	0x080755a0
 80194cc:	cccccccd 	.word	0xcccccccd
 80194d0:	08075698 	.word	0x08075698
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Gyro@%ld.%ld ",IneHz,IneSubHz);
 80194d4:	4670      	mov	r0, lr
 80194d6:	4653      	mov	r3, sl
 80194d8:	464a      	mov	r2, r9
 80194da:	4923      	ldr	r1, [pc, #140]	; (8019568 <DATALOG_SD_LogMems_Enable+0x42c>)
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", GyroX [mdps], GyroY, GyroZ");
 80194dc:	4f23      	ldr	r7, [pc, #140]	; (801956c <DATALOG_SD_LogMems_Enable+0x430>)
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Gyro@%ld.%ld ",IneHz,IneSubHz);
 80194de:	f006 f85b 	bl	801f598 <siprintf>
 80194e2:	4405      	add	r5, r0
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", GyroX [mdps], GyroY, GyroZ");
 80194e4:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 80194e6:	f10d 0e28 	add.w	lr, sp, #40	; 0x28
 80194ea:	f8d6 c268 	ldr.w	ip, [r6, #616]	; 0x268
 80194ee:	f84e 0008 	str.w	r0, [lr, r8]
 80194f2:	6061      	str	r1, [r4, #4]
 80194f4:	60a2      	str	r2, [r4, #8]
 80194f6:	cf07      	ldmia	r7!, {r0, r1, r2}
 80194f8:	60e3      	str	r3, [r4, #12]
 80194fa:	f897 e000 	ldrb.w	lr, [r7]
 80194fe:	f884 e01c 	strb.w	lr, [r4, #28]
 8019502:	ab4a      	add	r3, sp, #296	; 0x128
 8019504:	f108 081c 	add.w	r8, r8, #28
 8019508:	eb03 0e05 	add.w	lr, r3, r5
 801950c:	ab0a      	add	r3, sp, #40	; 0x28
 801950e:	6120      	str	r0, [r4, #16]
 8019510:	6161      	str	r1, [r4, #20]
 8019512:	61a2      	str	r2, [r4, #24]
 8019514:	eb03 0408 	add.w	r4, r3, r8
 8019518:	e69f      	b.n	801925a <DATALOG_SD_LogMems_Enable+0x11e>
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Acc@%ld.%ld ",IneHz,IneSubHz);
 801951a:	4670      	mov	r0, lr
 801951c:	4653      	mov	r3, sl
 801951e:	464a      	mov	r2, r9
 8019520:	4913      	ldr	r1, [pc, #76]	; (8019570 <DATALOG_SD_LogMems_Enable+0x434>)
 8019522:	f006 f839 	bl	801f598 <siprintf>
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", AccX [mg], AccY, AccZ");
 8019526:	f8df e054 	ldr.w	lr, [pc, #84]	; 801957c <DATALOG_SD_LogMems_Enable+0x440>
 801952a:	f8d6 c268 	ldr.w	ip, [r6, #616]	; 0x268
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Acc@%ld.%ld ",IneHz,IneSubHz);
 801952e:	4405      	add	r5, r0
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", AccX [mg], AccY, AccZ");
 8019530:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8019534:	ac10      	add	r4, sp, #64	; 0x40
 8019536:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019538:	e89e 0003 	ldmia.w	lr, {r0, r1}
 801953c:	ab4a      	add	r3, sp, #296	; 0x128
 801953e:	eb03 0e05 	add.w	lr, r3, r5
 8019542:	e884 0003 	stmia.w	r4, {r0, r1}
 8019546:	f04f 082f 	mov.w	r8, #47	; 0x2f
 801954a:	e67f      	b.n	801924c <DATALOG_SD_LogMems_Enable+0x110>
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Mic@%d Volume=%ld ",AUDIO_SAMPLING_FREQUENCY,TargetBoardFeatures.AudioVolume);
 801954c:	4b09      	ldr	r3, [pc, #36]	; (8019574 <DATALOG_SD_LogMems_Enable+0x438>)
 801954e:	490a      	ldr	r1, [pc, #40]	; (8019578 <DATALOG_SD_LogMems_Enable+0x43c>)
 8019550:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8019552:	f44f 527a 	mov.w	r2, #16000	; 0x3e80
 8019556:	f20d 1043 	addw	r0, sp, #323	; 0x143
 801955a:	f006 f81d 	bl	801f598 <siprintf>
 801955e:	f8d6 c268 	ldr.w	ip, [r6, #616]	; 0x268
 8019562:	f100 051b 	add.w	r5, r0, #27
 8019566:	e668      	b.n	801923a <DATALOG_SD_LogMems_Enable+0xfe>
 8019568:	08075658 	.word	0x08075658
 801956c:	08075668 	.word	0x08075668
 8019570:	08075630 	.word	0x08075630
 8019574:	20011458 	.word	0x20011458
 8019578:	0807561c 	.word	0x0807561c
 801957c:	08075640 	.word	0x08075640

08019580 <AudioProcess_SD_Recording>:
{
 8019580:	b430      	push	{r4, r5}
 8019582:	4c18      	ldr	r4, [pc, #96]	; (80195e4 <AudioProcess_SD_Recording+0x64>)
 8019584:	4a18      	ldr	r2, [pc, #96]	; (80195e8 <AudioProcess_SD_Recording+0x68>)
 8019586:	f8b4 34e0 	ldrh.w	r3, [r4, #1248]	; 0x4e0
 801958a:	f102 0520 	add.w	r5, r2, #32
    Audio_OUT_Buff[OUT_Buff_lvl] = PCM_Buffer[index*AUDIO_CHANNELS];
 801958e:	f832 0f02 	ldrh.w	r0, [r2, #2]!
 8019592:	eb04 0143 	add.w	r1, r4, r3, lsl #1
  for (index = 0; index < PCM_AUDIO_IN_SAMPLES ; index++) {
 8019596:	42aa      	cmp	r2, r5
    OUT_Buff_lvl = (OUT_Buff_lvl + 1)%AUDIO_BUFF_SIZE;
 8019598:	f103 0301 	add.w	r3, r3, #1
    Audio_OUT_Buff[OUT_Buff_lvl] = PCM_Buffer[index*AUDIO_CHANNELS];
 801959c:	f8a1 04e4 	strh.w	r0, [r1, #1252]	; 0x4e4
    OUT_Buff_lvl = (OUT_Buff_lvl + 1)%AUDIO_BUFF_SIZE;
 80195a0:	f3c3 0309 	ubfx	r3, r3, #0, #10
  for (index = 0; index < PCM_AUDIO_IN_SAMPLES ; index++) {
 80195a4:	d1f3      	bne.n	801958e <AudioProcess_SD_Recording+0xe>
  if(OUT_Buff_lvl == (AUDIO_BUFF_SIZE/2)){
 80195a6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80195aa:	f8a4 34e0 	strh.w	r3, [r4, #1248]	; 0x4e0
 80195ae:	d00d      	beq.n	80195cc <AudioProcess_SD_Recording+0x4c>
  } else if (OUT_Buff_lvl == 0) {
 80195b0:	b9b3      	cbnz	r3, 80195e0 <AudioProcess_SD_Recording+0x60>
    if(semRun) {
 80195b2:	4b0e      	ldr	r3, [pc, #56]	; (80195ec <AudioProcess_SD_Recording+0x6c>)
 80195b4:	6818      	ldr	r0, [r3, #0]
    index_buff= AUDIO_BUFF_SIZE/2;
 80195b6:	f44f 7200 	mov.w	r2, #512	; 0x200
    writeAudio_flag=1;
 80195ba:	2301      	movs	r3, #1
    index_buff= AUDIO_BUFF_SIZE/2;
 80195bc:	f8c4 2ce4 	str.w	r2, [r4, #3300]	; 0xce4
    writeAudio_flag=1;
 80195c0:	f884 3ce8 	strb.w	r3, [r4, #3304]	; 0xce8
    if(semRun) {
 80195c4:	b160      	cbz	r0, 80195e0 <AudioProcess_SD_Recording+0x60>
}
 80195c6:	bc30      	pop	{r4, r5}
      osSemaphoreRelease(semRun); 
 80195c8:	f7fc bf28 	b.w	801641c <osSemaphoreRelease>
    if(semRun) {
 80195cc:	4b07      	ldr	r3, [pc, #28]	; (80195ec <AudioProcess_SD_Recording+0x6c>)
 80195ce:	6818      	ldr	r0, [r3, #0]
    index_buff=0;
 80195d0:	2200      	movs	r2, #0
    writeAudio_flag=1;
 80195d2:	2301      	movs	r3, #1
    index_buff=0;
 80195d4:	f8c4 2ce4 	str.w	r2, [r4, #3300]	; 0xce4
    writeAudio_flag=1;
 80195d8:	f884 3ce8 	strb.w	r3, [r4, #3304]	; 0xce8
    if(semRun) {
 80195dc:	2800      	cmp	r0, #0
 80195de:	d1f2      	bne.n	80195c6 <AudioProcess_SD_Recording+0x46>
}
 80195e0:	bc30      	pop	{r4, r5}
 80195e2:	4770      	bx	lr
 80195e4:	2000f074 	.word	0x2000f074
 80195e8:	2001149a 	.word	0x2001149a
 80195ec:	200132a4 	.word	0x200132a4

080195f0 <SD_CardLoggingMemsStop>:
{
 80195f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(IsSdMemsRecording) {
 80195f2:	4c41      	ldr	r4, [pc, #260]	; (80196f8 <SD_CardLoggingMemsStop+0x108>)
 80195f4:	f8d4 3cec 	ldr.w	r3, [r4, #3308]	; 0xcec
 80195f8:	bb1b      	cbnz	r3, 8019642 <SD_CardLoggingMemsStop+0x52>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 80195fa:	4b40      	ldr	r3, [pc, #256]	; (80196fc <SD_CardLoggingMemsStop+0x10c>)
 80195fc:	681b      	ldr	r3, [r3, #0]
 80195fe:	065b      	lsls	r3, r3, #25
 8019600:	d406      	bmi.n	8019610 <SD_CardLoggingMemsStop+0x20>
  PowerCtrlUnLock();
 8019602:	f000 feff 	bl	801a404 <PowerCtrlUnLock>
  BSP_LED_Init( LED1 );
 8019606:	2000      	movs	r0, #0
}
 8019608:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  BSP_LED_Init( LED1 );
 801960c:	f7f4 bcc8 	b.w	800dfa0 <BSP_LED_Init>
      BytesToWrite =sprintf((char *)BufferToWrite,"5 None Data Log MEMS\n");
 8019610:	4c3b      	ldr	r4, [pc, #236]	; (8019700 <SD_CardLoggingMemsStop+0x110>)
 8019612:	4d3c      	ldr	r5, [pc, #240]	; (8019704 <SD_CardLoggingMemsStop+0x114>)
 8019614:	4f3c      	ldr	r7, [pc, #240]	; (8019708 <SD_CardLoggingMemsStop+0x118>)
 8019616:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8019618:	2615      	movs	r6, #21
 801961a:	6028      	str	r0, [r5, #0]
 801961c:	6820      	ldr	r0, [r4, #0]
 801961e:	88a4      	ldrh	r4, [r4, #4]
 8019620:	6069      	str	r1, [r5, #4]
 8019622:	6128      	str	r0, [r5, #16]
 8019624:	60aa      	str	r2, [r5, #8]
      Stderr_Update(BufferToWrite,BytesToWrite);
 8019626:	4631      	mov	r1, r6
      BytesToWrite =sprintf((char *)BufferToWrite,"5 None Data Log MEMS\n");
 8019628:	60eb      	str	r3, [r5, #12]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801962a:	4628      	mov	r0, r5
      BytesToWrite =sprintf((char *)BufferToWrite,"5 None Data Log MEMS\n");
 801962c:	82ac      	strh	r4, [r5, #20]
 801962e:	603e      	str	r6, [r7, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 8019630:	f002 fc02 	bl	801be38 <Stderr_Update>
  PowerCtrlUnLock();
 8019634:	f000 fee6 	bl	801a404 <PowerCtrlUnLock>
  BSP_LED_Init( LED1 );
 8019638:	2000      	movs	r0, #0
}
 801963a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  BSP_LED_Init( LED1 );
 801963e:	f7f4 bcaf 	b.w	800dfa0 <BSP_LED_Init>
    stopProc(SD_CARD_LOGGING);
 8019642:	200e      	movs	r0, #14
 8019644:	f001 fa2a 	bl	801aa9c <stopProc>
  if(SD_LogMems_Enabled) {
 8019648:	f8d4 326c 	ldr.w	r3, [r4, #620]	; 0x26c
    IsSdMemsRecording= 0;
 801964c:	2500      	movs	r5, #0
 801964e:	f8c4 5cec 	str.w	r5, [r4, #3308]	; 0xcec
  if(SD_LogMems_Enabled) {
 8019652:	bb83      	cbnz	r3, 80196b6 <SD_CardLoggingMemsStop+0xc6>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 8019654:	4b29      	ldr	r3, [pc, #164]	; (80196fc <SD_CardLoggingMemsStop+0x10c>)
 8019656:	681b      	ldr	r3, [r3, #0]
 8019658:	069d      	lsls	r5, r3, #26
 801965a:	d41a      	bmi.n	8019692 <SD_CardLoggingMemsStop+0xa2>
      (SD_Card_FeaturesMask & FEATURE_MASK_GRYO) ||
 801965c:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
    if((SD_Card_FeaturesMask & FEATURE_MASK_ACC)  ||
 8019660:	f413 0f60 	tst.w	r3, #14680064	; 0xe00000
 8019664:	d009      	beq.n	801967a <SD_CardLoggingMemsStop+0x8a>
      if(SD_Card_FeaturesMask & FEATURE_MASK_ACC) {
 8019666:	0218      	lsls	r0, r3, #8
 8019668:	d43c      	bmi.n	80196e4 <SD_CardLoggingMemsStop+0xf4>
      if(SD_Card_FeaturesMask & FEATURE_MASK_GRYO) {
 801966a:	0259      	lsls	r1, r3, #9
 801966c:	d431      	bmi.n	80196d2 <SD_CardLoggingMemsStop+0xe2>
      if(SD_Card_FeaturesMask & FEATURE_MASK_MAG) {
 801966e:	029a      	lsls	r2, r3, #10
 8019670:	d428      	bmi.n	80196c4 <SD_CardLoggingMemsStop+0xd4>
      disableMotionSensors();
 8019672:	f001 f845 	bl	801a700 <disableMotionSensors>
 8019676:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
    if( (SD_Card_FeaturesMask & FEATURE_MASK_PRESS) ||
 801967a:	f413 1fe8 	tst.w	r3, #1900544	; 0x1d0000
 801967e:	d0c0      	beq.n	8019602 <SD_CardLoggingMemsStop+0x12>
      disableEnvSensors ();
 8019680:	f001 f87a 	bl	801a778 <disableEnvSensors>
  PowerCtrlUnLock();
 8019684:	f000 febe 	bl	801a404 <PowerCtrlUnLock>
  BSP_LED_Init( LED1 );
 8019688:	2000      	movs	r0, #0
}
 801968a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  BSP_LED_Init( LED1 );
 801968e:	f7f4 bc87 	b.w	800dfa0 <BSP_LED_Init>
      BytesToWrite =sprintf((char *)BufferToWrite,"Stop Data Log MEMS Rec\n");
 8019692:	4d1e      	ldr	r5, [pc, #120]	; (801970c <SD_CardLoggingMemsStop+0x11c>)
 8019694:	4e1b      	ldr	r6, [pc, #108]	; (8019704 <SD_CardLoggingMemsStop+0x114>)
 8019696:	4f1c      	ldr	r7, [pc, #112]	; (8019708 <SD_CardLoggingMemsStop+0x118>)
 8019698:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801969a:	6030      	str	r0, [r6, #0]
 801969c:	6071      	str	r1, [r6, #4]
 801969e:	cd03      	ldmia	r5!, {r0, r1}
 80196a0:	2517      	movs	r5, #23
 80196a2:	6130      	str	r0, [r6, #16]
 80196a4:	6171      	str	r1, [r6, #20]
      Term_Update(BufferToWrite,BytesToWrite);
 80196a6:	4630      	mov	r0, r6
 80196a8:	4629      	mov	r1, r5
      BytesToWrite =sprintf((char *)BufferToWrite,"Stop Data Log MEMS Rec\n");
 80196aa:	60b2      	str	r2, [r6, #8]
 80196ac:	60f3      	str	r3, [r6, #12]
 80196ae:	603d      	str	r5, [r7, #0]
      Term_Update(BufferToWrite,BytesToWrite);
 80196b0:	f002 fbf4 	bl	801be9c <Term_Update>
 80196b4:	e7d2      	b.n	801965c <SD_CardLoggingMemsStop+0x6c>
    DATALOG_SD_LogMems_Disable(SomethingAlreadyRecording);
 80196b6:	f8d4 0cf0 	ldr.w	r0, [r4, #3312]	; 0xcf0
 80196ba:	f7ff fd23 	bl	8019104 <DATALOG_SD_LogMems_Disable>
    SD_LogMems_Enabled=0;
 80196be:	f8c4 526c 	str.w	r5, [r4, #620]	; 0x26c
 80196c2:	e7c7      	b.n	8019654 <SD_CardLoggingMemsStop+0x64>
        BSP_MAGNETO_Set_ODR_Value(TargetBoardFeatures.HandleMagSensor,TargetBoardFeatures.DefaultMagODR);
 80196c4:	4b12      	ldr	r3, [pc, #72]	; (8019710 <SD_CardLoggingMemsStop+0x120>)
 80196c6:	ed93 0a0b 	vldr	s0, [r3, #44]	; 0x2c
 80196ca:	6a18      	ldr	r0, [r3, #32]
 80196cc:	f7f6 fc02 	bl	800fed4 <BSP_MAGNETO_Set_ODR_Value>
 80196d0:	e7cf      	b.n	8019672 <SD_CardLoggingMemsStop+0x82>
        BSP_GYRO_Set_ODR_Value(TargetBoardFeatures.HandleGyroSensor,TargetBoardFeatures.DefaultGyroODR);
 80196d2:	4b0f      	ldr	r3, [pc, #60]	; (8019710 <SD_CardLoggingMemsStop+0x120>)
 80196d4:	ed93 0a0a 	vldr	s0, [r3, #40]	; 0x28
 80196d8:	69d8      	ldr	r0, [r3, #28]
 80196da:	f7f6 fb53 	bl	800fd84 <BSP_GYRO_Set_ODR_Value>
 80196de:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
 80196e2:	e7c4      	b.n	801966e <SD_CardLoggingMemsStop+0x7e>
        BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,TargetBoardFeatures.DefaultAccODR);
 80196e4:	4b0a      	ldr	r3, [pc, #40]	; (8019710 <SD_CardLoggingMemsStop+0x120>)
 80196e6:	ed93 0a09 	vldr	s0, [r3, #36]	; 0x24
 80196ea:	6998      	ldr	r0, [r3, #24]
 80196ec:	f7f5 fa34 	bl	800eb58 <BSP_ACCELERO_Set_ODR_Value>
 80196f0:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
 80196f4:	e7b9      	b.n	801966a <SD_CardLoggingMemsStop+0x7a>
 80196f6:	bf00      	nop
 80196f8:	2000f074 	.word	0x2000f074
 80196fc:	20010030 	.word	0x20010030
 8019700:	08075744 	.word	0x08075744
 8019704:	20013174 	.word	0x20013174
 8019708:	200132a0 	.word	0x200132a0
 801970c:	0807572c 	.word	0x0807572c
 8019710:	20011458 	.word	0x20011458

08019714 <SD_CardLoggingAudioStop>:
{
 8019714:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(IsSdAudioRecording) {
 8019716:	4c2c      	ldr	r4, [pc, #176]	; (80197c8 <SD_CardLoggingAudioStop+0xb4>)
 8019718:	f8d4 3cf0 	ldr.w	r3, [r4, #3312]	; 0xcf0
 801971c:	bb3b      	cbnz	r3, 801976e <SD_CardLoggingAudioStop+0x5a>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801971e:	4b2b      	ldr	r3, [pc, #172]	; (80197cc <SD_CardLoggingAudioStop+0xb8>)
 8019720:	681b      	ldr	r3, [r3, #0]
 8019722:	065b      	lsls	r3, r3, #25
 8019724:	d406      	bmi.n	8019734 <SD_CardLoggingAudioStop+0x20>
  PowerCtrlUnLock();
 8019726:	f000 fe6d 	bl	801a404 <PowerCtrlUnLock>
  BSP_LED_Init( LED1 );
 801972a:	2000      	movs	r0, #0
}
 801972c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  BSP_LED_Init( LED1 );
 8019730:	f7f4 bc36 	b.w	800dfa0 <BSP_LED_Init>
      BytesToWrite =sprintf((char *)BufferToWrite,"6 None Data Log Audio\n");
 8019734:	4c26      	ldr	r4, [pc, #152]	; (80197d0 <SD_CardLoggingAudioStop+0xbc>)
 8019736:	4d27      	ldr	r5, [pc, #156]	; (80197d4 <SD_CardLoggingAudioStop+0xc0>)
 8019738:	4f27      	ldr	r7, [pc, #156]	; (80197d8 <SD_CardLoggingAudioStop+0xc4>)
 801973a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801973c:	2616      	movs	r6, #22
 801973e:	f8b4 c004 	ldrh.w	ip, [r4, #4]
 8019742:	6028      	str	r0, [r5, #0]
 8019744:	6820      	ldr	r0, [r4, #0]
 8019746:	79a4      	ldrb	r4, [r4, #6]
 8019748:	6069      	str	r1, [r5, #4]
 801974a:	6128      	str	r0, [r5, #16]
 801974c:	60aa      	str	r2, [r5, #8]
 801974e:	60eb      	str	r3, [r5, #12]
      Stderr_Update(BufferToWrite,BytesToWrite);
 8019750:	4631      	mov	r1, r6
      BytesToWrite =sprintf((char *)BufferToWrite,"6 None Data Log Audio\n");
 8019752:	f8a5 c014 	strh.w	ip, [r5, #20]
      Stderr_Update(BufferToWrite,BytesToWrite);
 8019756:	4628      	mov	r0, r5
      BytesToWrite =sprintf((char *)BufferToWrite,"6 None Data Log Audio\n");
 8019758:	75ac      	strb	r4, [r5, #22]
 801975a:	603e      	str	r6, [r7, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801975c:	f002 fb6c 	bl	801be38 <Stderr_Update>
  PowerCtrlUnLock();
 8019760:	f000 fe50 	bl	801a404 <PowerCtrlUnLock>
  BSP_LED_Init( LED1 );
 8019764:	2000      	movs	r0, #0
}
 8019766:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  BSP_LED_Init( LED1 );
 801976a:	f7f4 bc19 	b.w	800dfa0 <BSP_LED_Init>
    DeInitMics();
 801976e:	f001 f835 	bl	801a7dc <DeInitMics>
  if(SD_LogAudio_Enabled) {
 8019772:	6823      	ldr	r3, [r4, #0]
    writeAudio_flag=0;
 8019774:	2500      	movs	r5, #0
 8019776:	f884 5ce8 	strb.w	r5, [r4, #3304]	; 0xce8
    IsSdAudioRecording= 0;
 801977a:	f8c4 5cf0 	str.w	r5, [r4, #3312]	; 0xcf0
  if(SD_LogAudio_Enabled) {
 801977e:	b9eb      	cbnz	r3, 80197bc <SD_CardLoggingAudioStop+0xa8>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 8019780:	4b12      	ldr	r3, [pc, #72]	; (80197cc <SD_CardLoggingAudioStop+0xb8>)
 8019782:	681b      	ldr	r3, [r3, #0]
 8019784:	069a      	lsls	r2, r3, #26
 8019786:	d5ce      	bpl.n	8019726 <SD_CardLoggingAudioStop+0x12>
      BytesToWrite =sprintf((char *)BufferToWrite,"Stop Data Log Audio Rec\n");
 8019788:	4c14      	ldr	r4, [pc, #80]	; (80197dc <SD_CardLoggingAudioStop+0xc8>)
 801978a:	4d12      	ldr	r5, [pc, #72]	; (80197d4 <SD_CardLoggingAudioStop+0xc0>)
 801978c:	4f12      	ldr	r7, [pc, #72]	; (80197d8 <SD_CardLoggingAudioStop+0xc4>)
 801978e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8019790:	6028      	str	r0, [r5, #0]
 8019792:	6069      	str	r1, [r5, #4]
 8019794:	cc03      	ldmia	r4!, {r0, r1}
 8019796:	2618      	movs	r6, #24
 8019798:	7824      	ldrb	r4, [r4, #0]
 801979a:	6128      	str	r0, [r5, #16]
 801979c:	6169      	str	r1, [r5, #20]
 801979e:	60aa      	str	r2, [r5, #8]
      Term_Update(BufferToWrite,BytesToWrite);
 80197a0:	4631      	mov	r1, r6
      BytesToWrite =sprintf((char *)BufferToWrite,"Stop Data Log Audio Rec\n");
 80197a2:	60eb      	str	r3, [r5, #12]
      Term_Update(BufferToWrite,BytesToWrite);
 80197a4:	4628      	mov	r0, r5
      BytesToWrite =sprintf((char *)BufferToWrite,"Stop Data Log Audio Rec\n");
 80197a6:	762c      	strb	r4, [r5, #24]
 80197a8:	603e      	str	r6, [r7, #0]
      Term_Update(BufferToWrite,BytesToWrite);
 80197aa:	f002 fb77 	bl	801be9c <Term_Update>
  PowerCtrlUnLock();
 80197ae:	f000 fe29 	bl	801a404 <PowerCtrlUnLock>
  BSP_LED_Init( LED1 );
 80197b2:	2000      	movs	r0, #0
}
 80197b4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  BSP_LED_Init( LED1 );
 80197b8:	f7f4 bbf2 	b.w	800dfa0 <BSP_LED_Init>
    DATALOG_SD_LogAudio_Disable(SomethingAlreadyRecording);
 80197bc:	f8d4 0cec 	ldr.w	r0, [r4, #3308]	; 0xcec
 80197c0:	f7ff fab0 	bl	8018d24 <DATALOG_SD_LogAudio_Disable>
    SD_LogAudio_Enabled=0;
 80197c4:	6025      	str	r5, [r4, #0]
 80197c6:	e7db      	b.n	8019780 <SD_CardLoggingAudioStop+0x6c>
 80197c8:	2000f074 	.word	0x2000f074
 80197cc:	20010030 	.word	0x20010030
 80197d0:	08075778 	.word	0x08075778
 80197d4:	20013174 	.word	0x20013174
 80197d8:	200132a0 	.word	0x200132a0
 80197dc:	0807575c 	.word	0x0807575c

080197e0 <DATALOG_SD_Init>:
{   
 80197e0:	b508      	push	{r3, lr}
  if(FATFS_LinkDriver(&SD_Driver, SDPath) == 0) {
 80197e2:	490d      	ldr	r1, [pc, #52]	; (8019818 <DATALOG_SD_Init+0x38>)
 80197e4:	480d      	ldr	r0, [pc, #52]	; (801981c <DATALOG_SD_Init+0x3c>)
 80197e6:	f7fc fc5f 	bl	80160a8 <FATFS_LinkDriver>
 80197ea:	b100      	cbz	r0, 80197ee <DATALOG_SD_Init+0xe>
}
 80197ec:	bd08      	pop	{r3, pc}
    if(f_mount(&SDFatFs, (TCHAR const*)SDPath, 0) != FR_OK) {
 80197ee:	490a      	ldr	r1, [pc, #40]	; (8019818 <DATALOG_SD_Init+0x38>)
 80197f0:	4602      	mov	r2, r0
 80197f2:	1d08      	adds	r0, r1, #4
 80197f4:	f7fb ffbe 	bl	8015774 <f_mount>
 80197f8:	2800      	cmp	r0, #0
 80197fa:	d0f7      	beq.n	80197ec <DATALOG_SD_Init+0xc>
        BSP_LED_On(LED1);
 80197fc:	2000      	movs	r0, #0
 80197fe:	f7f4 fc0d 	bl	800e01c <BSP_LED_On>
        HAL_Delay(500);
 8019802:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8019806:	f001 fc7f 	bl	801b108 <HAL_Delay>
        BSP_LED_Off(LED1);
 801980a:	2000      	movs	r0, #0
 801980c:	f7f4 fc1a 	bl	800e044 <BSP_LED_Off>
        HAL_Delay(100);
 8019810:	2064      	movs	r0, #100	; 0x64
 8019812:	f001 fc79 	bl	801b108 <HAL_Delay>
 8019816:	e7f1      	b.n	80197fc <DATALOG_SD_Init+0x1c>
 8019818:	2000fd68 	.word	0x2000fd68
 801981c:	0807539c 	.word	0x0807539c

08019820 <SD_CardLoggingMemsStart>:
{
 8019820:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(!IsSdMemsRecording) {
 8019822:	4c8f      	ldr	r4, [pc, #572]	; (8019a60 <SD_CardLoggingMemsStart+0x240>)
 8019824:	f8d4 5cec 	ldr.w	r5, [r4, #3308]	; 0xcec
 8019828:	b1f5      	cbz	r5, 8019868 <SD_CardLoggingMemsStart+0x48>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801982a:	4b8e      	ldr	r3, [pc, #568]	; (8019a64 <SD_CardLoggingMemsStart+0x244>)
 801982c:	681b      	ldr	r3, [r3, #0]
 801982e:	065b      	lsls	r3, r3, #25
 8019830:	d400      	bmi.n	8019834 <SD_CardLoggingMemsStart+0x14>
}
 8019832:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      BytesToWrite =sprintf((char *)BufferToWrite,"2 Data Log MEMS is already started\n");
 8019834:	4e8c      	ldr	r6, [pc, #560]	; (8019a68 <SD_CardLoggingMemsStart+0x248>)
 8019836:	4d8d      	ldr	r5, [pc, #564]	; (8019a6c <SD_CardLoggingMemsStart+0x24c>)
 8019838:	f106 0720 	add.w	r7, r6, #32
 801983c:	4634      	mov	r4, r6
 801983e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8019840:	42bc      	cmp	r4, r7
 8019842:	6028      	str	r0, [r5, #0]
 8019844:	6069      	str	r1, [r5, #4]
 8019846:	60aa      	str	r2, [r5, #8]
 8019848:	60eb      	str	r3, [r5, #12]
 801984a:	4626      	mov	r6, r4
 801984c:	f105 0510 	add.w	r5, r5, #16
 8019850:	d1f4      	bne.n	801983c <SD_CardLoggingMemsStart+0x1c>
 8019852:	6820      	ldr	r0, [r4, #0]
 8019854:	4a86      	ldr	r2, [pc, #536]	; (8019a70 <SD_CardLoggingMemsStart+0x250>)
 8019856:	6028      	str	r0, [r5, #0]
 8019858:	2323      	movs	r3, #35	; 0x23
      Stderr_Update(BufferToWrite,BytesToWrite);
 801985a:	4619      	mov	r1, r3
      BytesToWrite =sprintf((char *)BufferToWrite,"2 Data Log MEMS is already started\n");
 801985c:	6013      	str	r3, [r2, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801985e:	4883      	ldr	r0, [pc, #524]	; (8019a6c <SD_CardLoggingMemsStart+0x24c>)
}
 8019860:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      Stderr_Update(BufferToWrite,BytesToWrite);
 8019864:	f002 bae8 	b.w	801be38 <Stderr_Update>
 8019868:	4606      	mov	r6, r0
    LedOffTargetPlatform();
 801986a:	f000 ffc3 	bl	801a7f4 <LedOffTargetPlatform>
    openFileMems(IsSdAudioRecording,OnlyForAnnotation);
 801986e:	f8d4 7cf0 	ldr.w	r7, [r4, #3312]	; 0xcf0
  if(DATALOG_SD_LogMems_Enable(SomethingAlreadyRecording,OnlyForAnnotation)) {
 8019872:	4631      	mov	r1, r6
 8019874:	4638      	mov	r0, r7
 8019876:	f7ff fc61 	bl	801913c <DATALOG_SD_LogMems_Enable>
 801987a:	2800      	cmp	r0, #0
 801987c:	d042      	beq.n	8019904 <SD_CardLoggingMemsStart+0xe4>
    SD_LogMems_Enabled=1;
 801987e:	2301      	movs	r3, #1
    NoSDFlag =0;
 8019880:	f8c4 5260 	str.w	r5, [r4, #608]	; 0x260
    SD_LogMems_Enabled=1;
 8019884:	f8c4 326c 	str.w	r3, [r4, #620]	; 0x26c
     osDelay(100); 
 8019888:	2064      	movs	r0, #100	; 0x64
 801988a:	f7fc fcd1 	bl	8016230 <osDelay>
    if(SD_LogMems_Enabled) {
 801988e:	f8d4 326c 	ldr.w	r3, [r4, #620]	; 0x26c
 8019892:	b1db      	cbz	r3, 80198cc <SD_CardLoggingMemsStart+0xac>
      IsSdMemsRecording= 1;
 8019894:	2301      	movs	r3, #1
 8019896:	f8c4 3cec 	str.w	r3, [r4, #3308]	; 0xcec
      if(OnlyForAnnotation==0) {
 801989a:	2e00      	cmp	r6, #0
 801989c:	d1c9      	bne.n	8019832 <SD_CardLoggingMemsStart+0x12>
        startProc(SD_CARD_LOGGING,RoundedInertialWakeUpTimer);
 801989e:	4f75      	ldr	r7, [pc, #468]	; (8019a74 <SD_CardLoggingMemsStart+0x254>)
 80198a0:	200e      	movs	r0, #14
 80198a2:	68f9      	ldr	r1, [r7, #12]
 80198a4:	f001 f99a 	bl	801abdc <startProc>
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 80198a8:	4b6e      	ldr	r3, [pc, #440]	; (8019a64 <SD_CardLoggingMemsStart+0x244>)
 80198aa:	681b      	ldr	r3, [r3, #0]
 80198ac:	069e      	lsls	r6, r3, #26
 80198ae:	d464      	bmi.n	801997a <SD_CardLoggingMemsStart+0x15a>
        PowerCtrlLock();
 80198b0:	f000 fda0 	bl	801a3f4 <PowerCtrlLock>
            (SD_Card_FeaturesMask & FEATURE_MASK_GRYO) ||
 80198b4:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
        if( (SD_Card_FeaturesMask & FEATURE_MASK_ACC)  ||
 80198b8:	f413 0f60 	tst.w	r3, #14680064	; 0xe00000
 80198bc:	d13a      	bne.n	8019934 <SD_CardLoggingMemsStart+0x114>
        if( (SD_Card_FeaturesMask & FEATURE_MASK_PRESS) ||
 80198be:	f413 1fe8 	tst.w	r3, #1900544	; 0x1d0000
 80198c2:	d0b6      	beq.n	8019832 <SD_CardLoggingMemsStart+0x12>
}
 80198c4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
            enableEnvSensors ();
 80198c8:	f000 bf2e 	b.w	801a728 <enableEnvSensors>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 80198cc:	4b65      	ldr	r3, [pc, #404]	; (8019a64 <SD_CardLoggingMemsStart+0x244>)
 80198ce:	681b      	ldr	r3, [r3, #0]
 80198d0:	065a      	lsls	r2, r3, #25
 80198d2:	d5ae      	bpl.n	8019832 <SD_CardLoggingMemsStart+0x12>
        BytesToWrite =sprintf((char *)BufferToWrite,"1 SD Card not present\n");
 80198d4:	4c68      	ldr	r4, [pc, #416]	; (8019a78 <SD_CardLoggingMemsStart+0x258>)
 80198d6:	4d65      	ldr	r5, [pc, #404]	; (8019a6c <SD_CardLoggingMemsStart+0x24c>)
 80198d8:	4f65      	ldr	r7, [pc, #404]	; (8019a70 <SD_CardLoggingMemsStart+0x250>)
 80198da:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80198dc:	6028      	str	r0, [r5, #0]
 80198de:	f8b4 c004 	ldrh.w	ip, [r4, #4]
 80198e2:	6820      	ldr	r0, [r4, #0]
 80198e4:	79a4      	ldrb	r4, [r4, #6]
 80198e6:	6069      	str	r1, [r5, #4]
 80198e8:	2616      	movs	r6, #22
 80198ea:	6128      	str	r0, [r5, #16]
 80198ec:	60aa      	str	r2, [r5, #8]
 80198ee:	60eb      	str	r3, [r5, #12]
 80198f0:	f8a5 c014 	strh.w	ip, [r5, #20]
 80198f4:	75ac      	strb	r4, [r5, #22]
        Stderr_Update(BufferToWrite,BytesToWrite);
 80198f6:	4628      	mov	r0, r5
 80198f8:	4631      	mov	r1, r6
        BytesToWrite =sprintf((char *)BufferToWrite,"1 SD Card not present\n");
 80198fa:	603e      	str	r6, [r7, #0]
}
 80198fc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        Stderr_Update(BufferToWrite,BytesToWrite);
 8019900:	f002 ba9a 	b.w	801be38 <Stderr_Update>
    DATALOG_SD_LogMems_Disable(SomethingAlreadyRecording);
 8019904:	4638      	mov	r0, r7
 8019906:	f7ff fbfd 	bl	8019104 <DATALOG_SD_LogMems_Disable>
    if((SomethingAlreadyRecording==0) & (NoSDFlag==0)){
 801990a:	f8d4 3260 	ldr.w	r3, [r4, #608]	; 0x260
 801990e:	433b      	orrs	r3, r7
 8019910:	d1ba      	bne.n	8019888 <SD_CardLoggingMemsStart+0x68>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 8019912:	4b54      	ldr	r3, [pc, #336]	; (8019a64 <SD_CardLoggingMemsStart+0x244>)
 8019914:	681b      	ldr	r3, [r3, #0]
 8019916:	055f      	lsls	r7, r3, #21
 8019918:	d408      	bmi.n	801992c <SD_CardLoggingMemsStart+0x10c>
      NoSDFlag = 1;
 801991a:	2301      	movs	r3, #1
  FATFS_UnLinkDriver(SDPath);
 801991c:	4857      	ldr	r0, [pc, #348]	; (8019a7c <SD_CardLoggingMemsStart+0x25c>)
      NoSDFlag = 1;
 801991e:	f8c4 3260 	str.w	r3, [r4, #608]	; 0x260
  FATFS_UnLinkDriver(SDPath);
 8019922:	f7fc fbe5 	bl	80160f0 <FATFS_UnLinkDriver>
      DATALOG_SD_Init();
 8019926:	f7ff ff5b 	bl	80197e0 <DATALOG_SD_Init>
 801992a:	e7ad      	b.n	8019888 <SD_CardLoggingMemsStart+0x68>
        SDLog_Update(SD_CARD_LOGGING_NO_SD);
 801992c:	2002      	movs	r0, #2
 801992e:	f002 ff05 	bl	801c73c <SDLog_Update>
 8019932:	e7f2      	b.n	801991a <SD_CardLoggingMemsStart+0xfa>
          enableMotionSensors ();
 8019934:	f000 fed0 	bl	801a6d8 <enableMotionSensors>
          if(SD_Card_FeaturesMask & FEATURE_MASK_ACC) {
 8019938:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
 801993c:	021d      	lsls	r5, r3, #8
 801993e:	d44c      	bmi.n	80199da <SD_CardLoggingMemsStart+0x1ba>
          if(SD_Card_FeaturesMask & FEATURE_MASK_GRYO) {
 8019940:	0258      	lsls	r0, r3, #9
 8019942:	d431      	bmi.n	80199a8 <SD_CardLoggingMemsStart+0x188>
          if(SD_Card_FeaturesMask & FEATURE_MASK_MAG) {
 8019944:	0299      	lsls	r1, r3, #10
 8019946:	d5ba      	bpl.n	80198be <SD_CardLoggingMemsStart+0x9e>
            BSP_MAGNETO_Get_ODR(TargetBoardFeatures.HandleMagSensor,&TargetBoardFeatures.DefaultMagODR);
 8019948:	4d4d      	ldr	r5, [pc, #308]	; (8019a80 <SD_CardLoggingMemsStart+0x260>)
 801994a:	f105 012c 	add.w	r1, r5, #44	; 0x2c
 801994e:	6a28      	ldr	r0, [r5, #32]
 8019950:	f7f6 faae 	bl	800feb0 <BSP_MAGNETO_Get_ODR>
            if(SampleRateIneFeatures <= 130) {
 8019954:	88bb      	ldrh	r3, [r7, #4]
              BSP_MAGNETO_Set_ODR_Value(TargetBoardFeatures.HandleMagSensor,10.0f);
 8019956:	6a28      	ldr	r0, [r5, #32]
            if(SampleRateIneFeatures <= 130) {
 8019958:	2b82      	cmp	r3, #130	; 0x82
 801995a:	d95e      	bls.n	8019a1a <SD_CardLoggingMemsStart+0x1fa>
            } else if (SampleRateIneFeatures <= 260) {
 801995c:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8019960:	d977      	bls.n	8019a52 <SD_CardLoggingMemsStart+0x232>
            } else if (SampleRateIneFeatures <= 520) {
 8019962:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
              BSP_MAGNETO_Set_ODR_Value(TargetBoardFeatures.HandleMagSensor,50.0f);
 8019966:	bf94      	ite	ls
 8019968:	ed9f 0a46 	vldrls	s0, [pc, #280]	; 8019a84 <SD_CardLoggingMemsStart+0x264>
              BSP_MAGNETO_Set_ODR_Value(TargetBoardFeatures.HandleMagSensor,100.0f);
 801996c:	ed9f 0a46 	vldrhi	s0, [pc, #280]	; 8019a88 <SD_CardLoggingMemsStart+0x268>
 8019970:	f7f6 fab0 	bl	800fed4 <BSP_MAGNETO_Set_ODR_Value>
 8019974:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
 8019978:	e7a1      	b.n	80198be <SD_CardLoggingMemsStart+0x9e>
          BytesToWrite =sprintf((char *)BufferToWrite,"Start Data Log MEMS Rec\n");
 801997a:	4d44      	ldr	r5, [pc, #272]	; (8019a8c <SD_CardLoggingMemsStart+0x26c>)
 801997c:	4e3b      	ldr	r6, [pc, #236]	; (8019a6c <SD_CardLoggingMemsStart+0x24c>)
 801997e:	f8df e0f0 	ldr.w	lr, [pc, #240]	; 8019a70 <SD_CardLoggingMemsStart+0x250>
 8019982:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019984:	6030      	str	r0, [r6, #0]
 8019986:	6071      	str	r1, [r6, #4]
 8019988:	cd03      	ldmia	r5!, {r0, r1}
 801998a:	f04f 0c18 	mov.w	ip, #24
 801998e:	782d      	ldrb	r5, [r5, #0]
 8019990:	6130      	str	r0, [r6, #16]
 8019992:	6171      	str	r1, [r6, #20]
 8019994:	60b2      	str	r2, [r6, #8]
          Term_Update(BufferToWrite,BytesToWrite);
 8019996:	4630      	mov	r0, r6
 8019998:	4661      	mov	r1, ip
          BytesToWrite =sprintf((char *)BufferToWrite,"Start Data Log MEMS Rec\n");
 801999a:	60f3      	str	r3, [r6, #12]
 801999c:	7635      	strb	r5, [r6, #24]
 801999e:	f8ce c000 	str.w	ip, [lr]
          Term_Update(BufferToWrite,BytesToWrite);
 80199a2:	f002 fa7b 	bl	801be9c <Term_Update>
 80199a6:	e783      	b.n	80198b0 <SD_CardLoggingMemsStart+0x90>
            BSP_GYRO_Get_ODR(TargetBoardFeatures.HandleGyroSensor,&TargetBoardFeatures.DefaultGyroODR);
 80199a8:	4d35      	ldr	r5, [pc, #212]	; (8019a80 <SD_CardLoggingMemsStart+0x260>)
 80199aa:	f105 0128 	add.w	r1, r5, #40	; 0x28
 80199ae:	69e8      	ldr	r0, [r5, #28]
 80199b0:	f7f6 f9d6 	bl	800fd60 <BSP_GYRO_Get_ODR>
            if(SampleRateIneFeatures <= 130) {
 80199b4:	88bb      	ldrh	r3, [r7, #4]
              BSP_GYRO_Set_ODR_Value(TargetBoardFeatures.HandleGyroSensor,13.0f);
 80199b6:	69e8      	ldr	r0, [r5, #28]
            if(SampleRateIneFeatures <= 130) {
 80199b8:	2b82      	cmp	r3, #130	; 0x82
 80199ba:	d927      	bls.n	8019a0c <SD_CardLoggingMemsStart+0x1ec>
            } else if (SampleRateIneFeatures <= 260) {
 80199bc:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80199c0:	d940      	bls.n	8019a44 <SD_CardLoggingMemsStart+0x224>
            } else if (SampleRateIneFeatures <= 520) {
 80199c2:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
              BSP_GYRO_Set_ODR_Value(TargetBoardFeatures.HandleGyroSensor,52.0f);
 80199c6:	bf94      	ite	ls
 80199c8:	ed9f 0a31 	vldrls	s0, [pc, #196]	; 8019a90 <SD_CardLoggingMemsStart+0x270>
              BSP_GYRO_Set_ODR_Value(TargetBoardFeatures.HandleGyroSensor,104.0f);
 80199cc:	ed9f 0a31 	vldrhi	s0, [pc, #196]	; 8019a94 <SD_CardLoggingMemsStart+0x274>
 80199d0:	f7f6 f9d8 	bl	800fd84 <BSP_GYRO_Set_ODR_Value>
 80199d4:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
 80199d8:	e7b4      	b.n	8019944 <SD_CardLoggingMemsStart+0x124>
            BSP_ACCELERO_Get_ODR(TargetBoardFeatures.HandleAccSensor,&TargetBoardFeatures.DefaultAccODR);
 80199da:	4d29      	ldr	r5, [pc, #164]	; (8019a80 <SD_CardLoggingMemsStart+0x260>)
 80199dc:	f105 0124 	add.w	r1, r5, #36	; 0x24
 80199e0:	69a8      	ldr	r0, [r5, #24]
 80199e2:	f7f5 f8a7 	bl	800eb34 <BSP_ACCELERO_Get_ODR>
            if(SampleRateIneFeatures <= 130) {
 80199e6:	88bb      	ldrh	r3, [r7, #4]
              BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,13.0f);
 80199e8:	69a8      	ldr	r0, [r5, #24]
            if(SampleRateIneFeatures <= 130) {
 80199ea:	2b82      	cmp	r3, #130	; 0x82
 80199ec:	d91c      	bls.n	8019a28 <SD_CardLoggingMemsStart+0x208>
            } else if (SampleRateIneFeatures <= 260) {
 80199ee:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80199f2:	d920      	bls.n	8019a36 <SD_CardLoggingMemsStart+0x216>
            } else if (SampleRateIneFeatures <= 520) {
 80199f4:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
              BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,52.0f);
 80199f8:	bf94      	ite	ls
 80199fa:	ed9f 0a25 	vldrls	s0, [pc, #148]	; 8019a90 <SD_CardLoggingMemsStart+0x270>
              BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,104.0f);
 80199fe:	ed9f 0a25 	vldrhi	s0, [pc, #148]	; 8019a94 <SD_CardLoggingMemsStart+0x274>
 8019a02:	f7f5 f8a9 	bl	800eb58 <BSP_ACCELERO_Set_ODR_Value>
 8019a06:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
 8019a0a:	e799      	b.n	8019940 <SD_CardLoggingMemsStart+0x120>
              BSP_GYRO_Set_ODR_Value(TargetBoardFeatures.HandleGyroSensor,13.0f);
 8019a0c:	eeb2 0a0a 	vmov.f32	s0, #42	; 0x41500000  13.0
 8019a10:	f7f6 f9b8 	bl	800fd84 <BSP_GYRO_Set_ODR_Value>
 8019a14:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
 8019a18:	e794      	b.n	8019944 <SD_CardLoggingMemsStart+0x124>
              BSP_MAGNETO_Set_ODR_Value(TargetBoardFeatures.HandleMagSensor,10.0f);
 8019a1a:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 8019a1e:	f7f6 fa59 	bl	800fed4 <BSP_MAGNETO_Set_ODR_Value>
 8019a22:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
 8019a26:	e74a      	b.n	80198be <SD_CardLoggingMemsStart+0x9e>
              BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,13.0f);
 8019a28:	eeb2 0a0a 	vmov.f32	s0, #42	; 0x41500000  13.0
 8019a2c:	f7f5 f894 	bl	800eb58 <BSP_ACCELERO_Set_ODR_Value>
 8019a30:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
 8019a34:	e784      	b.n	8019940 <SD_CardLoggingMemsStart+0x120>
              BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,26.0f);
 8019a36:	eeb3 0a0a 	vmov.f32	s0, #58	; 0x41d00000  26.0
 8019a3a:	f7f5 f88d 	bl	800eb58 <BSP_ACCELERO_Set_ODR_Value>
 8019a3e:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
 8019a42:	e77d      	b.n	8019940 <SD_CardLoggingMemsStart+0x120>
              BSP_GYRO_Set_ODR_Value(TargetBoardFeatures.HandleGyroSensor,26.0f);
 8019a44:	eeb3 0a0a 	vmov.f32	s0, #58	; 0x41d00000  26.0
 8019a48:	f7f6 f99c 	bl	800fd84 <BSP_GYRO_Set_ODR_Value>
 8019a4c:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
 8019a50:	e778      	b.n	8019944 <SD_CardLoggingMemsStart+0x124>
              BSP_MAGNETO_Set_ODR_Value(TargetBoardFeatures.HandleMagSensor,20.0f);
 8019a52:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 8019a56:	f7f6 fa3d 	bl	800fed4 <BSP_MAGNETO_Set_ODR_Value>
 8019a5a:	f8d4 3268 	ldr.w	r3, [r4, #616]	; 0x268
 8019a5e:	e72e      	b.n	80198be <SD_CardLoggingMemsStart+0x9e>
 8019a60:	2000f074 	.word	0x2000f074
 8019a64:	20010030 	.word	0x20010030
 8019a68:	080757c4 	.word	0x080757c4
 8019a6c:	20013174 	.word	0x20013174
 8019a70:	200132a0 	.word	0x200132a0
 8019a74:	200014a0 	.word	0x200014a0
 8019a78:	080757ac 	.word	0x080757ac
 8019a7c:	2000fd68 	.word	0x2000fd68
 8019a80:	20011458 	.word	0x20011458
 8019a84:	42480000 	.word	0x42480000
 8019a88:	42c80000 	.word	0x42c80000
 8019a8c:	08075790 	.word	0x08075790
 8019a90:	42500000 	.word	0x42500000
 8019a94:	42d00000 	.word	0x42d00000

08019a98 <SdCardMemsRecordingRun>:
{
 8019a98:	b510      	push	{r4, lr}
  if(!IsSdMemsRecording) {
 8019a9a:	4c0d      	ldr	r4, [pc, #52]	; (8019ad0 <SdCardMemsRecordingRun+0x38>)
 8019a9c:	f8d4 3cec 	ldr.w	r3, [r4, #3308]	; 0xcec
 8019aa0:	b143      	cbz	r3, 8019ab4 <SdCardMemsRecordingRun+0x1c>
     SD_CardLoggingMemsData();
 8019aa2:	f7ff f989 	bl	8018db8 <SD_CardLoggingMemsData>
  BSP_LED_Init(LED1);
 8019aa6:	2000      	movs	r0, #0
 8019aa8:	f7f4 fa7a 	bl	800dfa0 <BSP_LED_Init>
}
 8019aac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LedOffTargetPlatform();
 8019ab0:	f000 bea0 	b.w	801a7f4 <LedOffTargetPlatform>
    SD_CardLoggingMemsStart(OnlyForAnnotation);
 8019ab4:	f7ff feb4 	bl	8019820 <SD_CardLoggingMemsStart>
  if(IsSdMemsRecording) {
 8019ab8:	f8d4 3cec 	ldr.w	r3, [r4, #3308]	; 0xcec
 8019abc:	2b00      	cmp	r3, #0
 8019abe:	d1f0      	bne.n	8019aa2 <SdCardMemsRecordingRun+0xa>
  BSP_LED_Init(LED1);
 8019ac0:	2000      	movs	r0, #0
 8019ac2:	f7f4 fa6d 	bl	800dfa0 <BSP_LED_Init>
}
 8019ac6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LedOffTargetPlatform();
 8019aca:	f000 be93 	b.w	801a7f4 <LedOffTargetPlatform>
 8019ace:	bf00      	nop
 8019ad0:	2000f074 	.word	0x2000f074

08019ad4 <SD_CardLoggingAudioStart>:
{
 8019ad4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if(!IsSdAudioRecording) {
 8019ad8:	4c89      	ldr	r4, [pc, #548]	; (8019d00 <SD_CardLoggingAudioStart+0x22c>)
 8019ada:	f8d4 5cf0 	ldr.w	r5, [r4, #3312]	; 0xcf0
{
 8019ade:	b089      	sub	sp, #36	; 0x24
  if(!IsSdAudioRecording) {
 8019ae0:	b30d      	cbz	r5, 8019b26 <SD_CardLoggingAudioStart+0x52>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 8019ae2:	4b88      	ldr	r3, [pc, #544]	; (8019d04 <SD_CardLoggingAudioStart+0x230>)
 8019ae4:	681b      	ldr	r3, [r3, #0]
 8019ae6:	065b      	lsls	r3, r3, #25
 8019ae8:	d402      	bmi.n	8019af0 <SD_CardLoggingAudioStart+0x1c>
}
 8019aea:	b009      	add	sp, #36	; 0x24
 8019aec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      BytesToWrite =sprintf((char *)BufferToWrite,"4 Data Log Audio is already started\n");
 8019af0:	4e85      	ldr	r6, [pc, #532]	; (8019d08 <SD_CardLoggingAudioStart+0x234>)
 8019af2:	4d86      	ldr	r5, [pc, #536]	; (8019d0c <SD_CardLoggingAudioStart+0x238>)
 8019af4:	f106 0720 	add.w	r7, r6, #32
 8019af8:	4634      	mov	r4, r6
 8019afa:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8019afc:	42bc      	cmp	r4, r7
 8019afe:	6028      	str	r0, [r5, #0]
 8019b00:	6069      	str	r1, [r5, #4]
 8019b02:	60aa      	str	r2, [r5, #8]
 8019b04:	60eb      	str	r3, [r5, #12]
 8019b06:	4626      	mov	r6, r4
 8019b08:	f105 0510 	add.w	r5, r5, #16
 8019b0c:	d1f4      	bne.n	8019af8 <SD_CardLoggingAudioStart+0x24>
 8019b0e:	6820      	ldr	r0, [r4, #0]
 8019b10:	7921      	ldrb	r1, [r4, #4]
 8019b12:	4a7f      	ldr	r2, [pc, #508]	; (8019d10 <SD_CardLoggingAudioStart+0x23c>)
 8019b14:	6028      	str	r0, [r5, #0]
 8019b16:	2324      	movs	r3, #36	; 0x24
 8019b18:	7129      	strb	r1, [r5, #4]
      Stderr_Update(BufferToWrite,BytesToWrite);
 8019b1a:	487c      	ldr	r0, [pc, #496]	; (8019d0c <SD_CardLoggingAudioStart+0x238>)
      BytesToWrite =sprintf((char *)BufferToWrite,"4 Data Log Audio is already started\n");
 8019b1c:	6013      	str	r3, [r2, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 8019b1e:	4619      	mov	r1, r3
 8019b20:	f002 f98a 	bl	801be38 <Stderr_Update>
}
 8019b24:	e7e1      	b.n	8019aea <SD_CardLoggingAudioStart+0x16>
    LedOffTargetPlatform();
 8019b26:	f000 fe65 	bl	801a7f4 <LedOffTargetPlatform>
    openFileAudio(IsSdMemsRecording);
 8019b2a:	f8d4 acec 	ldr.w	sl, [r4, #3308]	; 0xcec
  if(SomethingAlreadyRecording==0) {
 8019b2e:	f1ba 0f00 	cmp.w	sl, #0
 8019b32:	f000 80d8 	beq.w	8019ce6 <SD_CardLoggingAudioStart+0x212>
  pAudioHeader[3] = 'F';
 8019b36:	4b77      	ldr	r3, [pc, #476]	; (8019d14 <SD_CardLoggingAudioStart+0x240>)
  pAudioHeader[0] = 'R';
 8019b38:	4e77      	ldr	r6, [pc, #476]	; (8019d18 <SD_CardLoggingAudioStart+0x244>)
  pAudioHeader[7] = 0x00;
 8019b3a:	4878      	ldr	r0, [pc, #480]	; (8019d1c <SD_CardLoggingAudioStart+0x248>)
  pAudioHeader[11] = 'E';
 8019b3c:	f8df c214 	ldr.w	ip, [pc, #532]	; 8019d54 <SD_CardLoggingAudioStart+0x280>
  pAudioHeader[31]  = (uint8_t)(( ByteRate >> 24) & 0xFF);
 8019b40:	4977      	ldr	r1, [pc, #476]	; (8019d20 <SD_CardLoggingAudioStart+0x24c>)
  pAudioHeader[35]  = 0x00;
 8019b42:	4a78      	ldr	r2, [pc, #480]	; (8019d24 <SD_CardLoggingAudioStart+0x250>)
  pAudioHeader[0] = 'R';
 8019b44:	f8c4 6234 	str.w	r6, [r4, #564]	; 0x234
  pAudioHeader[15]  = ' ';
 8019b48:	2710      	movs	r7, #16
  pAudioHeader[3] = 'F';
 8019b4a:	f8c4 3238 	str.w	r3, [r4, #568]	; 0x238
  pAudioHeader[39]  = 'a';
 8019b4e:	f8c4 325c 	str.w	r3, [r4, #604]	; 0x25c
  pAudioHeader[19]  = 0x00;
 8019b52:	f04f 1601 	mov.w	r6, #65537	; 0x10001
  pAudioHeader[27]  = (uint8_t)((SampleRate >> 24) & 0xFF);
 8019b56:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  pAudioHeader[7] = 0x00;
 8019b5a:	f8c4 023c 	str.w	r0, [r4, #572]	; 0x23c
  pAudioHeader[23]  = 0x00;
 8019b5e:	f44f 507a 	mov.w	r0, #16000	; 0x3e80
  pAudioHeader[11] = 'E';
 8019b62:	f8c4 c240 	str.w	ip, [r4, #576]	; 0x240
  pAudioHeader[15]  = ' ';
 8019b66:	f8c4 7244 	str.w	r7, [r4, #580]	; 0x244
  pAudioHeader[19]  = 0x00;
 8019b6a:	f8c4 6248 	str.w	r6, [r4, #584]	; 0x248
  pAudioHeader[27]  = (uint8_t)((SampleRate >> 24) & 0xFF);
 8019b6e:	f8c4 3250 	str.w	r3, [r4, #592]	; 0x250
  pAudioHeader[31]  = (uint8_t)(( ByteRate >> 24) & 0xFF);
 8019b72:	f8c4 1254 	str.w	r1, [r4, #596]	; 0x254
  pAudioHeader[35]  = 0x00;
 8019b76:	f8c4 2258 	str.w	r2, [r4, #600]	; 0x258
  pAudioHeader[23]  = 0x00;
 8019b7a:	f8c4 024c 	str.w	r0, [r4, #588]	; 0x24c
* @param  FileName Name of the create file
* @retval None
*/
static void CreateAudioFileName(char *FileName)
{
  RTC_GetCurrentDateTime();
 8019b7e:	f001 faad 	bl	801b0dc <RTC_GetCurrentDateTime>
  sprintf(FileName, "%s-Audio_%02d_%s_%02d_%02dh_%02dm_%02ds.wav",
                     DefaultDataFileName,
                     CurrentDate.Date,
 8019b82:	4869      	ldr	r0, [pc, #420]	; (8019d28 <SD_CardLoggingAudioStart+0x254>)
                     MonthName[CurrentDate.Month-1],
                     CurrentDate.Year,
                     CurrentTime.Hours,
                     CurrentTime.Minutes,
                     CurrentTime.Seconds);  
 8019b84:	4a69      	ldr	r2, [pc, #420]	; (8019d2c <SD_CardLoggingAudioStart+0x258>)
                     MonthName[CurrentDate.Month-1],
 8019b86:	7841      	ldrb	r1, [r0, #1]
  sprintf(FileName, "%s-Audio_%02d_%s_%02d_%02dh_%02dm_%02ds.wav",
 8019b88:	7883      	ldrb	r3, [r0, #2]
 8019b8a:	4e69      	ldr	r6, [pc, #420]	; (8019d30 <SD_CardLoggingAudioStart+0x25c>)
 8019b8c:	78c0      	ldrb	r0, [r0, #3]
 8019b8e:	9001      	str	r0, [sp, #4]
 8019b90:	3901      	subs	r1, #1
 8019b92:	7890      	ldrb	r0, [r2, #2]
 8019b94:	f856 6021 	ldr.w	r6, [r6, r1, lsl #2]
 8019b98:	7851      	ldrb	r1, [r2, #1]
 8019b9a:	7812      	ldrb	r2, [r2, #0]
 8019b9c:	9202      	str	r2, [sp, #8]
 8019b9e:	e9cd 1003 	strd	r1, r0, [sp, #12]
 8019ba2:	4864      	ldr	r0, [pc, #400]	; (8019d34 <SD_CardLoggingAudioStart+0x260>)
 8019ba4:	9600      	str	r6, [sp, #0]
 8019ba6:	4a64      	ldr	r2, [pc, #400]	; (8019d38 <SD_CardLoggingAudioStart+0x264>)
 8019ba8:	4964      	ldr	r1, [pc, #400]	; (8019d3c <SD_CardLoggingAudioStart+0x268>)
 8019baa:	f8df 8158 	ldr.w	r8, [pc, #344]	; 8019d04 <SD_CardLoggingAudioStart+0x230>
        BytesToWrite =sprintf((char *)BufferToWrite, "FileName=%s\n",AudioDataFileName);
 8019bae:	f8df b1a8 	ldr.w	fp, [pc, #424]	; 8019d58 <SD_CardLoggingAudioStart+0x284>
 8019bb2:	f8df 9158 	ldr.w	r9, [pc, #344]	; 8019d0c <SD_CardLoggingAudioStart+0x238>
    if(f_open(&MyFileAudio, (char const*)AudioDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 8019bb6:	4607      	mov	r7, r0
  sprintf(FileName, "%s-Audio_%02d_%s_%02d_%02dh_%02dm_%02ds.wav",
 8019bb8:	f005 fcee 	bl	801f598 <siprintf>
 8019bbc:	6826      	ldr	r6, [r4, #0]
    if(f_open(&MyFileAudio, (char const*)AudioDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 8019bbe:	4860      	ldr	r0, [pc, #384]	; (8019d40 <SD_CardLoggingAudioStart+0x26c>)
 8019bc0:	220a      	movs	r2, #10
 8019bc2:	4639      	mov	r1, r7
    SDCardFileCount++;
 8019bc4:	3501      	adds	r5, #1
  while(SD_LogAudio_Enabled==0) {
 8019bc6:	b996      	cbnz	r6, 8019bee <SD_CardLoggingAudioStart+0x11a>
    if(f_open(&MyFileAudio, (char const*)AudioDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 8019bc8:	f7fb fe0c 	bl	80157e4 <f_open>
      SD_LogAudio_Enabled =1;
 8019bcc:	2301      	movs	r3, #1
    if(f_open(&MyFileAudio, (char const*)AudioDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 8019bce:	2800      	cmp	r0, #0
 8019bd0:	d056      	beq.n	8019c80 <SD_CardLoggingAudioStart+0x1ac>
      if(SDCardFileCount > MAX_TRIALS_OPENS_SD) {
 8019bd2:	2d0a      	cmp	r5, #10
      osDelay(100);
 8019bd4:	f04f 0064 	mov.w	r0, #100	; 0x64
      if(SDCardFileCount > MAX_TRIALS_OPENS_SD) {
 8019bd8:	f200 8088 	bhi.w	8019cec <SD_CardLoggingAudioStart+0x218>
      osDelay(100);
 8019bdc:	f7fc fb28 	bl	8016230 <osDelay>
 8019be0:	6826      	ldr	r6, [r4, #0]
    if(f_open(&MyFileAudio, (char const*)AudioDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 8019be2:	4857      	ldr	r0, [pc, #348]	; (8019d40 <SD_CardLoggingAudioStart+0x26c>)
 8019be4:	220a      	movs	r2, #10
 8019be6:	4639      	mov	r1, r7
    SDCardFileCount++;
 8019be8:	3501      	adds	r5, #1
  while(SD_LogAudio_Enabled==0) {
 8019bea:	2e00      	cmp	r6, #0
 8019bec:	d0ec      	beq.n	8019bc8 <SD_CardLoggingAudioStart+0xf4>
  if(f_write(&MyFileAudio, (uint8_t*) pAudioHeader, sizeof(pAudioHeader), (void *)&byteswritten) != FR_OK) {
 8019bee:	4955      	ldr	r1, [pc, #340]	; (8019d44 <SD_CardLoggingAudioStart+0x270>)
 8019bf0:	ab07      	add	r3, sp, #28
 8019bf2:	f5a1 700c 	sub.w	r0, r1, #560	; 0x230
 8019bf6:	222c      	movs	r2, #44	; 0x2c
 8019bf8:	f7fb ff74 	bl	8015ae4 <f_write>
 8019bfc:	4605      	mov	r5, r0
 8019bfe:	b1c0      	cbz	r0, 8019c32 <SD_CardLoggingAudioStart+0x15e>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 8019c00:	f8d8 3000 	ldr.w	r3, [r8]
 8019c04:	055d      	lsls	r5, r3, #21
 8019c06:	d473      	bmi.n	8019cf0 <SD_CardLoggingAudioStart+0x21c>
    DATALOG_SD_LogAudio_Disable(SomethingAlreadyRecording);
 8019c08:	4650      	mov	r0, sl
 8019c0a:	f7ff f88b 	bl	8018d24 <DATALOG_SD_LogAudio_Disable>
    if((SomethingAlreadyRecording==0) & (NoSDFlag==0)){
 8019c0e:	f8d4 3260 	ldr.w	r3, [r4, #608]	; 0x260
 8019c12:	ea5a 0303 	orrs.w	r3, sl, r3
 8019c16:	d112      	bne.n	8019c3e <SD_CardLoggingAudioStart+0x16a>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 8019c18:	f8d8 3000 	ldr.w	r3, [r8]
 8019c1c:	0558      	lsls	r0, r3, #21
 8019c1e:	d46b      	bmi.n	8019cf8 <SD_CardLoggingAudioStart+0x224>
      NoSDFlag = 1;
 8019c20:	2301      	movs	r3, #1
  FATFS_UnLinkDriver(SDPath);
 8019c22:	4849      	ldr	r0, [pc, #292]	; (8019d48 <SD_CardLoggingAudioStart+0x274>)
      NoSDFlag = 1;
 8019c24:	f8c4 3260 	str.w	r3, [r4, #608]	; 0x260
  FATFS_UnLinkDriver(SDPath);
 8019c28:	f7fc fa62 	bl	80160f0 <FATFS_UnLinkDriver>
      DATALOG_SD_Init();
 8019c2c:	f7ff fdd8 	bl	80197e0 <DATALOG_SD_Init>
 8019c30:	e005      	b.n	8019c3e <SD_CardLoggingAudioStart+0x16a>
  PowerCtrlLock();
 8019c32:	f000 fbdf 	bl	801a3f4 <PowerCtrlLock>
    SD_LogAudio_Enabled=1;
 8019c36:	2301      	movs	r3, #1
    NoSDFlag =0;
 8019c38:	f8c4 5260 	str.w	r5, [r4, #608]	; 0x260
    SD_LogAudio_Enabled=1;
 8019c3c:	6023      	str	r3, [r4, #0]
    osDelay(100);
 8019c3e:	2064      	movs	r0, #100	; 0x64
 8019c40:	f7fc faf6 	bl	8016230 <osDelay>
    if(SD_LogAudio_Enabled) {
 8019c44:	6823      	ldr	r3, [r4, #0]
 8019c46:	bb73      	cbnz	r3, 8019ca6 <SD_CardLoggingAudioStart+0x1d2>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 8019c48:	f8d8 3000 	ldr.w	r3, [r8]
 8019c4c:	065a      	lsls	r2, r3, #25
 8019c4e:	f57f af4c 	bpl.w	8019aea <SD_CardLoggingAudioStart+0x16>
        BytesToWrite =sprintf((char *)BufferToWrite,"3 SD Card not present\n");
 8019c52:	4c3e      	ldr	r4, [pc, #248]	; (8019d4c <SD_CardLoggingAudioStart+0x278>)
 8019c54:	4d2d      	ldr	r5, [pc, #180]	; (8019d0c <SD_CardLoggingAudioStart+0x238>)
 8019c56:	4f2e      	ldr	r7, [pc, #184]	; (8019d10 <SD_CardLoggingAudioStart+0x23c>)
 8019c58:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8019c5a:	2616      	movs	r6, #22
 8019c5c:	f8b4 c004 	ldrh.w	ip, [r4, #4]
 8019c60:	6028      	str	r0, [r5, #0]
 8019c62:	6820      	ldr	r0, [r4, #0]
 8019c64:	79a4      	ldrb	r4, [r4, #6]
 8019c66:	6069      	str	r1, [r5, #4]
 8019c68:	6128      	str	r0, [r5, #16]
 8019c6a:	60aa      	str	r2, [r5, #8]
        Stderr_Update(BufferToWrite,BytesToWrite);
 8019c6c:	4628      	mov	r0, r5
        BytesToWrite =sprintf((char *)BufferToWrite,"3 SD Card not present\n");
 8019c6e:	60eb      	str	r3, [r5, #12]
        Stderr_Update(BufferToWrite,BytesToWrite);
 8019c70:	4631      	mov	r1, r6
        BytesToWrite =sprintf((char *)BufferToWrite,"3 SD Card not present\n");
 8019c72:	f8a5 c014 	strh.w	ip, [r5, #20]
 8019c76:	75ac      	strb	r4, [r5, #22]
 8019c78:	603e      	str	r6, [r7, #0]
        Stderr_Update(BufferToWrite,BytesToWrite);
 8019c7a:	f002 f8dd 	bl	801be38 <Stderr_Update>
 8019c7e:	e734      	b.n	8019aea <SD_CardLoggingAudioStart+0x16>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 8019c80:	f8d8 2000 	ldr.w	r2, [r8]
      SD_LogAudio_Enabled =1;
 8019c84:	6023      	str	r3, [r4, #0]
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 8019c86:	0696      	lsls	r6, r2, #26
 8019c88:	d5b1      	bpl.n	8019bee <SD_CardLoggingAudioStart+0x11a>
        BytesToWrite =sprintf((char *)BufferToWrite, "FileName=%s\n",AudioDataFileName);
 8019c8a:	463a      	mov	r2, r7
 8019c8c:	4659      	mov	r1, fp
 8019c8e:	4648      	mov	r0, r9
 8019c90:	f005 fc82 	bl	801f598 <siprintf>
 8019c94:	4a1e      	ldr	r2, [pc, #120]	; (8019d10 <SD_CardLoggingAudioStart+0x23c>)
 8019c96:	4603      	mov	r3, r0
        Term_Update(BufferToWrite,BytesToWrite);
 8019c98:	b2c1      	uxtb	r1, r0
 8019c9a:	4648      	mov	r0, r9
        BytesToWrite =sprintf((char *)BufferToWrite, "FileName=%s\n",AudioDataFileName);
 8019c9c:	6013      	str	r3, [r2, #0]
        Term_Update(BufferToWrite,BytesToWrite);
 8019c9e:	f002 f8fd 	bl	801be9c <Term_Update>
 8019ca2:	6826      	ldr	r6, [r4, #0]
 8019ca4:	e78b      	b.n	8019bbe <SD_CardLoggingAudioStart+0xea>
      IsSdAudioRecording= 1;
 8019ca6:	2301      	movs	r3, #1
      InitMics(AUDIO_SAMPLING_FREQUENCY);
 8019ca8:	f44f 507a 	mov.w	r0, #16000	; 0x3e80
      IsSdAudioRecording= 1;
 8019cac:	f8c4 3cf0 	str.w	r3, [r4, #3312]	; 0xcf0
      InitMics(AUDIO_SAMPLING_FREQUENCY);
 8019cb0:	f000 fd7a 	bl	801a7a8 <InitMics>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 8019cb4:	f8d8 3000 	ldr.w	r3, [r8]
 8019cb8:	0699      	lsls	r1, r3, #26
 8019cba:	f57f af16 	bpl.w	8019aea <SD_CardLoggingAudioStart+0x16>
        BytesToWrite =sprintf((char *)BufferToWrite,"Start Data Log Audio Rec\n");
 8019cbe:	4c24      	ldr	r4, [pc, #144]	; (8019d50 <SD_CardLoggingAudioStart+0x27c>)
 8019cc0:	4d12      	ldr	r5, [pc, #72]	; (8019d0c <SD_CardLoggingAudioStart+0x238>)
 8019cc2:	4f13      	ldr	r7, [pc, #76]	; (8019d10 <SD_CardLoggingAudioStart+0x23c>)
 8019cc4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8019cc6:	6028      	str	r0, [r5, #0]
 8019cc8:	6069      	str	r1, [r5, #4]
 8019cca:	cc03      	ldmia	r4!, {r0, r1}
 8019ccc:	2619      	movs	r6, #25
 8019cce:	8824      	ldrh	r4, [r4, #0]
 8019cd0:	6128      	str	r0, [r5, #16]
 8019cd2:	6169      	str	r1, [r5, #20]
 8019cd4:	60aa      	str	r2, [r5, #8]
        Term_Update(BufferToWrite,BytesToWrite);
 8019cd6:	4628      	mov	r0, r5
 8019cd8:	4631      	mov	r1, r6
        BytesToWrite =sprintf((char *)BufferToWrite,"Start Data Log Audio Rec\n");
 8019cda:	60eb      	str	r3, [r5, #12]
 8019cdc:	832c      	strh	r4, [r5, #24]
 8019cde:	603e      	str	r6, [r7, #0]
        Term_Update(BufferToWrite,BytesToWrite);
 8019ce0:	f002 f8dc 	bl	801be9c <Term_Update>
 8019ce4:	e701      	b.n	8019aea <SD_CardLoggingAudioStart+0x16>
    SD_IO_CS_Init();
 8019ce6:	f7f4 fce5 	bl	800e6b4 <SD_IO_CS_Init>
 8019cea:	e724      	b.n	8019b36 <SD_CardLoggingAudioStart+0x62>
        SD_LogAudio_Enabled= 0;
 8019cec:	6026      	str	r6, [r4, #0]
 8019cee:	e78b      	b.n	8019c08 <SD_CardLoggingAudioStart+0x134>
      SDLog_Update(SD_CARD_LOGGING_IO_ERROR);
 8019cf0:	2003      	movs	r0, #3
 8019cf2:	f002 fd23 	bl	801c73c <SDLog_Update>
 8019cf6:	e787      	b.n	8019c08 <SD_CardLoggingAudioStart+0x134>
        SDLog_Update(SD_CARD_LOGGING_NO_SD);
 8019cf8:	2002      	movs	r0, #2
 8019cfa:	f002 fd1f 	bl	801c73c <SDLog_Update>
 8019cfe:	e78f      	b.n	8019c20 <SD_CardLoggingAudioStart+0x14c>
 8019d00:	2000f074 	.word	0x2000f074
 8019d04:	20010030 	.word	0x20010030
 8019d08:	08075848 	.word	0x08075848
 8019d0c:	20013174 	.word	0x20013174
 8019d10:	200132a0 	.word	0x200132a0
 8019d14:	001d4c00 	.word	0x001d4c00
 8019d18:	46464952 	.word	0x46464952
 8019d1c:	45564157 	.word	0x45564157
 8019d20:	00100002 	.word	0x00100002
 8019d24:	61746164 	.word	0x61746164
 8019d28:	20013274 	.word	0x20013274
 8019d2c:	20012f24 	.word	0x20012f24
 8019d30:	08075314 	.word	0x08075314
 8019d34:	2000ffa0 	.word	0x2000ffa0
 8019d38:	2001144c 	.word	0x2001144c
 8019d3c:	080757e8 	.word	0x080757e8
 8019d40:	2000f078 	.word	0x2000f078
 8019d44:	2000f2a8 	.word	0x2000f2a8
 8019d48:	2000fd68 	.word	0x2000fd68
 8019d4c:	08075830 	.word	0x08075830
 8019d50:	08075814 	.word	0x08075814
 8019d54:	20746d66 	.word	0x20746d66
 8019d58:	080755a0 	.word	0x080755a0

08019d5c <SdCardAudioRecordingRun>:
{
 8019d5c:	b510      	push	{r4, lr}
  if(!IsSdAudioRecording) {
 8019d5e:	4c13      	ldr	r4, [pc, #76]	; (8019dac <SdCardAudioRecordingRun+0x50>)
 8019d60:	f8d4 3cf0 	ldr.w	r3, [r4, #3312]	; 0xcf0
{
 8019d64:	b082      	sub	sp, #8
  if(!IsSdAudioRecording) {
 8019d66:	b1d3      	cbz	r3, 8019d9e <SdCardAudioRecordingRun+0x42>
  if(f_write(&MyFileAudio, ((uint8_t *)(Audio_OUT_Buff+index_buff)), AUDIO_BUFF_SIZE /* Because we need to write 16bit for sample */, (void *)&byteswritten) != FR_OK) {
 8019d68:	4811      	ldr	r0, [pc, #68]	; (8019db0 <SdCardAudioRecordingRun+0x54>)
 8019d6a:	f8d4 1ce4 	ldr.w	r1, [r4, #3300]	; 0xce4
 8019d6e:	ab01      	add	r3, sp, #4
 8019d70:	eb00 0141 	add.w	r1, r0, r1, lsl #1
 8019d74:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8019d78:	f5a0 609c 	sub.w	r0, r0, #1248	; 0x4e0
 8019d7c:	f7fb feb2 	bl	8015ae4 <f_write>
 8019d80:	b130      	cbz	r0, 8019d90 <SdCardAudioRecordingRun+0x34>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 8019d82:	4b0c      	ldr	r3, [pc, #48]	; (8019db4 <SdCardAudioRecordingRun+0x58>)
 8019d84:	681b      	ldr	r3, [r3, #0]
 8019d86:	055b      	lsls	r3, r3, #21
 8019d88:	d502      	bpl.n	8019d90 <SdCardAudioRecordingRun+0x34>
      SDLog_Update(SD_CARD_LOGGING_IO_ERROR);
 8019d8a:	2003      	movs	r0, #3
 8019d8c:	f002 fcd6 	bl	801c73c <SDLog_Update>
  BSP_LED_Init(LED1);
 8019d90:	2000      	movs	r0, #0
 8019d92:	f7f4 f905 	bl	800dfa0 <BSP_LED_Init>
  LedOffTargetPlatform();
 8019d96:	f000 fd2d 	bl	801a7f4 <LedOffTargetPlatform>
}
 8019d9a:	b002      	add	sp, #8
 8019d9c:	bd10      	pop	{r4, pc}
    SD_CardLoggingAudioStart();
 8019d9e:	f7ff fe99 	bl	8019ad4 <SD_CardLoggingAudioStart>
  if(IsSdAudioRecording) {
 8019da2:	f8d4 3cf0 	ldr.w	r3, [r4, #3312]	; 0xcf0
 8019da6:	2b00      	cmp	r3, #0
 8019da8:	d0f2      	beq.n	8019d90 <SdCardAudioRecordingRun+0x34>
 8019daa:	e7dd      	b.n	8019d68 <SdCardAudioRecordingRun+0xc>
 8019dac:	2000f074 	.word	0x2000f074
 8019db0:	2000f558 	.word	0x2000f558
 8019db4:	20010030 	.word	0x20010030

08019db8 <SaveDataAnnotation>:
{
 8019db8:	b570      	push	{r4, r5, r6, lr}
  if(SD_LogMems_Enabled) {
 8019dba:	4d45      	ldr	r5, [pc, #276]	; (8019ed0 <SaveDataAnnotation+0x118>)
 8019dbc:	f8d5 326c 	ldr.w	r3, [r5, #620]	; 0x26c
{
 8019dc0:	b096      	sub	sp, #88	; 0x58
  if(SD_LogMems_Enabled) {
 8019dc2:	b90b      	cbnz	r3, 8019dc8 <SaveDataAnnotation+0x10>
}
 8019dc4:	b016      	add	sp, #88	; 0x58
 8019dc6:	bd70      	pop	{r4, r5, r6, pc}
                        CurrentTime.Minutes,
 8019dc8:	4c42      	ldr	r4, [pc, #264]	; (8019ed4 <SaveDataAnnotation+0x11c>)
 8019dca:	4606      	mov	r6, r0
     RTC_GetCurrentDateTime();
 8019dcc:	f001 f986 	bl	801b0dc <RTC_GetCurrentDateTime>
    size = sprintf(myBuffer, "%02d:%02d:%02d.%03ld,%s",
 8019dd0:	9602      	str	r6, [sp, #8]
                        999- (CurrentTime.SubSeconds*1000)/(CurrentTime.SecondFraction),
 8019dd2:	e9d4 6001 	ldrd	r6, r0, [r4, #4]
    size = sprintf(myBuffer, "%02d:%02d:%02d.%03ld,%s",
 8019dd6:	78a1      	ldrb	r1, [r4, #2]
 8019dd8:	7863      	ldrb	r3, [r4, #1]
 8019dda:	7822      	ldrb	r2, [r4, #0]
 8019ddc:	9100      	str	r1, [sp, #0]
                        999- (CurrentTime.SubSeconds*1000)/(CurrentTime.SecondFraction),
 8019dde:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8019de2:	fb01 f106 	mul.w	r1, r1, r6
 8019de6:	fbb1 f1f0 	udiv	r1, r1, r0
    size = sprintf(myBuffer, "%02d:%02d:%02d.%03ld,%s",
 8019dea:	f5c1 7179 	rsb	r1, r1, #996	; 0x3e4
 8019dee:	3103      	adds	r1, #3
 8019df0:	9101      	str	r1, [sp, #4]
 8019df2:	a806      	add	r0, sp, #24
 8019df4:	4938      	ldr	r1, [pc, #224]	; (8019ed8 <SaveDataAnnotation+0x120>)
 8019df6:	f005 fbcf 	bl	801f598 <siprintf>
    if(SD_Card_FeaturesMask!=FEATURE_MASK_BLUEVOICE) {
 8019dfa:	f8d5 3268 	ldr.w	r3, [r5, #616]	; 0x268
 8019dfe:	aa06      	add	r2, sp, #24
 8019e00:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
    size = sprintf(myBuffer, "%02d:%02d:%02d.%03ld,%s",
 8019e04:	4604      	mov	r4, r0
 8019e06:	4402      	add	r2, r0
    if(SD_Card_FeaturesMask!=FEATURE_MASK_BLUEVOICE) {
 8019e08:	d00d      	beq.n	8019e26 <SaveDataAnnotation+0x6e>
      if(SD_Card_FeaturesMask&FEATURE_MASK_ACC) {
 8019e0a:	0219      	lsls	r1, r3, #8
 8019e0c:	d458      	bmi.n	8019ec0 <SaveDataAnnotation+0x108>
      if(SD_Card_FeaturesMask&FEATURE_MASK_GRYO) {
 8019e0e:	025e      	lsls	r6, r3, #9
 8019e10:	d44f      	bmi.n	8019eb2 <SaveDataAnnotation+0xfa>
      if(SD_Card_FeaturesMask&FEATURE_MASK_MAG) {
 8019e12:	0298      	lsls	r0, r3, #10
 8019e14:	d446      	bmi.n	8019ea4 <SaveDataAnnotation+0xec>
      if(SD_Card_FeaturesMask&FEATURE_MASK_PRESS) {
 8019e16:	02d9      	lsls	r1, r3, #11
 8019e18:	d439      	bmi.n	8019e8e <SaveDataAnnotation+0xd6>
      if(SD_Card_FeaturesMask&FEATURE_MASK_TEMP1) {
 8019e1a:	035e      	lsls	r6, r3, #13
 8019e1c:	d42c      	bmi.n	8019e78 <SaveDataAnnotation+0xc0>
      if(SD_Card_FeaturesMask&FEATURE_MASK_TEMP2) {
 8019e1e:	03d8      	lsls	r0, r3, #15
 8019e20:	d41f      	bmi.n	8019e62 <SaveDataAnnotation+0xaa>
      if(SD_Card_FeaturesMask&FEATURE_MASK_HUM) {
 8019e22:	0319      	lsls	r1, r3, #12
 8019e24:	d414      	bmi.n	8019e50 <SaveDataAnnotation+0x98>
    size += sprintf(myBuffer+size, "%c",'\n');
 8019e26:	4610      	mov	r0, r2
 8019e28:	492c      	ldr	r1, [pc, #176]	; (8019edc <SaveDataAnnotation+0x124>)
 8019e2a:	220a      	movs	r2, #10
 8019e2c:	f005 fbb4 	bl	801f598 <siprintf>
    if(f_write(&MyFileMems, myBuffer, size, (void *)&byteswritten) != FR_OK) {
 8019e30:	1c62      	adds	r2, r4, #1
 8019e32:	a906      	add	r1, sp, #24
 8019e34:	ab05      	add	r3, sp, #20
 8019e36:	482a      	ldr	r0, [pc, #168]	; (8019ee0 <SaveDataAnnotation+0x128>)
 8019e38:	f7fb fe54 	bl	8015ae4 <f_write>
 8019e3c:	2800      	cmp	r0, #0
 8019e3e:	d0c1      	beq.n	8019dc4 <SaveDataAnnotation+0xc>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 8019e40:	4b28      	ldr	r3, [pc, #160]	; (8019ee4 <SaveDataAnnotation+0x12c>)
 8019e42:	681b      	ldr	r3, [r3, #0]
 8019e44:	055b      	lsls	r3, r3, #21
 8019e46:	d5bd      	bpl.n	8019dc4 <SaveDataAnnotation+0xc>
        SDLog_Update(SD_CARD_LOGGING_IO_ERROR);
 8019e48:	2003      	movs	r0, #3
 8019e4a:	f002 fc77 	bl	801c73c <SDLog_Update>
}
 8019e4e:	e7b9      	b.n	8019dc4 <SaveDataAnnotation+0xc>
        size += sprintf(myBuffer+size, "%c",',');
 8019e50:	4610      	mov	r0, r2
 8019e52:	4922      	ldr	r1, [pc, #136]	; (8019edc <SaveDataAnnotation+0x124>)
 8019e54:	222c      	movs	r2, #44	; 0x2c
 8019e56:	f005 fb9f 	bl	801f598 <siprintf>
 8019e5a:	3401      	adds	r4, #1
 8019e5c:	ab06      	add	r3, sp, #24
 8019e5e:	191a      	adds	r2, r3, r4
 8019e60:	e7e1      	b.n	8019e26 <SaveDataAnnotation+0x6e>
        size += sprintf(myBuffer+size, "%c",',');
 8019e62:	4610      	mov	r0, r2
 8019e64:	491d      	ldr	r1, [pc, #116]	; (8019edc <SaveDataAnnotation+0x124>)
 8019e66:	222c      	movs	r2, #44	; 0x2c
 8019e68:	f005 fb96 	bl	801f598 <siprintf>
 8019e6c:	3401      	adds	r4, #1
 8019e6e:	aa06      	add	r2, sp, #24
 8019e70:	f8d5 3268 	ldr.w	r3, [r5, #616]	; 0x268
 8019e74:	4422      	add	r2, r4
 8019e76:	e7d4      	b.n	8019e22 <SaveDataAnnotation+0x6a>
        size += sprintf(myBuffer+size, "%c",',');
 8019e78:	4610      	mov	r0, r2
 8019e7a:	4918      	ldr	r1, [pc, #96]	; (8019edc <SaveDataAnnotation+0x124>)
 8019e7c:	222c      	movs	r2, #44	; 0x2c
 8019e7e:	f005 fb8b 	bl	801f598 <siprintf>
 8019e82:	3401      	adds	r4, #1
 8019e84:	aa06      	add	r2, sp, #24
 8019e86:	f8d5 3268 	ldr.w	r3, [r5, #616]	; 0x268
 8019e8a:	4422      	add	r2, r4
 8019e8c:	e7c7      	b.n	8019e1e <SaveDataAnnotation+0x66>
        size += sprintf(myBuffer+size, "%c",',');
 8019e8e:	4610      	mov	r0, r2
 8019e90:	4912      	ldr	r1, [pc, #72]	; (8019edc <SaveDataAnnotation+0x124>)
 8019e92:	222c      	movs	r2, #44	; 0x2c
 8019e94:	f005 fb80 	bl	801f598 <siprintf>
 8019e98:	3401      	adds	r4, #1
 8019e9a:	aa06      	add	r2, sp, #24
 8019e9c:	f8d5 3268 	ldr.w	r3, [r5, #616]	; 0x268
 8019ea0:	4422      	add	r2, r4
 8019ea2:	e7ba      	b.n	8019e1a <SaveDataAnnotation+0x62>
        size += sprintf(myBuffer+size, "%s",",,,");
 8019ea4:	4910      	ldr	r1, [pc, #64]	; (8019ee8 <SaveDataAnnotation+0x130>)
 8019ea6:	6808      	ldr	r0, [r1, #0]
 8019ea8:	6010      	str	r0, [r2, #0]
 8019eaa:	3403      	adds	r4, #3
 8019eac:	aa06      	add	r2, sp, #24
 8019eae:	4422      	add	r2, r4
 8019eb0:	e7b1      	b.n	8019e16 <SaveDataAnnotation+0x5e>
        size += sprintf(myBuffer+size, "%s",",,,");
 8019eb2:	490d      	ldr	r1, [pc, #52]	; (8019ee8 <SaveDataAnnotation+0x130>)
 8019eb4:	6808      	ldr	r0, [r1, #0]
 8019eb6:	6010      	str	r0, [r2, #0]
 8019eb8:	3403      	adds	r4, #3
 8019eba:	aa06      	add	r2, sp, #24
 8019ebc:	4422      	add	r2, r4
 8019ebe:	e7a8      	b.n	8019e12 <SaveDataAnnotation+0x5a>
        size += sprintf(myBuffer+size, "%s",",,,");
 8019ec0:	4909      	ldr	r1, [pc, #36]	; (8019ee8 <SaveDataAnnotation+0x130>)
 8019ec2:	6808      	ldr	r0, [r1, #0]
 8019ec4:	6010      	str	r0, [r2, #0]
 8019ec6:	3403      	adds	r4, #3
 8019ec8:	aa06      	add	r2, sp, #24
 8019eca:	4422      	add	r2, r4
 8019ecc:	e79f      	b.n	8019e0e <SaveDataAnnotation+0x56>
 8019ece:	bf00      	nop
 8019ed0:	2000f074 	.word	0x2000f074
 8019ed4:	20012f24 	.word	0x20012f24
 8019ed8:	08075870 	.word	0x08075870
 8019edc:	08075540 	.word	0x08075540
 8019ee0:	2000f2e4 	.word	0x2000f2e4
 8019ee4:	20010030 	.word	0x20010030
 8019ee8:	08075534 	.word	0x08075534

08019eec <InitHWFeatures>:
  * @param  None
  * @retval None
  */
void InitHWFeatures(void){
   /* Read the Default Output Data Rate for Accelerometer */
  BSP_ACCELERO_Get_ODR(TargetBoardFeatures.HandleAccSensor,&DefaultAccODR);
 8019eec:	4b02      	ldr	r3, [pc, #8]	; (8019ef8 <InitHWFeatures+0xc>)
 8019eee:	4903      	ldr	r1, [pc, #12]	; (8019efc <InitHWFeatures+0x10>)
 8019ef0:	6998      	ldr	r0, [r3, #24]
 8019ef2:	f7f4 be1f 	b.w	800eb34 <BSP_ACCELERO_Get_ODR>
 8019ef6:	bf00      	nop
 8019ef8:	20011458 	.word	0x20011458
 8019efc:	2000ffe0 	.word	0x2000ffe0

08019f00 <DisableHWOrientation6D>:
  * @brief  This function disables the HW's 6D Orientation
  * @param  None
  * @retval None
  */
void DisableHWOrientation6D(void)
{
 8019f00:	b510      	push	{r4, lr}
  /* Disable Free Fall detection */
  if(BSP_ACCELERO_Disable_6D_Orientation_Ext(TargetBoardFeatures.HandleAccSensor)==COMPONENT_ERROR) {
 8019f02:	4c0a      	ldr	r4, [pc, #40]	; (8019f2c <DisableHWOrientation6D+0x2c>)
 8019f04:	69a0      	ldr	r0, [r4, #24]
 8019f06:	f7f4 ff4d 	bl	800eda4 <BSP_ACCELERO_Disable_6D_Orientation_Ext>
 8019f0a:	4b09      	ldr	r3, [pc, #36]	; (8019f30 <DisableHWOrientation6D+0x30>)
 8019f0c:	2801      	cmp	r0, #1
    SENSING1_PRINTF("Error Disabling 6D Orientation\r\n");
  } else {
    SENSING1_PRINTF("Disabled 6D Orientation\r\n");
    W2ST_OFF_HW_FEATURE(W2ST_HWF_6DORIENTATION);
 8019f0e:	bf18      	it	ne
 8019f10:	685a      	ldrne	r2, [r3, #4]
  }

  /* Set the Output Data Rate to Default value */
  BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,DefaultAccODR);
 8019f12:	69a0      	ldr	r0, [r4, #24]
 8019f14:	ed93 0a00 	vldr	s0, [r3]
    W2ST_OFF_HW_FEATURE(W2ST_HWF_6DORIENTATION);
 8019f18:	bf18      	it	ne
 8019f1a:	f022 0240 	bicne.w	r2, r2, #64	; 0x40
}
 8019f1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    W2ST_OFF_HW_FEATURE(W2ST_HWF_6DORIENTATION);
 8019f22:	bf18      	it	ne
 8019f24:	605a      	strne	r2, [r3, #4]
  BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,DefaultAccODR);
 8019f26:	f7f4 be17 	b.w	800eb58 <BSP_ACCELERO_Set_ODR_Value>
 8019f2a:	bf00      	nop
 8019f2c:	20011458 	.word	0x20011458
 8019f30:	2000ffe0 	.word	0x2000ffe0

08019f34 <GetHWOrientation6D>:
  * @brief  This function eturns the HW's 6D Orientation result
  * @param  None
  * @retval AccEventType 6D Orientation Found
  */
AccEventType GetHWOrientation6D(void)
{
 8019f34:	b530      	push	{r4, r5, lr}
  uint8_t zl = 0;
  uint8_t zh = 0;

  AccEventType OrientationResult = ACC_NOT_USED;

  if ( BSP_ACCELERO_Get_6D_Orientation_XL_Ext( TargetBoardFeatures.HandleAccSensor, &xl ) == COMPONENT_ERROR ){
 8019f36:	4d4c      	ldr	r5, [pc, #304]	; (801a068 <GetHWOrientation6D+0x134>)
{
 8019f38:	b083      	sub	sp, #12
  uint8_t xl = 0;
 8019f3a:	2400      	movs	r4, #0
  if ( BSP_ACCELERO_Get_6D_Orientation_XL_Ext( TargetBoardFeatures.HandleAccSensor, &xl ) == COMPONENT_ERROR ){
 8019f3c:	f10d 0102 	add.w	r1, sp, #2
 8019f40:	69a8      	ldr	r0, [r5, #24]
  uint8_t xl = 0;
 8019f42:	f88d 4002 	strb.w	r4, [sp, #2]
  uint8_t xh = 0;
 8019f46:	f88d 4003 	strb.w	r4, [sp, #3]
  uint8_t yl = 0;
 8019f4a:	f88d 4004 	strb.w	r4, [sp, #4]
  uint8_t yh = 0;
 8019f4e:	f88d 4005 	strb.w	r4, [sp, #5]
  uint8_t zl = 0;
 8019f52:	f88d 4006 	strb.w	r4, [sp, #6]
  uint8_t zh = 0;
 8019f56:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( BSP_ACCELERO_Get_6D_Orientation_XL_Ext( TargetBoardFeatures.HandleAccSensor, &xl ) == COMPONENT_ERROR ){
 8019f5a:	f7f4 ff2f 	bl	800edbc <BSP_ACCELERO_Get_6D_Orientation_XL_Ext>
    SENSING1_PRINTF("Error getting 6D orientation XL axis from LSM6DS3\r\n");
  }

  if ( BSP_ACCELERO_Get_6D_Orientation_XH_Ext( TargetBoardFeatures.HandleAccSensor, &xh ) == COMPONENT_ERROR ){
 8019f5e:	f10d 0103 	add.w	r1, sp, #3
 8019f62:	69a8      	ldr	r0, [r5, #24]
 8019f64:	f7f4 ff3e 	bl	800ede4 <BSP_ACCELERO_Get_6D_Orientation_XH_Ext>
    SENSING1_PRINTF("Error getting 6D orientation XH axis from LSM6DS3\r\n");
  }

  if ( BSP_ACCELERO_Get_6D_Orientation_YL_Ext( TargetBoardFeatures.HandleAccSensor, &yl ) == COMPONENT_ERROR ){
 8019f68:	a901      	add	r1, sp, #4
 8019f6a:	69a8      	ldr	r0, [r5, #24]
 8019f6c:	f7f4 ff50 	bl	800ee10 <BSP_ACCELERO_Get_6D_Orientation_YL_Ext>
    SENSING1_PRINTF("Error getting 6D orientation YL axis from LSM6DS3\r\n");
  }

  if ( BSP_ACCELERO_Get_6D_Orientation_YH_Ext( TargetBoardFeatures.HandleAccSensor, &yh ) == COMPONENT_ERROR ){
 8019f70:	f10d 0105 	add.w	r1, sp, #5
 8019f74:	69a8      	ldr	r0, [r5, #24]
 8019f76:	f7f4 ff61 	bl	800ee3c <BSP_ACCELERO_Get_6D_Orientation_YH_Ext>
    SENSING1_PRINTF("Error getting 6D orientation YH axis from LSM6DS3\r\n");
  }

  if ( BSP_ACCELERO_Get_6D_Orientation_ZL_Ext( TargetBoardFeatures.HandleAccSensor, &zl ) == COMPONENT_ERROR ){
 8019f7a:	f10d 0106 	add.w	r1, sp, #6
 8019f7e:	69a8      	ldr	r0, [r5, #24]
 8019f80:	f7f4 ff72 	bl	800ee68 <BSP_ACCELERO_Get_6D_Orientation_ZL_Ext>
    SENSING1_PRINTF("Error getting 6D orientation ZL axis from LSM6DS3\r\n");
  }

  if ( BSP_ACCELERO_Get_6D_Orientation_ZH_Ext( TargetBoardFeatures.HandleAccSensor, &zh ) == COMPONENT_ERROR ){
 8019f84:	69a8      	ldr	r0, [r5, #24]
 8019f86:	f10d 0107 	add.w	r1, sp, #7
 8019f8a:	f7f4 ff83 	bl	800ee94 <BSP_ACCELERO_Get_6D_Orientation_ZH_Ext>
    SENSING1_PRINTF("Error getting 6D orientation ZH axis from LSM6DS3\r\n");
  }

  if ( xl == 0 && yl == 0 && zl == 0 && xh == 0 && yh == 1 && zh == 0 ) {
 8019f8e:	f89d 0002 	ldrb.w	r0, [sp, #2]
 8019f92:	b9a0      	cbnz	r0, 8019fbe <GetHWOrientation6D+0x8a>
 8019f94:	f89d 4004 	ldrb.w	r4, [sp, #4]
 8019f98:	bb2c      	cbnz	r4, 8019fe6 <GetHWOrientation6D+0xb2>
 8019f9a:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8019f9e:	b3bb      	cbz	r3, 801a010 <GetHWOrientation6D+0xdc>
    OrientationResult = ACC_6D_OR_BOTTOM;
  } else if ( xl == 0 && yl == 1 && zl == 0 && xh == 0 && yh == 0 && zh == 0 ) {
    OrientationResult = ACC_6D_OR_LEFT;
  } else if ( xl == 0 && yl == 0 && zl == 0 && xh == 0 && yh == 0 && zh == 1 ) {
    OrientationResult = ACC_6D_OR_UP;
  } else if ( xl == 0 && yl == 0 && zl == 1 && xh == 0 && yh == 0 && zh == 0 ){
 8019fa0:	2b01      	cmp	r3, #1
 8019fa2:	d14e      	bne.n	801a042 <GetHWOrientation6D+0x10e>
 8019fa4:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8019fa8:	bb78      	cbnz	r0, 801a00a <GetHWOrientation6D+0xd6>
 8019faa:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8019fae:	bb6b      	cbnz	r3, 801a00c <GetHWOrientation6D+0xd8>
 8019fb0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    OrientationResult = ACC_6D_OR_DOWN;
 8019fb4:	2b00      	cmp	r3, #0
 8019fb6:	bf14      	ite	ne
 8019fb8:	2000      	movne	r0, #0
 8019fba:	2006      	moveq	r0, #6
 8019fbc:	e026      	b.n	801a00c <GetHWOrientation6D+0xd8>
  } else if ( xl == 1 && yl == 0 && zl == 0 && xh == 0 && yh == 0 && zh == 0 ) {
 8019fbe:	2801      	cmp	r0, #1
 8019fc0:	d123      	bne.n	801a00a <GetHWOrientation6D+0xd6>
 8019fc2:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8019fc6:	bb00      	cbnz	r0, 801a00a <GetHWOrientation6D+0xd6>
 8019fc8:	f89d 4006 	ldrb.w	r4, [sp, #6]
 8019fcc:	b9f4      	cbnz	r4, 801a00c <GetHWOrientation6D+0xd8>
 8019fce:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8019fd2:	b9d0      	cbnz	r0, 801a00a <GetHWOrientation6D+0xd6>
 8019fd4:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8019fd8:	b9c3      	cbnz	r3, 801a00c <GetHWOrientation6D+0xd8>
 8019fda:	f89d 4007 	ldrb.w	r4, [sp, #7]
    OrientationResult = ACC_6D_OR_RIGTH;
 8019fde:	fab4 f084 	clz	r0, r4
 8019fe2:	0940      	lsrs	r0, r0, #5
 8019fe4:	e012      	b.n	801a00c <GetHWOrientation6D+0xd8>
  } else if ( xl == 0 && yl == 1 && zl == 0 && xh == 0 && yh == 0 && zh == 0 ) {
 8019fe6:	2c01      	cmp	r4, #1
 8019fe8:	d110      	bne.n	801a00c <GetHWOrientation6D+0xd8>
 8019fea:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8019fee:	b96b      	cbnz	r3, 801a00c <GetHWOrientation6D+0xd8>
 8019ff0:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8019ff4:	bb28      	cbnz	r0, 801a042 <GetHWOrientation6D+0x10e>
 8019ff6:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8019ffa:	b93b      	cbnz	r3, 801a00c <GetHWOrientation6D+0xd8>
 8019ffc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    OrientationResult = ACC_6D_OR_LEFT;
 801a000:	2b00      	cmp	r3, #0
 801a002:	bf14      	ite	ne
 801a004:	2000      	movne	r0, #0
 801a006:	2002      	moveq	r0, #2
 801a008:	e000      	b.n	801a00c <GetHWOrientation6D+0xd8>
  AccEventType OrientationResult = ACC_NOT_USED;
 801a00a:	4620      	mov	r0, r4
  } else {
    SENSING1_PRINTF("None of the 6D orientation axes is set in LSM6DS3\r\n");
  }
  return OrientationResult;
}
 801a00c:	b003      	add	sp, #12
 801a00e:	bd30      	pop	{r4, r5, pc}
  if ( xl == 0 && yl == 0 && zl == 0 && xh == 0 && yh == 1 && zh == 0 ) {
 801a010:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801a014:	b91b      	cbnz	r3, 801a01e <GetHWOrientation6D+0xea>
 801a016:	f89d 3005 	ldrb.w	r3, [sp, #5]
 801a01a:	2b01      	cmp	r3, #1
 801a01c:	d014      	beq.n	801a048 <GetHWOrientation6D+0x114>
  } else if ( xl == 0 && yl == 0 && zl == 0 && xh == 1 && yh == 0 && zh == 0 ) {
 801a01e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801a022:	2b01      	cmp	r3, #1
 801a024:	d016      	beq.n	801a054 <GetHWOrientation6D+0x120>
  } else if ( xl == 0 && yl == 0 && zl == 0 && xh == 0 && yh == 0 && zh == 1 ) {
 801a026:	f89d 0003 	ldrb.w	r0, [sp, #3]
 801a02a:	b950      	cbnz	r0, 801a042 <GetHWOrientation6D+0x10e>
 801a02c:	f89d 3005 	ldrb.w	r3, [sp, #5]
 801a030:	2b00      	cmp	r3, #0
 801a032:	d1eb      	bne.n	801a00c <GetHWOrientation6D+0xd8>
 801a034:	f89d 3007 	ldrb.w	r3, [sp, #7]
  AccEventType OrientationResult = ACC_NOT_USED;
 801a038:	2b01      	cmp	r3, #1
 801a03a:	bf0c      	ite	eq
 801a03c:	2005      	moveq	r0, #5
 801a03e:	2000      	movne	r0, #0
 801a040:	e7e4      	b.n	801a00c <GetHWOrientation6D+0xd8>
 801a042:	2000      	movs	r0, #0
}
 801a044:	b003      	add	sp, #12
 801a046:	bd30      	pop	{r4, r5, pc}
  if ( xl == 0 && yl == 0 && zl == 0 && xh == 0 && yh == 1 && zh == 0 ) {
 801a048:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801a04c:	2b00      	cmp	r3, #0
 801a04e:	d1e6      	bne.n	801a01e <GetHWOrientation6D+0xea>
    OrientationResult = ACC_6D_OR_RIGTH;
 801a050:	2004      	movs	r0, #4
 801a052:	e7db      	b.n	801a00c <GetHWOrientation6D+0xd8>
  } else if ( xl == 0 && yl == 0 && zl == 0 && xh == 1 && yh == 0 && zh == 0 ) {
 801a054:	f89d 3005 	ldrb.w	r3, [sp, #5]
 801a058:	2b00      	cmp	r3, #0
 801a05a:	d1e4      	bne.n	801a026 <GetHWOrientation6D+0xf2>
 801a05c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801a060:	2b00      	cmp	r3, #0
 801a062:	d1e0      	bne.n	801a026 <GetHWOrientation6D+0xf2>
    OrientationResult = ACC_6D_OR_BOTTOM;
 801a064:	2003      	movs	r0, #3
 801a066:	e7d1      	b.n	801a00c <GetHWOrientation6D+0xd8>
 801a068:	20011458 	.word	0x20011458

0801a06c <DisableHWTilt>:
  * @brief  This function disables the HW's Tilt Detection
  * @param  None
  * @retval None
  */
void DisableHWTilt(void)
{
 801a06c:	b510      	push	{r4, lr}
  /* Disable Tilt detection */
  if(BSP_ACCELERO_Disable_Tilt_Detection_Ext(TargetBoardFeatures.HandleAccSensor)==COMPONENT_ERROR) {
 801a06e:	4c0a      	ldr	r4, [pc, #40]	; (801a098 <DisableHWTilt+0x2c>)
 801a070:	69a0      	ldr	r0, [r4, #24]
 801a072:	f7f4 fe1b 	bl	800ecac <BSP_ACCELERO_Disable_Tilt_Detection_Ext>
 801a076:	4b09      	ldr	r3, [pc, #36]	; (801a09c <DisableHWTilt+0x30>)
 801a078:	2801      	cmp	r0, #1
    SENSING1_PRINTF("Error Disabling Tilt Detection\r\n");
  } else {
    SENSING1_PRINTF("Disabled Tilt\r\n");
    W2ST_OFF_HW_FEATURE(W2ST_HWF_TILT);
 801a07a:	bf18      	it	ne
 801a07c:	685a      	ldrne	r2, [r3, #4]
  }

  /* Set the Output Data Rate to Default value */
  BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,DefaultAccODR);
 801a07e:	69a0      	ldr	r0, [r4, #24]
 801a080:	ed93 0a00 	vldr	s0, [r3]
    W2ST_OFF_HW_FEATURE(W2ST_HWF_TILT);
 801a084:	bf18      	it	ne
 801a086:	f022 0220 	bicne.w	r2, r2, #32
}
 801a08a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    W2ST_OFF_HW_FEATURE(W2ST_HWF_TILT);
 801a08e:	bf18      	it	ne
 801a090:	605a      	strne	r2, [r3, #4]
  BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,DefaultAccODR);
 801a092:	f7f4 bd61 	b.w	800eb58 <BSP_ACCELERO_Set_ODR_Value>
 801a096:	bf00      	nop
 801a098:	20011458 	.word	0x20011458
 801a09c:	2000ffe0 	.word	0x2000ffe0

0801a0a0 <DisableHWWakeUp>:
  * @brief  This function disables the HW's Wake Up Detection
  * @param  None
  * @retval None
  */
void DisableHWWakeUp(void)
{
 801a0a0:	b510      	push	{r4, lr}
  /* Disable Wake up detection */
  if(BSP_ACCELERO_Disable_Wake_Up_Detection_Ext(TargetBoardFeatures.HandleAccSensor)==COMPONENT_ERROR) {
 801a0a2:	4c0a      	ldr	r4, [pc, #40]	; (801a0cc <DisableHWWakeUp+0x2c>)
 801a0a4:	69a0      	ldr	r0, [r4, #24]
 801a0a6:	f7f4 fe1d 	bl	800ece4 <BSP_ACCELERO_Disable_Wake_Up_Detection_Ext>
 801a0aa:	4b09      	ldr	r3, [pc, #36]	; (801a0d0 <DisableHWWakeUp+0x30>)
 801a0ac:	2801      	cmp	r0, #1
    SENSING1_PRINTF("Error Disabling Wake Up Detection\r\n");
  } else {
    SENSING1_PRINTF("Disabled Wake Up\r\n");
    W2ST_OFF_HW_FEATURE(W2ST_HWF_WAKE_UP);
 801a0ae:	bf18      	it	ne
 801a0b0:	685a      	ldrne	r2, [r3, #4]
  }

  /* Set the Output Data Rate to Default value */
  BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,DefaultAccODR);
 801a0b2:	69a0      	ldr	r0, [r4, #24]
 801a0b4:	ed93 0a00 	vldr	s0, [r3]
    W2ST_OFF_HW_FEATURE(W2ST_HWF_WAKE_UP);
 801a0b8:	bf18      	it	ne
 801a0ba:	f022 0210 	bicne.w	r2, r2, #16
}
 801a0be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    W2ST_OFF_HW_FEATURE(W2ST_HWF_WAKE_UP);
 801a0c2:	bf18      	it	ne
 801a0c4:	605a      	strne	r2, [r3, #4]
  BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,DefaultAccODR);
 801a0c6:	f7f4 bd47 	b.w	800eb58 <BSP_ACCELERO_Set_ODR_Value>
 801a0ca:	bf00      	nop
 801a0cc:	20011458 	.word	0x20011458
 801a0d0:	2000ffe0 	.word	0x2000ffe0

0801a0d4 <DisableHWFreeFall>:
  * @brief  This function disables the HW's Free Fall Detection
  * @param  None
  * @retval None
  */
void DisableHWFreeFall(void)
{
 801a0d4:	b510      	push	{r4, lr}
  /* Disable Free Fall detection */
  if(BSP_ACCELERO_Disable_Free_Fall_Detection_Ext(TargetBoardFeatures.HandleAccSensor)==COMPONENT_ERROR) {
 801a0d6:	4c0a      	ldr	r4, [pc, #40]	; (801a100 <DisableHWFreeFall+0x2c>)
 801a0d8:	69a0      	ldr	r0, [r4, #24]
 801a0da:	f7f4 fd6d 	bl	800ebb8 <BSP_ACCELERO_Disable_Free_Fall_Detection_Ext>
 801a0de:	4b09      	ldr	r3, [pc, #36]	; (801a104 <DisableHWFreeFall+0x30>)
 801a0e0:	2801      	cmp	r0, #1
    SENSING1_PRINTF("Error Disabling Free Fall Detection\r\n");
  } else {
    SENSING1_PRINTF("Disabled Free Fall\r\n");
    W2ST_OFF_HW_FEATURE(W2ST_HWF_FREE_FALL);
 801a0e2:	bf18      	it	ne
 801a0e4:	685a      	ldrne	r2, [r3, #4]
  }

  /* Set the Output Data Rate to Default value */
  BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,DefaultAccODR);
 801a0e6:	69a0      	ldr	r0, [r4, #24]
 801a0e8:	ed93 0a00 	vldr	s0, [r3]
    W2ST_OFF_HW_FEATURE(W2ST_HWF_FREE_FALL);
 801a0ec:	bf18      	it	ne
 801a0ee:	f022 0202 	bicne.w	r2, r2, #2
}
 801a0f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    W2ST_OFF_HW_FEATURE(W2ST_HWF_FREE_FALL);
 801a0f6:	bf18      	it	ne
 801a0f8:	605a      	strne	r2, [r3, #4]
  BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,DefaultAccODR);
 801a0fa:	f7f4 bd2d 	b.w	800eb58 <BSP_ACCELERO_Set_ODR_Value>
 801a0fe:	bf00      	nop
 801a100:	20011458 	.word	0x20011458
 801a104:	2000ffe0 	.word	0x2000ffe0

0801a108 <DisableHWDoubleTap>:
  * @brief  This function disables the HW's Double Tap Detection
  * @param  None
  * @retval None
  */
void DisableHWDoubleTap(void)
{
 801a108:	b510      	push	{r4, lr}
  /* Disable Double Tap detection */
  if(BSP_ACCELERO_Disable_Double_Tap_Detection_Ext(TargetBoardFeatures.HandleAccSensor)==COMPONENT_ERROR) {
 801a10a:	4c0a      	ldr	r4, [pc, #40]	; (801a134 <DisableHWDoubleTap+0x2c>)
 801a10c:	69a0      	ldr	r0, [r4, #24]
 801a10e:	f7f4 fe21 	bl	800ed54 <BSP_ACCELERO_Disable_Double_Tap_Detection_Ext>
 801a112:	4b09      	ldr	r3, [pc, #36]	; (801a138 <DisableHWDoubleTap+0x30>)
 801a114:	2801      	cmp	r0, #1
    SENSING1_PRINTF("Error Disabling Double Tap Detection\r\n");
  } else {
    SENSING1_PRINTF("Disabled Double Tap\r\n");
    W2ST_OFF_HW_FEATURE(W2ST_HWF_DOUBLE_TAP);
 801a116:	bf18      	it	ne
 801a118:	685a      	ldrne	r2, [r3, #4]
  }

  /* Set the Output Data Rate to Default value */
  BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,DefaultAccODR);
 801a11a:	69a0      	ldr	r0, [r4, #24]
 801a11c:	ed93 0a00 	vldr	s0, [r3]
    W2ST_OFF_HW_FEATURE(W2ST_HWF_DOUBLE_TAP);
 801a120:	bf18      	it	ne
 801a122:	f022 0204 	bicne.w	r2, r2, #4
}
 801a126:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    W2ST_OFF_HW_FEATURE(W2ST_HWF_DOUBLE_TAP);
 801a12a:	bf18      	it	ne
 801a12c:	605a      	strne	r2, [r3, #4]
  BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,DefaultAccODR);
 801a12e:	f7f4 bd13 	b.w	800eb58 <BSP_ACCELERO_Set_ODR_Value>
 801a132:	bf00      	nop
 801a134:	20011458 	.word	0x20011458
 801a138:	2000ffe0 	.word	0x2000ffe0

0801a13c <DisableHWSingleTap>:
  * @brief  This function disables the HW's Single Tap Detection
  * @param  None
  * @retval None
  */
void DisableHWSingleTap(void)
{
 801a13c:	b510      	push	{r4, lr}
  /* Disable Single Tap detection */
  if(BSP_ACCELERO_Disable_Single_Tap_Detection_Ext(TargetBoardFeatures.HandleAccSensor)==COMPONENT_ERROR) {
 801a13e:	4c0a      	ldr	r4, [pc, #40]	; (801a168 <DisableHWSingleTap+0x2c>)
 801a140:	69a0      	ldr	r0, [r4, #24]
 801a142:	f7f4 fdeb 	bl	800ed1c <BSP_ACCELERO_Disable_Single_Tap_Detection_Ext>
 801a146:	4b09      	ldr	r3, [pc, #36]	; (801a16c <DisableHWSingleTap+0x30>)
 801a148:	2801      	cmp	r0, #1
    SENSING1_PRINTF("Error Disabling Single Tap Detection\r\n");
  } else {
    SENSING1_PRINTF("Disabled Sigle Tap\r\n");
    W2ST_OFF_HW_FEATURE(W2ST_HWF_SINGLE_TAP);
 801a14a:	bf18      	it	ne
 801a14c:	685a      	ldrne	r2, [r3, #4]
  }

  /* Set the Output Data Rate to Default value */
  BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,DefaultAccODR);
 801a14e:	69a0      	ldr	r0, [r4, #24]
 801a150:	ed93 0a00 	vldr	s0, [r3]
    W2ST_OFF_HW_FEATURE(W2ST_HWF_SINGLE_TAP);
 801a154:	bf18      	it	ne
 801a156:	f022 0208 	bicne.w	r2, r2, #8
}
 801a15a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    W2ST_OFF_HW_FEATURE(W2ST_HWF_SINGLE_TAP);
 801a15e:	bf18      	it	ne
 801a160:	605a      	strne	r2, [r3, #4]
  BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,DefaultAccODR);
 801a162:	f7f4 bcf9 	b.w	800eb58 <BSP_ACCELERO_Set_ODR_Value>
 801a166:	bf00      	nop
 801a168:	20011458 	.word	0x20011458
 801a16c:	2000ffe0 	.word	0x2000ffe0

0801a170 <DisableHWPedometer>:
  * @brief  This function disables the HW's pedometer
  * @param  None
  * @retval None
  */
void DisableHWPedometer(void)
{
 801a170:	b510      	push	{r4, lr}
  if(BSP_ACCELERO_Disable_Pedometer_Ext(TargetBoardFeatures.HandleAccSensor)==COMPONENT_ERROR) {
 801a172:	4c0a      	ldr	r4, [pc, #40]	; (801a19c <DisableHWPedometer+0x2c>)
 801a174:	69a0      	ldr	r0, [r4, #24]
 801a176:	f7f4 fd47 	bl	800ec08 <BSP_ACCELERO_Disable_Pedometer_Ext>
 801a17a:	4b09      	ldr	r3, [pc, #36]	; (801a1a0 <DisableHWPedometer+0x30>)
 801a17c:	2801      	cmp	r0, #1
    SENSING1_PRINTF("Error Disabling Pedometer\r\n");
  } else {
    SENSING1_PRINTF("Disabled Pedometer\r\n");
    W2ST_OFF_HW_FEATURE(W2ST_HWF_PEDOMETER);
 801a17e:	bf18      	it	ne
 801a180:	685a      	ldrne	r2, [r3, #4]
  }

  /* Set the Output Data Rate to Default value */
  BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,DefaultAccODR);
 801a182:	69a0      	ldr	r0, [r4, #24]
 801a184:	ed93 0a00 	vldr	s0, [r3]
    W2ST_OFF_HW_FEATURE(W2ST_HWF_PEDOMETER);
 801a188:	bf18      	it	ne
 801a18a:	f022 0201 	bicne.w	r2, r2, #1
}
 801a18e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    W2ST_OFF_HW_FEATURE(W2ST_HWF_PEDOMETER);
 801a192:	bf18      	it	ne
 801a194:	605a      	strne	r2, [r3, #4]
  BSP_ACCELERO_Set_ODR_Value(TargetBoardFeatures.HandleAccSensor,DefaultAccODR);
 801a196:	f7f4 bcdf 	b.w	800eb58 <BSP_ACCELERO_Set_ODR_Value>
 801a19a:	bf00      	nop
 801a19c:	20011458 	.word	0x20011458
 801a1a0:	2000ffe0 	.word	0x2000ffe0

0801a1a4 <DisableHWFeatures>:
{
 801a1a4:	b510      	push	{r4, lr}
  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_PEDOMETER)) {
 801a1a6:	4c16      	ldr	r4, [pc, #88]	; (801a200 <DisableHWFeatures+0x5c>)
 801a1a8:	6863      	ldr	r3, [r4, #4]
 801a1aa:	07d8      	lsls	r0, r3, #31
 801a1ac:	d424      	bmi.n	801a1f8 <DisableHWFeatures+0x54>
  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_FREE_FALL)) {
 801a1ae:	0799      	lsls	r1, r3, #30
 801a1b0:	d41e      	bmi.n	801a1f0 <DisableHWFeatures+0x4c>
  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_DOUBLE_TAP)) {
 801a1b2:	075a      	lsls	r2, r3, #29
 801a1b4:	d418      	bmi.n	801a1e8 <DisableHWFeatures+0x44>
  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_SINGLE_TAP)) {
 801a1b6:	0718      	lsls	r0, r3, #28
 801a1b8:	d412      	bmi.n	801a1e0 <DisableHWFeatures+0x3c>
  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_WAKE_UP)) {
 801a1ba:	06d9      	lsls	r1, r3, #27
 801a1bc:	d40c      	bmi.n	801a1d8 <DisableHWFeatures+0x34>
  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_TILT)) {
 801a1be:	069a      	lsls	r2, r3, #26
 801a1c0:	d406      	bmi.n	801a1d0 <DisableHWFeatures+0x2c>
  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_6DORIENTATION)) {
 801a1c2:	065b      	lsls	r3, r3, #25
 801a1c4:	d400      	bmi.n	801a1c8 <DisableHWFeatures+0x24>
}
 801a1c6:	bd10      	pop	{r4, pc}
 801a1c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    DisableHWOrientation6D();
 801a1cc:	f7ff be98 	b.w	8019f00 <DisableHWOrientation6D>
    DisableHWTilt();
 801a1d0:	f7ff ff4c 	bl	801a06c <DisableHWTilt>
 801a1d4:	6863      	ldr	r3, [r4, #4]
 801a1d6:	e7f4      	b.n	801a1c2 <DisableHWFeatures+0x1e>
    DisableHWWakeUp();
 801a1d8:	f7ff ff62 	bl	801a0a0 <DisableHWWakeUp>
 801a1dc:	6863      	ldr	r3, [r4, #4]
 801a1de:	e7ee      	b.n	801a1be <DisableHWFeatures+0x1a>
    DisableHWSingleTap();
 801a1e0:	f7ff ffac 	bl	801a13c <DisableHWSingleTap>
 801a1e4:	6863      	ldr	r3, [r4, #4]
 801a1e6:	e7e8      	b.n	801a1ba <DisableHWFeatures+0x16>
    DisableHWDoubleTap();
 801a1e8:	f7ff ff8e 	bl	801a108 <DisableHWDoubleTap>
 801a1ec:	6863      	ldr	r3, [r4, #4]
 801a1ee:	e7e2      	b.n	801a1b6 <DisableHWFeatures+0x12>
    DisableHWFreeFall();
 801a1f0:	f7ff ff70 	bl	801a0d4 <DisableHWFreeFall>
 801a1f4:	6863      	ldr	r3, [r4, #4]
 801a1f6:	e7dc      	b.n	801a1b2 <DisableHWFeatures+0xe>
    DisableHWPedometer();
 801a1f8:	f7ff ffba 	bl	801a170 <DisableHWPedometer>
 801a1fc:	6863      	ldr	r3, [r4, #4]
 801a1fe:	e7d6      	b.n	801a1ae <DisableHWFeatures+0xa>
 801a200:	2000ffe0 	.word	0x2000ffe0

0801a204 <EnableHWOrientation6D>:
{
 801a204:	b510      	push	{r4, lr}
  if(!MultipleAccEventEnabled)
 801a206:	4c09      	ldr	r4, [pc, #36]	; (801a22c <EnableHWOrientation6D+0x28>)
 801a208:	7a23      	ldrb	r3, [r4, #8]
 801a20a:	b15b      	cbz	r3, 801a224 <EnableHWOrientation6D+0x20>
  if(BSP_ACCELERO_Enable_6D_Orientation_Ext(TargetBoardFeatures.HandleAccSensor,INT_PIN)==COMPONENT_ERROR) {
 801a20c:	4b08      	ldr	r3, [pc, #32]	; (801a230 <EnableHWOrientation6D+0x2c>)
 801a20e:	2101      	movs	r1, #1
 801a210:	6998      	ldr	r0, [r3, #24]
 801a212:	f7f4 fdb7 	bl	800ed84 <BSP_ACCELERO_Enable_6D_Orientation_Ext>
 801a216:	2801      	cmp	r0, #1
 801a218:	d003      	beq.n	801a222 <EnableHWOrientation6D+0x1e>
    W2ST_ON_HW_FEATURE(W2ST_HWF_6DORIENTATION);
 801a21a:	6863      	ldr	r3, [r4, #4]
 801a21c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801a220:	6063      	str	r3, [r4, #4]
}
 801a222:	bd10      	pop	{r4, pc}
    DisableHWFeatures();
 801a224:	f7ff ffbe 	bl	801a1a4 <DisableHWFeatures>
 801a228:	e7f0      	b.n	801a20c <EnableHWOrientation6D+0x8>
 801a22a:	bf00      	nop
 801a22c:	2000ffe0 	.word	0x2000ffe0
 801a230:	20011458 	.word	0x20011458

0801a234 <EnableHWTilt>:
{
 801a234:	b510      	push	{r4, lr}
  if(!MultipleAccEventEnabled)
 801a236:	4c09      	ldr	r4, [pc, #36]	; (801a25c <EnableHWTilt+0x28>)
 801a238:	7a23      	ldrb	r3, [r4, #8]
 801a23a:	b15b      	cbz	r3, 801a254 <EnableHWTilt+0x20>
  if(BSP_ACCELERO_Enable_Tilt_Detection_Ext(TargetBoardFeatures.HandleAccSensor,INT_PIN)==COMPONENT_ERROR) {
 801a23c:	4b08      	ldr	r3, [pc, #32]	; (801a260 <EnableHWTilt+0x2c>)
 801a23e:	2101      	movs	r1, #1
 801a240:	6998      	ldr	r0, [r3, #24]
 801a242:	f7f4 fd23 	bl	800ec8c <BSP_ACCELERO_Enable_Tilt_Detection_Ext>
 801a246:	2801      	cmp	r0, #1
 801a248:	d003      	beq.n	801a252 <EnableHWTilt+0x1e>
    W2ST_ON_HW_FEATURE(W2ST_HWF_TILT);
 801a24a:	6863      	ldr	r3, [r4, #4]
 801a24c:	f043 0320 	orr.w	r3, r3, #32
 801a250:	6063      	str	r3, [r4, #4]
}
 801a252:	bd10      	pop	{r4, pc}
    DisableHWFeatures();
 801a254:	f7ff ffa6 	bl	801a1a4 <DisableHWFeatures>
 801a258:	e7f0      	b.n	801a23c <EnableHWTilt+0x8>
 801a25a:	bf00      	nop
 801a25c:	2000ffe0 	.word	0x2000ffe0
 801a260:	20011458 	.word	0x20011458

0801a264 <EnableHWWakeUp>:
{
 801a264:	b510      	push	{r4, lr}
  if(!MultipleAccEventEnabled)
 801a266:	4c09      	ldr	r4, [pc, #36]	; (801a28c <EnableHWWakeUp+0x28>)
 801a268:	7a23      	ldrb	r3, [r4, #8]
 801a26a:	b15b      	cbz	r3, 801a284 <EnableHWWakeUp+0x20>
  if(BSP_ACCELERO_Enable_Wake_Up_Detection_Ext(TargetBoardFeatures.HandleAccSensor,INT_PIN_WAKE_UP)==COMPONENT_ERROR) {
 801a26c:	4b08      	ldr	r3, [pc, #32]	; (801a290 <EnableHWWakeUp+0x2c>)
 801a26e:	2101      	movs	r1, #1
 801a270:	6998      	ldr	r0, [r3, #24]
 801a272:	f7f4 fd27 	bl	800ecc4 <BSP_ACCELERO_Enable_Wake_Up_Detection_Ext>
 801a276:	2801      	cmp	r0, #1
 801a278:	d003      	beq.n	801a282 <EnableHWWakeUp+0x1e>
    W2ST_ON_HW_FEATURE(W2ST_HWF_WAKE_UP);
 801a27a:	6863      	ldr	r3, [r4, #4]
 801a27c:	f043 0310 	orr.w	r3, r3, #16
 801a280:	6063      	str	r3, [r4, #4]
}
 801a282:	bd10      	pop	{r4, pc}
    DisableHWFeatures();
 801a284:	f7ff ff8e 	bl	801a1a4 <DisableHWFeatures>
 801a288:	e7f0      	b.n	801a26c <EnableHWWakeUp+0x8>
 801a28a:	bf00      	nop
 801a28c:	2000ffe0 	.word	0x2000ffe0
 801a290:	20011458 	.word	0x20011458

0801a294 <EnableHWFreeFall>:
{
 801a294:	b538      	push	{r3, r4, r5, lr}
  if(!MultipleAccEventEnabled)
 801a296:	4c0b      	ldr	r4, [pc, #44]	; (801a2c4 <EnableHWFreeFall+0x30>)
 801a298:	7a23      	ldrb	r3, [r4, #8]
 801a29a:	b183      	cbz	r3, 801a2be <EnableHWFreeFall+0x2a>
  if(BSP_ACCELERO_Enable_Free_Fall_Detection_Ext(TargetBoardFeatures.HandleAccSensor,INT_PIN)==COMPONENT_ERROR) {
 801a29c:	4d0a      	ldr	r5, [pc, #40]	; (801a2c8 <EnableHWFreeFall+0x34>)
 801a29e:	2101      	movs	r1, #1
 801a2a0:	69a8      	ldr	r0, [r5, #24]
 801a2a2:	f7f4 fc79 	bl	800eb98 <BSP_ACCELERO_Enable_Free_Fall_Detection_Ext>
 801a2a6:	2801      	cmp	r0, #1
 801a2a8:	d003      	beq.n	801a2b2 <EnableHWFreeFall+0x1e>
    W2ST_ON_HW_FEATURE(W2ST_HWF_FREE_FALL);
 801a2aa:	6863      	ldr	r3, [r4, #4]
 801a2ac:	f043 0302 	orr.w	r3, r3, #2
 801a2b0:	6063      	str	r3, [r4, #4]
  if(BSP_ACCELERO_Set_Free_Fall_Threshold_Ext(TargetBoardFeatures.HandleAccSensor,LSM6DSM_ACC_GYRO_FF_THS_219mg)==COMPONENT_ERROR) {
 801a2b2:	69a8      	ldr	r0, [r5, #24]
 801a2b4:	2101      	movs	r1, #1
}
 801a2b6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  if(BSP_ACCELERO_Set_Free_Fall_Threshold_Ext(TargetBoardFeatures.HandleAccSensor,LSM6DSM_ACC_GYRO_FF_THS_219mg)==COMPONENT_ERROR) {
 801a2ba:	f7f4 bc89 	b.w	800ebd0 <BSP_ACCELERO_Set_Free_Fall_Threshold_Ext>
    DisableHWFeatures();
 801a2be:	f7ff ff71 	bl	801a1a4 <DisableHWFeatures>
 801a2c2:	e7eb      	b.n	801a29c <EnableHWFreeFall+0x8>
 801a2c4:	2000ffe0 	.word	0x2000ffe0
 801a2c8:	20011458 	.word	0x20011458

0801a2cc <EnableHWDoubleTap>:
{
 801a2cc:	b538      	push	{r3, r4, r5, lr}
  if(!MultipleAccEventEnabled)
 801a2ce:	4c0b      	ldr	r4, [pc, #44]	; (801a2fc <EnableHWDoubleTap+0x30>)
 801a2d0:	7a23      	ldrb	r3, [r4, #8]
 801a2d2:	b183      	cbz	r3, 801a2f6 <EnableHWDoubleTap+0x2a>
  if(BSP_ACCELERO_Enable_Double_Tap_Detection_Ext(TargetBoardFeatures.HandleAccSensor,INT_PIN)==COMPONENT_ERROR) {
 801a2d4:	4d0a      	ldr	r5, [pc, #40]	; (801a300 <EnableHWDoubleTap+0x34>)
 801a2d6:	2101      	movs	r1, #1
 801a2d8:	69a8      	ldr	r0, [r5, #24]
 801a2da:	f7f4 fd2b 	bl	800ed34 <BSP_ACCELERO_Enable_Double_Tap_Detection_Ext>
 801a2de:	2801      	cmp	r0, #1
 801a2e0:	d003      	beq.n	801a2ea <EnableHWDoubleTap+0x1e>
    W2ST_ON_HW_FEATURE(W2ST_HWF_DOUBLE_TAP);
 801a2e2:	6863      	ldr	r3, [r4, #4]
 801a2e4:	f043 0304 	orr.w	r3, r3, #4
 801a2e8:	6063      	str	r3, [r4, #4]
  if(BSP_ACCELERO_Set_Tap_Threshold_Ext(TargetBoardFeatures.HandleAccSensor,LSM6DSM_TAP_THRESHOLD_MID)==COMPONENT_ERROR) {
 801a2ea:	69a8      	ldr	r0, [r5, #24]
 801a2ec:	2110      	movs	r1, #16
}
 801a2ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  if(BSP_ACCELERO_Set_Tap_Threshold_Ext(TargetBoardFeatures.HandleAccSensor,LSM6DSM_TAP_THRESHOLD_MID)==COMPONENT_ERROR) {
 801a2f2:	f7f4 bd3b 	b.w	800ed6c <BSP_ACCELERO_Set_Tap_Threshold_Ext>
    DisableHWFeatures();
 801a2f6:	f7ff ff55 	bl	801a1a4 <DisableHWFeatures>
 801a2fa:	e7eb      	b.n	801a2d4 <EnableHWDoubleTap+0x8>
 801a2fc:	2000ffe0 	.word	0x2000ffe0
 801a300:	20011458 	.word	0x20011458

0801a304 <EnableHWSingleTap>:
{
 801a304:	b510      	push	{r4, lr}
  if(!MultipleAccEventEnabled)
 801a306:	4c09      	ldr	r4, [pc, #36]	; (801a32c <EnableHWSingleTap+0x28>)
 801a308:	7a23      	ldrb	r3, [r4, #8]
 801a30a:	b15b      	cbz	r3, 801a324 <EnableHWSingleTap+0x20>
  if(BSP_ACCELERO_Enable_Single_Tap_Detection_Ext(TargetBoardFeatures.HandleAccSensor,INT_PIN)==COMPONENT_ERROR) {
 801a30c:	4b08      	ldr	r3, [pc, #32]	; (801a330 <EnableHWSingleTap+0x2c>)
 801a30e:	2101      	movs	r1, #1
 801a310:	6998      	ldr	r0, [r3, #24]
 801a312:	f7f4 fcf3 	bl	800ecfc <BSP_ACCELERO_Enable_Single_Tap_Detection_Ext>
 801a316:	2801      	cmp	r0, #1
 801a318:	d003      	beq.n	801a322 <EnableHWSingleTap+0x1e>
    W2ST_ON_HW_FEATURE(W2ST_HWF_SINGLE_TAP);
 801a31a:	6863      	ldr	r3, [r4, #4]
 801a31c:	f043 0308 	orr.w	r3, r3, #8
 801a320:	6063      	str	r3, [r4, #4]
}
 801a322:	bd10      	pop	{r4, pc}
    DisableHWFeatures();
 801a324:	f7ff ff3e 	bl	801a1a4 <DisableHWFeatures>
 801a328:	e7f0      	b.n	801a30c <EnableHWSingleTap+0x8>
 801a32a:	bf00      	nop
 801a32c:	2000ffe0 	.word	0x2000ffe0
 801a330:	20011458 	.word	0x20011458

0801a334 <EnableHWPedometer>:
{
 801a334:	b510      	push	{r4, lr}
  if(!MultipleAccEventEnabled)
 801a336:	4c09      	ldr	r4, [pc, #36]	; (801a35c <EnableHWPedometer+0x28>)
 801a338:	7a23      	ldrb	r3, [r4, #8]
 801a33a:	b15b      	cbz	r3, 801a354 <EnableHWPedometer+0x20>
  if(BSP_ACCELERO_Enable_Pedometer_Ext(TargetBoardFeatures.HandleAccSensor, INT_PIN)==COMPONENT_ERROR) {
 801a33c:	4b08      	ldr	r3, [pc, #32]	; (801a360 <EnableHWPedometer+0x2c>)
 801a33e:	2101      	movs	r1, #1
 801a340:	6998      	ldr	r0, [r3, #24]
 801a342:	f7f4 fc51 	bl	800ebe8 <BSP_ACCELERO_Enable_Pedometer_Ext>
 801a346:	2801      	cmp	r0, #1
 801a348:	d003      	beq.n	801a352 <EnableHWPedometer+0x1e>
    W2ST_ON_HW_FEATURE(W2ST_HWF_PEDOMETER);
 801a34a:	6863      	ldr	r3, [r4, #4]
 801a34c:	f043 0301 	orr.w	r3, r3, #1
 801a350:	6063      	str	r3, [r4, #4]
}
 801a352:	bd10      	pop	{r4, pc}
    DisableHWFeatures();
 801a354:	f7ff ff26 	bl	801a1a4 <DisableHWFeatures>
 801a358:	e7f0      	b.n	801a33c <EnableHWPedometer+0x8>
 801a35a:	bf00      	nop
 801a35c:	2000ffe0 	.word	0x2000ffe0
 801a360:	20011458 	.word	0x20011458

0801a364 <ResetHWPedometer>:
  * @param  None
  * @retval None
  */
void ResetHWPedometer(void)
{
  if ( BSP_ACCELERO_Reset_Step_Counter_Ext( TargetBoardFeatures.HandleAccSensor ) == COMPONENT_ERROR ){
 801a364:	4b01      	ldr	r3, [pc, #4]	; (801a36c <ResetHWPedometer+0x8>)
 801a366:	6998      	ldr	r0, [r3, #24]
 801a368:	f7f4 bc6e 	b.w	800ec48 <BSP_ACCELERO_Reset_Step_Counter_Ext>
 801a36c:	20011458 	.word	0x20011458

0801a370 <GetStepHWPedometer>:
  * @brief  This function retunrs the HW's pedometer steps counter value
  * @param  None
  * @retval uint16_t Steps Counter
  */
uint16_t GetStepHWPedometer(void)
{
 801a370:	b500      	push	{lr}
 801a372:	b083      	sub	sp, #12
  uint16_t step_count=0;
 801a374:	a902      	add	r1, sp, #8
 801a376:	2300      	movs	r3, #0
 801a378:	f821 3d02 	strh.w	r3, [r1, #-2]!
  if(BSP_ACCELERO_Get_Step_Count_Ext( TargetBoardFeatures.HandleAccSensor, &step_count ) == COMPONENT_ERROR ){
 801a37c:	4b04      	ldr	r3, [pc, #16]	; (801a390 <GetStepHWPedometer+0x20>)
 801a37e:	6998      	ldr	r0, [r3, #24]
 801a380:	f7f4 fc4e 	bl	800ec20 <BSP_ACCELERO_Get_Step_Count_Ext>
    SENSING1_PRINTF("Error Reading Pedometer's Counter\r\n");
  } else {
    SENSING1_PRINTF("Pedometer's Counter=%u\r\n",step_count);
  }
  return step_count;
}
 801a384:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 801a388:	b003      	add	sp, #12
 801a38a:	f85d fb04 	ldr.w	pc, [sp], #4
 801a38e:	bf00      	nop
 801a390:	20011458 	.word	0x20011458

0801a394 <EnableHWMultipleEvents>:
  * @brief  This function enables the multiple HW's events
  * @param  None
  * @retval None
  */
void EnableHWMultipleEvents(void)
{
 801a394:	b510      	push	{r4, lr}
  DisableHWFeatures();
  
  MultipleAccEventEnabled= 1;
 801a396:	4c0e      	ldr	r4, [pc, #56]	; (801a3d0 <EnableHWMultipleEvents+0x3c>)
  DisableHWFeatures();
 801a398:	f7ff ff04 	bl	801a1a4 <DisableHWFeatures>
  MultipleAccEventEnabled= 1;
 801a39c:	2301      	movs	r3, #1
 801a39e:	7223      	strb	r3, [r4, #8]
  
  /* Do not change the enable sequenze of the HW events */
  /* It depends on the ODR value (from minor value to max value) */
  EnableHWPedometer();
 801a3a0:	f7ff ffc8 	bl	801a334 <EnableHWPedometer>
  EnableHWTilt();
 801a3a4:	f7ff ff46 	bl	801a234 <EnableHWTilt>
  EnableHWFreeFall();
 801a3a8:	f7ff ff74 	bl	801a294 <EnableHWFreeFall>
  EnableHWSingleTap();
 801a3ac:	f7ff ffaa 	bl	801a304 <EnableHWSingleTap>
  EnableHWDoubleTap();
 801a3b0:	f7ff ff8c 	bl	801a2cc <EnableHWDoubleTap>
  EnableHWOrientation6D();
 801a3b4:	f7ff ff26 	bl	801a204 <EnableHWOrientation6D>
  
  PedometerStepCount=0;
 801a3b8:	2300      	movs	r3, #0
 801a3ba:	4a06      	ldr	r2, [pc, #24]	; (801a3d4 <EnableHWMultipleEvents+0x40>)
  AccEvent_Notify(PedometerStepCount, 3);
 801a3bc:	4618      	mov	r0, r3
 801a3be:	2103      	movs	r1, #3
  PedometerStepCount=0;
 801a3c0:	8013      	strh	r3, [r2, #0]
  AccEvent_Notify(PedometerStepCount, 3);
 801a3c2:	f001 fe79 	bl	801c0b8 <AccEvent_Notify>
   
  W2ST_ON_HW_FEATURE(W2ST_HWF_MULTIPLE_EVENTS);
 801a3c6:	6863      	ldr	r3, [r4, #4]
 801a3c8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801a3cc:	6063      	str	r3, [r4, #4]
}
 801a3ce:	bd10      	pop	{r4, pc}
 801a3d0:	2000ffe0 	.word	0x2000ffe0
 801a3d4:	20010020 	.word	0x20010020

0801a3d8 <DisableHWMultipleEvents>:
  * @brief  This function disables the multiple HW's events
  * @param  None
  * @retval None
  */
void DisableHWMultipleEvents(void)
{
 801a3d8:	b508      	push	{r3, lr}
  DisableHWFeatures();
 801a3da:	f7ff fee3 	bl	801a1a4 <DisableHWFeatures>
  MultipleAccEventEnabled= 0;
 801a3de:	4b04      	ldr	r3, [pc, #16]	; (801a3f0 <DisableHWMultipleEvents+0x18>)
  W2ST_OFF_HW_FEATURE(W2ST_HWF_MULTIPLE_EVENTS);
 801a3e0:	685a      	ldr	r2, [r3, #4]
  MultipleAccEventEnabled= 0;
 801a3e2:	2100      	movs	r1, #0
  W2ST_OFF_HW_FEATURE(W2ST_HWF_MULTIPLE_EVENTS);
 801a3e4:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  MultipleAccEventEnabled= 0;
 801a3e8:	7219      	strb	r1, [r3, #8]
  W2ST_OFF_HW_FEATURE(W2ST_HWF_MULTIPLE_EVENTS);
 801a3ea:	605a      	str	r2, [r3, #4]
}
 801a3ec:	bd08      	pop	{r3, pc}
 801a3ee:	bf00      	nop
 801a3f0:	2000ffe0 	.word	0x2000ffe0

0801a3f4 <PowerCtrlLock>:
  return 0;
}

int PowerCtrlLock(void)
{
  return ++PowerCtrlLockToken;
 801a3f4:	4b02      	ldr	r3, [pc, #8]	; (801a400 <PowerCtrlLock+0xc>)
 801a3f6:	6858      	ldr	r0, [r3, #4]
 801a3f8:	3001      	adds	r0, #1
 801a3fa:	6058      	str	r0, [r3, #4]
}
 801a3fc:	4770      	bx	lr
 801a3fe:	bf00      	nop
 801a400:	2000ffec 	.word	0x2000ffec

0801a404 <PowerCtrlUnLock>:
int PowerCtrlUnLock(void)
{
  PowerCtrlLockToken -= (PowerCtrlLockToken) ? 1:0;
 801a404:	4b03      	ldr	r3, [pc, #12]	; (801a414 <PowerCtrlUnLock+0x10>)
 801a406:	6858      	ldr	r0, [r3, #4]
 801a408:	2800      	cmp	r0, #0
 801a40a:	bf18      	it	ne
 801a40c:	3801      	subne	r0, #1
 801a40e:	6058      	str	r0, [r3, #4]
  return PowerCtrlLockToken;
}
 801a410:	4770      	bx	lr
 801a412:	bf00      	nop
 801a414:	2000ffec 	.word	0x2000ffec

0801a418 <vApplicationIdleHook>:
  __ASM volatile ("wfi");
 801a418:	bf30      	wfi
}

void vApplicationIdleHook( void )
{
   __WFI();
}
 801a41a:	4770      	bx	lr

0801a41c <initPowerController>:

int initPowerController(void)
{
 801a41c:	b530      	push	{r4, r5, lr}
  minPowerMode = powerMode ;
 801a41e:	4b13      	ldr	r3, [pc, #76]	; (801a46c <initPowerController+0x50>)
    SetMinPowerMode (RUN);

  /* Enable Power Clock */
  __HAL_RCC_PWR_CLK_ENABLE();
 801a420:	4d13      	ldr	r5, [pc, #76]	; (801a470 <initPowerController+0x54>)
  minPowerMode = powerMode ;
 801a422:	2400      	movs	r4, #0
 801a424:	701c      	strb	r4, [r3, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 801a426:	6dab      	ldr	r3, [r5, #88]	; 0x58
 801a428:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 801a42c:	65ab      	str	r3, [r5, #88]	; 0x58
 801a42e:	6dab      	ldr	r3, [r5, #88]	; 0x58
{
 801a430:	b083      	sub	sp, #12
  __HAL_RCC_PWR_CLK_ENABLE();
 801a432:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 801a436:	9301      	str	r3, [sp, #4]
 801a438:	9b01      	ldr	r3, [sp, #4]
    HAL_PWR_EnableBkUpAccess(); 
 801a43a:	f7f7 fc21 	bl	8011c80 <HAL_PWR_EnableBkUpAccess>
    
  /* Ensure that MSI is wake-up system clock */ 
  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(RCC_STOP_WAKEUPCLOCK_MSI);
 801a43e:	68aa      	ldr	r2, [r5, #8]

  /* Configure RTC */
  RtcHandle.Instance = RTC;
 801a440:	4b0c      	ldr	r3, [pc, #48]	; (801a474 <initPowerController+0x58>)
 801a442:	490d      	ldr	r1, [pc, #52]	; (801a478 <initPowerController+0x5c>)
    - Asynch Prediv = Value according to source clock
    - Synch Prediv = Value according to source clock
    - OutPut = Output Disable
    - OutPutPolarity = High Polarity
    - OutPutType = Open Drain */
  RtcHandle.Init.HourFormat     = RTC_HOURFORMAT_24;
 801a444:	605c      	str	r4, [r3, #4]
  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(RCC_STOP_WAKEUPCLOCK_MSI);
 801a446:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 801a44a:	60aa      	str	r2, [r5, #8]
  RtcHandle.Init.AsynchPrediv   = RTC_ASYNCH_PREDIV;
  RtcHandle.Init.SynchPrediv    = RTC_SYNCH_PREDIV;
  RtcHandle.Init.OutPut         = RTC_OUTPUT_DISABLE;
  RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  RtcHandle.Init.OutPutType     = RTC_OUTPUT_TYPE_OPENDRAIN;
  if(HAL_RTC_Init(&RtcHandle) != HAL_OK)
 801a44c:	4618      	mov	r0, r3
  RtcHandle.Init.SynchPrediv    = RTC_SYNCH_PREDIV;
 801a44e:	f647 72ff 	movw	r2, #32767	; 0x7fff
  RtcHandle.Init.AsynchPrediv   = RTC_ASYNCH_PREDIV;
 801a452:	609c      	str	r4, [r3, #8]
  RtcHandle.Init.OutPut         = RTC_OUTPUT_DISABLE;
 801a454:	611c      	str	r4, [r3, #16]
  RtcHandle.Init.OutPutType     = RTC_OUTPUT_TYPE_OPENDRAIN;
 801a456:	e9c3 4406 	strd	r4, r4, [r3, #24]
  RtcHandle.Instance = RTC;
 801a45a:	6019      	str	r1, [r3, #0]
  RtcHandle.Init.SynchPrediv    = RTC_SYNCH_PREDIV;
 801a45c:	60da      	str	r2, [r3, #12]
  if(HAL_RTC_Init(&RtcHandle) != HAL_OK)
 801a45e:	f7f8 fc53 	bl	8012d08 <HAL_RTC_Init>
 801a462:	b100      	cbz	r0, 801a466 <initPowerController+0x4a>
 801a464:	e7fe      	b.n	801a464 <initPowerController+0x48>
  {
    /* Initialization Error */
    while(1);
  }
  return 0 ;
}
 801a466:	b003      	add	sp, #12
 801a468:	bd30      	pop	{r4, r5, pc}
 801a46a:	bf00      	nop
 801a46c:	2000ffec 	.word	0x2000ffec
 801a470:	40021000 	.word	0x40021000
 801a474:	20013278 	.word	0x20013278
 801a478:	40002800 	.word	0x40002800

0801a47c <timeInSeconds>:
uint32_t timeInSeconds( uint32_t inBCD)
{
  uint32_t timeOut;
  timeOut  = ((inBCD&RTC_TR_SU_Msk )>>RTC_TR_SU_Pos );         // seconds
  timeOut += ((inBCD&RTC_TR_ST_Msk )>>RTC_TR_ST_Pos )*10;      // tens of seconds
  timeOut += ((inBCD&RTC_TR_MNU_Msk)>>RTC_TR_MNU_Pos)*60;      // minutes 
 801a47c:	f3c0 2303 	ubfx	r3, r0, #8, #4
  timeOut += ((inBCD&RTC_TR_ST_Msk )>>RTC_TR_ST_Pos )*10;      // tens of seconds
 801a480:	f3c0 1202 	ubfx	r2, r0, #4, #3
  timeOut += ((inBCD&RTC_TR_MNU_Msk)>>RTC_TR_MNU_Pos)*60;      // minutes 
 801a484:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
  timeOut += ((inBCD&RTC_TR_ST_Msk )>>RTC_TR_ST_Pos )*10;      // tens of seconds
 801a488:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  timeOut += ((inBCD&RTC_TR_MNU_Msk)>>RTC_TR_MNU_Pos)*60;      // minutes 
 801a48c:	009b      	lsls	r3, r3, #2
 801a48e:	eb03 0342 	add.w	r3, r3, r2, lsl #1
  timeOut  = ((inBCD&RTC_TR_SU_Msk )>>RTC_TR_SU_Pos );         // seconds
 801a492:	f000 020f 	and.w	r2, r0, #15
  timeOut += ((inBCD&RTC_TR_MNU_Msk)>>RTC_TR_MNU_Pos)*60;      // minutes 
 801a496:	4413      	add	r3, r2
  timeOut += ((inBCD&RTC_TR_MNT_Msk)>>RTC_TR_MNT_Pos)*60*10;   // tens of minutes 
 801a498:	f44f 7116 	mov.w	r1, #600	; 0x258
 801a49c:	f3c0 3202 	ubfx	r2, r0, #12, #3
 801a4a0:	fb01 3202 	mla	r2, r1, r2, r3
  timeOut += ((inBCD&RTC_TR_HU_Msk )>>RTC_TR_HU_Pos )*60*60;   // hours 
 801a4a4:	f3c0 4303 	ubfx	r3, r0, #16, #4
 801a4a8:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 801a4ac:	fb01 2203 	mla	r2, r1, r3, r2
  timeOut += ((inBCD&RTC_TR_HT_Msk )>>RTC_TR_HT_Pos )*10*60*60;// tens of hours
 801a4b0:	f3c0 5301 	ubfx	r3, r0, #20, #2
 801a4b4:	f648 41a0 	movw	r1, #36000	; 0x8ca0
 801a4b8:	fb01 2303 	mla	r3, r1, r3, r2
  timeOut += ((inBCD&RTC_TR_PM_Msk )>>RTC_TR_PM_Pos )*12*60*60;// PM
 801a4bc:	f3c0 5080 	ubfx	r0, r0, #22, #1
 801a4c0:	f64a 02c0 	movw	r2, #43200	; 0xa8c0
  return timeOut;
}
 801a4c4:	fb02 3000 	mla	r0, r2, r0, r3
 801a4c8:	4770      	bx	lr
 801a4ca:	bf00      	nop

0801a4cc <wakeIn>:

void wakeIn( uint32_t waketime)
{
 801a4cc:	b510      	push	{r4, lr}
 801a4ce:	4604      	mov	r4, r0
  HAL_RTCEx_DeactivateWakeUpTimer(&RtcHandle);
 801a4d0:	480c      	ldr	r0, [pc, #48]	; (801a504 <wakeIn+0x38>)
 801a4d2:	f7f8 fe31 	bl	8013138 <HAL_RTCEx_DeactivateWakeUpTimer>
  if (waketime < 32000)
 801a4d6:	f5b4 4ffa 	cmp.w	r4, #32000	; 0x7d00
 801a4da:	d307      	bcc.n	801a4ec <wakeIn+0x20>
     /* resolution of 1/2048 = 0,48828125 ms */
    HAL_RTCEx_SetWakeUpTimer_IT(&RtcHandle, (waketime << 11)/1000, RTC_WAKEUPCLOCK_RTCCLK_DIV16);
  }
  else
  {
    HAL_RTCEx_SetWakeUpTimer_IT(&RtcHandle,0xFFFF, RTC_WAKEUPCLOCK_RTCCLK_DIV16);
 801a4dc:	2200      	movs	r2, #0
 801a4de:	f64f 71ff 	movw	r1, #65535	; 0xffff
 801a4e2:	4808      	ldr	r0, [pc, #32]	; (801a504 <wakeIn+0x38>)
    /* later, would set ALARM A or B with 1 second resolution instead */
  }
/*  SENSING1_PRINTF("(%d)",waketime);*/
}
 801a4e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_RTCEx_SetWakeUpTimer_IT(&RtcHandle,0xFFFF, RTC_WAKEUPCLOCK_RTCCLK_DIV16);
 801a4e8:	f7f8 bda8 	b.w	801303c <HAL_RTCEx_SetWakeUpTimer_IT>
    HAL_RTCEx_SetWakeUpTimer_IT(&RtcHandle, (waketime << 11)/1000, RTC_WAKEUPCLOCK_RTCCLK_DIV16);
 801a4ec:	4906      	ldr	r1, [pc, #24]	; (801a508 <wakeIn+0x3c>)
 801a4ee:	4805      	ldr	r0, [pc, #20]	; (801a504 <wakeIn+0x38>)
 801a4f0:	02e4      	lsls	r4, r4, #11
 801a4f2:	fba1 3104 	umull	r3, r1, r1, r4
 801a4f6:	0989      	lsrs	r1, r1, #6
 801a4f8:	2200      	movs	r2, #0
}
 801a4fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_RTCEx_SetWakeUpTimer_IT(&RtcHandle, (waketime << 11)/1000, RTC_WAKEUPCLOCK_RTCCLK_DIV16);
 801a4fe:	f7f8 bd9d 	b.w	801303c <HAL_RTCEx_SetWakeUpTimer_IT>
 801a502:	bf00      	nop
 801a504:	20013278 	.word	0x20013278
 801a508:	10624dd3 	.word	0x10624dd3

0801a50c <vPortSuppressTicksAndSleep>:

extern __IO uint32_t uwTick; // ?? needed

void vPortSuppressTicksAndSleep ( TickType_t xExpectedIdleTime )
{
 801a50c:	b5f0      	push	{r4, r5, r6, r7, lr}

#ifdef DISABLE_PM
  minPowerMode = IDLE_WFI;
#endif
  
  if (( minPowerMode < IDLE_WFI_TICK_SUPRESS ) || (PowerCtrlLockToken))
 801a50e:	4c3a      	ldr	r4, [pc, #232]	; (801a5f8 <vPortSuppressTicksAndSleep+0xec>)
 801a510:	7823      	ldrb	r3, [r4, #0]
 801a512:	2b01      	cmp	r3, #1
{
 801a514:	b085      	sub	sp, #20
  if (( minPowerMode < IDLE_WFI_TICK_SUPRESS ) || (PowerCtrlLockToken))
 801a516:	d901      	bls.n	801a51c <vPortSuppressTicksAndSleep+0x10>
 801a518:	6863      	ldr	r3, [r4, #4]
 801a51a:	b10b      	cbz	r3, 801a520 <vPortSuppressTicksAndSleep+0x14>
  HAL_ResumeTick();
  HAL_RTCEx_DeactivateWakeUpTimer(&RtcHandle);
#ifdef DEBUG_PM
  SENSING1_PRINTF( "zz %d ms\r\n",missedTicks );
#endif
}
 801a51c:	b005      	add	sp, #20
 801a51e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  tickIn = RTC->SSR; 
 801a520:	4f36      	ldr	r7, [pc, #216]	; (801a5fc <vPortSuppressTicksAndSleep+0xf0>)
 801a522:	4606      	mov	r6, r0
 801a524:	6abd      	ldr	r5, [r7, #40]	; 0x28
  HAL_SuspendTick();
 801a526:	f7f5 ffe7 	bl	80104f8 <HAL_SuspendTick>
  TRin = RTC->TR & RTC_TR_RESERVED_MASK;
 801a52a:	683b      	ldr	r3, [r7, #0]
 801a52c:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 801a530:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 801a534:	9302      	str	r3, [sp, #8]
  DR     = RTC->DR & RTC_DR_RESERVED_MASK;; // unlock shadow registers
 801a536:	687b      	ldr	r3, [r7, #4]
 801a538:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 801a53c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 801a540:	9301      	str	r3, [sp, #4]
  UNUSED(DR);
 801a542:	9b01      	ldr	r3, [sp, #4]
  eSleepStatus = eTaskConfirmSleepModeStatus();
 801a544:	f7fd fbde 	bl	8017d04 <eTaskConfirmSleepModeStatus>
  if( eSleepStatus != eAbortSleep )
 801a548:	b190      	cbz	r0, 801a570 <vPortSuppressTicksAndSleep+0x64>
    if( eSleepStatus != eNoTasksWaitingTimeout )
 801a54a:	2802      	cmp	r0, #2
 801a54c:	d002      	beq.n	801a554 <vPortSuppressTicksAndSleep+0x48>
        wakeIn(xExpectedIdleTime-1);
 801a54e:	1e70      	subs	r0, r6, #1
 801a550:	f7ff ffbc 	bl	801a4cc <wakeIn>
    __asm volatile ( "cpsid i" );
 801a554:	b672      	cpsid	i
    __asm volatile ( "dsb" );
 801a556:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
 801a55a:	f3bf 8f6f 	isb	sy
    if (minPowerMode >= IDLE_SLEEP_STOP ) {
 801a55e:	7823      	ldrb	r3, [r4, #0]
 801a560:	2b02      	cmp	r3, #2
 801a562:	d842      	bhi.n	801a5ea <vPortSuppressTicksAndSleep+0xde>
 801a564:	bf30      	wfi
    __asm volatile ( "cpsie i" );
 801a566:	b662      	cpsie	i
    __asm volatile ( "dsb" );
 801a568:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
 801a56c:	f3bf 8f6f 	isb	sy
  tickOut = RTC->SSR; 
 801a570:	4922      	ldr	r1, [pc, #136]	; (801a5fc <vPortSuppressTicksAndSleep+0xf0>)
 801a572:	6a8e      	ldr	r6, [r1, #40]	; 0x28
  TRout   = RTC->TR & RTC_TR_RESERVED_MASK;
 801a574:	680a      	ldr	r2, [r1, #0]
 801a576:	f002 327f 	and.w	r2, r2, #2139062143	; 0x7f7f7f7f
 801a57a:	f022 42fe 	bic.w	r2, r2, #2130706432	; 0x7f000000
 801a57e:	9203      	str	r2, [sp, #12]
  DR      = RTC->DR & RTC_DR_RESERVED_MASK; // unlock shadow registers & check day wrap around
 801a580:	684a      	ldr	r2, [r1, #4]
 801a582:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 801a586:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 801a58a:	9201      	str	r2, [sp, #4]
  UNUSED(DR);
 801a58c:	9b01      	ldr	r3, [sp, #4]
  secIn    = timeInSeconds (TRin);
 801a58e:	9802      	ldr	r0, [sp, #8]
 801a590:	f7ff ff74 	bl	801a47c <timeInSeconds>
 801a594:	4604      	mov	r4, r0
  secOut   = timeInSeconds (TRout);
 801a596:	9803      	ldr	r0, [sp, #12]
 801a598:	f7ff ff70 	bl	801a47c <timeInSeconds>
  if (secDif)
 801a59c:	1b02      	subs	r2, r0, r4
  tickDif  = tickIn - tickOut ; // sub second register is a decreasing counter
 801a59e:	eba5 0306 	sub.w	r3, r5, r6
  if (secDif)
 801a5a2:	d008      	beq.n	801a5b6 <vPortSuppressTicksAndSleep+0xaa>
    secDif  +=( secOut < secIn ) ? 24*60*60  : 0 ;
 801a5a4:	4284      	cmp	r4, r0
 801a5a6:	bf84      	itt	hi
 801a5a8:	f502 32a8 	addhi.w	r2, r2, #86016	; 0x15000
 801a5ac:	f502 72c0 	addhi.w	r2, r2, #384	; 0x180
    tickDif += (secDif-1)<<15; 
 801a5b0:	eb03 33c2 	add.w	r3, r3, r2, lsl #15
 801a5b4:	3b01      	subs	r3, #1
  missedTicks = (int)(((float)tickDif)/32.768f);
 801a5b6:	ee07 3a90 	vmov	s15, r3
 801a5ba:	eddf 6a11 	vldr	s13, [pc, #68]	; 801a600 <vPortSuppressTicksAndSleep+0xf4>
  uwTick += missedTicks;
 801a5be:	4a11      	ldr	r2, [pc, #68]	; (801a604 <vPortSuppressTicksAndSleep+0xf8>)
  missedTicks = (int)(((float)tickDif)/32.768f);
 801a5c0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  uwTick += missedTicks;
 801a5c4:	6813      	ldr	r3, [r2, #0]
  missedTicks = (int)(((float)tickDif)/32.768f);
 801a5c6:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 801a5ca:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 801a5ce:	ee17 0a90 	vmov	r0, s15
  uwTick += missedTicks;
 801a5d2:	4403      	add	r3, r0
 801a5d4:	6013      	str	r3, [r2, #0]
  vTaskStepTick( missedTicks);
 801a5d6:	f7fd f8cd 	bl	8017774 <vTaskStepTick>
  HAL_ResumeTick();
 801a5da:	f7f5 ff95 	bl	8010508 <HAL_ResumeTick>
  HAL_RTCEx_DeactivateWakeUpTimer(&RtcHandle);
 801a5de:	480a      	ldr	r0, [pc, #40]	; (801a608 <vPortSuppressTicksAndSleep+0xfc>)
}
 801a5e0:	b005      	add	sp, #20
 801a5e2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  HAL_RTCEx_DeactivateWakeUpTimer(&RtcHandle);
 801a5e6:	f7f8 bda7 	b.w	8013138 <HAL_RTCEx_DeactivateWakeUpTimer>
      HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 801a5ea:	2001      	movs	r0, #1
 801a5ec:	f7f7 fb68 	bl	8011cc0 <HAL_PWREx_EnterSTOP2Mode>
      SystemClock_Config();
 801a5f0:	f000 fc14 	bl	801ae1c <SystemClock_Config>
 801a5f4:	e7b7      	b.n	801a566 <vPortSuppressTicksAndSleep+0x5a>
 801a5f6:	bf00      	nop
 801a5f8:	2000ffec 	.word	0x2000ffec
 801a5fc:	40002800 	.word	0x40002800
 801a600:	4203126f 	.word	0x4203126f
 801a604:	200113e8 	.word	0x200113e8
 801a608:	20013278 	.word	0x20013278

0801a60c <InitTargetPlatform>:
  * @brief  Initialize all the Target platform's Features
  * @param  TargetType_t BoardType Nucleo/BlueCoin/SensorTile
  * @retval None
  */
void InitTargetPlatform(TargetType_t BoardType)
{
 801a60c:	b510      	push	{r4, lr}
  TargetBoardFeatures.BoardType = BoardType;
 801a60e:	4c2d      	ldr	r4, [pc, #180]	; (801a6c4 <InitTargetPlatform+0xb8>)
 801a610:	7020      	strb	r0, [r4, #0]

#elif STM32_SENSORTILE

#ifdef SENSING1_ENABLE_SD_CARD_LOGGING
  /* Configure the SDCard */
  DATALOG_SD_Init();
 801a612:	f7ff f8e5 	bl	80197e0 <DATALOG_SD_Init>
  HAL_Delay(200);
 801a616:	20c8      	movs	r0, #200	; 0xc8
 801a618:	f000 fd76 	bl	801b108 <HAL_Delay>
  sprintf(DefaultDataFileName,"%s","STile");
 801a61c:	4a2a      	ldr	r2, [pc, #168]	; (801a6c8 <InitTargetPlatform+0xbc>)
 801a61e:	4b2b      	ldr	r3, [pc, #172]	; (801a6cc <InitTargetPlatform+0xc0>)
 801a620:	6810      	ldr	r0, [r2, #0]
 801a622:	8892      	ldrh	r2, [r2, #4]
 801a624:	809a      	strh	r2, [r3, #4]
 801a626:	6018      	str	r0, [r3, #0]
#endif /* SENSING1_ENABLE_SD_CARD_LOGGING */
  
  /* Configure and disable all the Chip Select pins */
  Sensor_IO_SPI_CS_Init_All();
 801a628:	f7f3 fd9e 	bl	800e168 <Sensor_IO_SPI_CS_Init_All>
  
  /* Initialize LED */
#ifdef STM32_NUCLEO  
  BSP_LED_Init(LED2);
#elif STM32_SENSORTILE
  BSP_LED_Init( LED1 );  
 801a62c:	2000      	movs	r0, #0
 801a62e:	f7f3 fcb7 	bl	800dfa0 <BSP_LED_Init>
          "\r\n\n",
          SENSING1_PACKAGENAME,
          SENSING1_VERSION_MAJOR,SENSING1_VERSION_MINOR,SENSING1_VERSION_PATCH);

  /* Reset all the Target's Features */
  memset(&TargetBoardFeatures, 0, sizeof(TargetFeatures_t));
 801a632:	2100      	movs	r1, #0
 801a634:	4620      	mov	r0, r4
 801a636:	2244      	movs	r2, #68	; 0x44
 801a638:	f004 fa7a 	bl	801eb30 <memset>
 * @retval None
 */
static void Init_MEM1_Sensors(void)
{  
  /* Accelero */
  if (BSP_ACCELERO_Init( ACCELERO_SENSORS_AUTO, &TargetBoardFeatures.HandleAccSensor ) == COMPONENT_OK){
 801a63c:	f104 0118 	add.w	r1, r4, #24
 801a640:	f04f 30ff 	mov.w	r0, #4294967295
 801a644:	f7f4 fa0a 	bl	800ea5c <BSP_ACCELERO_Init>
 801a648:	b100      	cbz	r0, 801a64c <InitTargetPlatform+0x40>
 801a64a:	e7fe      	b.n	801a64a <InitTargetPlatform+0x3e>
  } else {
    SENSING1_PRINTF("Error Accelero Sensor\n\r");
    while(1);
  }
  /* set default range to 2G */
  Set2GAccelerometerFullScale();
 801a64c:	f000 fa92 	bl	801ab74 <Set2GAccelerometerFullScale>
  /* For accelero HW features */
  InitHWFeatures();
 801a650:	f7ff fc4c 	bl	8019eec <InitHWFeatures>
  
  /* Matteo */
  //LSM6DSM_ACC_GYRO_W_DRDY_G_on_INT1(&TargetBoardFeatures.HandleAccSensor, LSM6DSM_ACC_GYRO_INT1_DRDY_G_ENABLED);

  /* Gyro */
  if(BSP_GYRO_Init( GYRO_SENSORS_AUTO, &TargetBoardFeatures.HandleGyroSensor )==COMPONENT_OK){
 801a654:	f104 011c 	add.w	r1, r4, #28
 801a658:	f04f 30ff 	mov.w	r0, #4294967295
 801a65c:	f7f5 fb42 	bl	800fce4 <BSP_GYRO_Init>
 801a660:	b100      	cbz	r0, 801a664 <InitTargetPlatform+0x58>
 801a662:	e7fe      	b.n	801a662 <InitTargetPlatform+0x56>
  } else {
    SENSING1_PRINTF("Error Gyroscope Sensor\n\r");
    while(1);
  }

  if(BSP_MAGNETO_Init( MAGNETO_SENSORS_AUTO, &TargetBoardFeatures.HandleMagSensor )==COMPONENT_OK){
 801a664:	f104 0120 	add.w	r1, r4, #32
 801a668:	f04f 30ff 	mov.w	r0, #4294967295
 801a66c:	f7f5 fbe2 	bl	800fe34 <BSP_MAGNETO_Init>
 801a670:	b100      	cbz	r0, 801a674 <InitTargetPlatform+0x68>
 801a672:	e7fe      	b.n	801a672 <InitTargetPlatform+0x66>
    SENSING1_PRINTF("Error Magneto Sensor\n\r");
    while(1);
  }

  /* Humidity */  
  if(BSP_HUMIDITY_Init( HUMIDITY_SENSORS_AUTO, &TargetBoardFeatures.HandleHumSensor )==COMPONENT_OK){
 801a674:	f104 0114 	add.w	r1, r4, #20
 801a678:	f04f 30ff 	mov.w	r0, #4294967295
 801a67c:	f003 fca6 	bl	801dfcc <BSP_HUMIDITY_Init>
  } else {
    SENSING1_PRINTF("Error Humidity Sensor\n\r");
  }

  /* Temperature1 */
  if(BSP_TEMPERATURE_Init( TEMPERATURE_SENSORS_AUTO, &TargetBoardFeatures.HandleTempSensors[TargetBoardFeatures.NumTempSensors] )==COMPONENT_OK){
 801a680:	6863      	ldr	r3, [r4, #4]
 801a682:	3302      	adds	r3, #2
 801a684:	eb04 0183 	add.w	r1, r4, r3, lsl #2
 801a688:	f04f 30ff 	mov.w	r0, #4294967295
 801a68c:	f003 fe72 	bl	801e374 <BSP_TEMPERATURE_Init>
 801a690:	b910      	cbnz	r0, 801a698 <InitTargetPlatform+0x8c>
     SENSING1_PRINTF("OK Temperature Sensor1\n\r");
     TargetBoardFeatures.NumTempSensors++;
 801a692:	6863      	ldr	r3, [r4, #4]
 801a694:	3301      	adds	r3, #1
 801a696:	6063      	str	r3, [r4, #4]
     TargetBoardFeatures.NumTempSensors++;
  } else {
    SENSING1_PRINTF("Error Temperature Sensor2\n\r");
  }
#elif STM32_SENSORTILE
  if(BSP_TEMPERATURE_Init( LPS22HB_T_0, &TargetBoardFeatures.HandleTempSensors[TargetBoardFeatures.NumTempSensors] )==COMPONENT_OK){
 801a698:	6863      	ldr	r3, [r4, #4]
 801a69a:	3302      	adds	r3, #2
 801a69c:	eb04 0183 	add.w	r1, r4, r3, lsl #2
 801a6a0:	2000      	movs	r0, #0
 801a6a2:	f003 fe67 	bl	801e374 <BSP_TEMPERATURE_Init>
 801a6a6:	b910      	cbnz	r0, 801a6ae <InitTargetPlatform+0xa2>
     SENSING1_PRINTF("OK Temperature Sensor2\n\r");
     TargetBoardFeatures.NumTempSensors++;
 801a6a8:	6863      	ldr	r3, [r4, #4]
 801a6aa:	3301      	adds	r3, #1
 801a6ac:	6063      	str	r3, [r4, #4]
    SENSING1_PRINTF("Error Temperature Sensor2\n\r");
  }
#endif /* STM32_NUCLEO */
  
  /* Pressure */
  if(BSP_PRESSURE_Init( PRESSURE_SENSORS_AUTO, &TargetBoardFeatures.HandlePressSensor )==COMPONENT_OK){
 801a6ae:	4908      	ldr	r1, [pc, #32]	; (801a6d0 <InitTargetPlatform+0xc4>)
 801a6b0:	f04f 30ff 	mov.w	r0, #4294967295
 801a6b4:	f003 fd58 	bl	801e168 <BSP_PRESSURE_Init>
  if(BSP_GG_Init(&TargetBoardFeatures.HandleGGComponent) == COMPONENT_OK){
 801a6b8:	4806      	ldr	r0, [pc, #24]	; (801a6d4 <InitTargetPlatform+0xc8>)
 801a6ba:	f7f5 fa5b 	bl	800fb74 <BSP_GG_Init>
  TargetBoardFeatures.AudioVolume = AUDIO_VOLUME_VALUE;
 801a6be:	2320      	movs	r3, #32
 801a6c0:	63e3      	str	r3, [r4, #60]	; 0x3c
}
 801a6c2:	bd10      	pop	{r4, pc}
 801a6c4:	20011458 	.word	0x20011458
 801a6c8:	080758b8 	.word	0x080758b8
 801a6cc:	2001144c 	.word	0x2001144c
 801a6d0:	20011468 	.word	0x20011468
 801a6d4:	20011490 	.word	0x20011490

0801a6d8 <enableMotionSensors>:
{
 801a6d8:	b510      	push	{r4, lr}
    if(TargetBoardFeatures.HandleAccSensor) {
 801a6da:	4c08      	ldr	r4, [pc, #32]	; (801a6fc <enableMotionSensors+0x24>)
 801a6dc:	69a0      	ldr	r0, [r4, #24]
 801a6de:	b108      	cbz	r0, 801a6e4 <enableMotionSensors+0xc>
    if(BSP_ACCELERO_Sensor_Enable( TargetBoardFeatures.HandleAccSensor )==COMPONENT_OK) {
 801a6e0:	f7f4 f9e4 	bl	800eaac <BSP_ACCELERO_Sensor_Enable>
  if(TargetBoardFeatures.HandleGyroSensor) {
 801a6e4:	69e0      	ldr	r0, [r4, #28]
 801a6e6:	b108      	cbz	r0, 801a6ec <enableMotionSensors+0x14>
    if(BSP_GYRO_Sensor_Enable( TargetBoardFeatures.HandleGyroSensor )==COMPONENT_OK) {
 801a6e8:	f7f5 fb08 	bl	800fcfc <BSP_GYRO_Sensor_Enable>
  if(TargetBoardFeatures.HandleMagSensor) {
 801a6ec:	6a20      	ldr	r0, [r4, #32]
 801a6ee:	b118      	cbz	r0, 801a6f8 <enableMotionSensors+0x20>
}
 801a6f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if(BSP_MAGNETO_Sensor_Enable( TargetBoardFeatures.HandleMagSensor )==COMPONENT_OK) {
 801a6f4:	f7f5 bbaa 	b.w	800fe4c <BSP_MAGNETO_Sensor_Enable>
}
 801a6f8:	bd10      	pop	{r4, pc}
 801a6fa:	bf00      	nop
 801a6fc:	20011458 	.word	0x20011458

0801a700 <disableMotionSensors>:
{
 801a700:	b510      	push	{r4, lr}
  if(TargetBoardFeatures.HandleAccSensor) {
 801a702:	4c08      	ldr	r4, [pc, #32]	; (801a724 <disableMotionSensors+0x24>)
 801a704:	69a0      	ldr	r0, [r4, #24]
 801a706:	b108      	cbz	r0, 801a70c <disableMotionSensors+0xc>
    if(BSP_ACCELERO_Sensor_Disable( TargetBoardFeatures.HandleAccSensor )==COMPONENT_OK) {
 801a708:	f7f4 f9e0 	bl	800eacc <BSP_ACCELERO_Sensor_Disable>
  if(TargetBoardFeatures.HandleGyroSensor) {
 801a70c:	69e0      	ldr	r0, [r4, #28]
 801a70e:	b108      	cbz	r0, 801a714 <disableMotionSensors+0x14>
    if(BSP_GYRO_Sensor_Disable( TargetBoardFeatures.HandleGyroSensor )==COMPONENT_OK) {
 801a710:	f7f5 fb04 	bl	800fd1c <BSP_GYRO_Sensor_Disable>
  if(TargetBoardFeatures.HandleMagSensor) {
 801a714:	6a20      	ldr	r0, [r4, #32]
 801a716:	b118      	cbz	r0, 801a720 <disableMotionSensors+0x20>
}
 801a718:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if(BSP_MAGNETO_Sensor_Disable( TargetBoardFeatures.HandleMagSensor )==COMPONENT_OK) {
 801a71c:	f7f5 bba6 	b.w	800fe6c <BSP_MAGNETO_Sensor_Disable>
}
 801a720:	bd10      	pop	{r4, pc}
 801a722:	bf00      	nop
 801a724:	20011458 	.word	0x20011458

0801a728 <enableEnvSensors>:
{
 801a728:	b510      	push	{r4, lr}
  if(TargetBoardFeatures.HandleHumSensor) {
 801a72a:	4c12      	ldr	r4, [pc, #72]	; (801a774 <enableEnvSensors+0x4c>)
 801a72c:	6960      	ldr	r0, [r4, #20]
 801a72e:	b110      	cbz	r0, 801a736 <enableEnvSensors+0xe>
    if(BSP_HUMIDITY_Sensor_Enable( TargetBoardFeatures.HandleHumSensor)==COMPONENT_OK) {
 801a730:	f003 fc58 	bl	801dfe4 <BSP_HUMIDITY_Sensor_Enable>
 801a734:	b1a8      	cbz	r0, 801a762 <enableEnvSensors+0x3a>
  if(TargetBoardFeatures.HandleTempSensors[0]){
 801a736:	68a0      	ldr	r0, [r4, #8]
 801a738:	b110      	cbz	r0, 801a740 <enableEnvSensors+0x18>
    if(BSP_TEMPERATURE_Sensor_Enable( TargetBoardFeatures.HandleTempSensors[0])==COMPONENT_OK) {
 801a73a:	f003 fe3b 	bl	801e3b4 <BSP_TEMPERATURE_Sensor_Enable>
 801a73e:	b1a0      	cbz	r0, 801a76a <enableEnvSensors+0x42>
  if(TargetBoardFeatures.HandleTempSensors[1]){
 801a740:	68e0      	ldr	r0, [r4, #12]
 801a742:	b110      	cbz	r0, 801a74a <enableEnvSensors+0x22>
    if(BSP_TEMPERATURE_Sensor_Enable( TargetBoardFeatures.HandleTempSensors[1])==COMPONENT_OK) {
 801a744:	f003 fe36 	bl	801e3b4 <BSP_TEMPERATURE_Sensor_Enable>
 801a748:	b138      	cbz	r0, 801a75a <enableEnvSensors+0x32>
  if(TargetBoardFeatures.HandlePressSensor) {
 801a74a:	6920      	ldr	r0, [r4, #16]
 801a74c:	b108      	cbz	r0, 801a752 <enableEnvSensors+0x2a>
    if(BSP_PRESSURE_Sensor_Enable( TargetBoardFeatures.HandlePressSensor)==COMPONENT_OK) {
 801a74e:	f003 fd17 	bl	801e180 <BSP_PRESSURE_Sensor_Enable>
  TargetBoardFeatures.EnvSensorEnabled= 1;
 801a752:	2301      	movs	r3, #1
 801a754:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 801a758:	bd10      	pop	{r4, pc}
      if(BSP_TEMPERATURE_Set_One_Shot( TargetBoardFeatures.HandleTempSensors[1])==COMPONENT_OK) {
 801a75a:	68e0      	ldr	r0, [r4, #12]
 801a75c:	f003 fe64 	bl	801e428 <BSP_TEMPERATURE_Set_One_Shot>
 801a760:	e7f3      	b.n	801a74a <enableEnvSensors+0x22>
      if(BSP_HUMIDITY_Set_One_Shot( TargetBoardFeatures.HandleHumSensor)==COMPONENT_OK) {
 801a762:	6960      	ldr	r0, [r4, #20]
 801a764:	f003 fc78 	bl	801e058 <BSP_HUMIDITY_Set_One_Shot>
 801a768:	e7e5      	b.n	801a736 <enableEnvSensors+0xe>
      if(BSP_TEMPERATURE_Set_One_Shot( TargetBoardFeatures.HandleTempSensors[0])==COMPONENT_OK) {
 801a76a:	68a0      	ldr	r0, [r4, #8]
 801a76c:	f003 fe5c 	bl	801e428 <BSP_TEMPERATURE_Set_One_Shot>
 801a770:	e7e6      	b.n	801a740 <enableEnvSensors+0x18>
 801a772:	bf00      	nop
 801a774:	20011458 	.word	0x20011458

0801a778 <disableEnvSensors>:
{
 801a778:	b510      	push	{r4, lr}
  if(TargetBoardFeatures.HandleHumSensor) {
 801a77a:	4c0a      	ldr	r4, [pc, #40]	; (801a7a4 <disableEnvSensors+0x2c>)
 801a77c:	6960      	ldr	r0, [r4, #20]
 801a77e:	b108      	cbz	r0, 801a784 <disableEnvSensors+0xc>
    if(BSP_HUMIDITY_Sensor_Disable( TargetBoardFeatures.HandleHumSensor)==COMPONENT_OK) {
 801a780:	f003 fc40 	bl	801e004 <BSP_HUMIDITY_Sensor_Disable>
  if(TargetBoardFeatures.HandleTempSensors[0]){
 801a784:	68a0      	ldr	r0, [r4, #8]
 801a786:	b108      	cbz	r0, 801a78c <disableEnvSensors+0x14>
    if(BSP_TEMPERATURE_Sensor_Disable( TargetBoardFeatures.HandleTempSensors[0])==COMPONENT_OK) {
 801a788:	f003 fe24 	bl	801e3d4 <BSP_TEMPERATURE_Sensor_Disable>
  if(TargetBoardFeatures.HandleTempSensors[1]){
 801a78c:	68e0      	ldr	r0, [r4, #12]
 801a78e:	b108      	cbz	r0, 801a794 <disableEnvSensors+0x1c>
    if(BSP_TEMPERATURE_Sensor_Disable( TargetBoardFeatures.HandleTempSensors[1])==COMPONENT_OK) {
 801a790:	f003 fe20 	bl	801e3d4 <BSP_TEMPERATURE_Sensor_Disable>
  if(TargetBoardFeatures.HandlePressSensor) {
 801a794:	6920      	ldr	r0, [r4, #16]
 801a796:	b108      	cbz	r0, 801a79c <disableEnvSensors+0x24>
    if(BSP_PRESSURE_Sensor_Disable( TargetBoardFeatures.HandlePressSensor)==COMPONENT_OK) {
 801a798:	f003 fd02 	bl	801e1a0 <BSP_PRESSURE_Sensor_Disable>
  TargetBoardFeatures.EnvSensorEnabled= 0;
 801a79c:	2300      	movs	r3, #0
 801a79e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 801a7a2:	bd10      	pop	{r4, pc}
 801a7a4:	20011458 	.word	0x20011458

0801a7a8 <InitMics>:
/** @brief Initialize all the MEMS's Microphones
 * @param None
 * @retval None
 */
void InitMics(uint32_t AudioFreq)
{
 801a7a8:	b510      	push	{r4, lr}
  ret= BSP_AUDIO_IN_Init(AudioFreq, 16, AUDIO_CHANNELS);
 801a7aa:	2201      	movs	r2, #1
 801a7ac:	2110      	movs	r1, #16
 801a7ae:	f7f4 fccb 	bl	800f148 <BSP_AUDIO_IN_Init>
  if(ret != AUDIO_OK) {
 801a7b2:	b100      	cbz	r0, 801a7b6 <InitMics+0xe>
 801a7b4:	e7fe      	b.n	801a7b4 <InitMics+0xc>
  ret= BSP_AUDIO_IN_SetVolume(TargetBoardFeatures.AudioVolume);
 801a7b6:	4c07      	ldr	r4, [pc, #28]	; (801a7d4 <InitMics+0x2c>)
 801a7b8:	f894 003c 	ldrb.w	r0, [r4, #60]	; 0x3c
 801a7bc:	f7f5 f8f8 	bl	800f9b0 <BSP_AUDIO_IN_SetVolume>
  if(ret != AUDIO_OK) {
 801a7c0:	4601      	mov	r1, r0
 801a7c2:	b100      	cbz	r0, 801a7c6 <InitMics+0x1e>
 801a7c4:	e7fe      	b.n	801a7c4 <InitMics+0x1c>
  TargetBoardFeatures.NumMicSensors=AUDIO_CHANNELS;
 801a7c6:	2301      	movs	r3, #1
 801a7c8:	6363      	str	r3, [r4, #52]	; 0x34
  Init_MEMS_Mics(AudioFreq);
  BSP_AUDIO_IN_Record(PCM_Buffer,0);
 801a7ca:	4803      	ldr	r0, [pc, #12]	; (801a7d8 <InitMics+0x30>)
}
 801a7cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  BSP_AUDIO_IN_Record(PCM_Buffer,0);
 801a7d0:	f7f5 b89e 	b.w	800f910 <BSP_AUDIO_IN_Record>
 801a7d4:	20011458 	.word	0x20011458
 801a7d8:	2001149c 	.word	0x2001149c

0801a7dc <DeInitMics>:
/** @brief DeInitialize all the MEMS's Microphones
 * @param None
 * @retval None
 */
void DeInitMics(void)
{
 801a7dc:	b508      	push	{r3, lr}
  uint8_t ret= AUDIO_OK;
  
  BSP_AUDIO_IN_Stop();  
 801a7de:	f7f5 f8cb 	bl	800f978 <BSP_AUDIO_IN_Stop>
  ret= BSP_AUDIO_IN_DeInit();
 801a7e2:	f7f4 fc37 	bl	800f054 <BSP_AUDIO_IN_DeInit>
  
  if(ret != AUDIO_OK)
 801a7e6:	b100      	cbz	r0, 801a7ea <DeInitMics+0xe>
 801a7e8:	e7fe      	b.n	801a7e8 <DeInitMics+0xc>
  }
  else
  {
    SENSING1_PRINTF("OK Audio DeInit\r\n");
  }
}
 801a7ea:	bd08      	pop	{r3, pc}

0801a7ec <LedOnTargetPlatform>:
void LedOnTargetPlatform(void)
{
#ifdef STM32_NUCLEO
  BSP_LED_On(LED2);
#elif STM32_SENSORTILE
  BSP_LED_On( LED1 );
 801a7ec:	2000      	movs	r0, #0
 801a7ee:	f7f3 bc15 	b.w	800e01c <BSP_LED_On>
 801a7f2:	bf00      	nop

0801a7f4 <LedOffTargetPlatform>:
void LedOffTargetPlatform(void)
{
#ifdef STM32_NUCLEO
  BSP_LED_Off(LED2);
#elif STM32_SENSORTILE
  BSP_LED_Off( LED1 );
 801a7f4:	2000      	movs	r0, #0
 801a7f6:	f7f3 bc25 	b.w	800e044 <BSP_LED_Off>
 801a7fa:	bf00      	nop

0801a7fc <LedToggleTargetPlatform>:
void LedToggleTargetPlatform(void)
{
#ifdef STM32_NUCLEO
  BSP_LED_Toggle(LED2);
#elif STM32_SENSORTILE
  BSP_LED_Toggle( LED1 );
 801a7fc:	2000      	movs	r0, #0
 801a7fe:	f7f3 bc35 	b.w	800e06c <BSP_LED_Toggle>
 801a802:	bf00      	nop

0801a804 <UserFunctionForErasingFlash>:
/**
 * @brief User function for Erasing the MDM on Flash
 * @param None
 * @retval uint32_t Success/NotSuccess [1/0]
 */
uint32_t UserFunctionForErasingFlash(void) {
 801a804:	b510      	push	{r4, lr}
  FLASH_EraseInitTypeDef EraseInitStruct;
  uint32_t SectorError = 0;
 801a806:	2300      	movs	r3, #0
uint32_t UserFunctionForErasingFlash(void) {
 801a808:	b086      	sub	sp, #24
  uint32_t Success=1;

  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
 801a80a:	e9cd 3301 	strd	r3, r3, [sp, #4]
  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0)
 801a80e:	4a26      	ldr	r2, [pc, #152]	; (801a8a8 <UserFunctionForErasingFlash+0xa4>)
 801a810:	6813      	ldr	r3, [r2, #0]
 801a812:	f413 7f80 	tst.w	r3, #256	; 0x100
    if (Addr < (FLASH_BASE + FLASH_BANK_SIZE))
 801a816:	4b25      	ldr	r3, [pc, #148]	; (801a8ac <UserFunctionForErasingFlash+0xa8>)
 801a818:	881a      	ldrh	r2, [r3, #0]
 801a81a:	f64f 73ff 	movw	r3, #65535	; 0xffff
  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0)
 801a81e:	d10b      	bne.n	801a838 <UserFunctionForErasingFlash+0x34>
    if (Addr < (FLASH_BASE + FLASH_BANK_SIZE))
 801a820:	429a      	cmp	r2, r3
 801a822:	d03b      	beq.n	801a89c <UserFunctionForErasingFlash+0x98>
 801a824:	4b22      	ldr	r3, [pc, #136]	; (801a8b0 <UserFunctionForErasingFlash+0xac>)
 801a826:	4923      	ldr	r1, [pc, #140]	; (801a8b4 <UserFunctionForErasingFlash+0xb0>)
 801a828:	ea03 2342 	and.w	r3, r3, r2, lsl #9
 801a82c:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 801a830:	428b      	cmp	r3, r1
 801a832:	d90b      	bls.n	801a84c <UserFunctionForErasingFlash+0x48>
      bank = FLASH_BANK_1;
 801a834:	2201      	movs	r2, #1
 801a836:	e00a      	b.n	801a84e <UserFunctionForErasingFlash+0x4a>
    if (Addr < (FLASH_BASE + FLASH_BANK_SIZE))
 801a838:	429a      	cmp	r2, r3
 801a83a:	d033      	beq.n	801a8a4 <UserFunctionForErasingFlash+0xa0>
 801a83c:	4b1c      	ldr	r3, [pc, #112]	; (801a8b0 <UserFunctionForErasingFlash+0xac>)
 801a83e:	491d      	ldr	r1, [pc, #116]	; (801a8b4 <UserFunctionForErasingFlash+0xb0>)
 801a840:	ea03 2342 	and.w	r3, r3, r2, lsl #9
 801a844:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 801a848:	428b      	cmp	r3, r1
 801a84a:	d9f3      	bls.n	801a834 <UserFunctionForErasingFlash+0x30>
      bank = FLASH_BANK_2;
 801a84c:	2202      	movs	r2, #2
  if (Addr < (FLASH_BASE + FLASH_BANK_SIZE))
 801a84e:	4b17      	ldr	r3, [pc, #92]	; (801a8ac <UserFunctionForErasingFlash+0xa8>)
  EraseInitStruct.Banks       = GetBank(MDM_FLASH_ADD);
 801a850:	9203      	str	r2, [sp, #12]
  if (Addr < (FLASH_BASE + FLASH_BANK_SIZE))
 801a852:	8819      	ldrh	r1, [r3, #0]
 801a854:	4a16      	ldr	r2, [pc, #88]	; (801a8b0 <UserFunctionForErasingFlash+0xac>)
 801a856:	4b17      	ldr	r3, [pc, #92]	; (801a8b4 <UserFunctionForErasingFlash+0xb0>)
 801a858:	ea02 2241 	and.w	r2, r2, r1, lsl #9
 801a85c:	f102 6200 	add.w	r2, r2, #134217728	; 0x8000000
 801a860:	429a      	cmp	r2, r3
 801a862:	bf9a      	itte	ls
 801a864:	1a9b      	subls	r3, r3, r2
 801a866:	0adb      	lsrls	r3, r3, #11
    page = (Addr - FLASH_BASE) / FLASH_PAGE_SIZE;
 801a868:	f44f 73ff 	movhi.w	r3, #510	; 0x1fe
  EraseInitStruct.Page        = GetPage(MDM_FLASH_ADD);
  EraseInitStruct.NbPages     = 2;
 801a86c:	2202      	movs	r2, #2
 801a86e:	e9cd 3204 	strd	r3, r2, [sp, #16]

  /* Unlock the Flash to enable the flash control register access *************/
  HAL_FLASH_Unlock();
 801a872:	f7f6 fb07 	bl	8010e84 <HAL_FLASH_Unlock>

  if(HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError) != HAL_OK){
 801a876:	a901      	add	r1, sp, #4
 801a878:	a802      	add	r0, sp, #8
 801a87a:	f7f6 fc27 	bl	80110cc <HAL_FLASHEx_Erase>
 801a87e:	b928      	cbnz	r0, 801a88c <UserFunctionForErasingFlash+0x88>
    Error_Handler();
  }

  /* Lock the Flash to disable the flash control register access (recommended
  to protect the FLASH memory against possible unwanted operation) *********/
  HAL_FLASH_Lock();
 801a880:	f7f6 fb14 	bl	8010eac <HAL_FLASH_Lock>
  uint32_t Success=1;
 801a884:	2401      	movs	r4, #1

  return Success;
}
 801a886:	4620      	mov	r0, r4
 801a888:	b006      	add	sp, #24
 801a88a:	bd10      	pop	{r4, pc}
    Error_Handler();
 801a88c:	f000 ff6a 	bl	801b764 <Error_Handler>
  HAL_FLASH_Lock();
 801a890:	f7f6 fb0c 	bl	8010eac <HAL_FLASH_Lock>
    Success=0;
 801a894:	2400      	movs	r4, #0
}
 801a896:	4620      	mov	r0, r4
 801a898:	b006      	add	sp, #24
 801a89a:	bd10      	pop	{r4, pc}
      bank = FLASH_BANK_2;
 801a89c:	2302      	movs	r3, #2
  EraseInitStruct.Banks       = GetBank(MDM_FLASH_ADD);
 801a89e:	9303      	str	r3, [sp, #12]
 801a8a0:	23fe      	movs	r3, #254	; 0xfe
 801a8a2:	e7e3      	b.n	801a86c <UserFunctionForErasingFlash+0x68>
      bank = FLASH_BANK_1;
 801a8a4:	2301      	movs	r3, #1
 801a8a6:	e7fa      	b.n	801a89e <UserFunctionForErasingFlash+0x9a>
 801a8a8:	40010000 	.word	0x40010000
 801a8ac:	1fff75e0 	.word	0x1fff75e0
 801a8b0:	001ffe00 	.word	0x001ffe00
 801a8b4:	080ff000 	.word	0x080ff000

0801a8b8 <UserFunctionForSavingFlash>:
 * @param void * InitMetaDataVector Pointer to the MDM beginning
 * @param void * EndMetaDataVector Pointer to the MDM end
 * @retval uint32_t Success/NotSuccess [1/0]
 */
uint32_t UserFunctionForSavingFlash(void *InitMetaDataVector,void *EndMetaDataVector)
{
 801a8b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801a8ba:	4604      	mov	r4, r0
 801a8bc:	460d      	mov	r5, r1
  /* Store in Flash Memory */
  uint32_t Address = MDM_FLASH_ADD;
  uint64_t *WriteIndex;

  /* Unlock the Flash to enable the flash control register access *************/
  HAL_FLASH_Unlock();
 801a8be:	f7f6 fae1 	bl	8010e84 <HAL_FLASH_Unlock>
  for(WriteIndex =((uint64_t *) InitMetaDataVector); WriteIndex<((uint64_t *) EndMetaDataVector); WriteIndex++) {
 801a8c2:	42ac      	cmp	r4, r5
 801a8c4:	d21e      	bcs.n	801a904 <UserFunctionForSavingFlash+0x4c>
 801a8c6:	43e6      	mvns	r6, r4
 801a8c8:	442e      	add	r6, r5
 801a8ca:	f026 0607 	bic.w	r6, r6, #7
 801a8ce:	4426      	add	r6, r4
  uint32_t Address = MDM_FLASH_ADD;
 801a8d0:	4d0f      	ldr	r5, [pc, #60]	; (801a910 <UserFunctionForSavingFlash+0x58>)
 801a8d2:	3c08      	subs	r4, #8
  uint32_t Success=1;
 801a8d4:	2701      	movs	r7, #1
 801a8d6:	e003      	b.n	801a8e0 <UserFunctionForSavingFlash+0x28>
  for(WriteIndex =((uint64_t *) InitMetaDataVector); WriteIndex<((uint64_t *) EndMetaDataVector); WriteIndex++) {
 801a8d8:	42b4      	cmp	r4, r6
    if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, Address,*WriteIndex) == HAL_OK){
      Address = Address + 8;
 801a8da:	f105 0508 	add.w	r5, r5, #8
  for(WriteIndex =((uint64_t *) InitMetaDataVector); WriteIndex<((uint64_t *) EndMetaDataVector); WriteIndex++) {
 801a8de:	d00d      	beq.n	801a8fc <UserFunctionForSavingFlash+0x44>
    if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, Address,*WriteIndex) == HAL_OK){
 801a8e0:	e9f4 2302 	ldrd	r2, r3, [r4, #8]!
 801a8e4:	4629      	mov	r1, r5
 801a8e6:	2000      	movs	r0, #0
 801a8e8:	f7f6 fb30 	bl	8010f4c <HAL_FLASH_Program>
 801a8ec:	2800      	cmp	r0, #0
 801a8ee:	d0f3      	beq.n	801a8d8 <UserFunctionForSavingFlash+0x20>
    } else {
      /* Error occurred while writing data in Flash memory.
         User can add here some code to deal with this error
         FLASH_ErrorTypeDef errorcode = HAL_FLASH_GetError(); */
      Error_Handler();
 801a8f0:	f000 ff38 	bl	801b764 <Error_Handler>
  for(WriteIndex =((uint64_t *) InitMetaDataVector); WriteIndex<((uint64_t *) EndMetaDataVector); WriteIndex++) {
 801a8f4:	42b4      	cmp	r4, r6
      Success =0;
 801a8f6:	f04f 0700 	mov.w	r7, #0
  for(WriteIndex =((uint64_t *) InitMetaDataVector); WriteIndex<((uint64_t *) EndMetaDataVector); WriteIndex++) {
 801a8fa:	d1f1      	bne.n	801a8e0 <UserFunctionForSavingFlash+0x28>
    }
  }

  /* Lock the Flash to disable the flash control register access (recommended
   to protect the FLASH memory against possible unwanted operation) *********/
  HAL_FLASH_Lock();
 801a8fc:	f7f6 fad6 	bl	8010eac <HAL_FLASH_Lock>
 
  return Success;
}
 801a900:	4638      	mov	r0, r7
 801a902:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t Success=1;
 801a904:	2701      	movs	r7, #1
  HAL_FLASH_Lock();
 801a906:	f7f6 fad1 	bl	8010eac <HAL_FLASH_Lock>
}
 801a90a:	4638      	mov	r0, r7
 801a90c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801a90e:	bf00      	nop
 801a910:	080ff000 	.word	0x080ff000

0801a914 <startProcessing>:
  return 0;
}

static void startProcessing  (void const *arg)
{
  if     (arg == timEnvId){
 801a914:	4b1f      	ldr	r3, [pc, #124]	; (801a994 <startProcessing+0x80>)
 801a916:	681b      	ldr	r3, [r3, #0]
 801a918:	4283      	cmp	r3, r0
 801a91a:	d027      	beq.n	801a96c <startProcessing+0x58>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV))
      SendEnv=1;
  }
#ifdef STM32_SENSORTILE
  else if     (arg == timBatId){
 801a91c:	4b1e      	ldr	r3, [pc, #120]	; (801a998 <startProcessing+0x84>)
 801a91e:	681b      	ldr	r3, [r3, #0]
 801a920:	4283      	cmp	r3, r0
 801a922:	d017      	beq.n	801a954 <startProcessing+0x40>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_GG_EVENT))
      SendBatteryInfo= 1;
  }
#endif /* STM32_SENSORTILE */
  else if (arg == timMotionId){
 801a924:	4b1d      	ldr	r3, [pc, #116]	; (801a99c <startProcessing+0x88>)
 801a926:	681b      	ldr	r3, [r3, #0]
 801a928:	4283      	cmp	r3, r0
 801a92a:	d02b      	beq.n	801a984 <startProcessing+0x70>
    SendAccGyroMag=1;
  }
  else if (arg == timAudioLevId){
 801a92c:	4b1c      	ldr	r3, [pc, #112]	; (801a9a0 <startProcessing+0x8c>)
 801a92e:	681b      	ldr	r3, [r3, #0]
 801a930:	4283      	cmp	r3, r0
 801a932:	d02b      	beq.n	801a98c <startProcessing+0x78>
    SendAudioLevel=1;
  }
  else if (arg == timActivityId){
 801a934:	4b1b      	ldr	r3, [pc, #108]	; (801a9a4 <startProcessing+0x90>)
 801a936:	681b      	ldr	r3, [r3, #0]
 801a938:	4283      	cmp	r3, r0
 801a93a:	d01f      	beq.n	801a97c <startProcessing+0x68>
    UpdateMotionAR=1;
  }
#ifdef SENSING1_ENABLE_SD_CARD_LOGGING
  else if(arg == timSdCardLoggingId){
 801a93c:	4b1a      	ldr	r3, [pc, #104]	; (801a9a8 <startProcessing+0x94>)
 801a93e:	681b      	ldr	r3, [r3, #0]
 801a940:	4283      	cmp	r3, r0
 801a942:	d102      	bne.n	801a94a <startProcessing+0x36>
    SD_CardLogging= 1;
 801a944:	4b19      	ldr	r3, [pc, #100]	; (801a9ac <startProcessing+0x98>)
 801a946:	2201      	movs	r2, #1
 801a948:	615a      	str	r2, [r3, #20]
  }
#endif /* SENSING1_ENABLE_SD_CARD_LOGGING */
  else{
    SENSING1_PRINTF("wrong timer : %ld\n",(uint32_t)arg);
  }
  if( semRun ) osSemaphoreRelease(semRun);
 801a94a:	4b19      	ldr	r3, [pc, #100]	; (801a9b0 <startProcessing+0x9c>)
 801a94c:	6818      	ldr	r0, [r3, #0]
 801a94e:	b160      	cbz	r0, 801a96a <startProcessing+0x56>
 801a950:	f7fb bd64 	b.w	801641c <osSemaphoreRelease>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_GG_EVENT))
 801a954:	4b17      	ldr	r3, [pc, #92]	; (801a9b4 <startProcessing+0xa0>)
 801a956:	681b      	ldr	r3, [r3, #0]
 801a958:	05db      	lsls	r3, r3, #23
 801a95a:	d5f6      	bpl.n	801a94a <startProcessing+0x36>
      SendBatteryInfo= 1;
 801a95c:	4b13      	ldr	r3, [pc, #76]	; (801a9ac <startProcessing+0x98>)
 801a95e:	2201      	movs	r2, #1
 801a960:	605a      	str	r2, [r3, #4]
  if( semRun ) osSemaphoreRelease(semRun);
 801a962:	4b13      	ldr	r3, [pc, #76]	; (801a9b0 <startProcessing+0x9c>)
 801a964:	6818      	ldr	r0, [r3, #0]
 801a966:	2800      	cmp	r0, #0
 801a968:	d1f2      	bne.n	801a950 <startProcessing+0x3c>
}
 801a96a:	4770      	bx	lr
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV))
 801a96c:	4b11      	ldr	r3, [pc, #68]	; (801a9b4 <startProcessing+0xa0>)
 801a96e:	681b      	ldr	r3, [r3, #0]
 801a970:	07da      	lsls	r2, r3, #31
 801a972:	d5ea      	bpl.n	801a94a <startProcessing+0x36>
      SendEnv=1;
 801a974:	4b0d      	ldr	r3, [pc, #52]	; (801a9ac <startProcessing+0x98>)
 801a976:	2201      	movs	r2, #1
 801a978:	601a      	str	r2, [r3, #0]
 801a97a:	e7e6      	b.n	801a94a <startProcessing+0x36>
    UpdateMotionAR=1;
 801a97c:	4b0b      	ldr	r3, [pc, #44]	; (801a9ac <startProcessing+0x98>)
 801a97e:	2201      	movs	r2, #1
 801a980:	611a      	str	r2, [r3, #16]
 801a982:	e7e2      	b.n	801a94a <startProcessing+0x36>
    SendAccGyroMag=1;
 801a984:	4b09      	ldr	r3, [pc, #36]	; (801a9ac <startProcessing+0x98>)
 801a986:	2201      	movs	r2, #1
 801a988:	609a      	str	r2, [r3, #8]
 801a98a:	e7de      	b.n	801a94a <startProcessing+0x36>
    SendAudioLevel=1;
 801a98c:	4b07      	ldr	r3, [pc, #28]	; (801a9ac <startProcessing+0x98>)
 801a98e:	2201      	movs	r2, #1
 801a990:	60da      	str	r2, [r3, #12]
 801a992:	e7da      	b.n	801a94a <startProcessing+0x36>
 801a994:	200114cc 	.word	0x200114cc
 801a998:	20012f18 	.word	0x20012f18
 801a99c:	20012714 	.word	0x20012714
 801a9a0:	20012f38 	.word	0x20012f38
 801a9a4:	20012f20 	.word	0x20012f20
 801a9a8:	2001329c 	.word	0x2001329c
 801a9ac:	2000fff4 	.word	0x2000fff4
 801a9b0:	200132a4 	.word	0x200132a4
 801a9b4:	20010030 	.word	0x20010030

0801a9b8 <LedBlinkCb>:
  ledTimer = (uint32_t)NULL;
  }
}

static void LedBlinkCb  (void const *arg)
{
 801a9b8:	b510      	push	{r4, lr}
  if (ledTimer == LED_TIME_ON){
 801a9ba:	4c0b      	ldr	r4, [pc, #44]	; (801a9e8 <LedBlinkCb+0x30>)
 801a9bc:	69a3      	ldr	r3, [r4, #24]
 801a9be:	2b64      	cmp	r3, #100	; 0x64
 801a9c0:	d00c      	beq.n	801a9dc <LedBlinkCb+0x24>
    ledTimer = LED_TIME_OFF;
    LedOffTargetPlatform();
  }
  else{
    ledTimer = LED_TIME_ON;
 801a9c2:	2364      	movs	r3, #100	; 0x64
 801a9c4:	61a3      	str	r3, [r4, #24]
    LedOnTargetPlatform();
 801a9c6:	f7ff ff11 	bl	801a7ec <LedOnTargetPlatform>
  }
  if (timLedId){
 801a9ca:	4b08      	ldr	r3, [pc, #32]	; (801a9ec <LedBlinkCb+0x34>)
 801a9cc:	6818      	ldr	r0, [r3, #0]
 801a9ce:	b120      	cbz	r0, 801a9da <LedBlinkCb+0x22>
    if  (osTimerStart (timLedId, ledTimer) != osOK){
 801a9d0:	69a1      	ldr	r1, [r4, #24]
        SENSING1_PRINTF("failed starting timer\n\r");
    }
  }
}
 801a9d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if  (osTimerStart (timLedId, ledTimer) != osOK){
 801a9d6:	f7fb bc47 	b.w	8016268 <osTimerStart>
}
 801a9da:	bd10      	pop	{r4, pc}
    ledTimer = LED_TIME_OFF;
 801a9dc:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 801a9e0:	61a3      	str	r3, [r4, #24]
    LedOffTargetPlatform();
 801a9e2:	f7ff ff07 	bl	801a7f4 <LedOffTargetPlatform>
 801a9e6:	e7f0      	b.n	801a9ca <LedBlinkCb+0x12>
 801a9e8:	2000fff4 	.word	0x2000fff4
 801a9ec:	200114c4 	.word	0x200114c4

0801a9f0 <AudioProcess.part.0>:
static void AudioProcess(void)
 801a9f0:	b508      	push	{r3, lr}
 801a9f2:	4b16      	ldr	r3, [pc, #88]	; (801aa4c <AudioProcess.part.0+0x5c>)
 801a9f4:	4a16      	ldr	r2, [pc, #88]	; (801aa50 <AudioProcess.part.0+0x60>)
      sample /= (float32_t) ((1 << (8 * sizeof(int16_t) - 1)));
 801a9f6:	ed9f 7a17 	vldr	s14, [pc, #92]	; 801aa54 <AudioProcess.part.0+0x64>
 801a9fa:	f503 6100 	add.w	r1, r3, #2048	; 0x800
      sample = ((float32_t) Fill_Buffer[i]);
 801a9fe:	f933 0f02 	ldrsh.w	r0, [r3, #2]!
 801aa02:	ee07 0a90 	vmov	s15, r0
 801aa06:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    for (uint32_t i = 0; i < FILL_BUFFER_SIZE; i++) {
 801aa0a:	428b      	cmp	r3, r1
      sample /= (float32_t) ((1 << (8 * sizeof(int16_t) - 1)));
 801aa0c:	ee67 7a87 	vmul.f32	s15, s15, s14
      Proc_Buffer_f[i] = sample;
 801aa10:	ece2 7a01 	vstmia	r2!, {s15}
    for (uint32_t i = 0; i < FILL_BUFFER_SIZE; i++) {
 801aa14:	d1f3      	bne.n	801a9fe <AudioProcess.part.0+0xe>
    memmove(Fill_Buffer, Fill_Buffer + (FILL_BUFFER_SIZE / 2), sizeof(int16_t) * (FILL_BUFFER_SIZE / 2));
 801aa16:	4910      	ldr	r1, [pc, #64]	; (801aa58 <AudioProcess.part.0+0x68>)
 801aa18:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801aa1c:	f5a1 6080 	sub.w	r0, r1, #1024	; 0x400
 801aa20:	f004 f87b 	bl	801eb1a <memcpy>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ASC_EVENT)) {
 801aa24:	4a0d      	ldr	r2, [pc, #52]	; (801aa5c <AudioProcess.part.0+0x6c>)
    index_buff_fill = (FILL_BUFFER_SIZE / 2);
 801aa26:	4b0e      	ldr	r3, [pc, #56]	; (801aa60 <AudioProcess.part.0+0x70>)
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ASC_EVENT)) {
 801aa28:	6812      	ldr	r2, [r2, #0]
 801aa2a:	0512      	lsls	r2, r2, #20
    index_buff_fill = (FILL_BUFFER_SIZE / 2);
 801aa2c:	f44f 7100 	mov.w	r1, #512	; 0x200
      RunASCEvent = 1;
 801aa30:	bf48      	it	mi
 801aa32:	2201      	movmi	r2, #1
    index_buff_fill = (FILL_BUFFER_SIZE / 2);
 801aa34:	61d9      	str	r1, [r3, #28]
      RunASCEvent = 1;
 801aa36:	bf48      	it	mi
 801aa38:	621a      	strmi	r2, [r3, #32]
    if (semRun) {
 801aa3a:	4b0a      	ldr	r3, [pc, #40]	; (801aa64 <AudioProcess.part.0+0x74>)
 801aa3c:	6818      	ldr	r0, [r3, #0]
 801aa3e:	b118      	cbz	r0, 801aa48 <AudioProcess.part.0+0x58>
}
 801aa40:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      osSemaphoreRelease(semRun);
 801aa44:	f7fb bcea 	b.w	801641c <osSemaphoreRelease>
}
 801aa48:	bd08      	pop	{r3, pc}
 801aa4a:	bf00      	nop
 801aa4c:	20012716 	.word	0x20012716
 801aa50:	20011708 	.word	0x20011708
 801aa54:	38000000 	.word	0x38000000
 801aa58:	20012b18 	.word	0x20012b18
 801aa5c:	20010030 	.word	0x20010030
 801aa60:	2000fff4 	.word	0x2000fff4
 801aa64:	200132a4 	.word	0x200132a4

0801aa68 <SendMsgToHost>:
{
 801aa68:	b570      	push	{r4, r5, r6, lr}
  if (mail)
 801aa6a:	4e0b      	ldr	r6, [pc, #44]	; (801aa98 <SendMsgToHost+0x30>)
 801aa6c:	6833      	ldr	r3, [r6, #0]
 801aa6e:	b18b      	cbz	r3, 801aa94 <SendMsgToHost+0x2c>
 801aa70:	4605      	mov	r5, r0
    ptr = osMailAlloc(mail, osWaitForever);       /* Allocate memory */
 801aa72:	f04f 31ff 	mov.w	r1, #4294967295
 801aa76:	4618      	mov	r0, r3
 801aa78:	f7fb fd86 	bl	8016588 <osMailAlloc>
    if (ptr)
 801aa7c:	4604      	mov	r4, r0
 801aa7e:	b140      	cbz	r0, 801aa92 <SendMsgToHost+0x2a>
      Osal_MemCpy(ptr,msgPtr, sizeof(msgData_t));
 801aa80:	4629      	mov	r1, r5
 801aa82:	2228      	movs	r2, #40	; 0x28
 801aa84:	f7fe f8dc 	bl	8018c40 <Osal_MemCpy>
      osMailPut(mail, ptr);
 801aa88:	4621      	mov	r1, r4
 801aa8a:	6830      	ldr	r0, [r6, #0]
 801aa8c:	f7fb fd82 	bl	8016594 <osMailPut>
  return 1;
 801aa90:	2001      	movs	r0, #1
}
 801aa92:	bd70      	pop	{r4, r5, r6, pc}
  return 1;
 801aa94:	2001      	movs	r0, #1
}
 801aa96:	bd70      	pop	{r4, r5, r6, pc}
 801aa98:	20012710 	.word	0x20012710

0801aa9c <stopProc>:
{
 801aa9c:	b570      	push	{r4, r5, r6, lr}
 801aa9e:	b08a      	sub	sp, #40	; 0x28
  msg.type          = SET_HOST_LINK_TYPE;
 801aaa0:	220f      	movs	r2, #15
  msg.HostLinkType  = DEFAULT_HOST_LINK;
 801aaa2:	2301      	movs	r3, #1
  switch (type)
 801aaa4:	3805      	subs	r0, #5
  msg.type          = SET_HOST_LINK_TYPE;
 801aaa6:	f88d 2000 	strb.w	r2, [sp]
  msg.HostLinkType  = DEFAULT_HOST_LINK;
 801aaaa:	f88d 3004 	strb.w	r3, [sp, #4]
  switch (type)
 801aaae:	2809      	cmp	r0, #9
 801aab0:	d818      	bhi.n	801aae4 <stopProc+0x48>
 801aab2:	e8df f000 	tbb	[pc, r0]
 801aab6:	2922      	.short	0x2922
 801aab8:	17053017 	.word	0x17053017
 801aabc:	1d433e17 	.word	0x1d433e17
      if (audioInProgress&0x1) PowerCtrlUnLock();
 801aac0:	4d23      	ldr	r5, [pc, #140]	; (801ab50 <stopProc+0xb4>)
      id            = timAudioLevId;
 801aac2:	4e24      	ldr	r6, [pc, #144]	; (801ab54 <stopProc+0xb8>)
      if (audioInProgress&0x1) PowerCtrlUnLock();
 801aac4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
      id            = timAudioLevId;
 801aac6:	6834      	ldr	r4, [r6, #0]
      if (audioInProgress&0x1) PowerCtrlUnLock();
 801aac8:	07da      	lsls	r2, r3, #31
 801aaca:	d43c      	bmi.n	801ab46 <stopProc+0xaa>
      audioInProgress &= 0x2+0x4 ;
 801aacc:	f003 0306 	and.w	r3, r3, #6
      timAudioLevId = NULL;
 801aad0:	2200      	movs	r2, #0
      audioInProgress &= 0x2+0x4 ;
 801aad2:	626b      	str	r3, [r5, #36]	; 0x24
      timAudioLevId = NULL;
 801aad4:	6032      	str	r2, [r6, #0]
  if (id){
 801aad6:	b12c      	cbz	r4, 801aae4 <stopProc+0x48>
    if  (osTimerStop (id) != osOK){
 801aad8:	4620      	mov	r0, r4
 801aada:	f7fb fbf3 	bl	80162c4 <osTimerStop>
    if (osTimerDelete (id) != osOK)  {
 801aade:	4620      	mov	r0, r4
 801aae0:	f7fb fc1c 	bl	801631c <osTimerDelete>
  SendMsgToHost(&msg);
 801aae4:	4668      	mov	r0, sp
 801aae6:	f7ff ffbf 	bl	801aa68 <SendMsgToHost>
}
 801aaea:	2000      	movs	r0, #0
 801aaec:	b00a      	add	sp, #40	; 0x28
 801aaee:	bd70      	pop	{r4, r5, r6, pc}
      id                 = timSdCardLoggingId;
 801aaf0:	4b19      	ldr	r3, [pc, #100]	; (801ab58 <stopProc+0xbc>)
      timSdCardLoggingId = NULL;
 801aaf2:	2200      	movs	r2, #0
      id                 = timSdCardLoggingId;
 801aaf4:	681c      	ldr	r4, [r3, #0]
      timSdCardLoggingId = NULL;
 801aaf6:	601a      	str	r2, [r3, #0]
      break;
 801aaf8:	e7ed      	b.n	801aad6 <stopProc+0x3a>
      id           = timEnvId;
 801aafa:	4b18      	ldr	r3, [pc, #96]	; (801ab5c <stopProc+0xc0>)
      timEnvId     = NULL;
 801aafc:	2200      	movs	r2, #0
      id           = timEnvId;
 801aafe:	681c      	ldr	r4, [r3, #0]
      timEnvId     = NULL;
 801ab00:	601a      	str	r2, [r3, #0]
      disableEnvSensors();
 801ab02:	f7ff fe39 	bl	801a778 <disableEnvSensors>
      break;
 801ab06:	e7e6      	b.n	801aad6 <stopProc+0x3a>
      id            = timMotionId;
 801ab08:	4b15      	ldr	r3, [pc, #84]	; (801ab60 <stopProc+0xc4>)
      timMotionId   = NULL;
 801ab0a:	2200      	movs	r2, #0
      id            = timMotionId;
 801ab0c:	681c      	ldr	r4, [r3, #0]
      timMotionId   = NULL;
 801ab0e:	601a      	str	r2, [r3, #0]
      disableMotionSensors ();
 801ab10:	f7ff fdf6 	bl	801a700 <disableMotionSensors>
      break;
 801ab14:	e7df      	b.n	801aad6 <stopProc+0x3a>
      BSP_ACCELERO_Sensor_Disable( TargetBoardFeatures.HandleAccSensor );
 801ab16:	4d13      	ldr	r5, [pc, #76]	; (801ab64 <stopProc+0xc8>)
      id            = timActivityId;
 801ab18:	4b13      	ldr	r3, [pc, #76]	; (801ab68 <stopProc+0xcc>)
      BSP_ACCELERO_Sensor_Disable( TargetBoardFeatures.HandleAccSensor );
 801ab1a:	69a8      	ldr	r0, [r5, #24]
      id            = timActivityId;
 801ab1c:	681c      	ldr	r4, [r3, #0]
      timActivityId = NULL;
 801ab1e:	2200      	movs	r2, #0
 801ab20:	601a      	str	r2, [r3, #0]
      BSP_ACCELERO_Sensor_Disable( TargetBoardFeatures.HandleAccSensor );
 801ab22:	f7f3 ffd3 	bl	800eacc <BSP_ACCELERO_Sensor_Disable>
      BSP_GYRO_Sensor_Disable( TargetBoardFeatures.HandleGyroSensor );
 801ab26:	69e8      	ldr	r0, [r5, #28]
 801ab28:	f7f5 f8f8 	bl	800fd1c <BSP_GYRO_Sensor_Disable>
      Gesture_DeInitialize();
 801ab2c:	f7f9 f960 	bl	8013df0 <Gesture_DeInitialize>
      break;
 801ab30:	e7d1      	b.n	801aad6 <stopProc+0x3a>
      id           = timBatId;
 801ab32:	4b0e      	ldr	r3, [pc, #56]	; (801ab6c <stopProc+0xd0>)
      timBatId     = NULL;
 801ab34:	2200      	movs	r2, #0
      id           = timBatId;
 801ab36:	681c      	ldr	r4, [r3, #0]
      timBatId     = NULL;
 801ab38:	601a      	str	r2, [r3, #0]
      break;
 801ab3a:	e7cc      	b.n	801aad6 <stopProc+0x3a>
      id           = timBattPlugId;
 801ab3c:	4b0c      	ldr	r3, [pc, #48]	; (801ab70 <stopProc+0xd4>)
      timBattPlugId= NULL;
 801ab3e:	2200      	movs	r2, #0
      id           = timBattPlugId;
 801ab40:	681c      	ldr	r4, [r3, #0]
      timBattPlugId= NULL;
 801ab42:	601a      	str	r2, [r3, #0]
      break;
 801ab44:	e7c7      	b.n	801aad6 <stopProc+0x3a>
      if (audioInProgress&0x1) PowerCtrlUnLock();
 801ab46:	f7ff fc5d 	bl	801a404 <PowerCtrlUnLock>
 801ab4a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 801ab4c:	e7be      	b.n	801aacc <stopProc+0x30>
 801ab4e:	bf00      	nop
 801ab50:	2000fff4 	.word	0x2000fff4
 801ab54:	20012f38 	.word	0x20012f38
 801ab58:	2001329c 	.word	0x2001329c
 801ab5c:	200114cc 	.word	0x200114cc
 801ab60:	20012714 	.word	0x20012714
 801ab64:	20011458 	.word	0x20011458
 801ab68:	20012f20 	.word	0x20012f20
 801ab6c:	20012f18 	.word	0x20012f18
 801ab70:	20012f1c 	.word	0x20012f1c

0801ab74 <Set2GAccelerometerFullScale>:
{
 801ab74:	b510      	push	{r4, lr}
  BSP_ACCELERO_Set_FS_Value(TargetBoardFeatures.HandleAccSensor,2.0f);
 801ab76:	4c0a      	ldr	r4, [pc, #40]	; (801aba0 <Set2GAccelerometerFullScale+0x2c>)
{
 801ab78:	b082      	sub	sp, #8
  BSP_ACCELERO_Set_FS_Value(TargetBoardFeatures.HandleAccSensor,2.0f);
 801ab7a:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 801ab7e:	69a0      	ldr	r0, [r4, #24]
 801ab80:	f7f3 fffa 	bl	800eb78 <BSP_ACCELERO_Set_FS_Value>
  BSP_ACCELERO_Get_Sensitivity(TargetBoardFeatures.HandleAccSensor,&sensitivity);
 801ab84:	69a0      	ldr	r0, [r4, #24]
 801ab86:	a901      	add	r1, sp, #4
 801ab88:	f7f3 ffc2 	bl	800eb10 <BSP_ACCELERO_Get_Sensitivity>
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G ;
 801ab8c:	eddd 7a01 	vldr	s15, [sp, #4]
 801ab90:	ed9f 7a04 	vldr	s14, [pc, #16]	; 801aba4 <Set2GAccelerometerFullScale+0x30>
 801ab94:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ab98:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
}
 801ab9c:	b002      	add	sp, #8
 801ab9e:	bd10      	pop	{r4, pc}
 801aba0:	20011458 	.word	0x20011458
 801aba4:	3a83126f 	.word	0x3a83126f

0801aba8 <Set4GAccelerometerFullScale>:
{
 801aba8:	b510      	push	{r4, lr}
  BSP_ACCELERO_Set_FS_Value(TargetBoardFeatures.HandleAccSensor,4.0f);
 801abaa:	4c0a      	ldr	r4, [pc, #40]	; (801abd4 <Set4GAccelerometerFullScale+0x2c>)
{
 801abac:	b082      	sub	sp, #8
  BSP_ACCELERO_Set_FS_Value(TargetBoardFeatures.HandleAccSensor,4.0f);
 801abae:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801abb2:	69a0      	ldr	r0, [r4, #24]
 801abb4:	f7f3 ffe0 	bl	800eb78 <BSP_ACCELERO_Set_FS_Value>
  BSP_ACCELERO_Get_Sensitivity(TargetBoardFeatures.HandleAccSensor,&sensitivity);
 801abb8:	69a0      	ldr	r0, [r4, #24]
 801abba:	a901      	add	r1, sp, #4
 801abbc:	f7f3 ffa8 	bl	800eb10 <BSP_ACCELERO_Get_Sensitivity>
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G;
 801abc0:	eddd 7a01 	vldr	s15, [sp, #4]
 801abc4:	ed9f 7a04 	vldr	s14, [pc, #16]	; 801abd8 <Set4GAccelerometerFullScale+0x30>
 801abc8:	ee67 7a87 	vmul.f32	s15, s15, s14
 801abcc:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
}
 801abd0:	b002      	add	sp, #8
 801abd2:	bd10      	pop	{r4, pc}
 801abd4:	20011458 	.word	0x20011458
 801abd8:	3a83126f 	.word	0x3a83126f

0801abdc <startProc>:
{
 801abdc:	b570      	push	{r4, r5, r6, lr}
 801abde:	b08a      	sub	sp, #40	; 0x28
  msg.type         = SET_HOST_LINK_TYPE;
 801abe0:	220f      	movs	r2, #15
  msg.HostLinkType = DEFAULT_HOST_LINK;
 801abe2:	2301      	movs	r3, #1
  switch (type)
 801abe4:	3805      	subs	r0, #5
{
 801abe6:	460d      	mov	r5, r1
  msg.type         = SET_HOST_LINK_TYPE;
 801abe8:	f88d 2000 	strb.w	r2, [sp]
  msg.HostLinkType = DEFAULT_HOST_LINK;
 801abec:	f88d 3004 	strb.w	r3, [sp, #4]
  switch (type)
 801abf0:	2809      	cmp	r0, #9
 801abf2:	d80f      	bhi.n	801ac14 <startProc+0x38>
 801abf4:	e8df f000 	tbb	[pc, r0]
 801abf8:	380e2914 	.word	0x380e2914
 801abfc:	5c0e0e4b 	.word	0x5c0e0e4b
 801ac00:	056a      	.short	0x056a
       if (!timSdCardLoggingId)
 801ac02:	4e4d      	ldr	r6, [pc, #308]	; (801ad38 <startProc+0x15c>)
 801ac04:	6834      	ldr	r4, [r6, #0]
 801ac06:	2c00      	cmp	r4, #0
 801ac08:	f000 808b 	beq.w	801ad22 <startProc+0x146>
    if  (osTimerStart (id, period) != osOK){
 801ac0c:	4629      	mov	r1, r5
 801ac0e:	4620      	mov	r0, r4
 801ac10:	f7fb fb2a 	bl	8016268 <osTimerStart>
  SendMsgToHost(&msg);
 801ac14:	4668      	mov	r0, sp
 801ac16:	f7ff ff27 	bl	801aa68 <SendMsgToHost>
}
 801ac1a:	2000      	movs	r0, #0
 801ac1c:	b00a      	add	sp, #40	; 0x28
 801ac1e:	bd70      	pop	{r4, r5, r6, pc}
      if (!timEnvId)
 801ac20:	4c46      	ldr	r4, [pc, #280]	; (801ad3c <startProc+0x160>)
 801ac22:	6822      	ldr	r2, [r4, #0]
 801ac24:	2a00      	cmp	r2, #0
 801ac26:	d076      	beq.n	801ad16 <startProc+0x13a>
      if(!TargetBoardFeatures.EnvSensorEnabled)
 801ac28:	4b45      	ldr	r3, [pc, #276]	; (801ad40 <startProc+0x164>)
 801ac2a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801ac2e:	2b00      	cmp	r3, #0
 801ac30:	d05a      	beq.n	801ace8 <startProc+0x10c>
      id = timEnvId;
 801ac32:	6824      	ldr	r4, [r4, #0]
      msg.HostLinkType  = ENV_HOST_LINK;
 801ac34:	2302      	movs	r3, #2
 801ac36:	f88d 3004 	strb.w	r3, [sp, #4]
  if (id){
 801ac3a:	2c00      	cmp	r4, #0
 801ac3c:	d1e6      	bne.n	801ac0c <startProc+0x30>
  SendMsgToHost(&msg);
 801ac3e:	4668      	mov	r0, sp
 801ac40:	f7ff ff12 	bl	801aa68 <SendMsgToHost>
}
 801ac44:	2000      	movs	r0, #0
 801ac46:	b00a      	add	sp, #40	; 0x28
 801ac48:	bd70      	pop	{r4, r5, r6, pc}
      if (!timMotionId)
 801ac4a:	4c3e      	ldr	r4, [pc, #248]	; (801ad44 <startProc+0x168>)
 801ac4c:	6822      	ldr	r2, [r4, #0]
 801ac4e:	2a00      	cmp	r2, #0
 801ac50:	d04d      	beq.n	801acee <startProc+0x112>
      enableMotionSensors ();
 801ac52:	f7ff fd41 	bl	801a6d8 <enableMotionSensors>
      Set2GAccelerometerFullScale();
 801ac56:	f7ff ff8d 	bl	801ab74 <Set2GAccelerometerFullScale>
      id = timMotionId;
 801ac5a:	6824      	ldr	r4, [r4, #0]
      msg.HostLinkType  = MOTION_HOST_LINK;
 801ac5c:	2304      	movs	r3, #4
 801ac5e:	f88d 3004 	strb.w	r3, [sp, #4]
  if (id){
 801ac62:	2c00      	cmp	r4, #0
 801ac64:	d0eb      	beq.n	801ac3e <startProc+0x62>
 801ac66:	e7d1      	b.n	801ac0c <startProc+0x30>
     if (!timActivityId)
 801ac68:	4c37      	ldr	r4, [pc, #220]	; (801ad48 <startProc+0x16c>)
 801ac6a:	6822      	ldr	r2, [r4, #0]
 801ac6c:	2a00      	cmp	r2, #0
 801ac6e:	d04c      	beq.n	801ad0a <startProc+0x12e>
      BSP_ACCELERO_Sensor_Enable( TargetBoardFeatures.HandleAccSensor );
 801ac70:	4e33      	ldr	r6, [pc, #204]	; (801ad40 <startProc+0x164>)
 801ac72:	69b0      	ldr	r0, [r6, #24]
 801ac74:	f7f3 ff1a 	bl	800eaac <BSP_ACCELERO_Sensor_Enable>
      BSP_GYRO_Sensor_Enable( TargetBoardFeatures.HandleGyroSensor );
 801ac78:	69f0      	ldr	r0, [r6, #28]
 801ac7a:	f7f5 f83f 	bl	800fcfc <BSP_GYRO_Sensor_Enable>
      Set4GAccelerometerFullScale();
 801ac7e:	f7ff ff93 	bl	801aba8 <Set4GAccelerometerFullScale>
      Gesture_Initialize();
 801ac82:	f7f9 f81d 	bl	8013cc0 <Gesture_Initialize>
      id = timActivityId;
 801ac86:	6824      	ldr	r4, [r4, #0]
  if (id){
 801ac88:	2c00      	cmp	r4, #0
 801ac8a:	d0d8      	beq.n	801ac3e <startProc+0x62>
 801ac8c:	e7be      	b.n	801ac0c <startProc+0x30>
      if (!timAudioLevId)
 801ac8e:	4e2f      	ldr	r6, [pc, #188]	; (801ad4c <startProc+0x170>)
 801ac90:	6834      	ldr	r4, [r6, #0]
 801ac92:	2c00      	cmp	r4, #0
 801ac94:	d031      	beq.n	801acfa <startProc+0x11e>
      PowerCtrlLock();
 801ac96:	f7ff fbad 	bl	801a3f4 <PowerCtrlLock>
      audioInProgress |= 0x1 ;
 801ac9a:	4a2d      	ldr	r2, [pc, #180]	; (801ad50 <startProc+0x174>)
 801ac9c:	6a53      	ldr	r3, [r2, #36]	; 0x24
      msg.HostLinkType  = AUDIO_HOST_LINK;
 801ac9e:	2103      	movs	r1, #3
      audioInProgress |= 0x1 ;
 801aca0:	f043 0301 	orr.w	r3, r3, #1
 801aca4:	6253      	str	r3, [r2, #36]	; 0x24
      msg.HostLinkType  = AUDIO_HOST_LINK;
 801aca6:	f88d 1004 	strb.w	r1, [sp, #4]
  if (id){
 801acaa:	2c00      	cmp	r4, #0
 801acac:	d0c7      	beq.n	801ac3e <startProc+0x62>
 801acae:	e7ad      	b.n	801ac0c <startProc+0x30>
      if (!timBatId)
 801acb0:	4e28      	ldr	r6, [pc, #160]	; (801ad54 <startProc+0x178>)
 801acb2:	6834      	ldr	r4, [r6, #0]
 801acb4:	2c00      	cmp	r4, #0
 801acb6:	d1a9      	bne.n	801ac0c <startProc+0x30>
        timBatId = osTimerCreate (osTimer(TimerBatHandle), osTimerPeriodic, NULL);
 801acb8:	4622      	mov	r2, r4
 801acba:	2101      	movs	r1, #1
 801acbc:	4826      	ldr	r0, [pc, #152]	; (801ad58 <startProc+0x17c>)
 801acbe:	f7fb fabf 	bl	8016240 <osTimerCreate>
 801acc2:	4604      	mov	r4, r0
 801acc4:	6030      	str	r0, [r6, #0]
  if (id){
 801acc6:	2c00      	cmp	r4, #0
 801acc8:	d0b9      	beq.n	801ac3e <startProc+0x62>
 801acca:	e79f      	b.n	801ac0c <startProc+0x30>
      if (!timBattPlugId)
 801accc:	4e23      	ldr	r6, [pc, #140]	; (801ad5c <startProc+0x180>)
 801acce:	6834      	ldr	r4, [r6, #0]
 801acd0:	2c00      	cmp	r4, #0
 801acd2:	d19b      	bne.n	801ac0c <startProc+0x30>
        timBattPlugId = osTimerCreate (osTimer(TimerBattPlugHandle), osTimerPeriodic, NULL);
 801acd4:	4622      	mov	r2, r4
 801acd6:	2101      	movs	r1, #1
 801acd8:	4821      	ldr	r0, [pc, #132]	; (801ad60 <startProc+0x184>)
 801acda:	f7fb fab1 	bl	8016240 <osTimerCreate>
 801acde:	4604      	mov	r4, r0
 801ace0:	6030      	str	r0, [r6, #0]
  if (id){
 801ace2:	2c00      	cmp	r4, #0
 801ace4:	d0ab      	beq.n	801ac3e <startProc+0x62>
 801ace6:	e791      	b.n	801ac0c <startProc+0x30>
        enableEnvSensors();
 801ace8:	f7ff fd1e 	bl	801a728 <enableEnvSensors>
 801acec:	e7a1      	b.n	801ac32 <startProc+0x56>
        timMotionId = osTimerCreate (osTimer(TimerMotionHandle),osTimerPeriodic, NULL);
 801acee:	2101      	movs	r1, #1
 801acf0:	481c      	ldr	r0, [pc, #112]	; (801ad64 <startProc+0x188>)
 801acf2:	f7fb faa5 	bl	8016240 <osTimerCreate>
 801acf6:	6020      	str	r0, [r4, #0]
 801acf8:	e7ab      	b.n	801ac52 <startProc+0x76>
        timAudioLevId = osTimerCreate (osTimer(TimerAudioLevHandle),osTimerPeriodic, NULL);
 801acfa:	4622      	mov	r2, r4
 801acfc:	2101      	movs	r1, #1
 801acfe:	481a      	ldr	r0, [pc, #104]	; (801ad68 <startProc+0x18c>)
 801ad00:	f7fb fa9e 	bl	8016240 <osTimerCreate>
 801ad04:	4604      	mov	r4, r0
 801ad06:	6030      	str	r0, [r6, #0]
 801ad08:	e7c5      	b.n	801ac96 <startProc+0xba>
        timActivityId = osTimerCreate (osTimer(TimerActivityHandle),osTimerPeriodic, NULL);
 801ad0a:	2101      	movs	r1, #1
 801ad0c:	4817      	ldr	r0, [pc, #92]	; (801ad6c <startProc+0x190>)
 801ad0e:	f7fb fa97 	bl	8016240 <osTimerCreate>
 801ad12:	6020      	str	r0, [r4, #0]
 801ad14:	e7ac      	b.n	801ac70 <startProc+0x94>
        timEnvId = osTimerCreate (osTimer(TimerEnvHandle), osTimerPeriodic, NULL);
 801ad16:	2101      	movs	r1, #1
 801ad18:	4815      	ldr	r0, [pc, #84]	; (801ad70 <startProc+0x194>)
 801ad1a:	f7fb fa91 	bl	8016240 <osTimerCreate>
 801ad1e:	6020      	str	r0, [r4, #0]
 801ad20:	e782      	b.n	801ac28 <startProc+0x4c>
         timSdCardLoggingId = osTimerCreate (osTimer(TimerSdRecordingHandle), osTimerPeriodic, NULL);
 801ad22:	4622      	mov	r2, r4
 801ad24:	2101      	movs	r1, #1
 801ad26:	4813      	ldr	r0, [pc, #76]	; (801ad74 <startProc+0x198>)
 801ad28:	f7fb fa8a 	bl	8016240 <osTimerCreate>
 801ad2c:	4604      	mov	r4, r0
 801ad2e:	6030      	str	r0, [r6, #0]
  if (id){
 801ad30:	2c00      	cmp	r4, #0
 801ad32:	d084      	beq.n	801ac3e <startProc+0x62>
 801ad34:	e76a      	b.n	801ac0c <startProc+0x30>
 801ad36:	bf00      	nop
 801ad38:	2001329c 	.word	0x2001329c
 801ad3c:	200114cc 	.word	0x200114cc
 801ad40:	20011458 	.word	0x20011458
 801ad44:	20012714 	.word	0x20012714
 801ad48:	20012f20 	.word	0x20012f20
 801ad4c:	20012f38 	.word	0x20012f38
 801ad50:	2000fff4 	.word	0x2000fff4
 801ad54:	20012f18 	.word	0x20012f18
 801ad58:	08075344 	.word	0x08075344
 801ad5c:	20012f1c 	.word	0x20012f1c
 801ad60:	08075348 	.word	0x08075348
 801ad64:	08075350 	.word	0x08075350
 801ad68:	08075354 	.word	0x08075354
 801ad6c:	08075358 	.word	0x08075358
 801ad70:	0807534c 	.word	0x0807534c
 801ad74:	0807535c 	.word	0x0807535c

0801ad78 <AudioProcess_FromMics>:
{
 801ad78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  memcpy(Fill_Buffer + index_buff_fill, PCM_Buffer, sizeof(int16_t) * 16);
 801ad7a:	4f1f      	ldr	r7, [pc, #124]	; (801adf8 <AudioProcess_FromMics+0x80>)
 801ad7c:	4b1f      	ldr	r3, [pc, #124]	; (801adfc <AudioProcess_FromMics+0x84>)
 801ad7e:	69f9      	ldr	r1, [r7, #28]
 801ad80:	481f      	ldr	r0, [pc, #124]	; (801ae00 <AudioProcess_FromMics+0x88>)
 801ad82:	681e      	ldr	r6, [r3, #0]
 801ad84:	f840 6011 	str.w	r6, [r0, r1, lsl #1]
 801ad88:	eb00 0241 	add.w	r2, r0, r1, lsl #1
 801ad8c:	685d      	ldr	r5, [r3, #4]
 801ad8e:	689c      	ldr	r4, [r3, #8]
 801ad90:	6055      	str	r5, [r2, #4]
 801ad92:	68d8      	ldr	r0, [r3, #12]
 801ad94:	60d0      	str	r0, [r2, #12]
 801ad96:	6094      	str	r4, [r2, #8]
  index_buff_fill += 16;
 801ad98:	3110      	adds	r1, #16
  memcpy(Fill_Buffer + index_buff_fill, PCM_Buffer, sizeof(int16_t) * 16);
 801ad9a:	691e      	ldr	r6, [r3, #16]
 801ad9c:	695d      	ldr	r5, [r3, #20]
  index_buff_fill += 16;
 801ad9e:	61f9      	str	r1, [r7, #28]
  memcpy(Fill_Buffer + index_buff_fill, PCM_Buffer, sizeof(int16_t) * 16);
 801ada0:	699c      	ldr	r4, [r3, #24]
 801ada2:	69d8      	ldr	r0, [r3, #28]
 801ada4:	61d0      	str	r0, [r2, #28]
  if (index_buff_fill == FILL_BUFFER_SIZE) {
 801ada6:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
  memcpy(Fill_Buffer + index_buff_fill, PCM_Buffer, sizeof(int16_t) * 16);
 801adaa:	6116      	str	r6, [r2, #16]
 801adac:	6155      	str	r5, [r2, #20]
 801adae:	6194      	str	r4, [r2, #24]
  if (index_buff_fill == FILL_BUFFER_SIZE) {
 801adb0:	d01f      	beq.n	801adf2 <AudioProcess_FromMics+0x7a>
  if(SD_LogAudio_Enabled)
 801adb2:	4b14      	ldr	r3, [pc, #80]	; (801ae04 <AudioProcess_FromMics+0x8c>)
 801adb4:	681b      	ldr	r3, [r3, #0]
 801adb6:	b9c3      	cbnz	r3, 801adea <AudioProcess_FromMics+0x72>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_AUDIO_LEVEL)) {
 801adb8:	4b13      	ldr	r3, [pc, #76]	; (801ae08 <AudioProcess_FromMics+0x90>)
 801adba:	681b      	ldr	r3, [r3, #0]
 801adbc:	071b      	lsls	r3, r3, #28
 801adbe:	d513      	bpl.n	801ade8 <AudioProcess_FromMics+0x70>
 801adc0:	4a12      	ldr	r2, [pc, #72]	; (801ae0c <AudioProcess_FromMics+0x94>)
 801adc2:	4913      	ldr	r1, [pc, #76]	; (801ae10 <AudioProcess_FromMics+0x98>)
 801adc4:	f102 0020 	add.w	r0, r2, #32
      RMS_Ch[NumberMic] += (float)((int16_t)PCM_Buffer[i*AUDIO_CHANNELS+NumberMic] * ((int16_t)PCM_Buffer[i*AUDIO_CHANNELS+NumberMic]));
 801adc8:	f932 3f02 	ldrsh.w	r3, [r2, #2]!
 801adcc:	ed91 7a00 	vldr	s14, [r1]
 801add0:	fb03 f303 	mul.w	r3, r3, r3
 801add4:	ee07 3a90 	vmov	s15, r3
 801add8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  for(i = 0; i < 16; i++){
 801addc:	4282      	cmp	r2, r0
      RMS_Ch[NumberMic] += (float)((int16_t)PCM_Buffer[i*AUDIO_CHANNELS+NumberMic] * ((int16_t)PCM_Buffer[i*AUDIO_CHANNELS+NumberMic]));
 801adde:	ee77 7a87 	vadd.f32	s15, s15, s14
 801ade2:	edc1 7a00 	vstr	s15, [r1]
  for(i = 0; i < 16; i++){
 801ade6:	d1ef      	bne.n	801adc8 <AudioProcess_FromMics+0x50>
}
 801ade8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801adea:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    AudioProcess_SD_Recording();
 801adee:	f7fe bbc7 	b.w	8019580 <AudioProcess_SD_Recording>
 801adf2:	f7ff fdfd 	bl	801a9f0 <AudioProcess.part.0>
 801adf6:	e7dc      	b.n	801adb2 <AudioProcess_FromMics+0x3a>
 801adf8:	2000fff4 	.word	0x2000fff4
 801adfc:	2001149c 	.word	0x2001149c
 801ae00:	20012718 	.word	0x20012718
 801ae04:	2000f074 	.word	0x2000f074
 801ae08:	20010030 	.word	0x20010030
 801ae0c:	2001149a 	.word	0x2001149a
 801ae10:	200114c0 	.word	0x200114c0

0801ae14 <BSP_AUDIO_IN_HalfTransfer_CallBack>:
 801ae14:	f7ff bfb0 	b.w	801ad78 <AudioProcess_FromMics>

0801ae18 <BSP_AUDIO_IN_TransferComplete_CallBack>:
  AudioProcess_FromMics();
 801ae18:	f7ff bfae 	b.w	801ad78 <AudioProcess_FromMics>

0801ae1c <SystemClock_Config>:
{
 801ae1c:	b570      	push	{r4, r5, r6, lr}
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 801ae1e:	2400      	movs	r4, #0
{
 801ae20:	b0b8      	sub	sp, #224	; 0xe0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 801ae22:	4621      	mov	r1, r4
 801ae24:	2240      	movs	r2, #64	; 0x40
 801ae26:	a806      	add	r0, sp, #24
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 801ae28:	e9cd 4400 	strd	r4, r4, [sp]
 801ae2c:	e9cd 4402 	strd	r4, r4, [sp, #8]
 801ae30:	9404      	str	r4, [sp, #16]
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 801ae32:	f003 fe7d 	bl	801eb30 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 801ae36:	4621      	mov	r1, r4
 801ae38:	a816      	add	r0, sp, #88	; 0x58
 801ae3a:	2288      	movs	r2, #136	; 0x88
 801ae3c:	f003 fe78 	bl	801eb30 <memset>
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE;
 801ae40:	2504      	movs	r5, #4
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 801ae42:	2401      	movs	r4, #1
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK){
 801ae44:	a805      	add	r0, sp, #20
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE;
 801ae46:	9505      	str	r5, [sp, #20]
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 801ae48:	9407      	str	r4, [sp, #28]
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK){
 801ae4a:	f7f7 f81b 	bl	8011e84 <HAL_RCC_OscConfig>
 801ae4e:	b100      	cbz	r0, 801ae52 <SystemClock_Config+0x36>
 801ae50:	e7fe      	b.n	801ae50 <SystemClock_Config+0x34>
 801ae52:	4606      	mov	r6, r0
  HAL_RCCEx_DisableLSECSS();
 801ae54:	f7f7 fe6e 	bl	8012b34 <HAL_RCCEx_DisableLSECSS>
  RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_MSI;
 801ae58:	2110      	movs	r1, #16
  RCC_OscInitStruct.MSIClockRange       = RCC_MSIRANGE_11;
 801ae5a:	22b0      	movs	r2, #176	; 0xb0
  RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
 801ae5c:	2302      	movs	r3, #2
  RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_MSI;
 801ae5e:	9105      	str	r1, [sp, #20]
  RCC_OscInitStruct.MSIClockRange       = RCC_MSIRANGE_11;
 801ae60:	920d      	str	r2, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLM            = 6;
 801ae62:	2106      	movs	r1, #6
  RCC_OscInitStruct.PLL.PLLN            = 40;
 801ae64:	2228      	movs	r2, #40	; 0x28
  RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
 801ae66:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK){
 801ae68:	a805      	add	r0, sp, #20
  RCC_OscInitStruct.PLL.PLLP            = 7;
 801ae6a:	2307      	movs	r3, #7
  RCC_OscInitStruct.MSIState            = RCC_MSI_ON;
 801ae6c:	940b      	str	r4, [sp, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_MSI;
 801ae6e:	9410      	str	r4, [sp, #64]	; 0x40
  RCC_OscInitStruct.HSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 801ae70:	9609      	str	r6, [sp, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLR            = 4;
 801ae72:	e9cd 5514 	strd	r5, r5, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLN            = 40;
 801ae76:	e9cd 1211 	strd	r1, r2, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLP            = 7;
 801ae7a:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK){
 801ae7c:	f7f7 f802 	bl	8011e84 <HAL_RCC_OscConfig>
 801ae80:	4604      	mov	r4, r0
 801ae82:	b100      	cbz	r0, 801ae86 <SystemClock_Config+0x6a>
 801ae84:	e7fe      	b.n	801ae84 <SystemClock_Config+0x68>
  HAL_RCCEx_EnableMSIPLLMode();
 801ae86:	f7f7 fe63 	bl	8012b50 <HAL_RCCEx_EnableMSIPLLMode>
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB;
 801ae8a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_MSI;
 801ae8e:	f04f 6340 	mov.w	r3, #201326592	; 0xc000000
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
 801ae92:	a816      	add	r0, sp, #88	; 0x58
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB;
 801ae94:	9216      	str	r2, [sp, #88]	; 0x58
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_MSI;
 801ae96:	9331      	str	r3, [sp, #196]	; 0xc4
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
 801ae98:	f7f7 fc3c 	bl	8012714 <HAL_RCCEx_PeriphCLKConfig>
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 801ae9c:	220f      	movs	r2, #15
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 801ae9e:	2303      	movs	r3, #3
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK){
 801aea0:	4629      	mov	r1, r5
 801aea2:	4668      	mov	r0, sp
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 801aea4:	e9cd 4402 	strd	r4, r4, [sp, #8]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 801aea8:	9404      	str	r4, [sp, #16]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 801aeaa:	e9cd 2300 	strd	r2, r3, [sp]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK){
 801aeae:	f7f7 fa6d 	bl	801238c <HAL_RCC_ClockConfig>
 801aeb2:	b100      	cbz	r0, 801aeb6 <SystemClock_Config+0x9a>
 801aeb4:	e7fe      	b.n	801aeb4 <SystemClock_Config+0x98>
}
 801aeb6:	b038      	add	sp, #224	; 0xe0
 801aeb8:	bd70      	pop	{r4, r5, r6, pc}
 801aeba:	bf00      	nop

0801aebc <main>:
{
 801aebc:	b500      	push	{lr}
 801aebe:	b089      	sub	sp, #36	; 0x24
  HAL_Init();
 801aec0:	f7f5 fb00 	bl	80104c4 <HAL_Init>
  SystemClock_Config();
 801aec4:	f7ff ffaa 	bl	801ae1c <SystemClock_Config>
  initPowerController();
 801aec8:	f7ff faa8 	bl	801a41c <initPowerController>
  InitTargetPlatform(TARGET_SENSORTILE);
 801aecc:	2002      	movs	r0, #2
 801aece:	f7ff fb9d 	bl	801a60c <InitTargetPlatform>
  MDM_ReCallGMD(GMD_NODE_NAME,(void *)&NodeName);
 801aed2:	4c53      	ldr	r4, [pc, #332]	; (801b020 <main+0x164>)
 InitMetaDataManager((void *)&known_MetaData,MDM_DATA_TYPE_GMD,NULL);
 801aed4:	4853      	ldr	r0, [pc, #332]	; (801b024 <main+0x168>)
 801aed6:	2200      	movs	r2, #0
 801aed8:	2101      	movs	r1, #1
 801aeda:	f7fd f9bf 	bl	801825c <InitMetaDataManager>
  const char DefaultBoardName[7] = {NAME_BLUEMS};
 801aede:	4b52      	ldr	r3, [pc, #328]	; (801b028 <main+0x16c>)
 801aee0:	9306      	str	r3, [sp, #24]
 801aee2:	f243 0231 	movw	r2, #12337	; 0x3031
 801aee6:	2330      	movs	r3, #48	; 0x30
  MDM_ReCallGMD(GMD_NODE_NAME,(void *)&NodeName);
 801aee8:	4621      	mov	r1, r4
 801aeea:	2007      	movs	r0, #7
  const char DefaultBoardName[7] = {NAME_BLUEMS};
 801aeec:	f88d 301e 	strb.w	r3, [sp, #30]
 801aef0:	f8ad 201c 	strh.w	r2, [sp, #28]
  MDM_ReCallGMD(GMD_NODE_NAME,(void *)&NodeName);
 801aef4:	f7fd fc2c 	bl	8018750 <MDM_ReCallGMD>
  if(NodeName[0] != 0x12) {
 801aef8:	7823      	ldrb	r3, [r4, #0]
 801aefa:	2b12      	cmp	r3, #18
 801aefc:	d07b      	beq.n	801aff6 <main+0x13a>
    NodeName[0]= 0x12;
 801aefe:	4623      	mov	r3, r4
 801af00:	2212      	movs	r2, #18
 801af02:	f803 2b01 	strb.w	r2, [r3], #1
 801af06:	2254      	movs	r2, #84	; 0x54
      NodeName[i+1]= DefaultBoardName[i];
 801af08:	f803 2b01 	strb.w	r2, [r3], #1
 801af0c:	3408      	adds	r4, #8
    for(int i=0; i<7; i++) {
 801af0e:	42a3      	cmp	r3, r4
 801af10:	f10d 0119 	add.w	r1, sp, #25
 801af14:	d005      	beq.n	801af22 <main+0x66>
 801af16:	f811 2b01 	ldrb.w	r2, [r1], #1
      NodeName[i+1]= DefaultBoardName[i];
 801af1a:	f803 2b01 	strb.w	r2, [r3], #1
    for(int i=0; i<7; i++) {
 801af1e:	42a3      	cmp	r3, r4
 801af20:	d1f9      	bne.n	801af16 <main+0x5a>
    MDM_SaveGMD(GMD_NODE_NAME,(void *)&NodeName);
 801af22:	493f      	ldr	r1, [pc, #252]	; (801b020 <main+0x164>)
 801af24:	2007      	movs	r0, #7
 801af26:	f7fd fbfd 	bl	8018724 <MDM_SaveGMD>
    NecessityToSaveMetaDataManager=1;
 801af2a:	4b40      	ldr	r3, [pc, #256]	; (801b02c <main+0x170>)
 801af2c:	2201      	movs	r2, #1
 801af2e:	601a      	str	r2, [r3, #0]
 801af30:	4b3f      	ldr	r3, [pc, #252]	; (801b030 <main+0x174>)
 801af32:	f10d 0217 	add.w	r2, sp, #23
    BoardName[i]= NodeName[i+1];
 801af36:	f813 1b01 	ldrb.w	r1, [r3], #1
 801af3a:	f802 1f01 	strb.w	r1, [r2, #1]!
  for(int i=0; i<7; i++) {
 801af3e:	42a3      	cmp	r3, r4
 801af40:	d1f9      	bne.n	801af36 <main+0x7a>
  BoardName[7]= 0;
 801af42:	2300      	movs	r3, #0
 801af44:	f88d 301f 	strb.w	r3, [sp, #31]
  BNRG_SPI_Init();
 801af48:	f002 fed6 	bl	801dcf8 <BNRG_SPI_Init>
  HCI_Init();
 801af4c:	f003 fbe0 	bl	801e710 <HCI_Init>
  BlueNRG_RST();
 801af50:	f002 fef2 	bl	801dd38 <BlueNRG_RST>
    bdaddr[0] = (STM32_UUID[1]>>24)&0xFF;
 801af54:	4b37      	ldr	r3, [pc, #220]	; (801b034 <main+0x178>)
 801af56:	4c38      	ldr	r4, [pc, #224]	; (801b038 <main+0x17c>)
 801af58:	78db      	ldrb	r3, [r3, #3]
    bdaddr[1] = (STM32_UUID[0]    )&0xFF;
 801af5a:	4a38      	ldr	r2, [pc, #224]	; (801b03c <main+0x180>)
    bdaddr[0] = (STM32_UUID[1]>>24)&0xFF;
 801af5c:	7023      	strb	r3, [r4, #0]
    bdaddr[1] = (STM32_UUID[0]    )&0xFF;
 801af5e:	6811      	ldr	r1, [r2, #0]
    bdaddr[2] = (STM32_UUID[2] >>8)&0xFF;
 801af60:	4b37      	ldr	r3, [pc, #220]	; (801b040 <main+0x184>)
    bdaddr[1] = (STM32_UUID[0]    )&0xFF;
 801af62:	7061      	strb	r1, [r4, #1]
    bdaddr[2] = (STM32_UUID[2] >>8)&0xFF;
 801af64:	681b      	ldr	r3, [r3, #0]
    bdaddr[3] = (STM32_UUID[0]>>16)&0xFF;
 801af66:	8852      	ldrh	r2, [r2, #2]
 801af68:	70e2      	strb	r2, [r4, #3]
    bdaddr[4] = (((SENSING1_VERSION_MAJOR-48)*10) + (SENSING1_VERSION_MINOR-48)+100)&0xFF;
 801af6a:	216e      	movs	r1, #110	; 0x6e
    bdaddr[2] = (STM32_UUID[2] >>8)&0xFF;
 801af6c:	0a1b      	lsrs	r3, r3, #8
    bdaddr[5] = 0xC0; /* for a Legal BLE Random MAC */
 801af6e:	22c0      	movs	r2, #192	; 0xc0
    bdaddr[4] = (((SENSING1_VERSION_MAJOR-48)*10) + (SENSING1_VERSION_MINOR-48)+100)&0xFF;
 801af70:	7121      	strb	r1, [r4, #4]
    bdaddr[2] = (STM32_UUID[2] >>8)&0xFF;
 801af72:	70a3      	strb	r3, [r4, #2]
    bdaddr[5] = 0xC0; /* for a Legal BLE Random MAC */
 801af74:	7162      	strb	r2, [r4, #5]
  ret = aci_gatt_init();
 801af76:	f7fd fbff 	bl	8018778 <aci_gatt_init>
  if(ret){
 801af7a:	4601      	mov	r1, r0
 801af7c:	b1e0      	cbz	r0, 801afb8 <main+0xfc>
  ret = Add_HW_SW_ServW2ST_Service();
 801af7e:	f001 f8f3 	bl	801c168 <Add_HW_SW_ServW2ST_Service>
  ret = Add_ConsoleW2ST_Service();
 801af82:	f000 fecb 	bl	801bd1c <Add_ConsoleW2ST_Service>
  ret = Add_ConfigW2ST_Service();
 801af86:	f000 fe8d 	bl	801bca4 <Add_ConfigW2ST_Service>
  osThreadCreate(osThread(THREAD_1), NULL);
 801af8a:	2100      	movs	r1, #0
 801af8c:	482d      	ldr	r0, [pc, #180]	; (801b044 <main+0x188>)
 801af8e:	f7fb f937 	bl	8016200 <osThreadCreate>
  osThreadCreate(osThread(THREAD_2), NULL);
 801af92:	2100      	movs	r1, #0
 801af94:	482c      	ldr	r0, [pc, #176]	; (801b048 <main+0x18c>)
 801af96:	f7fb f933 	bl	8016200 <osThreadCreate>
  semRun = osSemaphoreCreate(osSemaphore(SEM_Sm1), 1);
 801af9a:	2101      	movs	r1, #1
 801af9c:	482b      	ldr	r0, [pc, #172]	; (801b04c <main+0x190>)
 801af9e:	f7fb f9fb 	bl	8016398 <osSemaphoreCreate>
 801afa2:	4b2b      	ldr	r3, [pc, #172]	; (801b050 <main+0x194>)
  mail = osMailCreate(osMailQ(mail), NULL);
 801afa4:	2100      	movs	r1, #0
  semRun = osSemaphoreCreate(osSemaphore(SEM_Sm1), 1);
 801afa6:	6018      	str	r0, [r3, #0]
  mail = osMailCreate(osMailQ(mail), NULL);
 801afa8:	482a      	ldr	r0, [pc, #168]	; (801b054 <main+0x198>)
 801afaa:	f7fb fabb 	bl	8016524 <osMailCreate>
 801afae:	4b2a      	ldr	r3, [pc, #168]	; (801b058 <main+0x19c>)
 801afb0:	6018      	str	r0, [r3, #0]
  osKernelStart();
 801afb2:	f7fb f91f 	bl	80161f4 <osKernelStart>
 801afb6:	e7fe      	b.n	801afb6 <main+0xfa>
  ret = aci_gap_init_IDB05A1(GAP_PERIPHERAL_ROLE_IDB05A1, 0, 0x07, &service_handle, &dev_name_char_handle, &appearance_char_handle);
 801afb8:	f10d 0216 	add.w	r2, sp, #22
 801afbc:	ab05      	add	r3, sp, #20
 801afbe:	e9cd 3200 	strd	r3, r2, [sp]
 801afc2:	2001      	movs	r0, #1
 801afc4:	f10d 0312 	add.w	r3, sp, #18
 801afc8:	2207      	movs	r2, #7
 801afca:	f003 fa53 	bl	801e474 <aci_gap_init_IDB05A1>
  if(ret != BLE_STATUS_SUCCESS){
 801afce:	2800      	cmp	r0, #0
 801afd0:	d1d5      	bne.n	801af7e <main+0xc2>
    ret = hci_le_set_random_address(bdaddr);
 801afd2:	4620      	mov	r0, r4
 801afd4:	f7fd fd86 	bl	8018ae4 <hci_le_set_random_address>
    if(ret){
 801afd8:	4602      	mov	r2, r0
 801afda:	2800      	cmp	r0, #0
 801afdc:	d1cf      	bne.n	801af7e <main+0xc2>
  ret = aci_gatt_update_char_value(service_handle, dev_name_char_handle, 0,
 801afde:	ab06      	add	r3, sp, #24
 801afe0:	9300      	str	r3, [sp, #0]
 801afe2:	f8bd 1014 	ldrh.w	r1, [sp, #20]
 801afe6:	f8bd 0012 	ldrh.w	r0, [sp, #18]
 801afea:	2307      	movs	r3, #7
 801afec:	f7fd fcb4 	bl	8018958 <aci_gatt_update_char_value>
  if(ret){
 801aff0:	4602      	mov	r2, r0
 801aff2:	b110      	cbz	r0, 801affa <main+0x13e>
 801aff4:	e7fe      	b.n	801aff4 <main+0x138>
 801aff6:	3408      	adds	r4, #8
 801aff8:	e79a      	b.n	801af30 <main+0x74>
  ret = aci_gap_set_auth_requirement(MITM_PROTECTION_REQUIRED,
 801affa:	2401      	movs	r4, #1
 801affc:	4917      	ldr	r1, [pc, #92]	; (801b05c <main+0x1a0>)
 801affe:	9001      	str	r0, [sp, #4]
 801b000:	2310      	movs	r3, #16
 801b002:	9102      	str	r1, [sp, #8]
 801b004:	9300      	str	r3, [sp, #0]
 801b006:	9403      	str	r4, [sp, #12]
 801b008:	4620      	mov	r0, r4
 801b00a:	2307      	movs	r3, #7
 801b00c:	4611      	mov	r1, r2
 801b00e:	f003 fad9 	bl	801e5c4 <aci_gap_set_auth_requirement>
  if (ret != BLE_STATUS_SUCCESS) {
 801b012:	2800      	cmp	r0, #0
 801b014:	d1b3      	bne.n	801af7e <main+0xc2>
  aci_hal_set_tx_power_level(1,4); /* -2,1 dBm */
 801b016:	4620      	mov	r0, r4
 801b018:	2104      	movs	r1, #4
 801b01a:	f003 fb3f 	bl	801e69c <aci_hal_set_tx_power_level>
 801b01e:	e7ae      	b.n	801af7e <main+0xc2>
 801b020:	20012708 	.word	0x20012708
 801b024:	200014b0 	.word	0x200014b0
 801b028:	5f494154 	.word	0x5f494154
 801b02c:	2000e028 	.word	0x2000e028
 801b030:	20012709 	.word	0x20012709
 801b034:	1fff7594 	.word	0x1fff7594
 801b038:	200114d0 	.word	0x200114d0
 801b03c:	1fff7590 	.word	0x1fff7590
 801b040:	1fff7598 	.word	0x1fff7598
 801b044:	08075360 	.word	0x08075360
 801b048:	08075374 	.word	0x08075374
 801b04c:	08075388 	.word	0x08075388
 801b050:	200132a4 	.word	0x200132a4
 801b054:	0807538c 	.word	0x0807538c
 801b058:	20012710 	.word	0x20012710
 801b05c:	0001e240 	.word	0x0001e240

0801b060 <RTC_DataConfig>:
{
 801b060:	b500      	push	{lr}
 801b062:	b083      	sub	sp, #12
  sdatestructure.WeekDay = WeekDay;
 801b064:	f88d 0004 	strb.w	r0, [sp, #4]
  sdatestructure.Date = Date;
 801b068:	f88d 1006 	strb.w	r1, [sp, #6]
  sdatestructure.Month = Month;
 801b06c:	f88d 2005 	strb.w	r2, [sp, #5]
  if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BCD) != HAL_OK)
 801b070:	a901      	add	r1, sp, #4
 801b072:	2201      	movs	r2, #1
 801b074:	4804      	ldr	r0, [pc, #16]	; (801b088 <RTC_DataConfig+0x28>)
  sdatestructure.Year = Year;
 801b076:	f88d 3007 	strb.w	r3, [sp, #7]
  if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BCD) != HAL_OK)
 801b07a:	f7f7 ff4f 	bl	8012f1c <HAL_RTC_SetDate>
 801b07e:	b100      	cbz	r0, 801b082 <RTC_DataConfig+0x22>
 801b080:	e7fe      	b.n	801b080 <RTC_DataConfig+0x20>
}
 801b082:	b003      	add	sp, #12
 801b084:	f85d fb04 	ldr.w	pc, [sp], #4
 801b088:	20013278 	.word	0x20013278

0801b08c <RTC_TimeConfig>:
{
 801b08c:	b500      	push	{lr}
 801b08e:	b087      	sub	sp, #28
  stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
 801b090:	2300      	movs	r3, #0
  stimestructure.Hours = Hours;
 801b092:	f88d 0004 	strb.w	r0, [sp, #4]
  stimestructure.Minutes = Minutes;
 801b096:	f88d 1005 	strb.w	r1, [sp, #5]
  stimestructure.Seconds = Seconds;
 801b09a:	f88d 2006 	strb.w	r2, [sp, #6]
  if(HAL_RTC_SetTime(&RtcHandle,&stimestructure,RTC_FORMAT_BCD) != HAL_OK)
 801b09e:	a901      	add	r1, sp, #4
 801b0a0:	2201      	movs	r2, #1
 801b0a2:	4806      	ldr	r0, [pc, #24]	; (801b0bc <RTC_TimeConfig+0x30>)
  stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
 801b0a4:	f88d 3007 	strb.w	r3, [sp, #7]
  stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
 801b0a8:	e9cd 3304 	strd	r3, r3, [sp, #16]
  if(HAL_RTC_SetTime(&RtcHandle,&stimestructure,RTC_FORMAT_BCD) != HAL_OK)
 801b0ac:	f7f7 fe8a 	bl	8012dc4 <HAL_RTC_SetTime>
 801b0b0:	b100      	cbz	r0, 801b0b4 <RTC_TimeConfig+0x28>
 801b0b2:	e7fe      	b.n	801b0b2 <RTC_TimeConfig+0x26>
}
 801b0b4:	b007      	add	sp, #28
 801b0b6:	f85d fb04 	ldr.w	pc, [sp], #4
 801b0ba:	bf00      	nop
 801b0bc:	20013278 	.word	0x20013278

0801b0c0 <HAL_RTC_AlarmAEventCallback>:
  if(semRun) osSemaphoreRelease(semRun);
 801b0c0:	4a04      	ldr	r2, [pc, #16]	; (801b0d4 <HAL_RTC_AlarmAEventCallback+0x14>)
  SD_CardLogging= 1;
 801b0c2:	4b05      	ldr	r3, [pc, #20]	; (801b0d8 <HAL_RTC_AlarmAEventCallback+0x18>)
  if(semRun) osSemaphoreRelease(semRun);
 801b0c4:	6810      	ldr	r0, [r2, #0]
  SD_CardLogging= 1;
 801b0c6:	2201      	movs	r2, #1
 801b0c8:	615a      	str	r2, [r3, #20]
  if(semRun) osSemaphoreRelease(semRun);
 801b0ca:	b108      	cbz	r0, 801b0d0 <HAL_RTC_AlarmAEventCallback+0x10>
 801b0cc:	f7fb b9a6 	b.w	801641c <osSemaphoreRelease>
}
 801b0d0:	4770      	bx	lr
 801b0d2:	bf00      	nop
 801b0d4:	200132a4 	.word	0x200132a4
 801b0d8:	2000fff4 	.word	0x2000fff4

0801b0dc <RTC_GetCurrentDateTime>:
{
 801b0dc:	b508      	push	{r3, lr}
  Status = HAL_RTC_GetTime(&RtcHandle, &CurrentTime, RTC_FORMAT_BIN);
 801b0de:	2200      	movs	r2, #0
 801b0e0:	4906      	ldr	r1, [pc, #24]	; (801b0fc <RTC_GetCurrentDateTime+0x20>)
 801b0e2:	4807      	ldr	r0, [pc, #28]	; (801b100 <RTC_GetCurrentDateTime+0x24>)
 801b0e4:	f7f7 fd3c 	bl	8012b60 <HAL_RTC_GetTime>
  if(Status == HAL_OK)  {
 801b0e8:	b100      	cbz	r0, 801b0ec <RTC_GetCurrentDateTime+0x10>
}
 801b0ea:	bd08      	pop	{r3, pc}
 801b0ec:	4602      	mov	r2, r0
    Status = HAL_RTC_GetDate(&RtcHandle, &CurrentDate, RTC_FORMAT_BIN);
 801b0ee:	4905      	ldr	r1, [pc, #20]	; (801b104 <RTC_GetCurrentDateTime+0x28>)
 801b0f0:	4803      	ldr	r0, [pc, #12]	; (801b100 <RTC_GetCurrentDateTime+0x24>)
}
 801b0f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Status = HAL_RTC_GetDate(&RtcHandle, &CurrentDate, RTC_FORMAT_BIN);
 801b0f6:	f7f7 bd69 	b.w	8012bcc <HAL_RTC_GetDate>
 801b0fa:	bf00      	nop
 801b0fc:	20012f24 	.word	0x20012f24
 801b100:	20013278 	.word	0x20013278
 801b104:	20013274 	.word	0x20013274

0801b108 <HAL_Delay>:
{
 801b108:	b510      	push	{r4, lr}
 801b10a:	b082      	sub	sp, #8
 801b10c:	9001      	str	r0, [sp, #4]
  tickstart = HAL_GetTick();
 801b10e:	f7f5 f9ed 	bl	80104ec <HAL_GetTick>
 801b112:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay){
 801b114:	e000      	b.n	801b118 <HAL_Delay+0x10>
 801b116:	bf30      	wfi
 801b118:	f7f5 f9e8 	bl	80104ec <HAL_GetTick>
 801b11c:	9b01      	ldr	r3, [sp, #4]
 801b11e:	1b00      	subs	r0, r0, r4
 801b120:	4298      	cmp	r0, r3
 801b122:	d3f8      	bcc.n	801b116 <HAL_Delay+0xe>
}
 801b124:	b002      	add	sp, #8
 801b126:	bd10      	pop	{r4, pc}

0801b128 <ProcessThread>:
{
 801b128:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b12c:	ed2d 8b08 	vpush	{d8-d11}
 801b130:	4d9e      	ldr	r5, [pc, #632]	; (801b3ac <ProcessThread+0x284>)
 801b132:	f8df 92ac 	ldr.w	r9, [pc, #684]	; 801b3e0 <ProcessThread+0x2b8>
 801b136:	4c9e      	ldr	r4, [pc, #632]	; (801b3b0 <ProcessThread+0x288>)
 801b138:	4e9e      	ldr	r6, [pc, #632]	; (801b3b4 <ProcessThread+0x28c>)
 801b13a:	f8df a2a8 	ldr.w	sl, [pc, #680]	; 801b3e4 <ProcessThread+0x2bc>
        MCR_BLUEMS_F2I_2D(SensorValue, intPart, decPart);
 801b13e:	ed9f ba9e 	vldr	s22, [pc, #632]	; 801b3b8 <ProcessThread+0x290>
    RMS_Ch[NumberMic] /= (16.0f*MICS_DB_UPDATE_MS);
 801b142:	eddf aa9e 	vldr	s21, [pc, #632]	; 801b3bc <ProcessThread+0x294>
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 801b146:	ed9f aa9e 	vldr	s20, [pc, #632]	; 801b3c0 <ProcessThread+0x298>
 801b14a:	eddf 9a9e 	vldr	s19, [pc, #632]	; 801b3c4 <ProcessThread+0x29c>
{
 801b14e:	b0a3      	sub	sp, #140	; 0x8c
 801b150:	f10d 082c 	add.w	r8, sp, #44	; 0x2c
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 801b154:	ed9f 9a9c 	vldr	s18, [pc, #624]	; 801b3c8 <ProcessThread+0x2a0>
 801b158:	eddf 8a9c 	vldr	s17, [pc, #624]	; 801b3cc <ProcessThread+0x2a4>
  if (semRun != NULL){
 801b15c:	6828      	ldr	r0, [r5, #0]
 801b15e:	b900      	cbnz	r0, 801b162 <ProcessThread+0x3a>
 801b160:	e7fe      	b.n	801b160 <ProcessThread+0x38>
    if(osSemaphoreWait(semRun, osWaitForever) == osOK) {
 801b162:	f04f 31ff 	mov.w	r1, #4294967295
 801b166:	f7fb f92b 	bl	80163c0 <osSemaphoreWait>
 801b16a:	4607      	mov	r7, r0
 801b16c:	2800      	cmp	r0, #0
 801b16e:	d1f5      	bne.n	801b15c <ProcessThread+0x34>
      if(set_connectable){
 801b170:	f899 3000 	ldrb.w	r3, [r9]
 801b174:	b16b      	cbz	r3, 801b192 <ProcessThread+0x6a>
        if(NecessityToSaveMetaDataManager) {
 801b176:	4b96      	ldr	r3, [pc, #600]	; (801b3d0 <ProcessThread+0x2a8>)
 801b178:	681b      	ldr	r3, [r3, #0]
 801b17a:	2b00      	cmp	r3, #0
 801b17c:	f040 81e2 	bne.w	801b544 <ProcessThread+0x41c>
        msg.type  = SET_CONNECTABLE ;
 801b180:	f04f 0b00 	mov.w	fp, #0
        SendMsgToHost(&msg);
 801b184:	a80e      	add	r0, sp, #56	; 0x38
        msg.type  = SET_CONNECTABLE ;
 801b186:	f88d b038 	strb.w	fp, [sp, #56]	; 0x38
        SendMsgToHost(&msg);
 801b18a:	f7ff fc6d 	bl	801aa68 <SendMsgToHost>
        set_connectable =0;
 801b18e:	f889 b000 	strb.w	fp, [r9]
      if(MEMSInterrupt) {
 801b192:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 801b194:	2b00      	cmp	r3, #0
 801b196:	f040 816f 	bne.w	801b478 <ProcessThread+0x350>
      if(ButtonPressed) {
 801b19a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801b19c:	b10b      	cbz	r3, 801b1a2 <ProcessThread+0x7a>
        ButtonPressed=0;
 801b19e:	2300      	movs	r3, #0
 801b1a0:	6323      	str	r3, [r4, #48]	; 0x30
      if(SendEnv) {
 801b1a2:	6823      	ldr	r3, [r4, #0]
 801b1a4:	2b00      	cmp	r3, #0
 801b1a6:	f040 811f 	bne.w	801b3e8 <ProcessThread+0x2c0>
      if (SendAudioLevel) {
 801b1aa:	68e3      	ldr	r3, [r4, #12]
 801b1ac:	2b00      	cmp	r3, #0
 801b1ae:	f040 80b5 	bne.w	801b31c <ProcessThread+0x1f4>
      if(SendAccGyroMag) {
 801b1b2:	68a3      	ldr	r3, [r4, #8]
 801b1b4:	2b00      	cmp	r3, #0
 801b1b6:	f040 808b 	bne.w	801b2d0 <ProcessThread+0x1a8>
      if(UpdateMotionAR) {
 801b1ba:	6923      	ldr	r3, [r4, #16]
 801b1bc:	2b00      	cmp	r3, #0
 801b1be:	d139      	bne.n	801b234 <ProcessThread+0x10c>
      if(SD_CardLogging) {
 801b1c0:	6963      	ldr	r3, [r4, #20]
 801b1c2:	2b00      	cmp	r3, #0
 801b1c4:	d130      	bne.n	801b228 <ProcessThread+0x100>
      if(writeAudio_flag) {
 801b1c6:	f89a 3000 	ldrb.w	r3, [sl]
 801b1ca:	bb3b      	cbnz	r3, 801b21c <ProcessThread+0xf4>
      if(SendBatteryInfo) {
 801b1cc:	6863      	ldr	r3, [r4, #4]
 801b1ce:	2b00      	cmp	r3, #0
 801b1d0:	d0c4      	beq.n	801b15c <ProcessThread+0x34>
        SendBatteryInfo=0;
 801b1d2:	2300      	movs	r3, #0
  BSP_GG_Task(TargetBoardFeatures.HandleGGComponent,&v_mode);
 801b1d4:	f10d 0113 	add.w	r1, sp, #19
 801b1d8:	6bb0      	ldr	r0, [r6, #56]	; 0x38
        SendBatteryInfo=0;
 801b1da:	6063      	str	r3, [r4, #4]
  int32_t current= 0;
 801b1dc:	9308      	str	r3, [sp, #32]
  BSP_GG_Task(TargetBoardFeatures.HandleGGComponent,&v_mode);
 801b1de:	f7f4 fd05 	bl	800fbec <BSP_GG_Task>
  BSP_GG_GetVoltage(TargetBoardFeatures.HandleGGComponent, &voltage);
 801b1e2:	4641      	mov	r1, r8
 801b1e4:	6bb0      	ldr	r0, [r6, #56]	; 0x38
 801b1e6:	f7f4 fd19 	bl	800fc1c <BSP_GG_GetVoltage>
  BSP_GG_GetCurrent(TargetBoardFeatures.HandleGGComponent, &current);
 801b1ea:	a908      	add	r1, sp, #32
 801b1ec:	6bb0      	ldr	r0, [r6, #56]	; 0x38
 801b1ee:	f7f4 fd0d 	bl	800fc0c <BSP_GG_GetCurrent>
  BSP_GG_GetSOC(TargetBoardFeatures.HandleGGComponent, &soc);
 801b1f2:	a905      	add	r1, sp, #20
 801b1f4:	6bb0      	ldr	r0, [r6, #56]	; 0x38
 801b1f6:	f7f4 fd01 	bl	800fbfc <BSP_GG_GetSOC>
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_GG_EVENT)) {
 801b1fa:	4b76      	ldr	r3, [pc, #472]	; (801b3d4 <ProcessThread+0x2ac>)
 801b1fc:	681b      	ldr	r3, [r3, #0]
 801b1fe:	05d9      	lsls	r1, r3, #23
 801b200:	d5a8      	bpl.n	801b154 <ProcessThread+0x2c>
    msg.batteryInfo.soc      = soc;
 801b202:	9b05      	ldr	r3, [sp, #20]
 801b204:	9319      	str	r3, [sp, #100]	; 0x64
    msg.type                 = BATTERY_INFO;
 801b206:	220c      	movs	r2, #12
 801b208:	f88d 2060 	strb.w	r2, [sp, #96]	; 0x60
    msg.batteryInfo.voltage  = voltage;
 801b20c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    msg.batteryInfo.current  = current;
 801b20e:	9a08      	ldr	r2, [sp, #32]
 801b210:	921b      	str	r2, [sp, #108]	; 0x6c
    SendMsgToHost(&msg);
 801b212:	a818      	add	r0, sp, #96	; 0x60
    msg.batteryInfo.voltage  = voltage;
 801b214:	931a      	str	r3, [sp, #104]	; 0x68
    SendMsgToHost(&msg);
 801b216:	f7ff fc27 	bl	801aa68 <SendMsgToHost>
 801b21a:	e79b      	b.n	801b154 <ProcessThread+0x2c>
        writeAudio_flag=0;
 801b21c:	2300      	movs	r3, #0
 801b21e:	f88a 3000 	strb.w	r3, [sl]
        SdCardAudioRecordingRun();
 801b222:	f7fe fd9b 	bl	8019d5c <SdCardAudioRecordingRun>
 801b226:	e7d1      	b.n	801b1cc <ProcessThread+0xa4>
        SD_CardLogging=0;
 801b228:	2300      	movs	r3, #0
        SdCardMemsRecordingRun(0);
 801b22a:	4618      	mov	r0, r3
        SD_CardLogging=0;
 801b22c:	6163      	str	r3, [r4, #20]
        SdCardMemsRecordingRun(0);
 801b22e:	f7fe fc33 	bl	8019a98 <SdCardMemsRecordingRun>
 801b232:	e7c8      	b.n	801b1c6 <ProcessThread+0x9e>
        UpdateMotionAR=0;
 801b234:	2300      	movs	r3, #0
  BSP_ACCELERO_Get_Axes(TargetBoardFeatures.HandleAccSensor, &Acceleration);
 801b236:	a908      	add	r1, sp, #32
 801b238:	69b0      	ldr	r0, [r6, #24]
        UpdateMotionAR=0;
 801b23a:	6123      	str	r3, [r4, #16]
  BSP_ACCELERO_Get_Axes(TargetBoardFeatures.HandleAccSensor, &Acceleration);
 801b23c:	f7f3 fc56 	bl	800eaec <BSP_ACCELERO_Get_Axes>
  BSP_GYRO_Get_Axes(TargetBoardFeatures.HandleGyroSensor, &AngularVelocity );
 801b240:	4641      	mov	r1, r8
 801b242:	69f0      	ldr	r0, [r6, #28]
 801b244:	f7f4 fd7a 	bl	800fd3c <BSP_GYRO_Get_Axes>
  ActivityCode =  Gesture_run(Acceleration, AngularVelocity);
 801b248:	ab0c      	add	r3, sp, #48	; 0x30
 801b24a:	e893 0003 	ldmia.w	r3, {r0, r1}
 801b24e:	e88d 0003 	stmia.w	sp, {r0, r1}
 801b252:	aa08      	add	r2, sp, #32
 801b254:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801b256:	ca07      	ldmia	r2, {r0, r1, r2}
 801b258:	f7f8 fcbe 	bl	8013bd8 <Gesture_run>
  if(ActivityCodeStored!=ActivityCode){
 801b25c:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 801b260:	4283      	cmp	r3, r0
  ActivityCode =  Gesture_run(Acceleration, AngularVelocity);
 801b262:	4607      	mov	r7, r0
  if(ActivityCodeStored!=ActivityCode){
 801b264:	d0ac      	beq.n	801b1c0 <ProcessThread+0x98>
    msg.type           = ACTIVITY;
 801b266:	2308      	movs	r3, #8
    SendMsgToHost(&msg);
 801b268:	a818      	add	r0, sp, #96	; 0x60
    msg.type           = ACTIVITY;
 801b26a:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
    ActivityCodeStored = ActivityCode;
 801b26e:	f884 7034 	strb.w	r7, [r4, #52]	; 0x34
    msg.activity       = ActivityCode ;
 801b272:	f88d 7064 	strb.w	r7, [sp, #100]	; 0x64
    SendMsgToHost(&msg);
 801b276:	f7ff fbf7 	bl	801aa68 <SendMsgToHost>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 801b27a:	4b56      	ldr	r3, [pc, #344]	; (801b3d4 <ProcessThread+0x2ac>)
 801b27c:	681b      	ldr	r3, [r3, #0]
 801b27e:	0698      	lsls	r0, r3, #26
 801b280:	f100 817f 	bmi.w	801b582 <ProcessThread+0x45a>
      LedToggleTargetPlatform();
 801b284:	f7ff faba 	bl	801a7fc <LedToggleTargetPlatform>
      HAL_Delay(100);
 801b288:	2064      	movs	r0, #100	; 0x64
 801b28a:	f7ff ff3d 	bl	801b108 <HAL_Delay>
      LedToggleTargetPlatform();
 801b28e:	f7ff fab5 	bl	801a7fc <LedToggleTargetPlatform>
      HAL_Delay(100);
 801b292:	2064      	movs	r0, #100	; 0x64
 801b294:	f7ff ff38 	bl	801b108 <HAL_Delay>
      LedToggleTargetPlatform();
 801b298:	f7ff fab0 	bl	801a7fc <LedToggleTargetPlatform>
      HAL_Delay(100);
 801b29c:	2064      	movs	r0, #100	; 0x64
 801b29e:	f7ff ff33 	bl	801b108 <HAL_Delay>
      LedToggleTargetPlatform();
 801b2a2:	f7ff faab 	bl	801a7fc <LedToggleTargetPlatform>
      HAL_Delay(100);
 801b2a6:	2064      	movs	r0, #100	; 0x64
 801b2a8:	f7ff ff2e 	bl	801b108 <HAL_Delay>
      LedToggleTargetPlatform();
 801b2ac:	f7ff faa6 	bl	801a7fc <LedToggleTargetPlatform>
      HAL_Delay(100);
 801b2b0:	2064      	movs	r0, #100	; 0x64
 801b2b2:	f7ff ff29 	bl	801b108 <HAL_Delay>
      LedToggleTargetPlatform();
 801b2b6:	f7ff faa1 	bl	801a7fc <LedToggleTargetPlatform>
      HAL_Delay(100);
 801b2ba:	2064      	movs	r0, #100	; 0x64
 801b2bc:	f7ff ff24 	bl	801b108 <HAL_Delay>
      LedToggleTargetPlatform();
 801b2c0:	f7ff fa9c 	bl	801a7fc <LedToggleTargetPlatform>
      HAL_Delay(100);
 801b2c4:	2064      	movs	r0, #100	; 0x64
 801b2c6:	f7ff ff1f 	bl	801b108 <HAL_Delay>
      LedToggleTargetPlatform();
 801b2ca:	f7ff fa97 	bl	801a7fc <LedToggleTargetPlatform>
 801b2ce:	e777      	b.n	801b1c0 <ProcessThread+0x98>
        SendAccGyroMag=0;
 801b2d0:	2300      	movs	r3, #0
  BSP_ACCELERO_Get_Axes(TargetBoardFeatures.HandleAccSensor,&ACC_Value);
 801b2d2:	a905      	add	r1, sp, #20
 801b2d4:	69b0      	ldr	r0, [r6, #24]
        SendAccGyroMag=0;
 801b2d6:	60a3      	str	r3, [r4, #8]
  BSP_ACCELERO_Get_Axes(TargetBoardFeatures.HandleAccSensor,&ACC_Value);
 801b2d8:	f7f3 fc08 	bl	800eaec <BSP_ACCELERO_Get_Axes>
  BSP_MAGNETO_Get_Axes(TargetBoardFeatures.HandleMagSensor,&MAG_Value);
 801b2dc:	4641      	mov	r1, r8
 801b2de:	6a30      	ldr	r0, [r6, #32]
 801b2e0:	f7f4 fdd4 	bl	800fe8c <BSP_MAGNETO_Get_Axes>
  BSP_GYRO_Get_Axes(TargetBoardFeatures.HandleGyroSensor,&GYR_Value);
 801b2e4:	a908      	add	r1, sp, #32
 801b2e6:	69f0      	ldr	r0, [r6, #28]
 801b2e8:	f7f4 fd28 	bl	800fd3c <BSP_GYRO_Get_Axes>
  msg.motion.acc  = ACC_Value ;
 801b2ec:	ab05      	add	r3, sp, #20
 801b2ee:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 801b2f2:	ab19      	add	r3, sp, #100	; 0x64
 801b2f4:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  msg.motion.gyr  = GYR_Value;
 801b2f8:	ab08      	add	r3, sp, #32
 801b2fa:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 801b2fe:	ab1c      	add	r3, sp, #112	; 0x70
 801b300:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  msg.motion.mag  = MAG_Value;
 801b304:	e898 0007 	ldmia.w	r8, {r0, r1, r2}
 801b308:	ab1f      	add	r3, sp, #124	; 0x7c
 801b30a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  msg.type    = MOTION;
 801b30e:	2306      	movs	r3, #6
  SendMsgToHost(&msg);
 801b310:	a818      	add	r0, sp, #96	; 0x60
  msg.type    = MOTION;
 801b312:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
  SendMsgToHost(&msg);
 801b316:	f7ff fba7 	bl	801aa68 <SendMsgToHost>
 801b31a:	e74e      	b.n	801b1ba <ProcessThread+0x92>
    RMS_Ch[NumberMic] /= (16.0f*MICS_DB_UPDATE_MS);
 801b31c:	4f2e      	ldr	r7, [pc, #184]	; (801b3d8 <ProcessThread+0x2b0>)
        SendAudioLevel = 0;
 801b31e:	2300      	movs	r3, #0
 801b320:	60e3      	str	r3, [r4, #12]
    RMS_Ch[NumberMic] /= (16.0f*MICS_DB_UPDATE_MS);
 801b322:	edd7 7a00 	vldr	s15, [r7]
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 801b326:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
    RMS_Ch[NumberMic] /= (16.0f*MICS_DB_UPDATE_MS);
 801b328:	ee87 7aaa 	vdiv.f32	s14, s15, s21
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 801b32c:	3b04      	subs	r3, #4
 801b32e:	ee00 3a10 	vmov	s0, r3
 801b332:	eebb 0acf 	vcvt.f32.u32	s0, s0, #2
 801b336:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801b33a:	ee30 0a27 	vadd.f32	s0, s0, s15
    RMS_Ch[NumberMic] /= (16.0f*MICS_DB_UPDATE_MS);
 801b33e:	ed87 7a00 	vstr	s14, [r7]
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 801b342:	ee20 0a0a 	vmul.f32	s0, s0, s20
 801b346:	f006 fa87 	bl	8021858 <log10f>
 801b34a:	eeb0 8a40 	vmov.f32	s16, s0
 801b34e:	ed97 0a00 	vldr	s0, [r7]
 801b352:	f006 fa81 	bl	8021858 <log10f>
 801b356:	eef3 7a04 	vmov.f32	s15, #52	; 0x41a00000  20.0
 801b35a:	ee68 7a27 	vmul.f32	s15, s16, s15
 801b35e:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 801b362:	ee20 0a07 	vmul.f32	s0, s0, s14
 801b366:	4a1d      	ldr	r2, [pc, #116]	; (801b3dc <ProcessThread+0x2b4>)
 801b368:	ee79 7ae7 	vsub.f32	s15, s19, s15
 801b36c:	ed92 7a00 	vldr	s14, [r2]
 801b370:	ee77 7a80 	vadd.f32	s15, s15, s0
 801b374:	ee27 7a28 	vmul.f32	s14, s14, s17
 801b378:	ee67 7a89 	vmul.f32	s15, s15, s18
    RMS_Ch[NumberMic] = 0.0f;
 801b37c:	2300      	movs	r3, #0
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 801b37e:	ee77 7a87 	vadd.f32	s15, s15, s14
    RMS_Ch[NumberMic] = 0.0f;
 801b382:	603b      	str	r3, [r7, #0]
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 801b384:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  msg.type  = AUDIO_LEV;
 801b388:	2309      	movs	r3, #9
 801b38a:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 801b38e:	ee17 3a90 	vmov	r3, s15
 801b392:	b29b      	uxth	r3, r3
    DBNOISE_Value_Old_Ch[NumberMic] = DBNOISE_Value_Ch[NumberMic];
 801b394:	ee07 3a90 	vmov	s15, r3
 801b398:	eef8 7a67 	vcvt.f32.u32	s15, s15
  SendMsgToHost(&msg);
 801b39c:	a818      	add	r0, sp, #96	; 0x60
  memcpy(&(msg.DBNOISE_Value_Ch),&DBNOISE_Value_Ch,AUDIO_CHANNELS* sizeof(uint16_t));
 801b39e:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
    DBNOISE_Value_Old_Ch[NumberMic] = DBNOISE_Value_Ch[NumberMic];
 801b3a2:	edc2 7a00 	vstr	s15, [r2]
  SendMsgToHost(&msg);
 801b3a6:	f7ff fb5f 	bl	801aa68 <SendMsgToHost>
 801b3aa:	e702      	b.n	801b1b2 <ProcessThread+0x8a>
 801b3ac:	200132a4 	.word	0x200132a4
 801b3b0:	2000fff4 	.word	0x2000fff4
 801b3b4:	20011458 	.word	0x20011458
 801b3b8:	42c80000 	.word	0x42c80000
 801b3bc:	44480000 	.word	0x44480000
 801b3c0:	47000000 	.word	0x47000000
 801b3c4:	42f00000 	.word	0x42f00000
 801b3c8:	3e99999a 	.word	0x3e99999a
 801b3cc:	3f333333 	.word	0x3f333333
 801b3d0:	2000e028 	.word	0x2000e028
 801b3d4:	20010030 	.word	0x20010030
 801b3d8:	200114c0 	.word	0x200114c0
 801b3dc:	200114bc 	.word	0x200114bc
 801b3e0:	20001554 	.word	0x20001554
 801b3e4:	2000fd5c 	.word	0x2000fd5c
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV)) {
 801b3e8:	4ba2      	ldr	r3, [pc, #648]	; (801b674 <ProcessThread+0x54c>)
 801b3ea:	681b      	ldr	r3, [r3, #0]
        SendEnv=0;
 801b3ec:	2200      	movs	r2, #0
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV)) {
 801b3ee:	07db      	lsls	r3, r3, #31
        SendEnv=0;
 801b3f0:	6022      	str	r2, [r4, #0]
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV)) {
 801b3f2:	f57f aeda 	bpl.w	801b1aa <ProcessThread+0x82>
    if(TargetBoardFeatures.HandlePressSensor) {
 801b3f6:	6930      	ldr	r0, [r6, #16]
 801b3f8:	b1e8      	cbz	r0, 801b436 <ProcessThread+0x30e>
      if(BSP_PRESSURE_IsInitialized(TargetBoardFeatures.HandlePressSensor,&Status)==COMPONENT_OK) {
 801b3fa:	a908      	add	r1, sp, #32
 801b3fc:	f002 fee0 	bl	801e1c0 <BSP_PRESSURE_IsInitialized>
 801b400:	b9c8      	cbnz	r0, 801b436 <ProcessThread+0x30e>
        BSP_PRESSURE_Get_Press(TargetBoardFeatures.HandlePressSensor,(float *)&SensorValue);
 801b402:	4641      	mov	r1, r8
 801b404:	6930      	ldr	r0, [r6, #16]
 801b406:	f002 fee3 	bl	801e1d0 <BSP_PRESSURE_Get_Press>
        BSP_PRESSURE_Set_One_Shot(TargetBoardFeatures.HandlePressSensor);
 801b40a:	6930      	ldr	r0, [r6, #16]
 801b40c:	f002 fef2 	bl	801e1f4 <BSP_PRESSURE_Set_One_Shot>
        MCR_BLUEMS_F2I_2D(SensorValue, intPart, decPart);
 801b410:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
 801b414:	eefd 6ae7 	vcvt.s32.f32	s13, s15
        PressToSend=intPart*100+decPart;
 801b418:	2364      	movs	r3, #100	; 0x64
        MCR_BLUEMS_F2I_2D(SensorValue, intPart, decPart);
 801b41a:	eeb8 7ae6 	vcvt.f32.s32	s14, s13
        PressToSend=intPart*100+decPart;
 801b41e:	ee16 2a90 	vmov	r2, s13
        MCR_BLUEMS_F2I_2D(SensorValue, intPart, decPart);
 801b422:	ee77 7ac7 	vsub.f32	s15, s15, s14
 801b426:	ee67 7a8b 	vmul.f32	s15, s15, s22
 801b42a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801b42e:	ee17 7a90 	vmov	r7, s15
        PressToSend=intPart*100+decPart;
 801b432:	fb03 7702 	mla	r7, r3, r2, r7
    if(TargetBoardFeatures.HandleHumSensor) {
 801b436:	6970      	ldr	r0, [r6, #20]
 801b438:	b128      	cbz	r0, 801b446 <ProcessThread+0x31e>
      if(BSP_HUMIDITY_IsInitialized(TargetBoardFeatures.HandleHumSensor,&Status)==COMPONENT_OK){
 801b43a:	a908      	add	r1, sp, #32
 801b43c:	f002 fdf2 	bl	801e024 <BSP_HUMIDITY_IsInitialized>
 801b440:	2800      	cmp	r0, #0
 801b442:	f000 80f4 	beq.w	801b62e <ProcessThread+0x506>
    uint16_t HumToSend=0;
 801b446:	f04f 0b00 	mov.w	fp, #0
    if(TargetBoardFeatures.NumTempSensors==2) {
 801b44a:	6873      	ldr	r3, [r6, #4]
 801b44c:	2b02      	cmp	r3, #2
 801b44e:	f000 80dc 	beq.w	801b60a <ProcessThread+0x4e2>
    } else if(TargetBoardFeatures.NumTempSensors==1) {
 801b452:	2b01      	cmp	r3, #1
 801b454:	f000 8118 	beq.w	801b688 <ProcessThread+0x560>
    int16_t Temp2ToSend=0,Temp1ToSend=0;
 801b458:	2300      	movs	r3, #0
 801b45a:	461a      	mov	r2, r3
    msg.type      = ENV;
 801b45c:	2105      	movs	r1, #5
    SendMsgToHost(&msg);
 801b45e:	a818      	add	r0, sp, #96	; 0x60
    msg.env.press = PressToSend;
 801b460:	9719      	str	r7, [sp, #100]	; 0x64
    msg.env.hum   = HumToSend;
 801b462:	f8ad b068 	strh.w	fp, [sp, #104]	; 0x68
    msg.env.temp2 = Temp2ToSend;
 801b466:	f8ad 206a 	strh.w	r2, [sp, #106]	; 0x6a
    msg.env.temp1 = Temp1ToSend;
 801b46a:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    msg.type      = ENV;
 801b46e:	f88d 1060 	strb.w	r1, [sp, #96]	; 0x60
    SendMsgToHost(&msg);
 801b472:	f7ff faf9 	bl	801aa68 <SendMsgToHost>
 801b476:	e698      	b.n	801b1aa <ProcessThread+0x82>
  BSP_ACCELERO_Get_Event_Status_Ext(TargetBoardFeatures.HandleAccSensor,&status);
 801b478:	4641      	mov	r1, r8
 801b47a:	69b0      	ldr	r0, [r6, #24]
 801b47c:	f7f3 fd20 	bl	800eec0 <BSP_ACCELERO_Get_Event_Status_Ext>
  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_PEDOMETER)) ||
 801b480:	4b7d      	ldr	r3, [pc, #500]	; (801b678 <ProcessThread+0x550>)
 801b482:	681b      	ldr	r3, [r3, #0]
 801b484:	07da      	lsls	r2, r3, #31
 801b486:	d401      	bmi.n	801b48c <ProcessThread+0x364>
 801b488:	0618      	lsls	r0, r3, #24
 801b48a:	d504      	bpl.n	801b496 <ProcessThread+0x36e>
    if(status.StepStatus != 0) {
 801b48c:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
 801b490:	06d1      	lsls	r1, r2, #27
 801b492:	f100 809b 	bmi.w	801b5cc <ProcessThread+0x4a4>
  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_FREE_FALL)) ||
 801b496:	0798      	lsls	r0, r3, #30
 801b498:	d401      	bmi.n	801b49e <ProcessThread+0x376>
 801b49a:	0619      	lsls	r1, r3, #24
 801b49c:	d503      	bpl.n	801b4a6 <ProcessThread+0x37e>
    if(status.FreeFallStatus != 0) {
 801b49e:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
 801b4a2:	07d2      	lsls	r2, r2, #31
 801b4a4:	d47a      	bmi.n	801b59c <ProcessThread+0x474>
  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_SINGLE_TAP)) ||
 801b4a6:	0718      	lsls	r0, r3, #28
 801b4a8:	d41d      	bmi.n	801b4e6 <ProcessThread+0x3be>
 801b4aa:	0619      	lsls	r1, r3, #24
 801b4ac:	d41b      	bmi.n	801b4e6 <ProcessThread+0x3be>
  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_DOUBLE_TAP)) ||
 801b4ae:	0759      	lsls	r1, r3, #29
 801b4b0:	d422      	bmi.n	801b4f8 <ProcessThread+0x3d0>
  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_TILT)) ||
 801b4b2:	069a      	lsls	r2, r3, #26
 801b4b4:	d428      	bmi.n	801b508 <ProcessThread+0x3e0>
  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_6DORIENTATION)) ||
 801b4b6:	065a      	lsls	r2, r3, #25
 801b4b8:	d430      	bmi.n	801b51c <ProcessThread+0x3f4>
  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_WAKE_UP)) {
 801b4ba:	06d8      	lsls	r0, r3, #27
 801b4bc:	d510      	bpl.n	801b4e0 <ProcessThread+0x3b8>
    if(status.WakeUpStatus != 0) {
 801b4be:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 801b4c2:	0719      	lsls	r1, r3, #28
 801b4c4:	d434      	bmi.n	801b530 <ProcessThread+0x408>
 801b4c6:	4b6c      	ldr	r3, [pc, #432]	; (801b678 <ProcessThread+0x550>)
 801b4c8:	681b      	ldr	r3, [r3, #0]
  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_MULTIPLE_EVENTS))
 801b4ca:	061a      	lsls	r2, r3, #24
 801b4cc:	d508      	bpl.n	801b4e0 <ProcessThread+0x3b8>
    AccStepEvent_Msg(PedometerStepCount);
 801b4ce:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
  msg.stepCnt = stepCnt;
 801b4d0:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
  SendMsgToHost(&msg);
 801b4d4:	a818      	add	r0, sp, #96	; 0x60
  msg.type    = ACC_STEP;
 801b4d6:	2304      	movs	r3, #4
 801b4d8:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
  SendMsgToHost(&msg);
 801b4dc:	f7ff fac4 	bl	801aa68 <SendMsgToHost>
        MEMSInterrupt=0;
 801b4e0:	2300      	movs	r3, #0
 801b4e2:	62a3      	str	r3, [r4, #40]	; 0x28
 801b4e4:	e659      	b.n	801b19a <ProcessThread+0x72>
    if(status.TapStatus != 0) {
 801b4e6:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
 801b4ea:	0792      	lsls	r2, r2, #30
 801b4ec:	f100 8081 	bmi.w	801b5f2 <ProcessThread+0x4ca>
  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_DOUBLE_TAP)) ||
 801b4f0:	0758      	lsls	r0, r3, #29
 801b4f2:	d401      	bmi.n	801b4f8 <ProcessThread+0x3d0>
 801b4f4:	0619      	lsls	r1, r3, #24
 801b4f6:	d5dc      	bpl.n	801b4b2 <ProcessThread+0x38a>
    if(status.DoubleTapStatus != 0) {
 801b4f8:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
 801b4fc:	0752      	lsls	r2, r2, #29
 801b4fe:	d459      	bmi.n	801b5b4 <ProcessThread+0x48c>
  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_TILT)) ||
 801b500:	0698      	lsls	r0, r3, #26
 801b502:	d401      	bmi.n	801b508 <ProcessThread+0x3e0>
 801b504:	061a      	lsls	r2, r3, #24
 801b506:	d5d6      	bpl.n	801b4b6 <ProcessThread+0x38e>
    if(status.TiltStatus != 0) {
 801b508:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 801b50c:	0699      	lsls	r1, r3, #26
 801b50e:	d42e      	bmi.n	801b56e <ProcessThread+0x446>
 801b510:	4b59      	ldr	r3, [pc, #356]	; (801b678 <ProcessThread+0x550>)
 801b512:	681b      	ldr	r3, [r3, #0]
  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_6DORIENTATION)) ||
 801b514:	0658      	lsls	r0, r3, #25
 801b516:	d401      	bmi.n	801b51c <ProcessThread+0x3f4>
 801b518:	0619      	lsls	r1, r3, #24
 801b51a:	d5ce      	bpl.n	801b4ba <ProcessThread+0x392>
    if(status.D6DOrientationStatus != 0) {
 801b51c:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
 801b520:	0652      	lsls	r2, r2, #25
 801b522:	d417      	bmi.n	801b554 <ProcessThread+0x42c>
  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_WAKE_UP)) {
 801b524:	06d8      	lsls	r0, r3, #27
 801b526:	d5d0      	bpl.n	801b4ca <ProcessThread+0x3a2>
    if(status.WakeUpStatus != 0) {
 801b528:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 801b52c:	0719      	lsls	r1, r3, #28
 801b52e:	d5ca      	bpl.n	801b4c6 <ProcessThread+0x39e>
  msg.type  = ACC;
 801b530:	2203      	movs	r2, #3
  msg.acc   = Event;
 801b532:	2380      	movs	r3, #128	; 0x80
  SendMsgToHost(&msg);
 801b534:	a818      	add	r0, sp, #96	; 0x60
  msg.type  = ACC;
 801b536:	f88d 2060 	strb.w	r2, [sp, #96]	; 0x60
  msg.acc   = Event;
 801b53a:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
  SendMsgToHost(&msg);
 801b53e:	f7ff fa93 	bl	801aa68 <SendMsgToHost>
 801b542:	e7c0      	b.n	801b4c6 <ProcessThread+0x39e>
          uint32_t Success = EraseMetaDataManager();
 801b544:	f7fd f8da 	bl	80186fc <EraseMetaDataManager>
          if(Success) {
 801b548:	2800      	cmp	r0, #0
 801b54a:	f43f ae19 	beq.w	801b180 <ProcessThread+0x58>
            SaveMetaDataManager();
 801b54e:	f7fd f8d7 	bl	8018700 <SaveMetaDataManager>
 801b552:	e615      	b.n	801b180 <ProcessThread+0x58>
      AccEventType Orientation = GetHWOrientation6D();
 801b554:	f7fe fcee 	bl	8019f34 <GetHWOrientation6D>
  msg.type  = ACC;
 801b558:	2303      	movs	r3, #3
  msg.acc   = Event;
 801b55a:	f88d 0064 	strb.w	r0, [sp, #100]	; 0x64
  SendMsgToHost(&msg);
 801b55e:	a818      	add	r0, sp, #96	; 0x60
  msg.type  = ACC;
 801b560:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
  SendMsgToHost(&msg);
 801b564:	f7ff fa80 	bl	801aa68 <SendMsgToHost>
 801b568:	4b43      	ldr	r3, [pc, #268]	; (801b678 <ProcessThread+0x550>)
 801b56a:	681b      	ldr	r3, [r3, #0]
 801b56c:	e7da      	b.n	801b524 <ProcessThread+0x3fc>
  msg.type  = ACC;
 801b56e:	2203      	movs	r2, #3
  msg.acc   = Event;
 801b570:	2308      	movs	r3, #8
  SendMsgToHost(&msg);
 801b572:	a818      	add	r0, sp, #96	; 0x60
  msg.type  = ACC;
 801b574:	f88d 2060 	strb.w	r2, [sp, #96]	; 0x60
  msg.acc   = Event;
 801b578:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
  SendMsgToHost(&msg);
 801b57c:	f7ff fa74 	bl	801aa68 <SendMsgToHost>
 801b580:	e7c6      	b.n	801b510 <ProcessThread+0x3e8>
       BytesToWrite = sprintf((char *)BufferToWrite,"Sending: AR=%d\n",ActivityCode);
 801b582:	463a      	mov	r2, r7
 801b584:	493d      	ldr	r1, [pc, #244]	; (801b67c <ProcessThread+0x554>)
 801b586:	483e      	ldr	r0, [pc, #248]	; (801b680 <ProcessThread+0x558>)
 801b588:	f004 f806 	bl	801f598 <siprintf>
 801b58c:	4a3d      	ldr	r2, [pc, #244]	; (801b684 <ProcessThread+0x55c>)
 801b58e:	4603      	mov	r3, r0
       Term_Update(BufferToWrite,BytesToWrite);
 801b590:	b2c1      	uxtb	r1, r0
 801b592:	483b      	ldr	r0, [pc, #236]	; (801b680 <ProcessThread+0x558>)
       BytesToWrite = sprintf((char *)BufferToWrite,"Sending: AR=%d\n",ActivityCode);
 801b594:	6013      	str	r3, [r2, #0]
       Term_Update(BufferToWrite,BytesToWrite);
 801b596:	f000 fc81 	bl	801be9c <Term_Update>
 801b59a:	e611      	b.n	801b1c0 <ProcessThread+0x98>
  msg.acc   = Event;
 801b59c:	2310      	movs	r3, #16
  msg.type  = ACC;
 801b59e:	2203      	movs	r2, #3
  SendMsgToHost(&msg);
 801b5a0:	a818      	add	r0, sp, #96	; 0x60
  msg.acc   = Event;
 801b5a2:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
  msg.type  = ACC;
 801b5a6:	f88d 2060 	strb.w	r2, [sp, #96]	; 0x60
  SendMsgToHost(&msg);
 801b5aa:	f7ff fa5d 	bl	801aa68 <SendMsgToHost>
 801b5ae:	4b32      	ldr	r3, [pc, #200]	; (801b678 <ProcessThread+0x550>)
 801b5b0:	681b      	ldr	r3, [r3, #0]
 801b5b2:	e778      	b.n	801b4a6 <ProcessThread+0x37e>
  msg.acc   = Event;
 801b5b4:	2340      	movs	r3, #64	; 0x40
  msg.type  = ACC;
 801b5b6:	2203      	movs	r2, #3
  SendMsgToHost(&msg);
 801b5b8:	a818      	add	r0, sp, #96	; 0x60
  msg.acc   = Event;
 801b5ba:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
  msg.type  = ACC;
 801b5be:	f88d 2060 	strb.w	r2, [sp, #96]	; 0x60
  SendMsgToHost(&msg);
 801b5c2:	f7ff fa51 	bl	801aa68 <SendMsgToHost>
 801b5c6:	4b2c      	ldr	r3, [pc, #176]	; (801b678 <ProcessThread+0x550>)
 801b5c8:	681b      	ldr	r3, [r3, #0]
 801b5ca:	e799      	b.n	801b500 <ProcessThread+0x3d8>
      PedometerStepCount = GetStepHWPedometer();
 801b5cc:	f7fe fed0 	bl	801a370 <GetStepHWPedometer>
       if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_PEDOMETER))
 801b5d0:	4b29      	ldr	r3, [pc, #164]	; (801b678 <ProcessThread+0x550>)
      PedometerStepCount = GetStepHWPedometer();
 801b5d2:	85a0      	strh	r0, [r4, #44]	; 0x2c
       if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_PEDOMETER))
 801b5d4:	681b      	ldr	r3, [r3, #0]
 801b5d6:	07da      	lsls	r2, r3, #31
 801b5d8:	f57f af5d 	bpl.w	801b496 <ProcessThread+0x36e>
  msg.type    = ACC_STEP;
 801b5dc:	2304      	movs	r3, #4
  msg.stepCnt = stepCnt;
 801b5de:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
  SendMsgToHost(&msg);
 801b5e2:	a818      	add	r0, sp, #96	; 0x60
  msg.type    = ACC_STEP;
 801b5e4:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
  SendMsgToHost(&msg);
 801b5e8:	f7ff fa3e 	bl	801aa68 <SendMsgToHost>
 801b5ec:	4b22      	ldr	r3, [pc, #136]	; (801b678 <ProcessThread+0x550>)
 801b5ee:	681b      	ldr	r3, [r3, #0]
 801b5f0:	e751      	b.n	801b496 <ProcessThread+0x36e>
  msg.acc   = Event;
 801b5f2:	2320      	movs	r3, #32
  msg.type  = ACC;
 801b5f4:	2203      	movs	r2, #3
  SendMsgToHost(&msg);
 801b5f6:	a818      	add	r0, sp, #96	; 0x60
  msg.acc   = Event;
 801b5f8:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
  msg.type  = ACC;
 801b5fc:	f88d 2060 	strb.w	r2, [sp, #96]	; 0x60
  SendMsgToHost(&msg);
 801b600:	f7ff fa32 	bl	801aa68 <SendMsgToHost>
 801b604:	4b1c      	ldr	r3, [pc, #112]	; (801b678 <ProcessThread+0x550>)
 801b606:	681b      	ldr	r3, [r3, #0]
 801b608:	e772      	b.n	801b4f0 <ProcessThread+0x3c8>
      if(BSP_TEMPERATURE_IsInitialized(TargetBoardFeatures.HandleTempSensors[0],&Status)==COMPONENT_OK){
 801b60a:	a908      	add	r1, sp, #32
 801b60c:	68b0      	ldr	r0, [r6, #8]
 801b60e:	f002 fef1 	bl	801e3f4 <BSP_TEMPERATURE_IsInitialized>
 801b612:	2800      	cmp	r0, #0
 801b614:	f000 8084 	beq.w	801b720 <ProcessThread+0x5f8>
    int16_t Temp2ToSend=0,Temp1ToSend=0;
 801b618:	2300      	movs	r3, #0
      if(BSP_TEMPERATURE_IsInitialized(TargetBoardFeatures.HandleTempSensors[1],&Status)==COMPONENT_OK){
 801b61a:	a908      	add	r1, sp, #32
 801b61c:	68f0      	ldr	r0, [r6, #12]
 801b61e:	9303      	str	r3, [sp, #12]
 801b620:	f002 fee8 	bl	801e3f4 <BSP_TEMPERATURE_IsInitialized>
 801b624:	9b03      	ldr	r3, [sp, #12]
 801b626:	2800      	cmp	r0, #0
 801b628:	d058      	beq.n	801b6dc <ProcessThread+0x5b4>
    int16_t Temp2ToSend=0,Temp1ToSend=0;
 801b62a:	2200      	movs	r2, #0
 801b62c:	e716      	b.n	801b45c <ProcessThread+0x334>
        BSP_HUMIDITY_Get_Hum(TargetBoardFeatures.HandleHumSensor,(float *)&SensorValue);
 801b62e:	4641      	mov	r1, r8
 801b630:	6970      	ldr	r0, [r6, #20]
 801b632:	f002 fcff 	bl	801e034 <BSP_HUMIDITY_Get_Hum>
        BSP_HUMIDITY_Set_One_Shot(TargetBoardFeatures.HandleHumSensor);
 801b636:	6970      	ldr	r0, [r6, #20]
 801b638:	f002 fd0e 	bl	801e058 <BSP_HUMIDITY_Set_One_Shot>
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801b63c:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
 801b640:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 801b644:	ee17 ba10 	vmov	fp, s14
 801b648:	ee06 ba90 	vmov	s13, fp
 801b64c:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 801b650:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 801b654:	ee77 7ae6 	vsub.f32	s15, s15, s13
        HumToSend = intPart*10+decPart;
 801b658:	eb0b 038b 	add.w	r3, fp, fp, lsl #2
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801b65c:	ee67 7a87 	vmul.f32	s15, s15, s14
 801b660:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801b664:	ee17 ba90 	vmov	fp, s15
        HumToSend = intPart*10+decPart;
 801b668:	eb0b 0b43 	add.w	fp, fp, r3, lsl #1
 801b66c:	fa1f fb8b 	uxth.w	fp, fp
 801b670:	e6eb      	b.n	801b44a <ProcessThread+0x322>
 801b672:	bf00      	nop
 801b674:	20010030 	.word	0x20010030
 801b678:	2000ffe4 	.word	0x2000ffe4
 801b67c:	080758c0 	.word	0x080758c0
 801b680:	20013174 	.word	0x20013174
 801b684:	200132a0 	.word	0x200132a0
      if(BSP_TEMPERATURE_IsInitialized(TargetBoardFeatures.HandleTempSensors[0],&Status)==COMPONENT_OK){
 801b688:	a908      	add	r1, sp, #32
 801b68a:	68b0      	ldr	r0, [r6, #8]
 801b68c:	f002 feb2 	bl	801e3f4 <BSP_TEMPERATURE_IsInitialized>
 801b690:	2800      	cmp	r0, #0
 801b692:	f47f aee1 	bne.w	801b458 <ProcessThread+0x330>
        BSP_TEMPERATURE_Get_Temp(TargetBoardFeatures.HandleTempSensors[0],(float *)&SensorValue);
 801b696:	4641      	mov	r1, r8
 801b698:	9003      	str	r0, [sp, #12]
 801b69a:	68b0      	ldr	r0, [r6, #8]
 801b69c:	f002 feb2 	bl	801e404 <BSP_TEMPERATURE_Get_Temp>
        BSP_TEMPERATURE_Set_One_Shot(TargetBoardFeatures.HandleTempSensors[0]);
 801b6a0:	68b0      	ldr	r0, [r6, #8]
 801b6a2:	f002 fec1 	bl	801e428 <BSP_TEMPERATURE_Set_One_Shot>
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801b6a6:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
    int16_t Temp2ToSend=0,Temp1ToSend=0;
 801b6aa:	9a03      	ldr	r2, [sp, #12]
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801b6ac:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 801b6b0:	ee17 3a10 	vmov	r3, s14
 801b6b4:	ee06 3a90 	vmov	s13, r3
 801b6b8:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 801b6bc:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 801b6c0:	ee77 7ae6 	vsub.f32	s15, s15, s13
        Temp1ToSend = intPart*10+decPart;
 801b6c4:	eb03 0183 	add.w	r1, r3, r3, lsl #2
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801b6c8:	ee67 7a87 	vmul.f32	s15, s15, s14
 801b6cc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801b6d0:	ee17 3a90 	vmov	r3, s15
        Temp1ToSend = intPart*10+decPart;
 801b6d4:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 801b6d8:	b21b      	sxth	r3, r3
 801b6da:	e6bf      	b.n	801b45c <ProcessThread+0x334>
        BSP_TEMPERATURE_Get_Temp(TargetBoardFeatures.HandleTempSensors[1],(float *)&SensorValue);
 801b6dc:	4641      	mov	r1, r8
 801b6de:	68f0      	ldr	r0, [r6, #12]
 801b6e0:	f002 fe90 	bl	801e404 <BSP_TEMPERATURE_Get_Temp>
        BSP_TEMPERATURE_Set_One_Shot(TargetBoardFeatures.HandleTempSensors[1]);
 801b6e4:	68f0      	ldr	r0, [r6, #12]
 801b6e6:	f002 fe9f 	bl	801e428 <BSP_TEMPERATURE_Set_One_Shot>
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801b6ea:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
 801b6ee:	9b03      	ldr	r3, [sp, #12]
 801b6f0:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 801b6f4:	ee17 2a10 	vmov	r2, s14
 801b6f8:	ee06 2a90 	vmov	s13, r2
 801b6fc:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 801b700:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 801b704:	ee77 7ae6 	vsub.f32	s15, s15, s13
        Temp2ToSend = intPart*10+decPart;
 801b708:	eb02 0182 	add.w	r1, r2, r2, lsl #2
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801b70c:	ee67 7a87 	vmul.f32	s15, s15, s14
 801b710:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801b714:	ee17 2a90 	vmov	r2, s15
        Temp2ToSend = intPart*10+decPart;
 801b718:	eb02 0241 	add.w	r2, r2, r1, lsl #1
 801b71c:	b212      	sxth	r2, r2
 801b71e:	e69d      	b.n	801b45c <ProcessThread+0x334>
        BSP_TEMPERATURE_Get_Temp(TargetBoardFeatures.HandleTempSensors[0],(float *)&SensorValue);
 801b720:	4641      	mov	r1, r8
 801b722:	68b0      	ldr	r0, [r6, #8]
 801b724:	f002 fe6e 	bl	801e404 <BSP_TEMPERATURE_Get_Temp>
        BSP_TEMPERATURE_Set_One_Shot(TargetBoardFeatures.HandleTempSensors[0]);
 801b728:	68b0      	ldr	r0, [r6, #8]
 801b72a:	f002 fe7d 	bl	801e428 <BSP_TEMPERATURE_Set_One_Shot>
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801b72e:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
 801b732:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 801b736:	ee17 3a10 	vmov	r3, s14
 801b73a:	ee06 3a90 	vmov	s13, r3
 801b73e:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 801b742:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 801b746:	ee77 7ae6 	vsub.f32	s15, s15, s13
        Temp1ToSend = intPart*10+decPart;
 801b74a:	eb03 0283 	add.w	r2, r3, r3, lsl #2
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801b74e:	ee67 7a87 	vmul.f32	s15, s15, s14
 801b752:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801b756:	ee17 3a90 	vmov	r3, s15
        Temp1ToSend = intPart*10+decPart;
 801b75a:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 801b75e:	b21b      	sxth	r3, r3
 801b760:	e75b      	b.n	801b61a <ProcessThread+0x4f2>
 801b762:	bf00      	nop

0801b764 <Error_Handler>:
{
 801b764:	e7fe      	b.n	801b764 <Error_Handler>
 801b766:	bf00      	nop

0801b768 <HAL_GPIO_EXTI_Callback>:
{
 801b768:	b500      	push	{lr}
  switch(GPIO_Pin){
 801b76a:	2804      	cmp	r0, #4
{
 801b76c:	b08b      	sub	sp, #44	; 0x2c
  switch(GPIO_Pin){
 801b76e:	d00c      	beq.n	801b78a <HAL_GPIO_EXTI_Callback+0x22>
 801b770:	2820      	cmp	r0, #32
 801b772:	d107      	bne.n	801b784 <HAL_GPIO_EXTI_Callback+0x1c>
      HCI_Isr();
 801b774:	f002 ffe6 	bl	801e744 <HCI_Isr>
      msg.type  = PROCESS_EVENT;
 801b778:	a80a      	add	r0, sp, #40	; 0x28
 801b77a:	2302      	movs	r3, #2
 801b77c:	f800 3d28 	strb.w	r3, [r0, #-40]!
      SendMsgToHost(&msg);
 801b780:	f7ff f972 	bl	801aa68 <SendMsgToHost>
}
 801b784:	b00b      	add	sp, #44	; 0x2c
 801b786:	f85d fb04 	ldr.w	pc, [sp], #4
    if(semRun) osSemaphoreRelease(semRun);
 801b78a:	4a06      	ldr	r2, [pc, #24]	; (801b7a4 <HAL_GPIO_EXTI_Callback+0x3c>)
    MEMSInterrupt=1;
 801b78c:	4b06      	ldr	r3, [pc, #24]	; (801b7a8 <HAL_GPIO_EXTI_Callback+0x40>)
    if(semRun) osSemaphoreRelease(semRun);
 801b78e:	6810      	ldr	r0, [r2, #0]
    MEMSInterrupt=1;
 801b790:	2201      	movs	r2, #1
 801b792:	629a      	str	r2, [r3, #40]	; 0x28
    if(semRun) osSemaphoreRelease(semRun);
 801b794:	2800      	cmp	r0, #0
 801b796:	d0f5      	beq.n	801b784 <HAL_GPIO_EXTI_Callback+0x1c>
 801b798:	f7fa fe40 	bl	801641c <osSemaphoreRelease>
}
 801b79c:	b00b      	add	sp, #44	; 0x2c
 801b79e:	f85d fb04 	ldr.w	pc, [sp], #4
 801b7a2:	bf00      	nop
 801b7a4:	200132a4 	.word	0x200132a4
 801b7a8:	2000fff4 	.word	0x2000fff4

0801b7ac <LedBlinkStart>:
{
 801b7ac:	b538      	push	{r3, r4, r5, lr}
  ledTimer = LED_TIME_ON;
 801b7ae:	4c0b      	ldr	r4, [pc, #44]	; (801b7dc <LedBlinkStart+0x30>)
  if (!timLedId) {
 801b7b0:	4d0b      	ldr	r5, [pc, #44]	; (801b7e0 <LedBlinkStart+0x34>)
  ledTimer = LED_TIME_ON;
 801b7b2:	2364      	movs	r3, #100	; 0x64
 801b7b4:	61a3      	str	r3, [r4, #24]
  LedOnTargetPlatform();
 801b7b6:	f7ff f819 	bl	801a7ec <LedOnTargetPlatform>
  if (!timLedId) {
 801b7ba:	6828      	ldr	r0, [r5, #0]
 801b7bc:	b120      	cbz	r0, 801b7c8 <LedBlinkStart+0x1c>
    if  (osTimerStart (timLedId, ledTimer) != osOK){
 801b7be:	69a1      	ldr	r1, [r4, #24]
}
 801b7c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    if  (osTimerStart (timLedId, ledTimer) != osOK){
 801b7c4:	f7fa bd50 	b.w	8016268 <osTimerStart>
    timLedId     = osTimerCreate (osTimer(TimerLedHandle),osTimerOnce, NULL);
 801b7c8:	4602      	mov	r2, r0
 801b7ca:	4601      	mov	r1, r0
 801b7cc:	4805      	ldr	r0, [pc, #20]	; (801b7e4 <LedBlinkStart+0x38>)
 801b7ce:	f7fa fd37 	bl	8016240 <osTimerCreate>
 801b7d2:	6028      	str	r0, [r5, #0]
  if (timLedId){
 801b7d4:	2800      	cmp	r0, #0
 801b7d6:	d1f2      	bne.n	801b7be <LedBlinkStart+0x12>
}
 801b7d8:	bd38      	pop	{r3, r4, r5, pc}
 801b7da:	bf00      	nop
 801b7dc:	2000fff4 	.word	0x2000fff4
 801b7e0:	200114c4 	.word	0x200114c4
 801b7e4:	08075398 	.word	0x08075398

0801b7e8 <HostThread>:
{
 801b7e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801b7ec:	4c45      	ldr	r4, [pc, #276]	; (801b904 <HostThread+0x11c>)
 801b7ee:	f8df 8120 	ldr.w	r8, [pc, #288]	; 801b910 <HostThread+0x128>
 801b7f2:	4f45      	ldr	r7, [pc, #276]	; (801b908 <HostThread+0x120>)
 801b7f4:	f8df 911c 	ldr.w	r9, [pc, #284]	; 801b914 <HostThread+0x12c>
 801b7f8:	4e44      	ldr	r6, [pc, #272]	; (801b90c <HostThread+0x124>)
 801b7fa:	b085      	sub	sp, #20
    evt = osMailGet(mail, osWaitForever);        /* wait for mail */
 801b7fc:	f04f 32ff 	mov.w	r2, #4294967295
 801b800:	6821      	ldr	r1, [r4, #0]
 801b802:	a801      	add	r0, sp, #4
 801b804:	f7fa fef6 	bl	80165f4 <osMailGet>
    if (evt.status == osEventMail) {
 801b808:	9b01      	ldr	r3, [sp, #4]
 801b80a:	2b20      	cmp	r3, #32
 801b80c:	d1f6      	bne.n	801b7fc <HostThread+0x14>
      msgPtr = evt.value.p;
 801b80e:	9d02      	ldr	r5, [sp, #8]
      switch(msgPtr->type)
 801b810:	782b      	ldrb	r3, [r5, #0]
 801b812:	2b0f      	cmp	r3, #15
 801b814:	d810      	bhi.n	801b838 <HostThread+0x50>
 801b816:	e8df f003 	tbb	[pc, r3]
 801b81a:	685d      	.short	0x685d
 801b81c:	3d465156 	.word	0x3d465156
 801b820:	292d3135 	.word	0x292d3135
 801b824:	0f191f24 	.word	0x0f191f24
 801b828:	080f      	.short	0x080f
          if (msgPtr->HostLinkType != hostConnection)
 801b82a:	792b      	ldrb	r3, [r5, #4]
 801b82c:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
 801b830:	4293      	cmp	r3, r2
 801b832:	d001      	beq.n	801b838 <HostThread+0x50>
            hostConnection = msgPtr->HostLinkType;
 801b834:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
      osMailFree(mail, msgPtr);                                              /* free memory allocated for mail */
 801b838:	4629      	mov	r1, r5
 801b83a:	6820      	ldr	r0, [r4, #0]
 801b83c:	f7fa ff20 	bl	8016680 <osMailFree>
      if( semRun    ) osSemaphoreRelease(semRun);                            /* check subsequent processing    */
 801b840:	6830      	ldr	r0, [r6, #0]
 801b842:	2800      	cmp	r0, #0
 801b844:	d0da      	beq.n	801b7fc <HostThread+0x14>
 801b846:	f7fa fde9 	bl	801641c <osSemaphoreRelease>
 801b84a:	e7d7      	b.n	801b7fc <HostThread+0x14>
          GG_Update(msgPtr->batteryInfo.soc, msgPtr->batteryInfo.voltage,
 801b84c:	e9d5 1202 	ldrd	r1, r2, [r5, #8]
 801b850:	6868      	ldr	r0, [r5, #4]
 801b852:	f000 ff13 	bl	801c67c <GG_Update>
          break;
 801b856:	e7ef      	b.n	801b838 <HostThread+0x50>
          UpdateTermStdErr(msgPtr->term.data,msgPtr->term.length);
 801b858:	7929      	ldrb	r1, [r5, #4]
 801b85a:	1d68      	adds	r0, r5, #5
 801b85c:	f000 fad2 	bl	801be04 <UpdateTermStdErr>
          break;
 801b860:	e7ea      	b.n	801b838 <HostThread+0x50>
          UpdateTermStdOut(msgPtr->term.data,msgPtr->term.length);
 801b862:	7929      	ldrb	r1, [r5, #4]
 801b864:	1d68      	adds	r0, r5, #5
 801b866:	f000 fab3 	bl	801bdd0 <UpdateTermStdOut>
          break;
 801b86a:	e7e5      	b.n	801b838 <HostThread+0x50>
          AudioLevel_Update(msgPtr->DBNOISE_Value_Ch);
 801b86c:	1d28      	adds	r0, r5, #4
 801b86e:	f000 febb 	bl	801c5e8 <AudioLevel_Update>
          break;
 801b872:	e7e1      	b.n	801b838 <HostThread+0x50>
          ActivityRec_Update(msgPtr->activity);
 801b874:	7928      	ldrb	r0, [r5, #4]
 801b876:	f000 fb43 	bl	801bf00 <ActivityRec_Update>
          break;
 801b87a:	e7dd      	b.n	801b838 <HostThread+0x50>
          AudioSRec_Update(msgPtr->audio_scene);
 801b87c:	7928      	ldrb	r0, [r5, #4]
 801b87e:	f000 fb87 	bl	801bf90 <AudioSRec_Update>
          break;
 801b882:	e7d9      	b.n	801b838 <HostThread+0x50>
          AccGyroMag_Update(&(msgPtr->motion.acc),&(msgPtr->motion.gyr),&(msgPtr->motion.mag));
 801b884:	f105 021c 	add.w	r2, r5, #28
 801b888:	f105 0110 	add.w	r1, r5, #16
 801b88c:	1d28      	adds	r0, r5, #4
 801b88e:	f000 fd83 	bl	801c398 <AccGyroMag_Update>
          break;
 801b892:	e7d1      	b.n	801b838 <HostThread+0x50>
          Environmental_Update(msgPtr->env.press,msgPtr->env.hum,msgPtr->env.temp2, msgPtr->env.temp1);
 801b894:	f9b5 300c 	ldrsh.w	r3, [r5, #12]
 801b898:	f9b5 200a 	ldrsh.w	r2, [r5, #10]
 801b89c:	8929      	ldrh	r1, [r5, #8]
 801b89e:	6868      	ldr	r0, [r5, #4]
 801b8a0:	f000 fe18 	bl	801c4d4 <Environmental_Update>
          break;
 801b8a4:	e7c8      	b.n	801b838 <HostThread+0x50>
          if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_PEDOMETER))
 801b8a6:	f8d9 3000 	ldr.w	r3, [r9]
 801b8aa:	07da      	lsls	r2, r3, #31
 801b8ac:	d423      	bmi.n	801b8f6 <HostThread+0x10e>
          if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_MULTIPLE_EVENTS))
 801b8ae:	061b      	lsls	r3, r3, #24
 801b8b0:	d5c2      	bpl.n	801b838 <HostThread+0x50>
            AccEvent_Notify(msgPtr->stepCnt, 3);
 801b8b2:	2103      	movs	r1, #3
 801b8b4:	88a8      	ldrh	r0, [r5, #4]
 801b8b6:	f000 fbff 	bl	801c0b8 <AccEvent_Notify>
 801b8ba:	e7bd      	b.n	801b838 <HostThread+0x50>
          AccEvent_Notify(msgPtr->acc, 2);
 801b8bc:	2102      	movs	r1, #2
 801b8be:	7928      	ldrb	r0, [r5, #4]
 801b8c0:	f000 fbfa 	bl	801c0b8 <AccEvent_Notify>
          break;
 801b8c4:	e7b8      	b.n	801b838 <HostThread+0x50>
          if (hciProcessEnable)
 801b8c6:	f8d8 3010 	ldr.w	r3, [r8, #16]
 801b8ca:	2b00      	cmp	r3, #0
 801b8cc:	d0b4      	beq.n	801b838 <HostThread+0x50>
            HCI_Process();
 801b8ce:	f002 ff75 	bl	801e7bc <HCI_Process>
 801b8d2:	e7b1      	b.n	801b838 <HostThread+0x50>
          hciProcessEnable = 1 ;
 801b8d4:	2301      	movs	r3, #1
 801b8d6:	f8c8 3010 	str.w	r3, [r8, #16]
          setConnectable();
 801b8da:	f000 ff6f 	bl	801c7bc <setConnectable>
          hostConnection = NOT_CONNECTED;
 801b8de:	2300      	movs	r3, #0
 801b8e0:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
          LedBlinkStart();
 801b8e4:	f7ff ff62 	bl	801b7ac <LedBlinkStart>
          break;
 801b8e8:	e7a6      	b.n	801b838 <HostThread+0x50>
          Config_NotifyBLE(msgPtr->conf.feature,msgPtr->conf.command,msgPtr->conf.data);
 801b8ea:	7a6a      	ldrb	r2, [r5, #9]
 801b8ec:	7a29      	ldrb	r1, [r5, #8]
 801b8ee:	6868      	ldr	r0, [r5, #4]
 801b8f0:	f000 fb8e 	bl	801c010 <Config_NotifyBLE>
          break;
 801b8f4:	e7a0      	b.n	801b838 <HostThread+0x50>
            AccEvent_Notify(msgPtr->stepCnt, 2);
 801b8f6:	2102      	movs	r1, #2
 801b8f8:	88a8      	ldrh	r0, [r5, #4]
 801b8fa:	f000 fbdd 	bl	801c0b8 <AccEvent_Notify>
 801b8fe:	f8d9 3000 	ldr.w	r3, [r9]
 801b902:	e7d4      	b.n	801b8ae <HostThread+0xc6>
 801b904:	20012710 	.word	0x20012710
 801b908:	2000fff4 	.word	0x2000fff4
 801b90c:	200132a4 	.word	0x200132a4
 801b910:	200014b0 	.word	0x200014b0
 801b914:	2000ffe4 	.word	0x2000ffe4

0801b918 <LedBlinkStop>:
{
 801b918:	b510      	push	{r4, lr}
  if (timLedId) {
 801b91a:	4c07      	ldr	r4, [pc, #28]	; (801b938 <LedBlinkStop+0x20>)
  LedOffTargetPlatform();
 801b91c:	f7fe ff6a 	bl	801a7f4 <LedOffTargetPlatform>
  if (timLedId) {
 801b920:	6820      	ldr	r0, [r4, #0]
 801b922:	b140      	cbz	r0, 801b936 <LedBlinkStop+0x1e>
    if  (osTimerStop (timLedId) != osOK){
 801b924:	f7fa fcce 	bl	80162c4 <osTimerStop>
    if (osTimerDelete (timLedId) != osOK)  {
 801b928:	6820      	ldr	r0, [r4, #0]
 801b92a:	f7fa fcf7 	bl	801631c <osTimerDelete>
  ledTimer = (uint32_t)NULL;
 801b92e:	4a03      	ldr	r2, [pc, #12]	; (801b93c <LedBlinkStop+0x24>)
  timLedId = NULL;
 801b930:	2300      	movs	r3, #0
  ledTimer = (uint32_t)NULL;
 801b932:	6193      	str	r3, [r2, #24]
  timLedId = NULL;
 801b934:	6023      	str	r3, [r4, #0]
}
 801b936:	bd10      	pop	{r4, pc}
 801b938:	200114c4 	.word	0x200114c4
 801b93c:	2000fff4 	.word	0x2000fff4

0801b940 <vApplicationStackOverflowHook>:
  CDC_FlushBuff();
}
#endif /* SENSING1_ENABLE_PRINTF */
#endif /* STM32_SENSORTILE */
void vApplicationStackOverflowHook (void)
{
 801b940:	e7fe      	b.n	801b940 <vApplicationStackOverflowHook>
 801b942:	bf00      	nop

0801b944 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 801b944:	b538      	push	{r3, r4, r5, lr}
  Stat = STA_NOINIT;
 801b946:	4c0a      	ldr	r4, [pc, #40]	; (801b970 <SD_initialize+0x2c>)
 801b948:	2501      	movs	r5, #1
 801b94a:	7025      	strb	r5, [r4, #0]
#if !defined(DISABLE_SD_INIT)

  if(BSP_SD_Init() == MSD_OK)
 801b94c:	f7f4 fad2 	bl	800fef4 <BSP_SD_Init>
 801b950:	b108      	cbz	r0, 801b956 <SD_initialize+0x12>
  }

#else
  Stat = SD_CheckStatus(lun);
#endif
  return Stat;
 801b952:	7820      	ldrb	r0, [r4, #0]
}
 801b954:	bd38      	pop	{r3, r4, r5, pc}
  Stat = STA_NOINIT;
 801b956:	7025      	strb	r5, [r4, #0]
  if(BSP_SD_GetCardState() == MSD_OK)
 801b958:	f7f4 fd72 	bl	8010440 <BSP_SD_GetCardState>
 801b95c:	b918      	cbnz	r0, 801b966 <SD_initialize+0x22>
    Stat &= ~STA_NOINIT;
 801b95e:	7823      	ldrb	r3, [r4, #0]
 801b960:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 801b964:	7023      	strb	r3, [r4, #0]
  return Stat;
 801b966:	7823      	ldrb	r3, [r4, #0]
 801b968:	b2db      	uxtb	r3, r3
    Stat = SD_CheckStatus(lun);
 801b96a:	7023      	strb	r3, [r4, #0]
  return Stat;
 801b96c:	7820      	ldrb	r0, [r4, #0]
}
 801b96e:	bd38      	pop	{r3, r4, r5, pc}
 801b970:	20001548 	.word	0x20001548

0801b974 <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
 801b974:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 801b976:	4c06      	ldr	r4, [pc, #24]	; (801b990 <SD_status+0x1c>)
 801b978:	2301      	movs	r3, #1
 801b97a:	7023      	strb	r3, [r4, #0]
  if(BSP_SD_GetCardState() == MSD_OK)
 801b97c:	f7f4 fd60 	bl	8010440 <BSP_SD_GetCardState>
 801b980:	b918      	cbnz	r0, 801b98a <SD_status+0x16>
    Stat &= ~STA_NOINIT;
 801b982:	7823      	ldrb	r3, [r4, #0]
 801b984:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 801b988:	7023      	strb	r3, [r4, #0]
  return Stat;
 801b98a:	7820      	ldrb	r0, [r4, #0]
  return SD_CheckStatus(lun);
}
 801b98c:	bd10      	pop	{r4, pc}
 801b98e:	bf00      	nop
 801b990:	20001548 	.word	0x20001548

0801b994 <SD_read>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 801b994:	b510      	push	{r4, lr}
 801b996:	b082      	sub	sp, #8
  DRESULT res = RES_ERROR;

  if(BSP_SD_ReadBlocks((uint32_t*)buff,
 801b998:	4c08      	ldr	r4, [pc, #32]	; (801b9bc <SD_read+0x28>)
 801b99a:	9300      	str	r3, [sp, #0]
 801b99c:	4608      	mov	r0, r1
 801b99e:	9401      	str	r4, [sp, #4]
 801b9a0:	2300      	movs	r3, #0
 801b9a2:	f7f4 fc85 	bl	80102b0 <BSP_SD_ReadBlocks>
 801b9a6:	b928      	cbnz	r0, 801b9b4 <SD_read+0x20>
                       (uint32_t) (sector),
                       count, SD_TIMEOUT) == MSD_OK)
  {
    /* wait until the read operation is finished */
    while(BSP_SD_GetCardState()!= MSD_OK)
 801b9a8:	f7f4 fd4a 	bl	8010440 <BSP_SD_GetCardState>
 801b9ac:	2800      	cmp	r0, #0
 801b9ae:	d1fb      	bne.n	801b9a8 <SD_read+0x14>
    }
    res = RES_OK;
  }

  return res;
}
 801b9b0:	b002      	add	sp, #8
 801b9b2:	bd10      	pop	{r4, pc}
  DRESULT res = RES_ERROR;
 801b9b4:	2001      	movs	r0, #1
}
 801b9b6:	b002      	add	sp, #8
 801b9b8:	bd10      	pop	{r4, pc}
 801b9ba:	bf00      	nop
 801b9bc:	05f5e100 	.word	0x05f5e100

0801b9c0 <SD_ioctl>:
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  BSP_SD_CardInfo CardInfo;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
 801b9c0:	4b16      	ldr	r3, [pc, #88]	; (801ba1c <SD_ioctl+0x5c>)
 801b9c2:	781b      	ldrb	r3, [r3, #0]
 801b9c4:	07db      	lsls	r3, r3, #31
 801b9c6:	d408      	bmi.n	801b9da <SD_ioctl+0x1a>
{
 801b9c8:	b510      	push	{r4, lr}
 801b9ca:	4614      	mov	r4, r2
 801b9cc:	b096      	sub	sp, #88	; 0x58

  switch (cmd)
 801b9ce:	2903      	cmp	r1, #3
 801b9d0:	d821      	bhi.n	801ba16 <SD_ioctl+0x56>
 801b9d2:	e8df f001 	tbb	[pc, r1]
 801b9d6:	0704      	.short	0x0704
 801b9d8:	170f      	.short	0x170f
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 801b9da:	2003      	movs	r0, #3
  default:
    res = RES_PARERR;
  }

  return res;
}
 801b9dc:	4770      	bx	lr
    res = RES_OK;
 801b9de:	2000      	movs	r0, #0
}
 801b9e0:	b016      	add	sp, #88	; 0x58
 801b9e2:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 801b9e4:	4668      	mov	r0, sp
 801b9e6:	f7f4 fb07 	bl	800fff8 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
 801b9ea:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801b9ec:	6023      	str	r3, [r4, #0]
    res = RES_OK;
 801b9ee:	2000      	movs	r0, #0
}
 801b9f0:	b016      	add	sp, #88	; 0x58
 801b9f2:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 801b9f4:	4668      	mov	r0, sp
 801b9f6:	f7f4 faff 	bl	800fff8 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
 801b9fa:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801b9fc:	8023      	strh	r3, [r4, #0]
    res = RES_OK;
 801b9fe:	2000      	movs	r0, #0
}
 801ba00:	b016      	add	sp, #88	; 0x58
 801ba02:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 801ba04:	4668      	mov	r0, sp
 801ba06:	f7f4 faf7 	bl	800fff8 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
 801ba0a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801ba0c:	2000      	movs	r0, #0
 801ba0e:	0a5b      	lsrs	r3, r3, #9
 801ba10:	6023      	str	r3, [r4, #0]
}
 801ba12:	b016      	add	sp, #88	; 0x58
 801ba14:	bd10      	pop	{r4, pc}
    res = RES_PARERR;
 801ba16:	2004      	movs	r0, #4
}
 801ba18:	b016      	add	sp, #88	; 0x58
 801ba1a:	bd10      	pop	{r4, pc}
 801ba1c:	20001548 	.word	0x20001548

0801ba20 <SD_write>:
{
 801ba20:	b510      	push	{r4, lr}
 801ba22:	b082      	sub	sp, #8
  if(BSP_SD_WriteBlocks((uint32_t*)buff,
 801ba24:	4c08      	ldr	r4, [pc, #32]	; (801ba48 <SD_write+0x28>)
 801ba26:	9300      	str	r3, [sp, #0]
 801ba28:	4608      	mov	r0, r1
 801ba2a:	9401      	str	r4, [sp, #4]
 801ba2c:	2300      	movs	r3, #0
 801ba2e:	f7f4 fc89 	bl	8010344 <BSP_SD_WriteBlocks>
 801ba32:	b928      	cbnz	r0, 801ba40 <SD_write+0x20>
    while(BSP_SD_GetCardState()!= MSD_OK)
 801ba34:	f7f4 fd04 	bl	8010440 <BSP_SD_GetCardState>
 801ba38:	2800      	cmp	r0, #0
 801ba3a:	d1fb      	bne.n	801ba34 <SD_write+0x14>
}
 801ba3c:	b002      	add	sp, #8
 801ba3e:	bd10      	pop	{r4, pc}
  DRESULT res = RES_ERROR;
 801ba40:	2001      	movs	r0, #1
}
 801ba42:	b002      	add	sp, #8
 801ba44:	bd10      	pop	{r4, pc}
 801ba46:	bf00      	nop
 801ba48:	05f5e100 	.word	0x05f5e100

0801ba4c <ConfigCommandParsing.isra.3>:
 * @brief  This function makes the parsing of the Configuration Commands
 * @param uint8_t *att_data attribute data
 * @param uint8_t data_length length of the data
 * @retval uint32_t SendItBack true/false
 */
static uint32_t ConfigCommandParsing(uint8_t * att_data, uint8_t data_length)
 801ba4c:	6803      	ldr	r3, [r0, #0]
  FeatureMask = (att_data[3]) | (att_data[2]<<8) | (att_data[1]<<16) | (att_data[0]<<24);
  uint8_t Command = att_data[4];
  uint8_t Data    = att_data[5];
  uint32_t SendItBack = 1;

  switch (FeatureMask) {
 801ba4e:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 801ba52:	d116      	bne.n	801ba82 <ConfigCommandParsing.isra.3+0x36>
static uint32_t ConfigCommandParsing(uint8_t * att_data, uint8_t data_length)
 801ba54:	b530      	push	{r4, r5, lr}
  uint8_t Data    = att_data[5];
 801ba56:	7945      	ldrb	r5, [r0, #5]
  uint8_t Command = att_data[4];
 801ba58:	7904      	ldrb	r4, [r0, #4]
      Term_Update(BufferToWrite,BytesToWrite);
    } else {
      SENSING1_PRINTF("Conf Sig F=%lx C=%c D=%x\r\n",FeatureMask,Command,Data);
    }
#endif /* SENSING1_DEBUG_CONNECTION */
    if (Data == 1 ) {
 801ba5a:	2d01      	cmp	r5, #1
static uint32_t ConfigCommandParsing(uint8_t * att_data, uint8_t data_length)
 801ba5c:	b08b      	sub	sp, #44	; 0x2c
    if (Data == 1 ) {
 801ba5e:	d012      	beq.n	801ba86 <ConfigCommandParsing.isra.3+0x3a>
      BSP_ACCELERO_Sensor_Enable( TargetBoardFeatures.HandleAccSensor );
    }
    switch(Command) {
 801ba60:	f1a4 0364 	sub.w	r3, r4, #100	; 0x64
 801ba64:	2b13      	cmp	r3, #19
 801ba66:	f200 80af 	bhi.w	801bbc8 <ConfigCommandParsing.isra.3+0x17c>
 801ba6a:	e8df f003 	tbb	[pc, r3]
 801ba6e:	ad94      	.short	0xad94
 801ba70:	adadad84 	.word	0xadadad84
 801ba74:	73adadad 	.word	0x73adadad
 801ba78:	ad5263ad 	.word	0xad5263ad
 801ba7c:	ad3242ad 	.word	0xad3242ad
 801ba80:	21ad      	.short	0x21ad
      BSP_ACCELERO_Sensor_Disable( TargetBoardFeatures.HandleAccSensor );
    }
    break;
  }
  return SendItBack;
}
 801ba82:	2001      	movs	r0, #1
 801ba84:	4770      	bx	lr
      BSP_ACCELERO_Sensor_Enable( TargetBoardFeatures.HandleAccSensor );
 801ba86:	4b85      	ldr	r3, [pc, #532]	; (801bc9c <ConfigCommandParsing.isra.3+0x250>)
 801ba88:	6998      	ldr	r0, [r3, #24]
 801ba8a:	f7f3 f80f 	bl	800eaac <BSP_ACCELERO_Sensor_Enable>
    switch(Command) {
 801ba8e:	f1a4 0364 	sub.w	r3, r4, #100	; 0x64
 801ba92:	2b13      	cmp	r3, #19
 801ba94:	f200 8095 	bhi.w	801bbc2 <ConfigCommandParsing.isra.3+0x176>
 801ba98:	e8df f003 	tbb	[pc, r3]
 801ba9c:	93729381 	.word	0x93729381
 801baa0:	93939393 	.word	0x93939393
 801baa4:	51936093 	.word	0x51936093
 801baa8:	3093933f 	.word	0x3093933f
 801baac:	10939320 	.word	0x10939320
        switch(Data) {
 801bab0:	2d00      	cmp	r5, #0
 801bab2:	f000 80b0 	beq.w	801bc16 <ConfigCommandParsing.isra.3+0x1ca>
 801bab6:	2d01      	cmp	r5, #1
 801bab8:	f040 8083 	bne.w	801bbc2 <ConfigCommandParsing.isra.3+0x176>
            EnableHWWakeUp();
 801babc:	f7fe fbd2 	bl	801a264 <EnableHWWakeUp>
            if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)) {
 801bac0:	4b77      	ldr	r3, [pc, #476]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bac2:	681b      	ldr	r3, [r3, #0]
 801bac4:	059b      	lsls	r3, r3, #22
 801bac6:	d57c      	bpl.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
  msg.conf.feature = Feature;
 801bac8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bacc:	f240 1377 	movw	r3, #375	; 0x177
 801bad0:	e06f      	b.n	801bbb2 <ConfigCommandParsing.isra.3+0x166>
        switch(Data) {
 801bad2:	2d00      	cmp	r5, #0
 801bad4:	f000 8081 	beq.w	801bbda <ConfigCommandParsing.isra.3+0x18e>
 801bad8:	2d01      	cmp	r5, #1
 801bada:	d172      	bne.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
            EnableHWTilt();
 801badc:	f7fe fbaa 	bl	801a234 <EnableHWTilt>
            if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)) {
 801bae0:	4b6f      	ldr	r3, [pc, #444]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bae2:	681b      	ldr	r3, [r3, #0]
 801bae4:	0598      	lsls	r0, r3, #22
 801bae6:	d56c      	bpl.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
  msg.conf.feature = Feature;
 801bae8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801baec:	f44f 73ba 	mov.w	r3, #372	; 0x174
 801baf0:	e05f      	b.n	801bbb2 <ConfigCommandParsing.isra.3+0x166>
        switch(Data) {
 801baf2:	2d00      	cmp	r5, #0
 801baf4:	f000 809a 	beq.w	801bc2c <ConfigCommandParsing.isra.3+0x1e0>
 801baf8:	2d01      	cmp	r5, #1
 801bafa:	d162      	bne.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
            EnableHWSingleTap();
 801bafc:	f7fe fc02 	bl	801a304 <EnableHWSingleTap>
            if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)) {
 801bb00:	4b67      	ldr	r3, [pc, #412]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bb02:	681b      	ldr	r3, [r3, #0]
 801bb04:	059c      	lsls	r4, r3, #22
 801bb06:	d55c      	bpl.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
  msg.conf.feature = Feature;
 801bb08:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bb0c:	f240 1373 	movw	r3, #371	; 0x173
 801bb10:	e04f      	b.n	801bbb2 <ConfigCommandParsing.isra.3+0x166>
        switch(Data) {
 801bb12:	2d00      	cmp	r5, #0
 801bb14:	d074      	beq.n	801bc00 <ConfigCommandParsing.isra.3+0x1b4>
 801bb16:	2d01      	cmp	r5, #1
 801bb18:	d153      	bne.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
            EnableHWPedometer();
 801bb1a:	f7fe fc0b 	bl	801a334 <EnableHWPedometer>
            ResetHWPedometer();
 801bb1e:	f7fe fc21 	bl	801a364 <ResetHWPedometer>
            if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)) {
 801bb22:	4b5f      	ldr	r3, [pc, #380]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bb24:	681b      	ldr	r3, [r3, #0]
 801bb26:	0599      	lsls	r1, r3, #22
 801bb28:	d54b      	bpl.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
  msg.conf.feature = Feature;
 801bb2a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bb2e:	f44f 73b8 	mov.w	r3, #368	; 0x170
 801bb32:	e03e      	b.n	801bbb2 <ConfigCommandParsing.isra.3+0x166>
        switch(Data) {
 801bb34:	2d00      	cmp	r5, #0
 801bb36:	f000 808f 	beq.w	801bc58 <ConfigCommandParsing.isra.3+0x20c>
 801bb3a:	2d01      	cmp	r5, #1
 801bb3c:	d141      	bne.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
          EnableHWOrientation6D();
 801bb3e:	f7fe fb61 	bl	801a204 <EnableHWOrientation6D>
          if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)) {
 801bb42:	4b57      	ldr	r3, [pc, #348]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bb44:	681b      	ldr	r3, [r3, #0]
 801bb46:	059a      	lsls	r2, r3, #22
 801bb48:	d53b      	bpl.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
  msg.conf.feature = Feature;
 801bb4a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bb4e:	f240 136f 	movw	r3, #367	; 0x16f
 801bb52:	e02e      	b.n	801bbb2 <ConfigCommandParsing.isra.3+0x166>
        switch(Data) {
 801bb54:	2d00      	cmp	r5, #0
 801bb56:	d074      	beq.n	801bc42 <ConfigCommandParsing.isra.3+0x1f6>
 801bb58:	2d01      	cmp	r5, #1
 801bb5a:	d132      	bne.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
            EnableHWMultipleEvents();
 801bb5c:	f7fe fc1a 	bl	801a394 <EnableHWMultipleEvents>
            ResetHWPedometer();
 801bb60:	f7fe fc00 	bl	801a364 <ResetHWPedometer>
            if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)){
 801bb64:	4b4e      	ldr	r3, [pc, #312]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bb66:	681b      	ldr	r3, [r3, #0]
 801bb68:	059c      	lsls	r4, r3, #22
 801bb6a:	d52a      	bpl.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
  msg.conf.feature = Feature;
 801bb6c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bb70:	f240 136d 	movw	r3, #365	; 0x16d
 801bb74:	e01d      	b.n	801bbb2 <ConfigCommandParsing.isra.3+0x166>
        switch(Data) {
 801bb76:	2d00      	cmp	r5, #0
 801bb78:	f000 8084 	beq.w	801bc84 <ConfigCommandParsing.isra.3+0x238>
 801bb7c:	2d01      	cmp	r5, #1
 801bb7e:	d120      	bne.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
            EnableHWFreeFall();
 801bb80:	f7fe fb88 	bl	801a294 <EnableHWFreeFall>
            if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)){
 801bb84:	4b46      	ldr	r3, [pc, #280]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bb86:	681b      	ldr	r3, [r3, #0]
 801bb88:	0599      	lsls	r1, r3, #22
 801bb8a:	d51a      	bpl.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
  msg.conf.feature = Feature;
 801bb8c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bb90:	f44f 73b3 	mov.w	r3, #358	; 0x166
 801bb94:	e00d      	b.n	801bbb2 <ConfigCommandParsing.isra.3+0x166>
        switch(Data) {
 801bb96:	2d00      	cmp	r5, #0
 801bb98:	d069      	beq.n	801bc6e <ConfigCommandParsing.isra.3+0x222>
 801bb9a:	2d01      	cmp	r5, #1
 801bb9c:	d111      	bne.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
            EnableHWDoubleTap();
 801bb9e:	f7fe fb95 	bl	801a2cc <EnableHWDoubleTap>
            if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)) {
 801bba2:	4b3f      	ldr	r3, [pc, #252]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bba4:	681b      	ldr	r3, [r3, #0]
 801bba6:	059b      	lsls	r3, r3, #22
 801bba8:	d50b      	bpl.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
  msg.conf.feature = Feature;
 801bbaa:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bbae:	f44f 73b2 	mov.w	r3, #356	; 0x164
  SendMsgToHost(&msg);
 801bbb2:	4668      	mov	r0, sp
  msg.type         = CONF_NOTIFY;
 801bbb4:	f88d 5000 	strb.w	r5, [sp]
  msg.conf.feature = Feature;
 801bbb8:	9201      	str	r2, [sp, #4]
 801bbba:	f8ad 3008 	strh.w	r3, [sp, #8]
  SendMsgToHost(&msg);
 801bbbe:	f7fe ff53 	bl	801aa68 <SendMsgToHost>
}
 801bbc2:	2001      	movs	r0, #1
 801bbc4:	b00b      	add	sp, #44	; 0x2c
 801bbc6:	bd30      	pop	{r4, r5, pc}
    if (Data == 0 ) {
 801bbc8:	2d00      	cmp	r5, #0
 801bbca:	d1fa      	bne.n	801bbc2 <ConfigCommandParsing.isra.3+0x176>
      BSP_ACCELERO_Sensor_Disable( TargetBoardFeatures.HandleAccSensor );
 801bbcc:	4b33      	ldr	r3, [pc, #204]	; (801bc9c <ConfigCommandParsing.isra.3+0x250>)
 801bbce:	6998      	ldr	r0, [r3, #24]
 801bbd0:	f7f2 ff7c 	bl	800eacc <BSP_ACCELERO_Sensor_Disable>
}
 801bbd4:	2001      	movs	r0, #1
 801bbd6:	b00b      	add	sp, #44	; 0x2c
 801bbd8:	bd30      	pop	{r4, r5, pc}
            DisableHWTilt();
 801bbda:	f7fe fa47 	bl	801a06c <DisableHWTilt>
            if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)) {
 801bbde:	4b30      	ldr	r3, [pc, #192]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bbe0:	681b      	ldr	r3, [r3, #0]
 801bbe2:	0599      	lsls	r1, r3, #22
 801bbe4:	d5f2      	bpl.n	801bbcc <ConfigCommandParsing.isra.3+0x180>
  msg.type         = CONF_NOTIFY;
 801bbe6:	2101      	movs	r1, #1
  msg.conf.feature = Feature;
 801bbe8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bbec:	2374      	movs	r3, #116	; 0x74
  SendMsgToHost(&msg);
 801bbee:	4668      	mov	r0, sp
  msg.type         = CONF_NOTIFY;
 801bbf0:	f88d 1000 	strb.w	r1, [sp]
  msg.conf.feature = Feature;
 801bbf4:	9201      	str	r2, [sp, #4]
 801bbf6:	f8ad 3008 	strh.w	r3, [sp, #8]
  SendMsgToHost(&msg);
 801bbfa:	f7fe ff35 	bl	801aa68 <SendMsgToHost>
 801bbfe:	e7e5      	b.n	801bbcc <ConfigCommandParsing.isra.3+0x180>
            DisableHWPedometer();
 801bc00:	f7fe fab6 	bl	801a170 <DisableHWPedometer>
            if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)) {
 801bc04:	4b26      	ldr	r3, [pc, #152]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bc06:	681b      	ldr	r3, [r3, #0]
 801bc08:	059a      	lsls	r2, r3, #22
 801bc0a:	d5df      	bpl.n	801bbcc <ConfigCommandParsing.isra.3+0x180>
  msg.type         = CONF_NOTIFY;
 801bc0c:	2101      	movs	r1, #1
  msg.conf.feature = Feature;
 801bc0e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bc12:	2370      	movs	r3, #112	; 0x70
 801bc14:	e7eb      	b.n	801bbee <ConfigCommandParsing.isra.3+0x1a2>
            DisableHWWakeUp();
 801bc16:	f7fe fa43 	bl	801a0a0 <DisableHWWakeUp>
            if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)) {
 801bc1a:	4b21      	ldr	r3, [pc, #132]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bc1c:	681b      	ldr	r3, [r3, #0]
 801bc1e:	059c      	lsls	r4, r3, #22
 801bc20:	d5d4      	bpl.n	801bbcc <ConfigCommandParsing.isra.3+0x180>
  msg.type         = CONF_NOTIFY;
 801bc22:	2101      	movs	r1, #1
  msg.conf.feature = Feature;
 801bc24:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bc28:	2377      	movs	r3, #119	; 0x77
 801bc2a:	e7e0      	b.n	801bbee <ConfigCommandParsing.isra.3+0x1a2>
            DisableHWSingleTap();
 801bc2c:	f7fe fa86 	bl	801a13c <DisableHWSingleTap>
            if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)) {
 801bc30:	4b1b      	ldr	r3, [pc, #108]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bc32:	681b      	ldr	r3, [r3, #0]
 801bc34:	0598      	lsls	r0, r3, #22
 801bc36:	d5c9      	bpl.n	801bbcc <ConfigCommandParsing.isra.3+0x180>
  msg.type         = CONF_NOTIFY;
 801bc38:	2101      	movs	r1, #1
  msg.conf.feature = Feature;
 801bc3a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bc3e:	2373      	movs	r3, #115	; 0x73
 801bc40:	e7d5      	b.n	801bbee <ConfigCommandParsing.isra.3+0x1a2>
            DisableHWMultipleEvents();
 801bc42:	f7fe fbc9 	bl	801a3d8 <DisableHWMultipleEvents>
            if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)){
 801bc46:	4b16      	ldr	r3, [pc, #88]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bc48:	681b      	ldr	r3, [r3, #0]
 801bc4a:	0598      	lsls	r0, r3, #22
 801bc4c:	d5be      	bpl.n	801bbcc <ConfigCommandParsing.isra.3+0x180>
  msg.type         = CONF_NOTIFY;
 801bc4e:	2101      	movs	r1, #1
  msg.conf.feature = Feature;
 801bc50:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bc54:	236d      	movs	r3, #109	; 0x6d
 801bc56:	e7ca      	b.n	801bbee <ConfigCommandParsing.isra.3+0x1a2>
          DisableHWOrientation6D();
 801bc58:	f7fe f952 	bl	8019f00 <DisableHWOrientation6D>
          if (W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)) {
 801bc5c:	4b10      	ldr	r3, [pc, #64]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bc5e:	681b      	ldr	r3, [r3, #0]
 801bc60:	059b      	lsls	r3, r3, #22
 801bc62:	d5b3      	bpl.n	801bbcc <ConfigCommandParsing.isra.3+0x180>
  msg.type         = CONF_NOTIFY;
 801bc64:	2101      	movs	r1, #1
  msg.conf.feature = Feature;
 801bc66:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bc6a:	236f      	movs	r3, #111	; 0x6f
 801bc6c:	e7bf      	b.n	801bbee <ConfigCommandParsing.isra.3+0x1a2>
            DisableHWDoubleTap();
 801bc6e:	f7fe fa4b 	bl	801a108 <DisableHWDoubleTap>
            if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)) {
 801bc72:	4b0b      	ldr	r3, [pc, #44]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bc74:	681b      	ldr	r3, [r3, #0]
 801bc76:	059d      	lsls	r5, r3, #22
 801bc78:	d5a8      	bpl.n	801bbcc <ConfigCommandParsing.isra.3+0x180>
  msg.type         = CONF_NOTIFY;
 801bc7a:	2101      	movs	r1, #1
  msg.conf.feature = Feature;
 801bc7c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bc80:	2364      	movs	r3, #100	; 0x64
 801bc82:	e7b4      	b.n	801bbee <ConfigCommandParsing.isra.3+0x1a2>
            DisableHWFreeFall();
 801bc84:	f7fe fa26 	bl	801a0d4 <DisableHWFreeFall>
            if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)) {
 801bc88:	4b05      	ldr	r3, [pc, #20]	; (801bca0 <ConfigCommandParsing.isra.3+0x254>)
 801bc8a:	681b      	ldr	r3, [r3, #0]
 801bc8c:	059a      	lsls	r2, r3, #22
 801bc8e:	d59d      	bpl.n	801bbcc <ConfigCommandParsing.isra.3+0x180>
  msg.type         = CONF_NOTIFY;
 801bc90:	2101      	movs	r1, #1
  msg.conf.feature = Feature;
 801bc92:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bc96:	2366      	movs	r3, #102	; 0x66
 801bc98:	e7a9      	b.n	801bbee <ConfigCommandParsing.isra.3+0x1a2>
 801bc9a:	bf00      	nop
 801bc9c:	20011458 	.word	0x20011458
 801bca0:	20010030 	.word	0x20010030

0801bca4 <Add_ConfigW2ST_Service>:
{
 801bca4:	b5f0      	push	{r4, r5, r6, r7, lr}
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3,&ConfigServW2STHandle);
 801bca6:	4c18      	ldr	r4, [pc, #96]	; (801bd08 <Add_ConfigW2ST_Service+0x64>)
  COPY_CONFIG_SERVICE_UUID(uuid);
 801bca8:	4818      	ldr	r0, [pc, #96]	; (801bd0c <Add_ConfigW2ST_Service+0x68>)
 801bcaa:	4d19      	ldr	r5, [pc, #100]	; (801bd10 <Add_ConfigW2ST_Service+0x6c>)
 801bcac:	4e19      	ldr	r6, [pc, #100]	; (801bd14 <Add_ConfigW2ST_Service+0x70>)
{
 801bcae:	b08b      	sub	sp, #44	; 0x2c
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3,&ConfigServW2STHandle);
 801bcb0:	f104 0308 	add.w	r3, r4, #8
 801bcb4:	9300      	str	r3, [sp, #0]
  COPY_CONFIG_SERVICE_UUID(uuid);
 801bcb6:	2700      	movs	r7, #0
 801bcb8:	9007      	str	r0, [sp, #28]
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3,&ConfigServW2STHandle);
 801bcba:	a906      	add	r1, sp, #24
 801bcbc:	2304      	movs	r3, #4
 801bcbe:	2201      	movs	r2, #1
 801bcc0:	2002      	movs	r0, #2
  COPY_CONFIG_SERVICE_UUID(uuid);
 801bcc2:	9606      	str	r6, [sp, #24]
 801bcc4:	e9cd 5708 	strd	r5, r7, [sp, #32]
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3,&ConfigServW2STHandle);
 801bcc8:	f7fc fd72 	bl	80187b0 <aci_gatt_add_serv>
  if (ret != BLE_STATUS_SUCCESS) {
 801bccc:	b9c8      	cbnz	r0, 801bd02 <Add_ConfigW2ST_Service+0x5e>
  ret =  aci_gatt_add_char(ConfigServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 801bcce:	8923      	ldrh	r3, [r4, #8]
 801bcd0:	9001      	str	r0, [sp, #4]
 801bcd2:	2101      	movs	r1, #1
 801bcd4:	4618      	mov	r0, r3
 801bcd6:	2310      	movs	r3, #16
 801bcd8:	e9cd 3103 	strd	r3, r1, [sp, #12]
 801bcdc:	2305      	movs	r3, #5
 801bcde:	340a      	adds	r4, #10
  COPY_CONFIG_W2ST_CHAR_UUID(uuid);
 801bce0:	2702      	movs	r7, #2
  ret =  aci_gatt_add_char(ConfigServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 801bce2:	9302      	str	r3, [sp, #8]
 801bce4:	2314      	movs	r3, #20
 801bce6:	9405      	str	r4, [sp, #20]
 801bce8:	aa06      	add	r2, sp, #24
  COPY_CONFIG_W2ST_CHAR_UUID(uuid);
 801bcea:	4c0b      	ldr	r4, [pc, #44]	; (801bd18 <Add_ConfigW2ST_Service+0x74>)
  ret =  aci_gatt_add_char(ConfigServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 801bcec:	9300      	str	r3, [sp, #0]
 801bcee:	4639      	mov	r1, r7
  COPY_CONFIG_W2ST_CHAR_UUID(uuid);
 801bcf0:	9606      	str	r6, [sp, #24]
 801bcf2:	9508      	str	r5, [sp, #32]
 801bcf4:	9709      	str	r7, [sp, #36]	; 0x24
 801bcf6:	9407      	str	r4, [sp, #28]
  ret =  aci_gatt_add_char(ConfigServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 801bcf8:	f7fc fda4 	bl	8018844 <aci_gatt_add_char>
  if (ret != BLE_STATUS_SUCCESS) {
 801bcfc:	b908      	cbnz	r0, 801bd02 <Add_ConfigW2ST_Service+0x5e>
}
 801bcfe:	b00b      	add	sp, #44	; 0x2c
 801bd00:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return BLE_STATUS_ERROR;
 801bd02:	2047      	movs	r0, #71	; 0x47
}
 801bd04:	b00b      	add	sp, #44	; 0x2c
 801bd06:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801bd08:	20010030 	.word	0x20010030
 801bd0c:	9ab40002 	.word	0x9ab40002
 801bd10:	000f11e1 	.word	0x000f11e1
 801bd14:	a5d5c51b 	.word	0xa5d5c51b
 801bd18:	ac360002 	.word	0xac360002

0801bd1c <Add_ConsoleW2ST_Service>:
{
 801bd1c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3*2,&ConsoleW2STHandle);
 801bd20:	4c26      	ldr	r4, [pc, #152]	; (801bdbc <Add_ConsoleW2ST_Service+0xa0>)
  COPY_CONSOLE_SERVICE_UUID(uuid);
 801bd22:	4827      	ldr	r0, [pc, #156]	; (801bdc0 <Add_ConsoleW2ST_Service+0xa4>)
 801bd24:	4d27      	ldr	r5, [pc, #156]	; (801bdc4 <Add_ConsoleW2ST_Service+0xa8>)
 801bd26:	4e28      	ldr	r6, [pc, #160]	; (801bdc8 <Add_ConsoleW2ST_Service+0xac>)
{
 801bd28:	b08b      	sub	sp, #44	; 0x2c
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3*2,&ConsoleW2STHandle);
 801bd2a:	f104 030c 	add.w	r3, r4, #12
 801bd2e:	9300      	str	r3, [sp, #0]
  COPY_CONSOLE_SERVICE_UUID(uuid);
 801bd30:	2700      	movs	r7, #0
 801bd32:	9007      	str	r0, [sp, #28]
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3*2,&ConsoleW2STHandle);
 801bd34:	a906      	add	r1, sp, #24
 801bd36:	2307      	movs	r3, #7
 801bd38:	2201      	movs	r2, #1
 801bd3a:	2002      	movs	r0, #2
  COPY_CONSOLE_SERVICE_UUID(uuid);
 801bd3c:	9606      	str	r6, [sp, #24]
 801bd3e:	e9cd 5708 	strd	r5, r7, [sp, #32]
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3*2,&ConsoleW2STHandle);
 801bd42:	f7fc fd35 	bl	80187b0 <aci_gatt_add_serv>
  if (ret != BLE_STATUS_SUCCESS) {
 801bd46:	bba0      	cbnz	r0, 801bdb2 <Add_ConsoleW2ST_Service+0x96>
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 801bd48:	f8b4 c00c 	ldrh.w	ip, [r4, #12]
  COPY_TERM_CHAR_UUID(uuid);
 801bd4c:	f8df 807c 	ldr.w	r8, [pc, #124]	; 801bdcc <Add_ConsoleW2ST_Service+0xb0>
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 801bd50:	9001      	str	r0, [sp, #4]
  COPY_TERM_CHAR_UUID(uuid);
 801bd52:	2701      	movs	r7, #1
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 801bd54:	f104 010e 	add.w	r1, r4, #14
 801bd58:	2205      	movs	r2, #5
 801bd5a:	231e      	movs	r3, #30
 801bd5c:	f04f 0910 	mov.w	r9, #16
 801bd60:	e9cd 7104 	strd	r7, r1, [sp, #16]
 801bd64:	e9cd 2902 	strd	r2, r9, [sp, #8]
 801bd68:	9300      	str	r3, [sp, #0]
 801bd6a:	4660      	mov	r0, ip
 801bd6c:	2314      	movs	r3, #20
 801bd6e:	aa06      	add	r2, sp, #24
 801bd70:	2102      	movs	r1, #2
  COPY_TERM_CHAR_UUID(uuid);
 801bd72:	9606      	str	r6, [sp, #24]
 801bd74:	e9cd 5708 	strd	r5, r7, [sp, #32]
 801bd78:	f8cd 801c 	str.w	r8, [sp, #28]
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 801bd7c:	f7fc fd62 	bl	8018844 <aci_gatt_add_char>
  if (ret != BLE_STATUS_SUCCESS) {
 801bd80:	b9b8      	cbnz	r0, 801bdb2 <Add_ConsoleW2ST_Service+0x96>
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 801bd82:	f8b4 c00c 	ldrh.w	ip, [r4, #12]
 801bd86:	9704      	str	r7, [sp, #16]
 801bd88:	2104      	movs	r1, #4
  COPY_STDERR_CHAR_UUID(uuid);
 801bd8a:	2702      	movs	r7, #2
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 801bd8c:	2312      	movs	r3, #18
 801bd8e:	444c      	add	r4, r9
 801bd90:	9001      	str	r0, [sp, #4]
 801bd92:	9102      	str	r1, [sp, #8]
 801bd94:	9300      	str	r3, [sp, #0]
 801bd96:	f8cd 900c 	str.w	r9, [sp, #12]
 801bd9a:	aa06      	add	r2, sp, #24
 801bd9c:	4660      	mov	r0, ip
 801bd9e:	9405      	str	r4, [sp, #20]
 801bda0:	4639      	mov	r1, r7
 801bda2:	2314      	movs	r3, #20
  COPY_STDERR_CHAR_UUID(uuid);
 801bda4:	e9cd 6806 	strd	r6, r8, [sp, #24]
 801bda8:	e9cd 5708 	strd	r5, r7, [sp, #32]
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 801bdac:	f7fc fd4a 	bl	8018844 <aci_gatt_add_char>
  if (ret != BLE_STATUS_SUCCESS) {
 801bdb0:	b100      	cbz	r0, 801bdb4 <Add_ConsoleW2ST_Service+0x98>
  return BLE_STATUS_ERROR;
 801bdb2:	2047      	movs	r0, #71	; 0x47
}
 801bdb4:	b00b      	add	sp, #44	; 0x2c
 801bdb6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801bdba:	bf00      	nop
 801bdbc:	20010030 	.word	0x20010030
 801bdc0:	9ab40002 	.word	0x9ab40002
 801bdc4:	000e11e1 	.word	0x000e11e1
 801bdc8:	a5d5c51b 	.word	0xa5d5c51b
 801bdcc:	ac360002 	.word	0xac360002

0801bdd0 <UpdateTermStdOut>:
{
 801bdd0:	b510      	push	{r4, lr}
 801bdd2:	b082      	sub	sp, #8
  if (aci_gatt_update_char_value(ConsoleW2STHandle, TermCharHandle, 0, length , data) != BLE_STATUS_SUCCESS) {
 801bdd4:	4b0a      	ldr	r3, [pc, #40]	; (801be00 <UpdateTermStdOut+0x30>)
 801bdd6:	9000      	str	r0, [sp, #0]
 801bdd8:	89da      	ldrh	r2, [r3, #14]
 801bdda:	8998      	ldrh	r0, [r3, #12]
 801bddc:	460b      	mov	r3, r1
 801bdde:	4611      	mov	r1, r2
 801bde0:	2200      	movs	r2, #0
 801bde2:	f7fc fdb9 	bl	8018958 <aci_gatt_update_char_value>
 801bde6:	b930      	cbnz	r0, 801bdf6 <UpdateTermStdOut+0x26>
 801bde8:	4604      	mov	r4, r0
  osDelay(20);
 801bdea:	2014      	movs	r0, #20
 801bdec:	f7fa fa20 	bl	8016230 <osDelay>
}
 801bdf0:	4620      	mov	r0, r4
 801bdf2:	b002      	add	sp, #8
 801bdf4:	bd10      	pop	{r4, pc}
    return BLE_STATUS_ERROR;
 801bdf6:	2447      	movs	r4, #71	; 0x47
}
 801bdf8:	4620      	mov	r0, r4
 801bdfa:	b002      	add	sp, #8
 801bdfc:	bd10      	pop	{r4, pc}
 801bdfe:	bf00      	nop
 801be00:	20010030 	.word	0x20010030

0801be04 <UpdateTermStdErr>:
{
 801be04:	b510      	push	{r4, lr}
 801be06:	b082      	sub	sp, #8
  if (aci_gatt_update_char_value(ConsoleW2STHandle, StdErrCharHandle, 0, length , data) != BLE_STATUS_SUCCESS) {
 801be08:	4b0a      	ldr	r3, [pc, #40]	; (801be34 <UpdateTermStdErr+0x30>)
 801be0a:	9000      	str	r0, [sp, #0]
 801be0c:	8a1a      	ldrh	r2, [r3, #16]
 801be0e:	8998      	ldrh	r0, [r3, #12]
 801be10:	460b      	mov	r3, r1
 801be12:	4611      	mov	r1, r2
 801be14:	2200      	movs	r2, #0
 801be16:	f7fc fd9f 	bl	8018958 <aci_gatt_update_char_value>
 801be1a:	b930      	cbnz	r0, 801be2a <UpdateTermStdErr+0x26>
 801be1c:	4604      	mov	r4, r0
  osDelay(20);
 801be1e:	2014      	movs	r0, #20
 801be20:	f7fa fa06 	bl	8016230 <osDelay>
}
 801be24:	4620      	mov	r0, r4
 801be26:	b002      	add	sp, #8
 801be28:	bd10      	pop	{r4, pc}
    return BLE_STATUS_ERROR;
 801be2a:	2447      	movs	r4, #71	; 0x47
}
 801be2c:	4620      	mov	r0, r4
 801be2e:	b002      	add	sp, #8
 801be30:	bd10      	pop	{r4, pc}
 801be32:	bf00      	nop
 801be34:	20010030 	.word	0x20010030

0801be38 <Stderr_Update>:
{
 801be38:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801be3c:	b08a      	sub	sp, #40	; 0x28
  msg.type        = TERM_STDERR;
 801be3e:	230b      	movs	r3, #11
 801be40:	f88d 3000 	strb.w	r3, [sp]
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 801be44:	b319      	cbz	r1, 801be8e <Stderr_Update+0x56>
 801be46:	4f14      	ldr	r7, [pc, #80]	; (801be98 <Stderr_Update+0x60>)
 801be48:	4689      	mov	r9, r1
 801be4a:	4606      	mov	r6, r0
 801be4c:	2500      	movs	r5, #0
    memcpy(LastStderrBuffer,data+Offset,DataToSend);
 801be4e:	f107 0814 	add.w	r8, r7, #20
    DataToSend = (length-Offset);
 801be52:	eba9 0405 	sub.w	r4, r9, r5
 801be56:	b2e4      	uxtb	r4, r4
    DataToSend = (DataToSend>W2ST_MAX_CHAR_LEN) ?  W2ST_MAX_CHAR_LEN : DataToSend;
 801be58:	2c14      	cmp	r4, #20
 801be5a:	bf28      	it	cs
 801be5c:	2414      	movcs	r4, #20
    memcpy(LastStderrBuffer,data+Offset,DataToSend);
 801be5e:	eb06 0a05 	add.w	sl, r6, r5
 801be62:	4622      	mov	r2, r4
 801be64:	4651      	mov	r1, sl
 801be66:	4640      	mov	r0, r8
 801be68:	f002 fe57 	bl	801eb1a <memcpy>
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 801be6c:	3514      	adds	r5, #20
    memcpy(msg.term.data,data+Offset,DataToSend);
 801be6e:	4622      	mov	r2, r4
 801be70:	4651      	mov	r1, sl
 801be72:	f10d 0005 	add.w	r0, sp, #5
    LastStderrLen = DataToSend;
 801be76:	f887 4028 	strb.w	r4, [r7, #40]	; 0x28
    msg.term.length   =  DataToSend;
 801be7a:	f88d 4004 	strb.w	r4, [sp, #4]
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 801be7e:	b2ed      	uxtb	r5, r5
    memcpy(msg.term.data,data+Offset,DataToSend);
 801be80:	f002 fe4b 	bl	801eb1a <memcpy>
    SendMsgToHost(&msg);
 801be84:	4668      	mov	r0, sp
 801be86:	f7fe fdef 	bl	801aa68 <SendMsgToHost>
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 801be8a:	45a9      	cmp	r9, r5
 801be8c:	d8e1      	bhi.n	801be52 <Stderr_Update+0x1a>
}
 801be8e:	2000      	movs	r0, #0
 801be90:	b00a      	add	sp, #40	; 0x28
 801be92:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801be96:	bf00      	nop
 801be98:	20010030 	.word	0x20010030

0801be9c <Term_Update>:
{
 801be9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801bea0:	b08a      	sub	sp, #40	; 0x28
  msg.type = TERM_STDOUT;
 801bea2:	230a      	movs	r3, #10
 801bea4:	f88d 3000 	strb.w	r3, [sp]
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 801bea8:	b319      	cbz	r1, 801bef2 <Term_Update+0x56>
 801beaa:	4f14      	ldr	r7, [pc, #80]	; (801befc <Term_Update+0x60>)
 801beac:	4689      	mov	r9, r1
 801beae:	4606      	mov	r6, r0
 801beb0:	2500      	movs	r5, #0
    memcpy(LastTermBuffer,data+Offset,DataToSend);
 801beb2:	f107 082c 	add.w	r8, r7, #44	; 0x2c
    DataToSend = (length-Offset);
 801beb6:	eba9 0405 	sub.w	r4, r9, r5
 801beba:	b2e4      	uxtb	r4, r4
    DataToSend = (DataToSend>W2ST_MAX_CHAR_LEN) ?  W2ST_MAX_CHAR_LEN : DataToSend;
 801bebc:	2c14      	cmp	r4, #20
 801bebe:	bf28      	it	cs
 801bec0:	2414      	movcs	r4, #20
    memcpy(LastTermBuffer,data+Offset,DataToSend);
 801bec2:	eb06 0a05 	add.w	sl, r6, r5
 801bec6:	4622      	mov	r2, r4
 801bec8:	4651      	mov	r1, sl
 801beca:	4640      	mov	r0, r8
 801becc:	f002 fe25 	bl	801eb1a <memcpy>
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 801bed0:	3514      	adds	r5, #20
    memcpy(msg.term.data,data+Offset,DataToSend);
 801bed2:	4622      	mov	r2, r4
 801bed4:	4651      	mov	r1, sl
 801bed6:	f10d 0005 	add.w	r0, sp, #5
    LastTermLen = DataToSend;
 801beda:	f887 4040 	strb.w	r4, [r7, #64]	; 0x40
    msg.term.length   =  DataToSend;
 801bede:	f88d 4004 	strb.w	r4, [sp, #4]
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 801bee2:	b2ed      	uxtb	r5, r5
    memcpy(msg.term.data,data+Offset,DataToSend);
 801bee4:	f002 fe19 	bl	801eb1a <memcpy>
    SendMsgToHost(&msg);
 801bee8:	4668      	mov	r0, sp
 801beea:	f7fe fdbd 	bl	801aa68 <SendMsgToHost>
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 801beee:	45a9      	cmp	r9, r5
 801bef0:	d8e1      	bhi.n	801beb6 <Term_Update+0x1a>
}
 801bef2:	2000      	movs	r0, #0
 801bef4:	b00a      	add	sp, #40	; 0x28
 801bef6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801befa:	bf00      	nop
 801befc:	20010030 	.word	0x20010030

0801bf00 <ActivityRec_Update>:
{
 801bf00:	b5f0      	push	{r4, r5, r6, r7, lr}
 801bf02:	b085      	sub	sp, #20
 801bf04:	4606      	mov	r6, r0
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801bf06:	f7f4 faf1 	bl	80104ec <HAL_GetTick>
 801bf0a:	08c0      	lsrs	r0, r0, #3
  ret = aci_gatt_update_char_value(HWServW2STHandle, ActivityRecCharHandle, 0, 2+1+1, buff);
 801bf0c:	4c1c      	ldr	r4, [pc, #112]	; (801bf80 <ActivityRec_Update+0x80>)
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801bf0e:	f88d 000c 	strb.w	r0, [sp, #12]
 801bf12:	f7f4 faeb 	bl	80104ec <HAL_GetTick>
  ret = aci_gatt_update_char_value(HWServW2STHandle, ActivityRecCharHandle, 0, 2+1+1, buff);
 801bf16:	f8b4 5044 	ldrh.w	r5, [r4, #68]	; 0x44
 801bf1a:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
  buff[2] = ActivityCode;
 801bf1e:	f88d 600e 	strb.w	r6, [sp, #14]
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801bf22:	0ac2      	lsrs	r2, r0, #11
  ret = aci_gatt_update_char_value(HWServW2STHandle, ActivityRecCharHandle, 0, 2+1+1, buff);
 801bf24:	ab03      	add	r3, sp, #12
 801bf26:	4628      	mov	r0, r5
 801bf28:	9300      	str	r3, [sp, #0]
  buff[3] = HAR_ALG_ID ;
 801bf2a:	2501      	movs	r5, #1
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801bf2c:	f88d 200d 	strb.w	r2, [sp, #13]
  ret = aci_gatt_update_char_value(HWServW2STHandle, ActivityRecCharHandle, 0, 2+1+1, buff);
 801bf30:	2304      	movs	r3, #4
 801bf32:	2200      	movs	r2, #0
  buff[3] = HAR_ALG_ID ;
 801bf34:	f88d 500f 	strb.w	r5, [sp, #15]
  ret = aci_gatt_update_char_value(HWServW2STHandle, ActivityRecCharHandle, 0, 2+1+1, buff);
 801bf38:	f7fc fd0e 	bl	8018958 <aci_gatt_update_char_value>
  if (ret != BLE_STATUS_SUCCESS){
 801bf3c:	b118      	cbz	r0, 801bf46 <ActivityRec_Update+0x46>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801bf3e:	6823      	ldr	r3, [r4, #0]
 801bf40:	065b      	lsls	r3, r3, #25
 801bf42:	d402      	bmi.n	801bf4a <ActivityRec_Update+0x4a>
    return BLE_STATUS_ERROR;
 801bf44:	2047      	movs	r0, #71	; 0x47
}
 801bf46:	b005      	add	sp, #20
 801bf48:	bdf0      	pop	{r4, r5, r6, r7, pc}
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating ActivityRec Char\n");
 801bf4a:	4e0e      	ldr	r6, [pc, #56]	; (801bf84 <ActivityRec_Update+0x84>)
 801bf4c:	4d0e      	ldr	r5, [pc, #56]	; (801bf88 <ActivityRec_Update+0x88>)
 801bf4e:	f106 0720 	add.w	r7, r6, #32
 801bf52:	4634      	mov	r4, r6
 801bf54:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801bf56:	42bc      	cmp	r4, r7
 801bf58:	6028      	str	r0, [r5, #0]
 801bf5a:	6069      	str	r1, [r5, #4]
 801bf5c:	60aa      	str	r2, [r5, #8]
 801bf5e:	60eb      	str	r3, [r5, #12]
 801bf60:	4626      	mov	r6, r4
 801bf62:	f105 0510 	add.w	r5, r5, #16
 801bf66:	d1f4      	bne.n	801bf52 <ActivityRec_Update+0x52>
 801bf68:	7823      	ldrb	r3, [r4, #0]
 801bf6a:	702b      	strb	r3, [r5, #0]
 801bf6c:	4a07      	ldr	r2, [pc, #28]	; (801bf8c <ActivityRec_Update+0x8c>)
      Stderr_Update(BufferToWrite,BytesToWrite);
 801bf6e:	4806      	ldr	r0, [pc, #24]	; (801bf88 <ActivityRec_Update+0x88>)
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating ActivityRec Char\n");
 801bf70:	2320      	movs	r3, #32
      Stderr_Update(BufferToWrite,BytesToWrite);
 801bf72:	4619      	mov	r1, r3
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating ActivityRec Char\n");
 801bf74:	6013      	str	r3, [r2, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801bf76:	f7ff ff5f 	bl	801be38 <Stderr_Update>
 801bf7a:	2047      	movs	r0, #71	; 0x47
 801bf7c:	e7e3      	b.n	801bf46 <ActivityRec_Update+0x46>
 801bf7e:	bf00      	nop
 801bf80:	20010030 	.word	0x20010030
 801bf84:	080758e8 	.word	0x080758e8
 801bf88:	20013174 	.word	0x20013174
 801bf8c:	200132a0 	.word	0x200132a0

0801bf90 <AudioSRec_Update>:
{
 801bf90:	b5f0      	push	{r4, r5, r6, r7, lr}
 801bf92:	b085      	sub	sp, #20
 801bf94:	4605      	mov	r5, r0
  STORE_LE_16(buff, (HAL_GetTick() >> 3));
 801bf96:	f7f4 faa9 	bl	80104ec <HAL_GetTick>
  ret = aci_gatt_update_char_value(HWServW2STHandle, AudioSRecCharHandle, 0, 2+1, buff);
 801bf9a:	4c19      	ldr	r4, [pc, #100]	; (801c000 <AudioSRec_Update+0x70>)
  STORE_LE_16(buff, (HAL_GetTick() >> 3));
 801bf9c:	08c0      	lsrs	r0, r0, #3
 801bf9e:	f88d 000c 	strb.w	r0, [sp, #12]
 801bfa2:	f7f4 faa3 	bl	80104ec <HAL_GetTick>
  ret = aci_gatt_update_char_value(HWServW2STHandle, AudioSRecCharHandle, 0, 2+1, buff);
 801bfa6:	f8b4 3044 	ldrh.w	r3, [r4, #68]	; 0x44
  buff[2] = SceneClassificationCode;
 801bfaa:	f88d 500e 	strb.w	r5, [sp, #14]
  ret = aci_gatt_update_char_value(HWServW2STHandle, AudioSRecCharHandle, 0, 2+1, buff);
 801bfae:	a903      	add	r1, sp, #12
 801bfb0:	2200      	movs	r2, #0
  STORE_LE_16(buff, (HAL_GetTick() >> 3));
 801bfb2:	0ac5      	lsrs	r5, r0, #11
  ret = aci_gatt_update_char_value(HWServW2STHandle, AudioSRecCharHandle, 0, 2+1, buff);
 801bfb4:	9100      	str	r1, [sp, #0]
 801bfb6:	4618      	mov	r0, r3
 801bfb8:	4611      	mov	r1, r2
 801bfba:	2303      	movs	r3, #3
  STORE_LE_16(buff, (HAL_GetTick() >> 3));
 801bfbc:	f88d 500d 	strb.w	r5, [sp, #13]
  ret = aci_gatt_update_char_value(HWServW2STHandle, AudioSRecCharHandle, 0, 2+1, buff);
 801bfc0:	f7fc fcca 	bl	8018958 <aci_gatt_update_char_value>
  if (ret != BLE_STATUS_SUCCESS) {
 801bfc4:	b118      	cbz	r0, 801bfce <AudioSRec_Update+0x3e>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801bfc6:	6823      	ldr	r3, [r4, #0]
 801bfc8:	065b      	lsls	r3, r3, #25
 801bfca:	d402      	bmi.n	801bfd2 <AudioSRec_Update+0x42>
    return BLE_STATUS_ERROR;
 801bfcc:	2047      	movs	r0, #71	; 0x47
}
 801bfce:	b005      	add	sp, #20
 801bfd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating AudioRec Char\n");
 801bfd2:	4c0c      	ldr	r4, [pc, #48]	; (801c004 <AudioSRec_Update+0x74>)
 801bfd4:	4d0c      	ldr	r5, [pc, #48]	; (801c008 <AudioSRec_Update+0x78>)
 801bfd6:	4f0d      	ldr	r7, [pc, #52]	; (801c00c <AudioSRec_Update+0x7c>)
 801bfd8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801bfda:	6028      	str	r0, [r5, #0]
 801bfdc:	6069      	str	r1, [r5, #4]
 801bfde:	60aa      	str	r2, [r5, #8]
 801bfe0:	cc07      	ldmia	r4!, {r0, r1, r2}
 801bfe2:	261d      	movs	r6, #29
 801bfe4:	8824      	ldrh	r4, [r4, #0]
 801bfe6:	6128      	str	r0, [r5, #16]
 801bfe8:	6169      	str	r1, [r5, #20]
 801bfea:	60eb      	str	r3, [r5, #12]
      Stderr_Update(BufferToWrite, BytesToWrite);
 801bfec:	4628      	mov	r0, r5
 801bfee:	4631      	mov	r1, r6
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating AudioRec Char\n");
 801bff0:	83ac      	strh	r4, [r5, #28]
 801bff2:	61aa      	str	r2, [r5, #24]
 801bff4:	603e      	str	r6, [r7, #0]
      Stderr_Update(BufferToWrite, BytesToWrite);
 801bff6:	f7ff ff1f 	bl	801be38 <Stderr_Update>
    return BLE_STATUS_ERROR;
 801bffa:	2047      	movs	r0, #71	; 0x47
}
 801bffc:	b005      	add	sp, #20
 801bffe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801c000:	20010030 	.word	0x20010030
 801c004:	0807590c 	.word	0x0807590c
 801c008:	20013174 	.word	0x20013174
 801c00c:	200132a0 	.word	0x200132a0

0801c010 <Config_NotifyBLE>:
{
 801c010:	b5f0      	push	{r4, r5, r6, r7, lr}
 801c012:	b085      	sub	sp, #20
 801c014:	4604      	mov	r4, r0
 801c016:	460f      	mov	r7, r1
 801c018:	4616      	mov	r6, r2
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c01a:	f7f4 fa67 	bl	80104ec <HAL_GetTick>
 801c01e:	08c0      	lsrs	r0, r0, #3
 801c020:	f88d 0008 	strb.w	r0, [sp, #8]
 801c024:	f7f4 fa62 	bl	80104ec <HAL_GetTick>
  ret = aci_gatt_update_char_value (ConfigServW2STHandle, ConfigCharHandle, 0, 8,buff);
 801c028:	4d1f      	ldr	r5, [pc, #124]	; (801c0a8 <Config_NotifyBLE+0x98>)
  STORE_BE_32(buff+2,Feature);
 801c02a:	f88d 400d 	strb.w	r4, [sp, #13]
  ret = aci_gatt_update_char_value (ConfigServW2STHandle, ConfigCharHandle, 0, 8,buff);
 801c02e:	892a      	ldrh	r2, [r5, #8]
 801c030:	8969      	ldrh	r1, [r5, #10]
  buff[6] = Command;
 801c032:	f88d 700e 	strb.w	r7, [sp, #14]
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c036:	0ac3      	lsrs	r3, r0, #11
 801c038:	f88d 3009 	strb.w	r3, [sp, #9]
  ret = aci_gatt_update_char_value (ConfigServW2STHandle, ConfigCharHandle, 0, 8,buff);
 801c03c:	ab02      	add	r3, sp, #8
 801c03e:	4610      	mov	r0, r2
 801c040:	9300      	str	r3, [sp, #0]
  STORE_BE_32(buff+2,Feature);
 801c042:	0c22      	lsrs	r2, r4, #16
 801c044:	0a23      	lsrs	r3, r4, #8
 801c046:	f88d 300c 	strb.w	r3, [sp, #12]
 801c04a:	0e24      	lsrs	r4, r4, #24
 801c04c:	f88d 200b 	strb.w	r2, [sp, #11]
  ret = aci_gatt_update_char_value (ConfigServW2STHandle, ConfigCharHandle, 0, 8,buff);
 801c050:	2308      	movs	r3, #8
 801c052:	2200      	movs	r2, #0
  buff[7] = data;
 801c054:	f88d 600f 	strb.w	r6, [sp, #15]
  STORE_BE_32(buff+2,Feature);
 801c058:	f88d 400a 	strb.w	r4, [sp, #10]
  ret = aci_gatt_update_char_value (ConfigServW2STHandle, ConfigCharHandle, 0, 8,buff);
 801c05c:	f7fc fc7c 	bl	8018958 <aci_gatt_update_char_value>
  if (ret != BLE_STATUS_SUCCESS){
 801c060:	b118      	cbz	r0, 801c06a <Config_NotifyBLE+0x5a>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801c062:	682b      	ldr	r3, [r5, #0]
 801c064:	065b      	lsls	r3, r3, #25
 801c066:	d402      	bmi.n	801c06e <Config_NotifyBLE+0x5e>
    return BLE_STATUS_ERROR;
 801c068:	2047      	movs	r0, #71	; 0x47
}
 801c06a:	b005      	add	sp, #20
 801c06c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Configuration Char\n");
 801c06e:	4e0f      	ldr	r6, [pc, #60]	; (801c0ac <Config_NotifyBLE+0x9c>)
 801c070:	4d0f      	ldr	r5, [pc, #60]	; (801c0b0 <Config_NotifyBLE+0xa0>)
 801c072:	f106 0720 	add.w	r7, r6, #32
 801c076:	4634      	mov	r4, r6
 801c078:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801c07a:	42bc      	cmp	r4, r7
 801c07c:	6028      	str	r0, [r5, #0]
 801c07e:	6069      	str	r1, [r5, #4]
 801c080:	60aa      	str	r2, [r5, #8]
 801c082:	60eb      	str	r3, [r5, #12]
 801c084:	4626      	mov	r6, r4
 801c086:	f105 0510 	add.w	r5, r5, #16
 801c08a:	d1f4      	bne.n	801c076 <Config_NotifyBLE+0x66>
 801c08c:	8833      	ldrh	r3, [r6, #0]
 801c08e:	4c09      	ldr	r4, [pc, #36]	; (801c0b4 <Config_NotifyBLE+0xa4>)
 801c090:	802b      	strh	r3, [r5, #0]
 801c092:	78b2      	ldrb	r2, [r6, #2]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c094:	4806      	ldr	r0, [pc, #24]	; (801c0b0 <Config_NotifyBLE+0xa0>)
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Configuration Char\n");
 801c096:	2322      	movs	r3, #34	; 0x22
 801c098:	6023      	str	r3, [r4, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c09a:	4619      	mov	r1, r3
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Configuration Char\n");
 801c09c:	70aa      	strb	r2, [r5, #2]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c09e:	f7ff fecb 	bl	801be38 <Stderr_Update>
    return BLE_STATUS_ERROR;
 801c0a2:	2047      	movs	r0, #71	; 0x47
 801c0a4:	e7e1      	b.n	801c06a <Config_NotifyBLE+0x5a>
 801c0a6:	bf00      	nop
 801c0a8:	20010030 	.word	0x20010030
 801c0ac:	0807592c 	.word	0x0807592c
 801c0b0:	20013174 	.word	0x20013174
 801c0b4:	200132a0 	.word	0x200132a0

0801c0b8 <AccEvent_Notify>:
{
 801c0b8:	b5f0      	push	{r4, r5, r6, r7, lr}
 801c0ba:	b085      	sub	sp, #20
 801c0bc:	4605      	mov	r5, r0
 801c0be:	460c      	mov	r4, r1
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c0c0:	f7f4 fa14 	bl	80104ec <HAL_GetTick>
 801c0c4:	08c0      	lsrs	r0, r0, #3
 801c0c6:	f88d 0008 	strb.w	r0, [sp, #8]
 801c0ca:	f7f4 fa0f 	bl	80104ec <HAL_GetTick>
  if(dimByte==3) {
 801c0ce:	2c03      	cmp	r4, #3
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c0d0:	ea4f 20d0 	mov.w	r0, r0, lsr #11
 801c0d4:	b2eb      	uxtb	r3, r5
 801c0d6:	f88d 0009 	strb.w	r0, [sp, #9]
 801c0da:	ea4f 2515 	mov.w	r5, r5, lsr #8
  if(dimByte==3) {
 801c0de:	d016      	beq.n	801c10e <AccEvent_Notify+0x56>
    STORE_LE_16(buff+2,Command);
 801c0e0:	f88d 300a 	strb.w	r3, [sp, #10]
 801c0e4:	f88d 500b 	strb.w	r5, [sp, #11]
  ret = aci_gatt_update_char_value(HWServW2STHandle, AccEventCharHandle, 0, 2+dimByte,buff);
 801c0e8:	4d1b      	ldr	r5, [pc, #108]	; (801c158 <AccEvent_Notify+0xa0>)
 801c0ea:	aa02      	add	r2, sp, #8
 801c0ec:	1ca3      	adds	r3, r4, #2
 801c0ee:	f8b5 1046 	ldrh.w	r1, [r5, #70]	; 0x46
 801c0f2:	f8b5 0044 	ldrh.w	r0, [r5, #68]	; 0x44
 801c0f6:	9200      	str	r2, [sp, #0]
 801c0f8:	b2db      	uxtb	r3, r3
 801c0fa:	2200      	movs	r2, #0
 801c0fc:	f7fc fc2c 	bl	8018958 <aci_gatt_update_char_value>
  if (ret != BLE_STATUS_SUCCESS){
 801c100:	b118      	cbz	r0, 801c10a <AccEvent_Notify+0x52>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801c102:	682b      	ldr	r3, [r5, #0]
 801c104:	065b      	lsls	r3, r3, #25
 801c106:	d40a      	bmi.n	801c11e <AccEvent_Notify+0x66>
    return BLE_STATUS_ERROR;
 801c108:	2047      	movs	r0, #71	; 0x47
}
 801c10a:	b005      	add	sp, #20
 801c10c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    buff[2]= 0;
 801c10e:	2200      	movs	r2, #0
    STORE_LE_16(buff+3,Command);
 801c110:	f88d 300b 	strb.w	r3, [sp, #11]
 801c114:	f88d 500c 	strb.w	r5, [sp, #12]
    buff[2]= 0;
 801c118:	f88d 200a 	strb.w	r2, [sp, #10]
 801c11c:	e7e4      	b.n	801c0e8 <AccEvent_Notify+0x30>
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating AccEvent_Notify Char\n");
 801c11e:	4e0f      	ldr	r6, [pc, #60]	; (801c15c <AccEvent_Notify+0xa4>)
 801c120:	4d0f      	ldr	r5, [pc, #60]	; (801c160 <AccEvent_Notify+0xa8>)
 801c122:	f106 0720 	add.w	r7, r6, #32
 801c126:	4634      	mov	r4, r6
 801c128:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801c12a:	42bc      	cmp	r4, r7
 801c12c:	6028      	str	r0, [r5, #0]
 801c12e:	6069      	str	r1, [r5, #4]
 801c130:	60aa      	str	r2, [r5, #8]
 801c132:	60eb      	str	r3, [r5, #12]
 801c134:	4626      	mov	r6, r4
 801c136:	f105 0510 	add.w	r5, r5, #16
 801c13a:	d1f4      	bne.n	801c126 <AccEvent_Notify+0x6e>
 801c13c:	6820      	ldr	r0, [r4, #0]
 801c13e:	7921      	ldrb	r1, [r4, #4]
 801c140:	4a08      	ldr	r2, [pc, #32]	; (801c164 <AccEvent_Notify+0xac>)
 801c142:	6028      	str	r0, [r5, #0]
 801c144:	2324      	movs	r3, #36	; 0x24
 801c146:	7129      	strb	r1, [r5, #4]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c148:	4805      	ldr	r0, [pc, #20]	; (801c160 <AccEvent_Notify+0xa8>)
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating AccEvent_Notify Char\n");
 801c14a:	6013      	str	r3, [r2, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c14c:	4619      	mov	r1, r3
 801c14e:	f7ff fe73 	bl	801be38 <Stderr_Update>
 801c152:	2047      	movs	r0, #71	; 0x47
 801c154:	e7d9      	b.n	801c10a <AccEvent_Notify+0x52>
 801c156:	bf00      	nop
 801c158:	20010030 	.word	0x20010030
 801c15c:	08075950 	.word	0x08075950
 801c160:	20013174 	.word	0x20013174
 801c164:	200132a0 	.word	0x200132a0

0801c168 <Add_HW_SW_ServW2ST_Service>:
{
 801c168:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if(TargetBoardFeatures.HandleGGComponent) {
 801c16c:	4c80      	ldr	r4, [pc, #512]	; (801c370 <Add_HW_SW_ServW2ST_Service+0x208>)
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE,
 801c16e:	4a81      	ldr	r2, [pc, #516]	; (801c374 <Add_HW_SW_ServW2ST_Service+0x20c>)
  if(TargetBoardFeatures.HandleGGComponent) {
 801c170:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  COPY_HW_SENS_W2ST_SERVICE_UUID(uuid);
 801c172:	4881      	ldr	r0, [pc, #516]	; (801c378 <Add_HW_SW_ServW2ST_Service+0x210>)
 801c174:	4d81      	ldr	r5, [pc, #516]	; (801c37c <Add_HW_SW_ServW2ST_Service+0x214>)
 801c176:	4e82      	ldr	r6, [pc, #520]	; (801c380 <Add_HW_SW_ServW2ST_Service+0x218>)
{
 801c178:	b08b      	sub	sp, #44	; 0x2c
  if(TargetBoardFeatures.HandleGGComponent) {
 801c17a:	2b00      	cmp	r3, #0
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE,
 801c17c:	9200      	str	r2, [sp, #0]
 801c17e:	bf14      	ite	ne
 801c180:	2319      	movne	r3, #25
 801c182:	2316      	moveq	r3, #22
  COPY_HW_SENS_W2ST_SERVICE_UUID(uuid);
 801c184:	2700      	movs	r7, #0
 801c186:	9007      	str	r0, [sp, #28]
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE,
 801c188:	a906      	add	r1, sp, #24
 801c18a:	2201      	movs	r2, #1
 801c18c:	2002      	movs	r0, #2
  COPY_HW_SENS_W2ST_SERVICE_UUID(uuid);
 801c18e:	9606      	str	r6, [sp, #24]
 801c190:	e9cd 5708 	strd	r5, r7, [sp, #32]
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE,
 801c194:	f7fc fb0c 	bl	80187b0 <aci_gatt_add_serv>
  if (ret != BLE_STATUS_SUCCESS) {
 801c198:	2800      	cmp	r0, #0
 801c19a:	d163      	bne.n	801c264 <Add_HW_SW_ServW2ST_Service+0xfc>
  if(TargetBoardFeatures.NumTempSensors==2) {
 801c19c:	6861      	ldr	r1, [r4, #4]
 801c19e:	4a79      	ldr	r2, [pc, #484]	; (801c384 <Add_HW_SW_ServW2ST_Service+0x21c>)
  COPY_ENVIRONMENTAL_W2ST_CHAR_UUID(uuid);
 801c1a0:	9508      	str	r5, [sp, #32]
  if(TargetBoardFeatures.NumTempSensors==2) {
 801c1a2:	2902      	cmp	r1, #2
  COPY_ENVIRONMENTAL_W2ST_CHAR_UUID(uuid);
 801c1a4:	4d78      	ldr	r5, [pc, #480]	; (801c388 <Add_HW_SW_ServW2ST_Service+0x220>)
 801c1a6:	9606      	str	r6, [sp, #24]
 801c1a8:	9009      	str	r0, [sp, #36]	; 0x24
 801c1aa:	7813      	ldrb	r3, [r2, #0]
 801c1ac:	9507      	str	r5, [sp, #28]
  if(TargetBoardFeatures.NumTempSensors==2) {
 801c1ae:	d008      	beq.n	801c1c2 <Add_HW_SW_ServW2ST_Service+0x5a>
  } else if(TargetBoardFeatures.NumTempSensors==1) {
 801c1b0:	2901      	cmp	r1, #1
 801c1b2:	d10c      	bne.n	801c1ce <Add_HW_SW_ServW2ST_Service+0x66>
    EnvironmentalCharSize+=2;
 801c1b4:	3302      	adds	r3, #2
 801c1b6:	b2db      	uxtb	r3, r3
    uuid[14] |= 0x04; /* One Temperature value*/
 801c1b8:	2104      	movs	r1, #4
    EnvironmentalCharSize+=2;
 801c1ba:	7013      	strb	r3, [r2, #0]
    uuid[14] |= 0x04; /* One Temperature value*/
 801c1bc:	f88d 1026 	strb.w	r1, [sp, #38]	; 0x26
 801c1c0:	e005      	b.n	801c1ce <Add_HW_SW_ServW2ST_Service+0x66>
    EnvironmentalCharSize+=2*2;
 801c1c2:	3304      	adds	r3, #4
 801c1c4:	b2db      	uxtb	r3, r3
    uuid[14] |= 0x05; /* Two Temperature values*/
 801c1c6:	2105      	movs	r1, #5
    EnvironmentalCharSize+=2*2;
 801c1c8:	7013      	strb	r3, [r2, #0]
    uuid[14] |= 0x05; /* Two Temperature values*/
 801c1ca:	f88d 1026 	strb.w	r1, [sp, #38]	; 0x26
  if(TargetBoardFeatures.HandleHumSensor) {
 801c1ce:	6961      	ldr	r1, [r4, #20]
 801c1d0:	b141      	cbz	r1, 801c1e4 <Add_HW_SW_ServW2ST_Service+0x7c>
   uuid[14] |= 0x08; /* Humidity */
 801c1d2:	f89d 1026 	ldrb.w	r1, [sp, #38]	; 0x26
   EnvironmentalCharSize+=2;
 801c1d6:	3302      	adds	r3, #2
 801c1d8:	b2db      	uxtb	r3, r3
   uuid[14] |= 0x08; /* Humidity */
 801c1da:	f041 0108 	orr.w	r1, r1, #8
   EnvironmentalCharSize+=2;
 801c1de:	7013      	strb	r3, [r2, #0]
   uuid[14] |= 0x08; /* Humidity */
 801c1e0:	f88d 1026 	strb.w	r1, [sp, #38]	; 0x26
  if(TargetBoardFeatures.HandlePressSensor) {
 801c1e4:	6921      	ldr	r1, [r4, #16]
 801c1e6:	b141      	cbz	r1, 801c1fa <Add_HW_SW_ServW2ST_Service+0x92>
    uuid[14] |= 0x10; /* Pressure value*/
 801c1e8:	f89d 1026 	ldrb.w	r1, [sp, #38]	; 0x26
    EnvironmentalCharSize+=4;
 801c1ec:	3304      	adds	r3, #4
 801c1ee:	b2db      	uxtb	r3, r3
    uuid[14] |= 0x10; /* Pressure value*/
 801c1f0:	f041 0110 	orr.w	r1, r1, #16
    EnvironmentalCharSize+=4;
 801c1f4:	7013      	strb	r3, [r2, #0]
    uuid[14] |= 0x10; /* Pressure value*/
 801c1f6:	f88d 1026 	strb.w	r1, [sp, #38]	; 0x26
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, EnvironmentalCharSize,
 801c1fa:	4d64      	ldr	r5, [pc, #400]	; (801c38c <Add_HW_SW_ServW2ST_Service+0x224>)
 801c1fc:	2200      	movs	r2, #0
 801c1fe:	f105 0148 	add.w	r1, r5, #72	; 0x48
 801c202:	2610      	movs	r6, #16
 801c204:	2704      	movs	r7, #4
 801c206:	f04f 0812 	mov.w	r8, #18
 801c20a:	f8b5 0044 	ldrh.w	r0, [r5, #68]	; 0x44
 801c20e:	9201      	str	r2, [sp, #4]
 801c210:	e9cd 2104 	strd	r2, r1, [sp, #16]
 801c214:	e9cd 7602 	strd	r7, r6, [sp, #8]
 801c218:	f8cd 8000 	str.w	r8, [sp]
 801c21c:	aa06      	add	r2, sp, #24
 801c21e:	2102      	movs	r1, #2
 801c220:	f7fc fb10 	bl	8018844 <aci_gatt_add_char>
  if (ret != BLE_STATUS_SUCCESS) {
 801c224:	b9f0      	cbnz	r0, 801c264 <Add_HW_SW_ServW2ST_Service+0xfc>
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+3*3*2,
 801c226:	f8b5 2044 	ldrh.w	r2, [r5, #68]	; 0x44
  COPY_ACC_GYRO_MAG_W2ST_CHAR_UUID(uuid);
 801c22a:	f8df a15c 	ldr.w	sl, [pc, #348]	; 801c388 <Add_HW_SW_ServW2ST_Service+0x220>
 801c22e:	f8df 914c 	ldr.w	r9, [pc, #332]	; 801c37c <Add_HW_SW_ServW2ST_Service+0x214>
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+3*3*2,
 801c232:	9004      	str	r0, [sp, #16]
 801c234:	f105 034a 	add.w	r3, r5, #74	; 0x4a
 801c238:	e9cd 6000 	strd	r6, r0, [sp]
 801c23c:	9305      	str	r3, [sp, #20]
 801c23e:	4610      	mov	r0, r2
  COPY_ACC_GYRO_MAG_W2ST_CHAR_UUID(uuid);
 801c240:	f8df b13c 	ldr.w	fp, [pc, #316]	; 801c380 <Add_HW_SW_ServW2ST_Service+0x218>
 801c244:	f8cd b018 	str.w	fp, [sp, #24]
 801c248:	f44f 0c60 	mov.w	ip, #14680064	; 0xe00000
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+3*3*2,
 801c24c:	e9cd 7602 	strd	r7, r6, [sp, #8]
 801c250:	2314      	movs	r3, #20
 801c252:	aa06      	add	r2, sp, #24
 801c254:	2102      	movs	r1, #2
  COPY_ACC_GYRO_MAG_W2ST_CHAR_UUID(uuid);
 801c256:	e9cd a907 	strd	sl, r9, [sp, #28]
 801c25a:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+3*3*2,
 801c25e:	f7fc faf1 	bl	8018844 <aci_gatt_add_char>
  if (ret != BLE_STATUS_SUCCESS) {
 801c262:	b118      	cbz	r0, 801c26c <Add_HW_SW_ServW2ST_Service+0x104>
  return BLE_STATUS_ERROR;
 801c264:	2047      	movs	r0, #71	; 0x47
}
 801c266:	b00b      	add	sp, #44	; 0x2c
 801c268:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+3, //2+2,
 801c26c:	f8b5 1044 	ldrh.w	r1, [r5, #68]	; 0x44
 801c270:	9603      	str	r6, [sp, #12]
 801c272:	f105 0246 	add.w	r2, r5, #70	; 0x46
 801c276:	2301      	movs	r3, #1
 801c278:	e9cd 3204 	strd	r3, r2, [sp, #16]
 801c27c:	e9cd 0701 	strd	r0, r7, [sp, #4]
  COPY_ACC_EVENT_W2ST_CHAR_UUID(uuid);
 801c280:	f44f 6c80 	mov.w	ip, #1024	; 0x400
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+3, //2+2,
 801c284:	4608      	mov	r0, r1
 801c286:	f8cd 8000 	str.w	r8, [sp]
 801c28a:	2305      	movs	r3, #5
 801c28c:	aa06      	add	r2, sp, #24
 801c28e:	2102      	movs	r1, #2
  COPY_ACC_EVENT_W2ST_CHAR_UUID(uuid);
 801c290:	e9cd ba06 	strd	fp, sl, [sp, #24]
 801c294:	e9cd 9c08 	strd	r9, ip, [sp, #32]
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+3, //2+2,
 801c298:	f7fc fad4 	bl	8018844 <aci_gatt_add_char>
  if (ret != BLE_STATUS_SUCCESS) {
 801c29c:	2800      	cmp	r0, #0
 801c29e:	d1e1      	bne.n	801c264 <Add_HW_SW_ServW2ST_Service+0xfc>
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid,2+AUDIO_CHANNELS,
 801c2a0:	f8b5 2044 	ldrh.w	r2, [r5, #68]	; 0x44
 801c2a4:	9004      	str	r0, [sp, #16]
 801c2a6:	f105 034c 	add.w	r3, r5, #76	; 0x4c
 801c2aa:	e9cd 6000 	strd	r6, r0, [sp]
 801c2ae:	9305      	str	r3, [sp, #20]
 801c2b0:	4610      	mov	r0, r2
  COPY_MIC_W2ST_CHAR_UUID(uuid);
 801c2b2:	f04f 6c80 	mov.w	ip, #67108864	; 0x4000000
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid,2+AUDIO_CHANNELS,
 801c2b6:	e9cd 7602 	strd	r7, r6, [sp, #8]
 801c2ba:	2303      	movs	r3, #3
 801c2bc:	aa06      	add	r2, sp, #24
 801c2be:	2102      	movs	r1, #2
  COPY_MIC_W2ST_CHAR_UUID(uuid);
 801c2c0:	e9cd ba06 	strd	fp, sl, [sp, #24]
 801c2c4:	e9cd 9c08 	strd	r9, ip, [sp, #32]
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid,2+AUDIO_CHANNELS,
 801c2c8:	f7fc fabc 	bl	8018844 <aci_gatt_add_char>
  if (ret != BLE_STATUS_SUCCESS) {
 801c2cc:	2800      	cmp	r0, #0
 801c2ce:	d1c9      	bne.n	801c264 <Add_HW_SW_ServW2ST_Service+0xfc>
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+1+1, /* 2 byte timestamp, 1 byte action, 1 byte algorithm */
 801c2d0:	f8b5 2044 	ldrh.w	r2, [r5, #68]	; 0x44
 801c2d4:	9004      	str	r0, [sp, #16]
 801c2d6:	f105 0342 	add.w	r3, r5, #66	; 0x42
 801c2da:	e9cd 8000 	strd	r8, r0, [sp]
 801c2de:	9305      	str	r3, [sp, #20]
 801c2e0:	4610      	mov	r0, r2
 801c2e2:	463b      	mov	r3, r7
 801c2e4:	e9cd 7602 	strd	r7, r6, [sp, #8]
 801c2e8:	aa06      	add	r2, sp, #24
 801c2ea:	2102      	movs	r1, #2
  COPY_ACTIVITY_REC_W2ST_CHAR_UUID(uuid);
 801c2ec:	e9cd ba06 	strd	fp, sl, [sp, #24]
 801c2f0:	e9cd 9608 	strd	r9, r6, [sp, #32]
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+1+1, /* 2 byte timestamp, 1 byte action, 1 byte algorithm */
 801c2f4:	f7fc faa6 	bl	8018844 <aci_gatt_add_char>
  if (ret != BLE_STATUS_SUCCESS) {
 801c2f8:	4603      	mov	r3, r0
 801c2fa:	2800      	cmp	r0, #0
 801c2fc:	d1b2      	bne.n	801c264 <Add_HW_SW_ServW2ST_Service+0xfc>
  if(TargetBoardFeatures.HandleGGComponent) {
 801c2fe:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 801c300:	f8b5 0044 	ldrh.w	r0, [r5, #68]	; 0x44
 801c304:	b1ba      	cbz	r2, 801c336 <Add_HW_SW_ServW2ST_Service+0x1ce>
    ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+2+2+2+1,
 801c306:	f105 024e 	add.w	r2, r5, #78	; 0x4e
 801c30a:	e9cd 6303 	strd	r6, r3, [sp, #12]
 801c30e:	e9cd 3701 	strd	r3, r7, [sp, #4]
 801c312:	9205      	str	r2, [sp, #20]
    COPY_GG_W2ST_CHAR_UUID(uuid);
 801c314:	f44f 3400 	mov.w	r4, #131072	; 0x20000
    ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+2+2+2+1,
 801c318:	f8cd 8000 	str.w	r8, [sp]
 801c31c:	2309      	movs	r3, #9
 801c31e:	aa06      	add	r2, sp, #24
 801c320:	2102      	movs	r1, #2
    COPY_GG_W2ST_CHAR_UUID(uuid);
 801c322:	e9cd ba06 	strd	fp, sl, [sp, #24]
 801c326:	e9cd 9408 	strd	r9, r4, [sp, #32]
    ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+2+2+2+1,
 801c32a:	f7fc fa8b 	bl	8018844 <aci_gatt_add_char>
    if (ret != BLE_STATUS_SUCCESS) {
 801c32e:	2800      	cmp	r0, #0
 801c330:	d198      	bne.n	801c264 <Add_HW_SW_ServW2ST_Service+0xfc>
 801c332:	f8b5 0044 	ldrh.w	r0, [r5, #68]	; 0x44
    ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 801c336:	4b16      	ldr	r3, [pc, #88]	; (801c390 <Add_HW_SW_ServW2ST_Service+0x228>)
 801c338:	9305      	str	r3, [sp, #20]
 801c33a:	2301      	movs	r3, #1
 801c33c:	2510      	movs	r5, #16
 801c33e:	2405      	movs	r4, #5
 801c340:	2100      	movs	r1, #0
 801c342:	9304      	str	r3, [sp, #16]
 801c344:	2314      	movs	r3, #20
 801c346:	e9cd 4502 	strd	r4, r5, [sp, #8]
 801c34a:	e9cd 3100 	strd	r3, r1, [sp]
    COPY_SDLOG_W2ST_CHAR_UUID(uuid);
 801c34e:	4c0c      	ldr	r4, [pc, #48]	; (801c380 <Add_HW_SW_ServW2ST_Service+0x218>)
 801c350:	490d      	ldr	r1, [pc, #52]	; (801c388 <Add_HW_SW_ServW2ST_Service+0x220>)
 801c352:	4d10      	ldr	r5, [pc, #64]	; (801c394 <Add_HW_SW_ServW2ST_Service+0x22c>)
 801c354:	9406      	str	r4, [sp, #24]
 801c356:	9107      	str	r1, [sp, #28]
 801c358:	2404      	movs	r4, #4
    ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 801c35a:	aa06      	add	r2, sp, #24
 801c35c:	2102      	movs	r1, #2
    COPY_SDLOG_W2ST_CHAR_UUID(uuid);
 801c35e:	e9cd 5408 	strd	r5, r4, [sp, #32]
    ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 801c362:	f7fc fa6f 	bl	8018844 <aci_gatt_add_char>
    if (ret != BLE_STATUS_SUCCESS) {
 801c366:	2800      	cmp	r0, #0
 801c368:	f43f af7d 	beq.w	801c266 <Add_HW_SW_ServW2ST_Service+0xfe>
fail:
 801c36c:	e77a      	b.n	801c264 <Add_HW_SW_ServW2ST_Service+0xfc>
 801c36e:	bf00      	nop
 801c370:	20011458 	.word	0x20011458
 801c374:	20010074 	.word	0x20010074
 801c378:	9ab40002 	.word	0x9ab40002
 801c37c:	000111e1 	.word	0x000111e1
 801c380:	a5d5c51b 	.word	0xa5d5c51b
 801c384:	2000154c 	.word	0x2000154c
 801c388:	ac360002 	.word	0xac360002
 801c38c:	20010030 	.word	0x20010030
 801c390:	20010080 	.word	0x20010080
 801c394:	000211e1 	.word	0x000211e1

0801c398 <AccGyroMag_Update>:
{
 801c398:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801c39c:	b089      	sub	sp, #36	; 0x24
 801c39e:	460e      	mov	r6, r1
 801c3a0:	4690      	mov	r8, r2
 801c3a2:	4607      	mov	r7, r0
  STORE_LE_16(buff   ,(HAL_GetTick()>>3));
 801c3a4:	f7f4 f8a2 	bl	80104ec <HAL_GetTick>
 801c3a8:	08c0      	lsrs	r0, r0, #3
 801c3aa:	f88d 000c 	strb.w	r0, [sp, #12]
 801c3ae:	f7f4 f89d 	bl	80104ec <HAL_GetTick>
  Gyro->AXIS_Z/=100;
 801c3b2:	e9d6 5401 	ldrd	r5, r4, [r6, #4]
  Gyro->AXIS_X/=100;
 801c3b6:	6833      	ldr	r3, [r6, #0]
 801c3b8:	4941      	ldr	r1, [pc, #260]	; (801c4c0 <AccGyroMag_Update+0x128>)
 801c3ba:	fb81 9e03 	smull	r9, lr, r1, r3
 801c3be:	17db      	asrs	r3, r3, #31
 801c3c0:	ebc3 136e 	rsb	r3, r3, lr, asr #5
  Gyro->AXIS_Y/=100;
 801c3c4:	fb81 9e05 	smull	r9, lr, r1, r5
  Gyro->AXIS_Z/=100;
 801c3c8:	fb81 9104 	smull	r9, r1, r1, r4
  Gyro->AXIS_Y/=100;
 801c3cc:	17ed      	asrs	r5, r5, #31
  Gyro->AXIS_Z/=100;
 801c3ce:	17e4      	asrs	r4, r4, #31
  STORE_LE_16(buff+4 ,Acc->AXIS_Y);
 801c3d0:	e9d7 c200 	ldrd	ip, r2, [r7]
  Gyro->AXIS_Y/=100;
 801c3d4:	ebc5 156e 	rsb	r5, r5, lr, asr #5
  Gyro->AXIS_Z/=100;
 801c3d8:	ebc4 1461 	rsb	r4, r4, r1, asr #5
  STORE_LE_16(buff+6 ,Acc->AXIS_Z);
 801c3dc:	68bf      	ldr	r7, [r7, #8]
  STORE_LE_16(buff+2 ,Acc->AXIS_X);
 801c3de:	f88d c00e 	strb.w	ip, [sp, #14]
  Gyro->AXIS_Z/=100;
 801c3e2:	e9c6 5401 	strd	r5, r4, [r6, #4]
  Gyro->AXIS_X/=100;
 801c3e6:	6033      	str	r3, [r6, #0]
  STORE_LE_16(buff   ,(HAL_GetTick()>>3));
 801c3e8:	0ac0      	lsrs	r0, r0, #11
  STORE_LE_16(buff+2 ,Acc->AXIS_X);
 801c3ea:	ea4f 2c2c 	mov.w	ip, ip, asr #8
  if (breath > 0) {
 801c3ee:	4e35      	ldr	r6, [pc, #212]	; (801c4c4 <AccGyroMag_Update+0x12c>)
  STORE_LE_16(buff+14, Mag->AXIS_X);
 801c3f0:	f8d8 1000 	ldr.w	r1, [r8]
  STORE_LE_16(buff+8 ,Gyro->AXIS_X);
 801c3f4:	f88d 3014 	strb.w	r3, [sp, #20]
  STORE_LE_16(buff   ,(HAL_GetTick()>>3));
 801c3f8:	f88d 000d 	strb.w	r0, [sp, #13]
  STORE_LE_16(buff+8 ,Gyro->AXIS_X);
 801c3fc:	121b      	asrs	r3, r3, #8
  STORE_LE_16(buff+2 ,Acc->AXIS_X);
 801c3fe:	f88d c00f 	strb.w	ip, [sp, #15]
  STORE_LE_16(buff+18, Mag->AXIS_Z);
 801c402:	e9d8 c001 	ldrd	ip, r0, [r8, #4]
  STORE_LE_16(buff+8 ,Gyro->AXIS_X);
 801c406:	f88d 3015 	strb.w	r3, [sp, #21]
  STORE_LE_16(buff+4 ,Acc->AXIS_Y);
 801c40a:	f88d 2010 	strb.w	r2, [sp, #16]
  if (breath > 0) {
 801c40e:	6873      	ldr	r3, [r6, #4]
  STORE_LE_16(buff+14, Mag->AXIS_X);
 801c410:	f88d 101a 	strb.w	r1, [sp, #26]
  STORE_LE_16(buff+4 ,Acc->AXIS_Y);
 801c414:	1212      	asrs	r2, r2, #8
  STORE_LE_16(buff+14, Mag->AXIS_X);
 801c416:	1209      	asrs	r1, r1, #8
  STORE_LE_16(buff+4 ,Acc->AXIS_Y);
 801c418:	f88d 2011 	strb.w	r2, [sp, #17]
  STORE_LE_16(buff+10,Gyro->AXIS_Y);
 801c41c:	122a      	asrs	r2, r5, #8
  STORE_LE_16(buff+6 ,Acc->AXIS_Z);
 801c41e:	f88d 7012 	strb.w	r7, [sp, #18]
  STORE_LE_16(buff+14, Mag->AXIS_X);
 801c422:	f88d 101b 	strb.w	r1, [sp, #27]
  STORE_LE_16(buff+6 ,Acc->AXIS_Z);
 801c426:	123f      	asrs	r7, r7, #8
  STORE_LE_16(buff+10,Gyro->AXIS_Y);
 801c428:	f88d 5016 	strb.w	r5, [sp, #22]
 801c42c:	f88d 2017 	strb.w	r2, [sp, #23]
  STORE_LE_16(buff+16, Mag->AXIS_Y);
 801c430:	ea4f 252c 	mov.w	r5, ip, asr #8
  STORE_LE_16(buff+18, Mag->AXIS_Z);
 801c434:	1201      	asrs	r1, r0, #8
  STORE_LE_16(buff+12,Gyro->AXIS_Z);
 801c436:	1222      	asrs	r2, r4, #8
  if (breath > 0) {
 801c438:	2b00      	cmp	r3, #0
  STORE_LE_16(buff+6 ,Acc->AXIS_Z);
 801c43a:	f88d 7013 	strb.w	r7, [sp, #19]
  STORE_LE_16(buff+16, Mag->AXIS_Y);
 801c43e:	f88d c01c 	strb.w	ip, [sp, #28]
 801c442:	f88d 501d 	strb.w	r5, [sp, #29]
  STORE_LE_16(buff+18, Mag->AXIS_Z);
 801c446:	f88d 001e 	strb.w	r0, [sp, #30]
 801c44a:	f88d 101f 	strb.w	r1, [sp, #31]
  STORE_LE_16(buff+12,Gyro->AXIS_Z);
 801c44e:	f88d 4018 	strb.w	r4, [sp, #24]
 801c452:	f88d 2019 	strb.w	r2, [sp, #25]
  if (breath > 0) {
 801c456:	dd24      	ble.n	801c4a2 <AccGyroMag_Update+0x10a>
    breath--;
 801c458:	3b01      	subs	r3, #1
 801c45a:	6073      	str	r3, [r6, #4]
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801c45c:	6833      	ldr	r3, [r6, #0]
 801c45e:	065b      	lsls	r3, r3, #25
 801c460:	d403      	bmi.n	801c46a <AccGyroMag_Update+0xd2>
    return BLE_STATUS_ERROR;
 801c462:	2047      	movs	r0, #71	; 0x47
}
 801c464:	b009      	add	sp, #36	; 0x24
 801c466:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Acc/Gyro/Mag Char\n");
 801c46a:	4e17      	ldr	r6, [pc, #92]	; (801c4c8 <AccGyroMag_Update+0x130>)
 801c46c:	4d17      	ldr	r5, [pc, #92]	; (801c4cc <AccGyroMag_Update+0x134>)
 801c46e:	f106 0720 	add.w	r7, r6, #32
 801c472:	4634      	mov	r4, r6
 801c474:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801c476:	42bc      	cmp	r4, r7
 801c478:	6028      	str	r0, [r5, #0]
 801c47a:	6069      	str	r1, [r5, #4]
 801c47c:	60aa      	str	r2, [r5, #8]
 801c47e:	60eb      	str	r3, [r5, #12]
 801c480:	4626      	mov	r6, r4
 801c482:	f105 0510 	add.w	r5, r5, #16
 801c486:	d1f4      	bne.n	801c472 <AccGyroMag_Update+0xda>
 801c488:	8823      	ldrh	r3, [r4, #0]
 801c48a:	802b      	strh	r3, [r5, #0]
 801c48c:	4a10      	ldr	r2, [pc, #64]	; (801c4d0 <AccGyroMag_Update+0x138>)
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c48e:	480f      	ldr	r0, [pc, #60]	; (801c4cc <AccGyroMag_Update+0x134>)
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Acc/Gyro/Mag Char\n");
 801c490:	2321      	movs	r3, #33	; 0x21
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c492:	4619      	mov	r1, r3
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Acc/Gyro/Mag Char\n");
 801c494:	6013      	str	r3, [r2, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c496:	f7ff fccf 	bl	801be38 <Stderr_Update>
    return BLE_STATUS_ERROR;
 801c49a:	2047      	movs	r0, #71	; 0x47
}
 801c49c:	b009      	add	sp, #36	; 0x24
 801c49e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    ret = aci_gatt_update_char_value(servHandle,charHandle,charValOffset,charValueLen,charValue);
 801c4a2:	ab03      	add	r3, sp, #12
 801c4a4:	f8b6 104a 	ldrh.w	r1, [r6, #74]	; 0x4a
 801c4a8:	f8b6 0044 	ldrh.w	r0, [r6, #68]	; 0x44
 801c4ac:	9300      	str	r3, [sp, #0]
 801c4ae:	2200      	movs	r2, #0
 801c4b0:	2314      	movs	r3, #20
 801c4b2:	f7fc fa51 	bl	8018958 <aci_gatt_update_char_value>
    if (ret != BLE_STATUS_SUCCESS){
 801c4b6:	2800      	cmp	r0, #0
 801c4b8:	d0d4      	beq.n	801c464 <AccGyroMag_Update+0xcc>
      breath = ACC_BLUENRG_CONGESTION_SKIP;
 801c4ba:	231e      	movs	r3, #30
 801c4bc:	6073      	str	r3, [r6, #4]
 801c4be:	e7cd      	b.n	801c45c <AccGyroMag_Update+0xc4>
 801c4c0:	51eb851f 	.word	0x51eb851f
 801c4c4:	20010030 	.word	0x20010030
 801c4c8:	08075978 	.word	0x08075978
 801c4cc:	20013174 	.word	0x20013174
 801c4d0:	200132a0 	.word	0x200132a0

0801c4d4 <Environmental_Update>:
{
 801c4d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801c4d8:	b086      	sub	sp, #24
 801c4da:	4698      	mov	r8, r3
 801c4dc:	460e      	mov	r6, r1
 801c4de:	4617      	mov	r7, r2
 801c4e0:	4604      	mov	r4, r0
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c4e2:	f7f4 f803 	bl	80104ec <HAL_GetTick>
 801c4e6:	08c0      	lsrs	r0, r0, #3
 801c4e8:	f88d 000c 	strb.w	r0, [sp, #12]
  if(TargetBoardFeatures.HandlePressSensor) {
 801c4ec:	4d38      	ldr	r5, [pc, #224]	; (801c5d0 <Environmental_Update+0xfc>)
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c4ee:	f7f3 fffd 	bl	80104ec <HAL_GetTick>
  if(TargetBoardFeatures.HandlePressSensor) {
 801c4f2:	692b      	ldr	r3, [r5, #16]
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c4f4:	0ac0      	lsrs	r0, r0, #11
 801c4f6:	f88d 000d 	strb.w	r0, [sp, #13]
  if(TargetBoardFeatures.HandlePressSensor) {
 801c4fa:	2b00      	cmp	r3, #0
 801c4fc:	d049      	beq.n	801c592 <Environmental_Update+0xbe>
    STORE_LE_32(buff+BuffPos,Press);
 801c4fe:	1222      	asrs	r2, r4, #8
 801c500:	1423      	asrs	r3, r4, #16
 801c502:	f88d 400e 	strb.w	r4, [sp, #14]
 801c506:	1624      	asrs	r4, r4, #24
 801c508:	f88d 200f 	strb.w	r2, [sp, #15]
 801c50c:	f88d 3010 	strb.w	r3, [sp, #16]
 801c510:	f88d 4011 	strb.w	r4, [sp, #17]
    BuffPos+=4;
 801c514:	2006      	movs	r0, #6
  if(TargetBoardFeatures.HandleHumSensor) {
 801c516:	696b      	ldr	r3, [r5, #20]
 801c518:	b143      	cbz	r3, 801c52c <Environmental_Update+0x58>
    STORE_LE_16(buff+BuffPos,Hum);
 801c51a:	ab06      	add	r3, sp, #24
 801c51c:	4403      	add	r3, r0
 801c51e:	0a32      	lsrs	r2, r6, #8
    BuffPos+=2;
 801c520:	3002      	adds	r0, #2
    STORE_LE_16(buff+BuffPos,Hum);
 801c522:	f803 6c0c 	strb.w	r6, [r3, #-12]
 801c526:	f803 2c0b 	strb.w	r2, [r3, #-11]
    BuffPos+=2;
 801c52a:	b2c0      	uxtb	r0, r0
  if(TargetBoardFeatures.NumTempSensors==2) {
 801c52c:	6869      	ldr	r1, [r5, #4]
 801c52e:	2902      	cmp	r1, #2
 801c530:	d01e      	beq.n	801c570 <Environmental_Update+0x9c>
  } else if(TargetBoardFeatures.NumTempSensors==1) {
 801c532:	2901      	cmp	r1, #1
 801c534:	d013      	beq.n	801c55e <Environmental_Update+0x8a>
  ret = aci_gatt_update_char_value(HWServW2STHandle, EnvironmentalCharHandle, 0, EnvironmentalCharSize,buff);
 801c536:	4c27      	ldr	r4, [pc, #156]	; (801c5d4 <Environmental_Update+0x100>)
 801c538:	4b27      	ldr	r3, [pc, #156]	; (801c5d8 <Environmental_Update+0x104>)
 801c53a:	f8b4 1048 	ldrh.w	r1, [r4, #72]	; 0x48
 801c53e:	781b      	ldrb	r3, [r3, #0]
 801c540:	f8b4 0044 	ldrh.w	r0, [r4, #68]	; 0x44
 801c544:	aa03      	add	r2, sp, #12
 801c546:	9200      	str	r2, [sp, #0]
 801c548:	2200      	movs	r2, #0
 801c54a:	f7fc fa05 	bl	8018958 <aci_gatt_update_char_value>
  if (ret != BLE_STATUS_SUCCESS){
 801c54e:	b118      	cbz	r0, 801c558 <Environmental_Update+0x84>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801c550:	6823      	ldr	r3, [r4, #0]
 801c552:	065b      	lsls	r3, r3, #25
 801c554:	d41f      	bmi.n	801c596 <Environmental_Update+0xc2>
    return BLE_STATUS_ERROR;
 801c556:	2047      	movs	r0, #71	; 0x47
}
 801c558:	b006      	add	sp, #24
 801c55a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    STORE_LE_16(buff+BuffPos,Temp1);
 801c55e:	ab06      	add	r3, sp, #24
 801c560:	4418      	add	r0, r3
 801c562:	ea4f 2328 	mov.w	r3, r8, asr #8
 801c566:	f800 8c0c 	strb.w	r8, [r0, #-12]
 801c56a:	f800 3c0b 	strb.w	r3, [r0, #-11]
 801c56e:	e7e2      	b.n	801c536 <Environmental_Update+0x62>
    STORE_LE_16(buff+BuffPos,Temp1);
 801c570:	aa06      	add	r2, sp, #24
    BuffPos+=2;
 801c572:	1c83      	adds	r3, r0, #2
    STORE_LE_16(buff+BuffPos,Temp1);
 801c574:	fa52 f383 	uxtab	r3, r2, r3
    STORE_LE_16(buff+BuffPos,Temp2);
 801c578:	4410      	add	r0, r2
 801c57a:	1239      	asrs	r1, r7, #8
    STORE_LE_16(buff+BuffPos,Temp1);
 801c57c:	ea4f 2228 	mov.w	r2, r8, asr #8
    STORE_LE_16(buff+BuffPos,Temp2);
 801c580:	f800 7c0c 	strb.w	r7, [r0, #-12]
 801c584:	f800 1c0b 	strb.w	r1, [r0, #-11]
    STORE_LE_16(buff+BuffPos,Temp1);
 801c588:	f803 8c0c 	strb.w	r8, [r3, #-12]
 801c58c:	f803 2c0b 	strb.w	r2, [r3, #-11]
 801c590:	e7d1      	b.n	801c536 <Environmental_Update+0x62>
  BuffPos=2;
 801c592:	2002      	movs	r0, #2
 801c594:	e7bf      	b.n	801c516 <Environmental_Update+0x42>
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Environmental Char\n");
 801c596:	4e11      	ldr	r6, [pc, #68]	; (801c5dc <Environmental_Update+0x108>)
 801c598:	4d11      	ldr	r5, [pc, #68]	; (801c5e0 <Environmental_Update+0x10c>)
 801c59a:	f106 0720 	add.w	r7, r6, #32
 801c59e:	4634      	mov	r4, r6
 801c5a0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801c5a2:	42bc      	cmp	r4, r7
 801c5a4:	6028      	str	r0, [r5, #0]
 801c5a6:	6069      	str	r1, [r5, #4]
 801c5a8:	60aa      	str	r2, [r5, #8]
 801c5aa:	60eb      	str	r3, [r5, #12]
 801c5ac:	4626      	mov	r6, r4
 801c5ae:	f105 0510 	add.w	r5, r5, #16
 801c5b2:	d1f4      	bne.n	801c59e <Environmental_Update+0xca>
 801c5b4:	8833      	ldrh	r3, [r6, #0]
 801c5b6:	4c0b      	ldr	r4, [pc, #44]	; (801c5e4 <Environmental_Update+0x110>)
 801c5b8:	802b      	strh	r3, [r5, #0]
 801c5ba:	78b2      	ldrb	r2, [r6, #2]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c5bc:	4808      	ldr	r0, [pc, #32]	; (801c5e0 <Environmental_Update+0x10c>)
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Environmental Char\n");
 801c5be:	2322      	movs	r3, #34	; 0x22
 801c5c0:	6023      	str	r3, [r4, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c5c2:	4619      	mov	r1, r3
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Environmental Char\n");
 801c5c4:	70aa      	strb	r2, [r5, #2]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c5c6:	f7ff fc37 	bl	801be38 <Stderr_Update>
    return BLE_STATUS_ERROR;
 801c5ca:	2047      	movs	r0, #71	; 0x47
 801c5cc:	e7c4      	b.n	801c558 <Environmental_Update+0x84>
 801c5ce:	bf00      	nop
 801c5d0:	20011458 	.word	0x20011458
 801c5d4:	20010030 	.word	0x20010030
 801c5d8:	2000154c 	.word	0x2000154c
 801c5dc:	0807599c 	.word	0x0807599c
 801c5e0:	20013174 	.word	0x20013174
 801c5e4:	200132a0 	.word	0x200132a0

0801c5e8 <AudioLevel_Update>:
{
 801c5e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 801c5ea:	b085      	sub	sp, #20
 801c5ec:	4605      	mov	r5, r0
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c5ee:	f7f3 ff7d 	bl	80104ec <HAL_GetTick>
  if (breath > 0) {
 801c5f2:	4c1e      	ldr	r4, [pc, #120]	; (801c66c <AudioLevel_Update+0x84>)
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c5f4:	08c0      	lsrs	r0, r0, #3
 801c5f6:	f88d 000c 	strb.w	r0, [sp, #12]
 801c5fa:	f7f3 ff77 	bl	80104ec <HAL_GetTick>
  if (breath > 0) {
 801c5fe:	6863      	ldr	r3, [r4, #4]
    buff[2+Counter]= Mic[Counter]&0xFF;
 801c600:	882a      	ldrh	r2, [r5, #0]
 801c602:	f88d 200e 	strb.w	r2, [sp, #14]
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c606:	0ac0      	lsrs	r0, r0, #11
  if (breath > 0) {
 801c608:	2b00      	cmp	r3, #0
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c60a:	f88d 000d 	strb.w	r0, [sp, #13]
  if (breath > 0) {
 801c60e:	dd1d      	ble.n	801c64c <AudioLevel_Update+0x64>
    breath--;
 801c610:	3b01      	subs	r3, #1
 801c612:	6063      	str	r3, [r4, #4]
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801c614:	6823      	ldr	r3, [r4, #0]
 801c616:	065b      	lsls	r3, r3, #25
 801c618:	d402      	bmi.n	801c620 <AudioLevel_Update+0x38>
    return BLE_STATUS_ERROR;
 801c61a:	2047      	movs	r0, #71	; 0x47
}
 801c61c:	b005      	add	sp, #20
 801c61e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      BytesToWrite = sprintf((char *)BufferToWrite, "Error Updating Mic Char\n");
 801c620:	4c13      	ldr	r4, [pc, #76]	; (801c670 <AudioLevel_Update+0x88>)
 801c622:	4d14      	ldr	r5, [pc, #80]	; (801c674 <AudioLevel_Update+0x8c>)
 801c624:	4f14      	ldr	r7, [pc, #80]	; (801c678 <AudioLevel_Update+0x90>)
 801c626:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801c628:	6028      	str	r0, [r5, #0]
 801c62a:	6069      	str	r1, [r5, #4]
 801c62c:	cc03      	ldmia	r4!, {r0, r1}
 801c62e:	2618      	movs	r6, #24
 801c630:	7824      	ldrb	r4, [r4, #0]
 801c632:	6128      	str	r0, [r5, #16]
 801c634:	6169      	str	r1, [r5, #20]
 801c636:	60aa      	str	r2, [r5, #8]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c638:	4628      	mov	r0, r5
 801c63a:	4631      	mov	r1, r6
      BytesToWrite = sprintf((char *)BufferToWrite, "Error Updating Mic Char\n");
 801c63c:	60eb      	str	r3, [r5, #12]
 801c63e:	762c      	strb	r4, [r5, #24]
 801c640:	603e      	str	r6, [r7, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c642:	f7ff fbf9 	bl	801be38 <Stderr_Update>
    return BLE_STATUS_ERROR;
 801c646:	2047      	movs	r0, #71	; 0x47
}
 801c648:	b005      	add	sp, #20
 801c64a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ret = aci_gatt_update_char_value(servHandle,charHandle,charValOffset,charValueLen,charValue);
 801c64c:	ab03      	add	r3, sp, #12
 801c64e:	f8b4 104c 	ldrh.w	r1, [r4, #76]	; 0x4c
 801c652:	f8b4 0044 	ldrh.w	r0, [r4, #68]	; 0x44
 801c656:	9300      	str	r3, [sp, #0]
 801c658:	2200      	movs	r2, #0
 801c65a:	2303      	movs	r3, #3
 801c65c:	f7fc f97c 	bl	8018958 <aci_gatt_update_char_value>
    if (ret != BLE_STATUS_SUCCESS){
 801c660:	2800      	cmp	r0, #0
 801c662:	d0db      	beq.n	801c61c <AudioLevel_Update+0x34>
      breath = ACC_BLUENRG_CONGESTION_SKIP;
 801c664:	231e      	movs	r3, #30
 801c666:	6063      	str	r3, [r4, #4]
 801c668:	e7d4      	b.n	801c614 <AudioLevel_Update+0x2c>
 801c66a:	bf00      	nop
 801c66c:	20010030 	.word	0x20010030
 801c670:	080759c0 	.word	0x080759c0
 801c674:	20013174 	.word	0x20013174
 801c678:	200132a0 	.word	0x200132a0

0801c67c <GG_Update>:
{
 801c67c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801c67e:	b087      	sub	sp, #28
 801c680:	460e      	mov	r6, r1
 801c682:	4615      	mov	r5, r2
 801c684:	4604      	mov	r4, r0
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c686:	f7f3 ff31 	bl	80104ec <HAL_GetTick>
 801c68a:	08c0      	lsrs	r0, r0, #3
 801c68c:	f88d 000c 	strb.w	r0, [sp, #12]
 801c690:	f7f3 ff2c 	bl	80104ec <HAL_GetTick>
  STORE_LE_16(buff+2,soc*10);
 801c694:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 801c698:	005b      	lsls	r3, r3, #1
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c69a:	0ac0      	lsrs	r0, r0, #11
  STORE_LE_16(buff+4,voltage);
 801c69c:	0a37      	lsrs	r7, r6, #8
  STORE_LE_16(buff+2,soc*10);
 801c69e:	0a19      	lsrs	r1, r3, #8
  STORE_LE_16(buff+6,current);
 801c6a0:	122a      	asrs	r2, r5, #8
  if(soc<15) {
 801c6a2:	2c0e      	cmp	r4, #14
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c6a4:	f88d 000d 	strb.w	r0, [sp, #13]
  STORE_LE_16(buff+4,voltage);
 801c6a8:	f88d 6010 	strb.w	r6, [sp, #16]
 801c6ac:	f88d 7011 	strb.w	r7, [sp, #17]
  STORE_LE_16(buff+6,current);
 801c6b0:	f88d 5012 	strb.w	r5, [sp, #18]
  STORE_LE_16(buff+2,soc*10);
 801c6b4:	f88d 300e 	strb.w	r3, [sp, #14]
 801c6b8:	f88d 100f 	strb.w	r1, [sp, #15]
  STORE_LE_16(buff+6,current);
 801c6bc:	f88d 2013 	strb.w	r2, [sp, #19]
  if(soc<15) {
 801c6c0:	d814      	bhi.n	801c6ec <GG_Update+0x70>
    buff[8] = 0x00; /* Low Battery */
 801c6c2:	2300      	movs	r3, #0
 801c6c4:	f88d 3014 	strb.w	r3, [sp, #20]
  ret = aci_gatt_update_char_value(HWServW2STHandle, BatteryFeaturesCharHandle, 0, 2+2+2+2+1,buff);
 801c6c8:	4c17      	ldr	r4, [pc, #92]	; (801c728 <GG_Update+0xac>)
 801c6ca:	ab03      	add	r3, sp, #12
 801c6cc:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
 801c6d0:	f8b4 0044 	ldrh.w	r0, [r4, #68]	; 0x44
 801c6d4:	9300      	str	r3, [sp, #0]
 801c6d6:	2200      	movs	r2, #0
 801c6d8:	2309      	movs	r3, #9
 801c6da:	f7fc f93d 	bl	8018958 <aci_gatt_update_char_value>
  if (ret != BLE_STATUS_SUCCESS){
 801c6de:	b118      	cbz	r0, 801c6e8 <GG_Update+0x6c>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801c6e0:	6823      	ldr	r3, [r4, #0]
 801c6e2:	065b      	lsls	r3, r3, #25
 801c6e4:	d40b      	bmi.n	801c6fe <GG_Update+0x82>
    return BLE_STATUS_ERROR;
 801c6e6:	2047      	movs	r0, #71	; 0x47
}
 801c6e8:	b007      	add	sp, #28
 801c6ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(current <= 0) {
 801c6ec:	2d00      	cmp	r5, #0
      Status = 0x01; /* Discharging */
 801c6ee:	4a0f      	ldr	r2, [pc, #60]	; (801c72c <GG_Update+0xb0>)
 801c6f0:	bfd4      	ite	le
 801c6f2:	2301      	movle	r3, #1
      Status = 0x03; /* Charging */
 801c6f4:	2303      	movgt	r3, #3
 801c6f6:	6053      	str	r3, [r2, #4]
    buff[8] = Status;
 801c6f8:	f88d 3014 	strb.w	r3, [sp, #20]
 801c6fc:	e7e4      	b.n	801c6c8 <GG_Update+0x4c>
      BytesToWrite = sprintf((char *)BufferToWrite, "Error Updating GG Char\n");
 801c6fe:	4c0c      	ldr	r4, [pc, #48]	; (801c730 <GG_Update+0xb4>)
 801c700:	4d0c      	ldr	r5, [pc, #48]	; (801c734 <GG_Update+0xb8>)
 801c702:	4e0d      	ldr	r6, [pc, #52]	; (801c738 <GG_Update+0xbc>)
 801c704:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801c706:	6028      	str	r0, [r5, #0]
 801c708:	6069      	str	r1, [r5, #4]
 801c70a:	cc03      	ldmia	r4!, {r0, r1}
 801c70c:	2417      	movs	r4, #23
 801c70e:	6128      	str	r0, [r5, #16]
 801c710:	6169      	str	r1, [r5, #20]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c712:	4628      	mov	r0, r5
 801c714:	4621      	mov	r1, r4
      BytesToWrite = sprintf((char *)BufferToWrite, "Error Updating GG Char\n");
 801c716:	60aa      	str	r2, [r5, #8]
 801c718:	60eb      	str	r3, [r5, #12]
 801c71a:	6034      	str	r4, [r6, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801c71c:	f7ff fb8c 	bl	801be38 <Stderr_Update>
    return BLE_STATUS_ERROR;
 801c720:	2047      	movs	r0, #71	; 0x47
}
 801c722:	b007      	add	sp, #28
 801c724:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801c726:	bf00      	nop
 801c728:	20010030 	.word	0x20010030
 801c72c:	2000154c 	.word	0x2000154c
 801c730:	080759dc 	.word	0x080759dc
 801c734:	20013174 	.word	0x20013174
 801c738:	200132a0 	.word	0x200132a0

0801c73c <SDLog_Update>:
    {
 801c73c:	b570      	push	{r4, r5, r6, lr}
 801c73e:	b084      	sub	sp, #16
 801c740:	4605      	mov	r5, r0
      STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c742:	f7f3 fed3 	bl	80104ec <HAL_GetTick>
      ret = aci_gatt_update_char_value(HWServW2STHandle, SDLogFeaturesCharHandle, 0, 3,buff);
 801c746:	4c19      	ldr	r4, [pc, #100]	; (801c7ac <SDLog_Update+0x70>)
      STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c748:	08c0      	lsrs	r0, r0, #3
 801c74a:	f88d 000c 	strb.w	r0, [sp, #12]
 801c74e:	f7f3 fecd 	bl	80104ec <HAL_GetTick>
      ret = aci_gatt_update_char_value(HWServW2STHandle, SDLogFeaturesCharHandle, 0, 3,buff);
 801c752:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
 801c756:	f8b4 1050 	ldrh.w	r1, [r4, #80]	; 0x50
      buff[2] = ErrorCode;
 801c75a:	f88d 500e 	strb.w	r5, [sp, #14]
      ret = aci_gatt_update_char_value(HWServW2STHandle, SDLogFeaturesCharHandle, 0, 3,buff);
 801c75e:	ab03      	add	r3, sp, #12
      STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c760:	0ac5      	lsrs	r5, r0, #11
      ret = aci_gatt_update_char_value(HWServW2STHandle, SDLogFeaturesCharHandle, 0, 3,buff);
 801c762:	9300      	str	r3, [sp, #0]
 801c764:	4610      	mov	r0, r2
 801c766:	2303      	movs	r3, #3
 801c768:	2200      	movs	r2, #0
      STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 801c76a:	f88d 500d 	strb.w	r5, [sp, #13]
      ret = aci_gatt_update_char_value(HWServW2STHandle, SDLogFeaturesCharHandle, 0, 3,buff);
 801c76e:	f7fc f8f3 	bl	8018958 <aci_gatt_update_char_value>
      if (ret != BLE_STATUS_SUCCESS){
 801c772:	b118      	cbz	r0, 801c77c <SDLog_Update+0x40>
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801c774:	6823      	ldr	r3, [r4, #0]
 801c776:	065b      	lsls	r3, r3, #25
 801c778:	d402      	bmi.n	801c780 <SDLog_Update+0x44>
        return BLE_STATUS_ERROR;
 801c77a:	2047      	movs	r0, #71	; 0x47
    }
 801c77c:	b004      	add	sp, #16
 801c77e:	bd70      	pop	{r4, r5, r6, pc}
          BytesToWrite = sprintf((char *)BufferToWrite, "Error Updating SD Log Char\n");
 801c780:	4c0b      	ldr	r4, [pc, #44]	; (801c7b0 <SDLog_Update+0x74>)
 801c782:	4d0c      	ldr	r5, [pc, #48]	; (801c7b4 <SDLog_Update+0x78>)
 801c784:	4e0c      	ldr	r6, [pc, #48]	; (801c7b8 <SDLog_Update+0x7c>)
 801c786:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801c788:	6028      	str	r0, [r5, #0]
 801c78a:	6069      	str	r1, [r5, #4]
 801c78c:	60aa      	str	r2, [r5, #8]
 801c78e:	cc07      	ldmia	r4!, {r0, r1, r2}
 801c790:	241b      	movs	r4, #27
 801c792:	6128      	str	r0, [r5, #16]
 801c794:	6169      	str	r1, [r5, #20]
          Stderr_Update(BufferToWrite,BytesToWrite);
 801c796:	4628      	mov	r0, r5
 801c798:	4621      	mov	r1, r4
          BytesToWrite = sprintf((char *)BufferToWrite, "Error Updating SD Log Char\n");
 801c79a:	60eb      	str	r3, [r5, #12]
 801c79c:	61aa      	str	r2, [r5, #24]
 801c79e:	6034      	str	r4, [r6, #0]
          Stderr_Update(BufferToWrite,BytesToWrite);
 801c7a0:	f7ff fb4a 	bl	801be38 <Stderr_Update>
 801c7a4:	2047      	movs	r0, #71	; 0x47
    }
 801c7a6:	b004      	add	sp, #16
 801c7a8:	bd70      	pop	{r4, r5, r6, pc}
 801c7aa:	bf00      	nop
 801c7ac:	20010030 	.word	0x20010030
 801c7b0:	080759f4 	.word	0x080759f4
 801c7b4:	20013174 	.word	0x20013174
 801c7b8:	200132a0 	.word	0x200132a0

0801c7bc <setConnectable>:
{
 801c7bc:	b530      	push	{r4, r5, lr}
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 801c7be:	4b48      	ldr	r3, [pc, #288]	; (801c8e0 <setConnectable+0x124>)
  manuf_data[20] = bdaddr[5];
 801c7c0:	4a48      	ldr	r2, [pc, #288]	; (801c8e4 <setConnectable+0x128>)
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 801c7c2:	789c      	ldrb	r4, [r3, #2]
 801c7c4:	785d      	ldrb	r5, [r3, #1]
 801c7c6:	78d8      	ldrb	r0, [r3, #3]
  if(TargetBoardFeatures.HandleGGComponent){
 801c7c8:	4947      	ldr	r1, [pc, #284]	; (801c8e8 <setConnectable+0x12c>)
{
 801c7ca:	b093      	sub	sp, #76	; 0x4c
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 801c7cc:	f88d 4026 	strb.w	r4, [sp, #38]	; 0x26
  uint8_t manuf_data[26] = {
 801c7d0:	f88d 4032 	strb.w	r4, [sp, #50]	; 0x32
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 801c7d4:	795c      	ldrb	r4, [r3, #5]
 801c7d6:	f88d 5025 	strb.w	r5, [sp, #37]	; 0x25
  uint8_t manuf_data[26] = {
 801c7da:	f88d 5031 	strb.w	r5, [sp, #49]	; 0x31
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 801c7de:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
 801c7e2:	791d      	ldrb	r5, [r3, #4]
  uint8_t manuf_data[26] = {
 801c7e4:	f88d 0033 	strb.w	r0, [sp, #51]	; 0x33
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 801c7e8:	f88d 4029 	strb.w	r4, [sp, #41]	; 0x29
 801c7ec:	7998      	ldrb	r0, [r3, #6]
  uint8_t manuf_data[26] = {
 801c7ee:	f88d 4035 	strb.w	r4, [sp, #53]	; 0x35
  manuf_data[21] = bdaddr[4];
 801c7f2:	7914      	ldrb	r4, [r2, #4]
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 801c7f4:	79db      	ldrb	r3, [r3, #7]
 801c7f6:	f88d 5028 	strb.w	r5, [sp, #40]	; 0x28
  uint8_t manuf_data[26] = {
 801c7fa:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 801c7fe:	f88d 002a 	strb.w	r0, [sp, #42]	; 0x2a
  manuf_data[20] = bdaddr[5];
 801c802:	7955      	ldrb	r5, [r2, #5]
  uint8_t manuf_data[26] = {
 801c804:	f88d 0036 	strb.w	r0, [sp, #54]	; 0x36
  manuf_data[21] = bdaddr[4];
 801c808:	f88d 4041 	strb.w	r4, [sp, #65]	; 0x41
  manuf_data[22] = bdaddr[3];
 801c80c:	78d0      	ldrb	r0, [r2, #3]
  uint8_t manuf_data[26] = {
 801c80e:	4c37      	ldr	r4, [pc, #220]	; (801c8ec <setConnectable+0x130>)
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 801c810:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
  uint8_t manuf_data[26] = {
 801c814:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
  manuf_data[20] = bdaddr[5];
 801c818:	f88d 5040 	strb.w	r5, [sp, #64]	; 0x40
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 801c81c:	2309      	movs	r3, #9
  manuf_data[22] = bdaddr[3];
 801c81e:	f88d 0042 	strb.w	r0, [sp, #66]	; 0x42
  uint8_t manuf_data[26] = {
 801c822:	4d33      	ldr	r5, [pc, #204]	; (801c8f0 <setConnectable+0x134>)
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 801c824:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
  uint8_t manuf_data[26] = {
 801c828:	f44f 4060 	mov.w	r0, #57344	; 0xe000
 801c82c:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
 801c830:	950b      	str	r5, [sp, #44]	; 0x2c
 801c832:	e9cd 400e 	strd	r4, r0, [sp, #56]	; 0x38
  if(TargetBoardFeatures.HandleGGComponent){
 801c836:	6b8b      	ldr	r3, [r1, #56]	; 0x38
  manuf_data[23] = bdaddr[2];
 801c838:	7894      	ldrb	r4, [r2, #2]
  manuf_data[24] = bdaddr[1];
 801c83a:	7850      	ldrb	r0, [r2, #1]
  manuf_data[25] = bdaddr[0];
 801c83c:	7812      	ldrb	r2, [r2, #0]
  manuf_data[23] = bdaddr[2];
 801c83e:	f88d 4043 	strb.w	r4, [sp, #67]	; 0x43
  manuf_data[24] = bdaddr[1];
 801c842:	f88d 0044 	strb.w	r0, [sp, #68]	; 0x44
  manuf_data[25] = bdaddr[0];
 801c846:	f88d 2045 	strb.w	r2, [sp, #69]	; 0x45
  if(TargetBoardFeatures.HandleGGComponent){
 801c84a:	b113      	cbz	r3, 801c852 <setConnectable+0x96>
    manuf_data[17] |= 0x02; /* Battery Present */
 801c84c:	23e2      	movs	r3, #226	; 0xe2
 801c84e:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
  if(TargetBoardFeatures.NumTempSensors==2) {
 801c852:	684b      	ldr	r3, [r1, #4]
  manuf_data[16] |= 0x04; /* Mic */
 801c854:	2204      	movs	r2, #4
  if(TargetBoardFeatures.NumTempSensors==2) {
 801c856:	2b02      	cmp	r3, #2
  manuf_data[16] |= 0x04; /* Mic */
 801c858:	f88d 203c 	strb.w	r2, [sp, #60]	; 0x3c
  if(TargetBoardFeatures.NumTempSensors==2) {
 801c85c:	d039      	beq.n	801c8d2 <setConnectable+0x116>
  } else if(TargetBoardFeatures.NumTempSensors==1) {
 801c85e:	2b01      	cmp	r3, #1
 801c860:	d030      	beq.n	801c8c4 <setConnectable+0x108>
  if(TargetBoardFeatures.HandleHumSensor) {
 801c862:	694b      	ldr	r3, [r1, #20]
 801c864:	b12b      	cbz	r3, 801c872 <setConnectable+0xb6>
    manuf_data[17] |= 0x08; /* Humidity */
 801c866:	f89d 303d 	ldrb.w	r3, [sp, #61]	; 0x3d
 801c86a:	f043 0308 	orr.w	r3, r3, #8
 801c86e:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
  if(TargetBoardFeatures.HandlePressSensor) {
 801c872:	690b      	ldr	r3, [r1, #16]
 801c874:	b12b      	cbz	r3, 801c882 <setConnectable+0xc6>
    manuf_data[17] |= 0x10; /* Pressure value*/
 801c876:	f89d 303d 	ldrb.w	r3, [sp, #61]	; 0x3d
 801c87a:	f043 0310 	orr.w	r3, r3, #16
 801c87e:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
  manuf_data[18] |=0x04;
 801c882:	f241 0304 	movw	r3, #4100	; 0x1004
 801c886:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
   Enable_SPI_IRQ();
 801c88a:	f001 fb51 	bl	801df30 <Enable_SPI_IRQ>
  hci_le_set_scan_resp_data(0,NULL);
 801c88e:	2100      	movs	r1, #0
 801c890:	4608      	mov	r0, r1
 801c892:	f7fc f8f5 	bl	8018a80 <hci_le_set_scan_resp_data>
  aci_gap_set_discoverable(ADV_IND, 2048, 4096, (0), 
 801c896:	2300      	movs	r3, #0
 801c898:	a909      	add	r1, sp, #36	; 0x24
 801c89a:	2208      	movs	r2, #8
 801c89c:	e9cd 2101 	strd	r2, r1, [sp, #4]
 801c8a0:	e9cd 3305 	strd	r3, r3, [sp, #20]
 801c8a4:	e9cd 3303 	strd	r3, r3, [sp, #12]
 801c8a8:	9300      	str	r3, [sp, #0]
 801c8aa:	4618      	mov	r0, r3
 801c8ac:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801c8b0:	f44f 6100 	mov.w	r1, #2048	; 0x800
 801c8b4:	f001 fe1c 	bl	801e4f0 <aci_gap_set_discoverable>
  aci_gap_update_adv_data(26, manuf_data);
 801c8b8:	a90b      	add	r1, sp, #44	; 0x2c
 801c8ba:	201a      	movs	r0, #26
 801c8bc:	f001 fec0 	bl	801e640 <aci_gap_update_adv_data>
}
 801c8c0:	b013      	add	sp, #76	; 0x4c
 801c8c2:	bd30      	pop	{r4, r5, pc}
    manuf_data[17] |= 0x04; /* One Temperature value*/
 801c8c4:	f89d 303d 	ldrb.w	r3, [sp, #61]	; 0x3d
 801c8c8:	f043 0304 	orr.w	r3, r3, #4
 801c8cc:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
 801c8d0:	e7c7      	b.n	801c862 <setConnectable+0xa6>
    manuf_data[17] |= 0x05; /* Two Temperature values*/
 801c8d2:	f89d 303d 	ldrb.w	r3, [sp, #61]	; 0x3d
 801c8d6:	f043 0305 	orr.w	r3, r3, #5
 801c8da:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
 801c8de:	e7c0      	b.n	801c862 <setConnectable+0xa6>
 801c8e0:	20012708 	.word	0x20012708
 801c8e4:	200114d0 	.word	0x200114d0
 801c8e8:	20011458 	.word	0x20011458
 801c8ec:	0201ff0d 	.word	0x0201ff0d
 801c8f0:	08000a02 	.word	0x08000a02
 801c8f4:	00000000 	.word	0x00000000

0801c8f8 <HCI_Event_CB>:
 * @param  void *pckt Pointer to the ACI packet
 * @retval None
 */
//#define TRACE_HCI_CB
void HCI_Event_CB(void *pckt)
{
 801c8f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  hci_uart_pckt *hci_pckt = pckt;
  hci_event_pckt *event_pckt = (hci_event_pckt*)hci_pckt->data;

  if(hci_pckt->type != HCI_EVENT_PKT) {
 801c8fc:	7805      	ldrb	r5, [r0, #0]
 801c8fe:	2d04      	cmp	r5, #4
{
 801c900:	b09b      	sub	sp, #108	; 0x6c
  if(hci_pckt->type != HCI_EVENT_PKT) {
 801c902:	d002      	beq.n	801c90a <HCI_Event_CB+0x12>
        break;
       }
    }
    break;
  }
}
 801c904:	b01b      	add	sp, #108	; 0x6c
 801c906:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  switch(event_pckt->evt){
 801c90a:	7843      	ldrb	r3, [r0, #1]
 801c90c:	2b3e      	cmp	r3, #62	; 0x3e
 801c90e:	4604      	mov	r4, r0
 801c910:	d061      	beq.n	801c9d6 <HCI_Event_CB+0xde>
 801c912:	2bff      	cmp	r3, #255	; 0xff
 801c914:	d029      	beq.n	801c96a <HCI_Event_CB+0x72>
 801c916:	2b05      	cmp	r3, #5
 801c918:	d1f4      	bne.n	801c904 <HCI_Event_CB+0xc>
  set_connectable = TRUE;
 801c91a:	4bc5      	ldr	r3, [pc, #788]	; (801cc30 <HCI_Event_CB+0x338>)
  ConnectionBleStatus=0;
 801c91c:	4cc5      	ldr	r4, [pc, #788]	; (801cc34 <HCI_Event_CB+0x33c>)
  set_connectable = TRUE;
 801c91e:	2201      	movs	r2, #1
  ConnectionBleStatus=0;
 801c920:	2500      	movs	r5, #0
  set_connectable = TRUE;
 801c922:	721a      	strb	r2, [r3, #8]
  ConnectionBleStatus=0;
 801c924:	6025      	str	r5, [r4, #0]
  DisableHWFeatures();
 801c926:	f7fd fc3d 	bl	801a1a4 <DisableHWFeatures>
  if(SD_LogMems_Enabled) {
 801c92a:	4bc3      	ldr	r3, [pc, #780]	; (801cc38 <HCI_Event_CB+0x340>)
  SizeOfUpdateBlueFW = 0;
 801c92c:	6565      	str	r5, [r4, #84]	; 0x54
  if(SD_LogMems_Enabled) {
 801c92e:	681b      	ldr	r3, [r3, #0]
 801c930:	2b00      	cmp	r3, #0
 801c932:	f040 80d3 	bne.w	801cadc <HCI_Event_CB+0x1e4>
  if(SD_LogAudio_Enabled) {
 801c936:	4bc1      	ldr	r3, [pc, #772]	; (801cc3c <HCI_Event_CB+0x344>)
 801c938:	681b      	ldr	r3, [r3, #0]
 801c93a:	b14b      	cbz	r3, 801c950 <HCI_Event_CB+0x58>
    osDelay(100);
 801c93c:	2064      	movs	r0, #100	; 0x64
 801c93e:	f7f9 fc77 	bl	8016230 <osDelay>
    SD_Card_FeaturesMask &= ~FEATURE_MASK_BLUEVOICE;
 801c942:	4abf      	ldr	r2, [pc, #764]	; (801cc40 <HCI_Event_CB+0x348>)
 801c944:	6813      	ldr	r3, [r2, #0]
 801c946:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
 801c94a:	6013      	str	r3, [r2, #0]
    SD_CardLoggingAudioStop();
 801c94c:	f7fc fee2 	bl	8019714 <SD_CardLoggingAudioStop>
   stopProc(ACTIVITY);
 801c950:	2008      	movs	r0, #8
 801c952:	f7fe f8a3 	bl	801aa9c <stopProc>
  stopProc(MOTION);
 801c956:	2006      	movs	r0, #6
 801c958:	f7fe f8a0 	bl	801aa9c <stopProc>
  stopProc(ENV);
 801c95c:	2005      	movs	r0, #5
 801c95e:	f7fe f89d 	bl	801aa9c <stopProc>
  stopProc(AUDIO_LEV);
 801c962:	2009      	movs	r0, #9
 801c964:	f7fe f89a 	bl	801aa9c <stopProc>
 801c968:	e7cc      	b.n	801c904 <HCI_Event_CB+0xc>
      switch(blue_evt->ecode){
 801c96a:	f8b0 3003 	ldrh.w	r3, [r0, #3]
 801c96e:	f640 4201 	movw	r2, #3073	; 0xc01
 801c972:	4293      	cmp	r3, r2
 801c974:	d04c      	beq.n	801ca10 <HCI_Event_CB+0x118>
 801c976:	f640 4214 	movw	r2, #3092	; 0xc14
 801c97a:	4293      	cmp	r3, r2
 801c97c:	d1c2      	bne.n	801c904 <HCI_Event_CB+0xc>
  if(handle == EnvironmentalCharHandle + 1){
 801c97e:	4dad      	ldr	r5, [pc, #692]	; (801cc34 <HCI_Event_CB+0x33c>)
 801c980:	f8b0 2007 	ldrh.w	r2, [r0, #7]
 801c984:	f8b5 3048 	ldrh.w	r3, [r5, #72]	; 0x48
 801c988:	3301      	adds	r3, #1
 801c98a:	429a      	cmp	r2, r3
 801c98c:	f000 80bd 	beq.w	801cb0a <HCI_Event_CB+0x212>
  } else if(handle == AccEventCharHandle +1) {
 801c990:	f8b5 3046 	ldrh.w	r3, [r5, #70]	; 0x46
 801c994:	3301      	adds	r3, #1
 801c996:	429a      	cmp	r2, r3
 801c998:	f000 80ec 	beq.w	801cb74 <HCI_Event_CB+0x27c>
  } else if (handle == StdErrCharHandle + 1) {
 801c99c:	8a2b      	ldrh	r3, [r5, #16]
 801c99e:	3301      	adds	r3, #1
 801c9a0:	429a      	cmp	r2, r3
 801c9a2:	f000 810b 	beq.w	801cbbc <HCI_Event_CB+0x2c4>
  } else if (handle == TermCharHandle + 1) {
 801c9a6:	89eb      	ldrh	r3, [r5, #14]
 801c9a8:	3301      	adds	r3, #1
 801c9aa:	429a      	cmp	r2, r3
 801c9ac:	f000 812b 	beq.w	801cc06 <HCI_Event_CB+0x30e>
  } else if (handle == ActivityRecCharHandle + 1) {
 801c9b0:	f8b5 3042 	ldrh.w	r3, [r5, #66]	; 0x42
 801c9b4:	3301      	adds	r3, #1
 801c9b6:	429a      	cmp	r2, r3
 801c9b8:	f000 8197 	beq.w	801ccea <HCI_Event_CB+0x3f2>
  } else if(handle == BatteryFeaturesCharHandle + 1){
 801c9bc:	f8b5 304e 	ldrh.w	r3, [r5, #78]	; 0x4e
 801c9c0:	3301      	adds	r3, #1
 801c9c2:	429a      	cmp	r2, r3
 801c9c4:	f000 81c0 	beq.w	801cd48 <HCI_Event_CB+0x450>
  if(connection_handle != 0)
 801c9c8:	f8b5 0058 	ldrh.w	r0, [r5, #88]	; 0x58
 801c9cc:	2800      	cmp	r0, #0
 801c9ce:	d099      	beq.n	801c904 <HCI_Event_CB+0xc>
    aci_gatt_allow_read(connection_handle);
 801c9d0:	f7fc f806 	bl	80189e0 <aci_gatt_allow_read>
 801c9d4:	e796      	b.n	801c904 <HCI_Event_CB+0xc>
      switch(evt->subevent){
 801c9d6:	78c6      	ldrb	r6, [r0, #3]
 801c9d8:	2e01      	cmp	r6, #1
 801c9da:	d193      	bne.n	801c904 <HCI_Event_CB+0xc>
          GAP_ConnectionComplete_CB(cc->peer_bdaddr, cc->handle);
 801c9dc:	7981      	ldrb	r1, [r0, #6]
 801c9de:	7943      	ldrb	r3, [r0, #5]
  connection_handle = handle;
 801c9e0:	4a94      	ldr	r2, [pc, #592]	; (801cc34 <HCI_Event_CB+0x33c>)
          GAP_ConnectionComplete_CB(cc->peer_bdaddr, cc->handle);
 801c9e2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  ConnectionBleStatus=0;
 801c9e6:	2400      	movs	r4, #0
  connection_handle = handle;
 801c9e8:	f8a2 3058 	strh.w	r3, [r2, #88]	; 0x58
  ConnectionBleStatus=0;
 801c9ec:	6014      	str	r4, [r2, #0]
  DisableHWFeatures();
 801c9ee:	f7fd fbd9 	bl	801a1a4 <DisableHWFeatures>
  LedBlinkStop();
 801c9f2:	f7fe ff91 	bl	801b918 <LedBlinkStop>
    uint32_t charValue = 0x0000FFFF; /* Delete all the Handles from 0x0000 to 0xFFFF */
 801c9f6:	a91a      	add	r1, sp, #104	; 0x68
 801c9f8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801c9fc:	f841 3d28 	str.w	r3, [r1, #-40]!
    ret = aci_gatt_update_char_value(0x0001,0x0002,0,4,(uint8_t*) &charValue);
 801ca00:	4622      	mov	r2, r4
 801ca02:	9100      	str	r1, [sp, #0]
 801ca04:	462b      	mov	r3, r5
 801ca06:	4630      	mov	r0, r6
 801ca08:	2102      	movs	r1, #2
 801ca0a:	f7fb ffa5 	bl	8018958 <aci_gatt_update_char_value>
 801ca0e:	e779      	b.n	801c904 <HCI_Event_CB+0xc>
  if (attr_handle == ActivityRecCharHandle + 2) {
 801ca10:	4d88      	ldr	r5, [pc, #544]	; (801cc34 <HCI_Event_CB+0x33c>)
 801ca12:	f8b0 2007 	ldrh.w	r2, [r0, #7]
 801ca16:	f8b5 3042 	ldrh.w	r3, [r5, #66]	; 0x42
 801ca1a:	3302      	adds	r3, #2
 801ca1c:	429a      	cmp	r2, r3
 801ca1e:	d065      	beq.n	801caec <HCI_Event_CB+0x1f4>
  if (attr_handle == AudioSRecCharHandle + 2) {
 801ca20:	2a02      	cmp	r2, #2
 801ca22:	f000 8094 	beq.w	801cb4e <HCI_Event_CB+0x256>
  } else if(attr_handle == BatteryFeaturesCharHandle + 2){
 801ca26:	f8b5 304e 	ldrh.w	r3, [r5, #78]	; 0x4e
 801ca2a:	3302      	adds	r3, #2
 801ca2c:	429a      	cmp	r2, r3
 801ca2e:	f000 80aa 	beq.w	801cb86 <HCI_Event_CB+0x28e>
   } else if(attr_handle == ConfigCharHandle + 2){
 801ca32:	896b      	ldrh	r3, [r5, #10]
 801ca34:	1c99      	adds	r1, r3, #2
 801ca36:	428a      	cmp	r2, r1
 801ca38:	f000 80b4 	beq.w	801cba4 <HCI_Event_CB+0x2ac>
    } else if(attr_handle == SDLogFeaturesCharHandle + 2){
 801ca3c:	f8b5 1050 	ldrh.w	r1, [r5, #80]	; 0x50
 801ca40:	1c88      	adds	r0, r1, #2
 801ca42:	4282      	cmp	r2, r0
 801ca44:	f000 80e7 	beq.w	801cc16 <HCI_Event_CB+0x31e>
  } else if(attr_handle == AccGyroMagCharHandle + 2) {
 801ca48:	f8b5 004a 	ldrh.w	r0, [r5, #74]	; 0x4a
 801ca4c:	3002      	adds	r0, #2
 801ca4e:	4282      	cmp	r2, r0
 801ca50:	f000 81a1 	beq.w	801cd96 <HCI_Event_CB+0x49e>
  } else if(attr_handle == AccEventCharHandle + 2) {
 801ca54:	f8b5 0046 	ldrh.w	r0, [r5, #70]	; 0x46
 801ca58:	3002      	adds	r0, #2
 801ca5a:	4282      	cmp	r2, r0
 801ca5c:	f000 81af 	beq.w	801cdbe <HCI_Event_CB+0x4c6>
  } else if(attr_handle == EnvironmentalCharHandle + 2){
 801ca60:	f8b5 0048 	ldrh.w	r0, [r5, #72]	; 0x48
 801ca64:	3002      	adds	r0, #2
 801ca66:	4282      	cmp	r2, r0
 801ca68:	f000 8208 	beq.w	801ce7c <HCI_Event_CB+0x584>
  } else if(attr_handle == StdErrCharHandle + 2){
 801ca6c:	8a28      	ldrh	r0, [r5, #16]
 801ca6e:	3002      	adds	r0, #2
 801ca70:	4282      	cmp	r2, r0
 801ca72:	f000 8212 	beq.w	801ce9a <HCI_Event_CB+0x5a2>
  } else if(attr_handle == TermCharHandle + 2){
 801ca76:	89e8      	ldrh	r0, [r5, #14]
 801ca78:	1c86      	adds	r6, r0, #2
 801ca7a:	42b2      	cmp	r2, r6
 801ca7c:	f000 8219 	beq.w	801ceb2 <HCI_Event_CB+0x5ba>
  } else if (attr_handle == TermCharHandle + 1){
 801ca80:	3001      	adds	r0, #1
 801ca82:	4282      	cmp	r2, r0
            Attribute_Modified_CB(evt->attr_handle, evt->att_data,evt->data_length);
 801ca84:	f104 070c 	add.w	r7, r4, #12
 801ca88:	7a66      	ldrb	r6, [r4, #9]
  } else if (attr_handle == TermCharHandle + 1){
 801ca8a:	f000 821e 	beq.w	801ceca <HCI_Event_CB+0x5d2>
  } else if (attr_handle == AudioLevelCharHandle + 2) {
 801ca8e:	f8b5 004c 	ldrh.w	r0, [r5, #76]	; 0x4c
 801ca92:	3002      	adds	r0, #2
 801ca94:	4282      	cmp	r2, r0
 801ca96:	f000 82aa 	beq.w	801cfee <HCI_Event_CB+0x6f6>
  } else if (attr_handle == ConfigCharHandle + 1) {
 801ca9a:	3301      	adds	r3, #1
 801ca9c:	429a      	cmp	r2, r3
 801ca9e:	f000 85b6 	beq.w	801d60e <HCI_Event_CB+0xd16>
  } else if (attr_handle == SDLogFeaturesCharHandle + 1) {
 801caa2:	3101      	adds	r1, #1
 801caa4:	428a      	cmp	r2, r1
 801caa6:	f000 8284 	beq.w	801cfb2 <HCI_Event_CB+0x6ba>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801caaa:	682b      	ldr	r3, [r5, #0]
 801caac:	065b      	lsls	r3, r3, #25
 801caae:	f57f af29 	bpl.w	801c904 <HCI_Event_CB+0xc>
      BytesToWrite =sprintf((char *)BufferToWrite, "Notification UNKNOWN handle\n");
 801cab2:	4c64      	ldr	r4, [pc, #400]	; (801cc44 <HCI_Event_CB+0x34c>)
 801cab4:	4d64      	ldr	r5, [pc, #400]	; (801cc48 <HCI_Event_CB+0x350>)
 801cab6:	4f65      	ldr	r7, [pc, #404]	; (801cc4c <HCI_Event_CB+0x354>)
 801cab8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801caba:	6028      	str	r0, [r5, #0]
 801cabc:	6069      	str	r1, [r5, #4]
 801cabe:	60aa      	str	r2, [r5, #8]
 801cac0:	cc07      	ldmia	r4!, {r0, r1, r2}
 801cac2:	261c      	movs	r6, #28
 801cac4:	7824      	ldrb	r4, [r4, #0]
 801cac6:	6128      	str	r0, [r5, #16]
 801cac8:	6169      	str	r1, [r5, #20]
 801caca:	60eb      	str	r3, [r5, #12]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801cacc:	4628      	mov	r0, r5
 801cace:	4631      	mov	r1, r6
      BytesToWrite =sprintf((char *)BufferToWrite, "Notification UNKNOWN handle\n");
 801cad0:	772c      	strb	r4, [r5, #28]
 801cad2:	61aa      	str	r2, [r5, #24]
 801cad4:	603e      	str	r6, [r7, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801cad6:	f7ff f9af 	bl	801be38 <Stderr_Update>
 801cada:	e713      	b.n	801c904 <HCI_Event_CB+0xc>
    SD_Card_FeaturesMask &= ~(FEATURE_MASK_TEMP1 |
 801cadc:	4a58      	ldr	r2, [pc, #352]	; (801cc40 <HCI_Event_CB+0x348>)
 801cade:	6813      	ldr	r3, [r2, #0]
 801cae0:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 801cae4:	6013      	str	r3, [r2, #0]
    SD_CardLoggingMemsStop();
 801cae6:	f7fc fd83 	bl	80195f0 <SD_CardLoggingMemsStop>
 801caea:	e724      	b.n	801c936 <HCI_Event_CB+0x3e>
    if (att_data[0] == 01) {
 801caec:	7b03      	ldrb	r3, [r0, #12]
 801caee:	2b01      	cmp	r3, #1
 801caf0:	f000 80d5 	beq.w	801cc9e <HCI_Event_CB+0x3a6>
    } else if (att_data[0] == 0) {
 801caf4:	2b00      	cmp	r3, #0
 801caf6:	f47f af05 	bne.w	801c904 <HCI_Event_CB+0xc>
      W2ST_OFF_CONNECTION(W2ST_CONNECT_AR);
 801cafa:	682b      	ldr	r3, [r5, #0]
      stopProc(ACTIVITY);
 801cafc:	2008      	movs	r0, #8
      W2ST_OFF_CONNECTION(W2ST_CONNECT_AR);
 801cafe:	f023 0310 	bic.w	r3, r3, #16
 801cb02:	602b      	str	r3, [r5, #0]
      stopProc(ACTIVITY);
 801cb04:	f7fd ffca 	bl	801aa9c <stopProc>
 801cb08:	e6fc      	b.n	801c904 <HCI_Event_CB+0xc>
    if(TargetBoardFeatures.HandlePressSensor) {
 801cb0a:	4c51      	ldr	r4, [pc, #324]	; (801cc50 <HCI_Event_CB+0x358>)
 801cb0c:	6920      	ldr	r0, [r4, #16]
 801cb0e:	b128      	cbz	r0, 801cb1c <HCI_Event_CB+0x224>
      if(BSP_PRESSURE_IsInitialized(TargetBoardFeatures.HandlePressSensor,&Status)==COMPONENT_OK) {
 801cb10:	a90f      	add	r1, sp, #60	; 0x3c
 801cb12:	f001 fb55 	bl	801e1c0 <BSP_PRESSURE_IsInitialized>
 801cb16:	2800      	cmp	r0, #0
 801cb18:	f000 80ca 	beq.w	801ccb0 <HCI_Event_CB+0x3b8>
    int32_t PressToSend=0;
 801cb1c:	f04f 0800 	mov.w	r8, #0
    if(TargetBoardFeatures.HandleHumSensor) {
 801cb20:	6960      	ldr	r0, [r4, #20]
 801cb22:	b128      	cbz	r0, 801cb30 <HCI_Event_CB+0x238>
      if(BSP_HUMIDITY_IsInitialized(TargetBoardFeatures.HandleHumSensor,&Status)==COMPONENT_OK){
 801cb24:	a90f      	add	r1, sp, #60	; 0x3c
 801cb26:	f001 fa7d 	bl	801e024 <BSP_HUMIDITY_IsInitialized>
 801cb2a:	2800      	cmp	r0, #0
 801cb2c:	f000 8096 	beq.w	801cc5c <HCI_Event_CB+0x364>
    uint16_t HumToSend=0;
 801cb30:	2700      	movs	r7, #0
    if(TargetBoardFeatures.NumTempSensors==2) {
 801cb32:	6863      	ldr	r3, [r4, #4]
 801cb34:	2b02      	cmp	r3, #2
 801cb36:	d055      	beq.n	801cbe4 <HCI_Event_CB+0x2ec>
    } else if(TargetBoardFeatures.NumTempSensors==1) {
 801cb38:	2b01      	cmp	r3, #1
 801cb3a:	f000 80db 	beq.w	801ccf4 <HCI_Event_CB+0x3fc>
    int16_t Temp2ToSend=0,Temp1ToSend=0;
 801cb3e:	2600      	movs	r6, #0
 801cb40:	4632      	mov	r2, r6
    Environmental_Update(PressToSend,HumToSend,Temp2ToSend,Temp1ToSend);
 801cb42:	4633      	mov	r3, r6
 801cb44:	4639      	mov	r1, r7
 801cb46:	4640      	mov	r0, r8
 801cb48:	f7ff fcc4 	bl	801c4d4 <Environmental_Update>
 801cb4c:	e73c      	b.n	801c9c8 <HCI_Event_CB+0xd0>
    if (att_data[0] == 01) {
 801cb4e:	7b03      	ldrb	r3, [r0, #12]
 801cb50:	2b01      	cmp	r3, #1
 801cb52:	f000 8111 	beq.w	801cd78 <HCI_Event_CB+0x480>
    } else if (att_data[0] == 0) {
 801cb56:	2b00      	cmp	r3, #0
 801cb58:	f47f aed4 	bne.w	801c904 <HCI_Event_CB+0xc>
      W2ST_OFF_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 801cb5c:	682b      	ldr	r3, [r5, #0]
 801cb5e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 801cb62:	602b      	str	r3, [r5, #0]
      DeInitMics();
 801cb64:	f7fd fe3a 	bl	801a7dc <DeInitMics>
      PowerCtrlUnLock();
 801cb68:	f7fd fc4c 	bl	801a404 <PowerCtrlUnLock>
      stopProc(AUDIO_SC);
 801cb6c:	2007      	movs	r0, #7
 801cb6e:	f7fd ff95 	bl	801aa9c <stopProc>
 801cb72:	e6c7      	b.n	801c904 <HCI_Event_CB+0xc>
      if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_PEDOMETER)) {
 801cb74:	4b37      	ldr	r3, [pc, #220]	; (801cc54 <HCI_Event_CB+0x35c>)
 801cb76:	6818      	ldr	r0, [r3, #0]
 801cb78:	f010 0001 	ands.w	r0, r0, #1
 801cb7c:	d12f      	bne.n	801cbde <HCI_Event_CB+0x2e6>
      AccEvent_Notify(StepCount, 2);
 801cb7e:	2102      	movs	r1, #2
 801cb80:	f7ff fa9a 	bl	801c0b8 <AccEvent_Notify>
 801cb84:	e720      	b.n	801c9c8 <HCI_Event_CB+0xd0>
    if (att_data[0] == 01) {
 801cb86:	7b03      	ldrb	r3, [r0, #12]
 801cb88:	2b01      	cmp	r3, #1
 801cb8a:	f000 8126 	beq.w	801cdda <HCI_Event_CB+0x4e2>
    }else if (att_data[0] == 0){
 801cb8e:	2b00      	cmp	r3, #0
 801cb90:	f47f aeb8 	bne.w	801c904 <HCI_Event_CB+0xc>
      W2ST_OFF_CONNECTION(W2ST_CONNECT_GG_EVENT);
 801cb94:	682b      	ldr	r3, [r5, #0]
      stopProc(BATTERY_INFO);
 801cb96:	200c      	movs	r0, #12
      W2ST_OFF_CONNECTION(W2ST_CONNECT_GG_EVENT);
 801cb98:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 801cb9c:	602b      	str	r3, [r5, #0]
      stopProc(BATTERY_INFO);
 801cb9e:	f7fd ff7d 	bl	801aa9c <stopProc>
 801cba2:	e6af      	b.n	801c904 <HCI_Event_CB+0xc>
      if (att_data[0] == 01) {
 801cba4:	7b03      	ldrb	r3, [r0, #12]
 801cba6:	2b01      	cmp	r3, #1
 801cba8:	f000 8104 	beq.w	801cdb4 <HCI_Event_CB+0x4bc>
      } else if (att_data[0] == 0){
 801cbac:	2b00      	cmp	r3, #0
 801cbae:	f47f aea9 	bne.w	801c904 <HCI_Event_CB+0xc>
        W2ST_OFF_CONNECTION(W2ST_CONNECT_CONF_EVENT);
 801cbb2:	682b      	ldr	r3, [r5, #0]
 801cbb4:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 801cbb8:	602b      	str	r3, [r5, #0]
 801cbba:	e6a3      	b.n	801c904 <HCI_Event_CB+0xc>
  msg.term.length = LastStderrLen;
 801cbbc:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
 801cbc0:	f88d 2044 	strb.w	r2, [sp, #68]	; 0x44
  msg.type        = TERM_STDERR;
 801cbc4:	230b      	movs	r3, #11
  memcpy(msg.term.data,LastStderrBuffer,LastStderrLen);
 801cbc6:	f105 0114 	add.w	r1, r5, #20
  memcpy(msg.term.data,LastTermBuffer,LastTermLen);
 801cbca:	f10d 0045 	add.w	r0, sp, #69	; 0x45
  msg.type        = TERM_STDOUT;
 801cbce:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
  memcpy(msg.term.data,LastTermBuffer,LastTermLen);
 801cbd2:	f001 ffa2 	bl	801eb1a <memcpy>
  SendMsgToHost(&msg);
 801cbd6:	a810      	add	r0, sp, #64	; 0x40
 801cbd8:	f7fd ff46 	bl	801aa68 <SendMsgToHost>
 801cbdc:	e6f4      	b.n	801c9c8 <HCI_Event_CB+0xd0>
        StepCount = GetStepHWPedometer();
 801cbde:	f7fd fbc7 	bl	801a370 <GetStepHWPedometer>
 801cbe2:	e7cc      	b.n	801cb7e <HCI_Event_CB+0x286>
      if(BSP_TEMPERATURE_IsInitialized(TargetBoardFeatures.HandleTempSensors[0],&Status)==COMPONENT_OK){
 801cbe4:	a90f      	add	r1, sp, #60	; 0x3c
 801cbe6:	68a0      	ldr	r0, [r4, #8]
 801cbe8:	f001 fc04 	bl	801e3f4 <BSP_TEMPERATURE_IsInitialized>
 801cbec:	2800      	cmp	r0, #0
 801cbee:	f000 811f 	beq.w	801ce30 <HCI_Event_CB+0x538>
    int16_t Temp2ToSend=0,Temp1ToSend=0;
 801cbf2:	2600      	movs	r6, #0
      if(BSP_TEMPERATURE_IsInitialized(TargetBoardFeatures.HandleTempSensors[1],&Status)==COMPONENT_OK){
 801cbf4:	a90f      	add	r1, sp, #60	; 0x3c
 801cbf6:	68e0      	ldr	r0, [r4, #12]
 801cbf8:	f001 fbfc 	bl	801e3f4 <BSP_TEMPERATURE_IsInitialized>
 801cbfc:	2800      	cmp	r0, #0
 801cbfe:	f000 80f6 	beq.w	801cdee <HCI_Event_CB+0x4f6>
    int16_t Temp2ToSend=0,Temp1ToSend=0;
 801cc02:	2200      	movs	r2, #0
 801cc04:	e79d      	b.n	801cb42 <HCI_Event_CB+0x24a>
  msg.term.length = LastTermLen;
 801cc06:	f895 2040 	ldrb.w	r2, [r5, #64]	; 0x40
 801cc0a:	f88d 2044 	strb.w	r2, [sp, #68]	; 0x44
  msg.type        = TERM_STDOUT;
 801cc0e:	230a      	movs	r3, #10
  memcpy(msg.term.data,LastTermBuffer,LastTermLen);
 801cc10:	f105 012c 	add.w	r1, r5, #44	; 0x2c
 801cc14:	e7d9      	b.n	801cbca <HCI_Event_CB+0x2d2>
      if (att_data[0] == 01) {
 801cc16:	7b23      	ldrb	r3, [r4, #12]
 801cc18:	2b01      	cmp	r3, #1
 801cc1a:	f000 812a 	beq.w	801ce72 <HCI_Event_CB+0x57a>
      } else if (att_data[0] == 0){
 801cc1e:	2b00      	cmp	r3, #0
 801cc20:	f47f ae70 	bne.w	801c904 <HCI_Event_CB+0xc>
        W2ST_OFF_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING);
 801cc24:	682b      	ldr	r3, [r5, #0]
 801cc26:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 801cc2a:	602b      	str	r3, [r5, #0]
 801cc2c:	e66a      	b.n	801c904 <HCI_Event_CB+0xc>
 801cc2e:	bf00      	nop
 801cc30:	2000154c 	.word	0x2000154c
 801cc34:	20010030 	.word	0x20010030
 801cc38:	2000f2e0 	.word	0x2000f2e0
 801cc3c:	2000f074 	.word	0x2000f074
 801cc40:	2000f2dc 	.word	0x2000f2dc
 801cc44:	08075e54 	.word	0x08075e54
 801cc48:	20013174 	.word	0x20013174
 801cc4c:	200132a0 	.word	0x200132a0
 801cc50:	20011458 	.word	0x20011458
 801cc54:	2000ffe4 	.word	0x2000ffe4
 801cc58:	42c80000 	.word	0x42c80000
        BSP_HUMIDITY_Get_Hum(TargetBoardFeatures.HandleHumSensor,(float *)&SensorValue);
 801cc5c:	a910      	add	r1, sp, #64	; 0x40
 801cc5e:	6960      	ldr	r0, [r4, #20]
 801cc60:	f001 f9e8 	bl	801e034 <BSP_HUMIDITY_Get_Hum>
        BSP_HUMIDITY_Set_One_Shot(TargetBoardFeatures.HandleHumSensor);
 801cc64:	6960      	ldr	r0, [r4, #20]
 801cc66:	f001 f9f7 	bl	801e058 <BSP_HUMIDITY_Set_One_Shot>
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801cc6a:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
 801cc6e:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 801cc72:	ee17 7a10 	vmov	r7, s14
 801cc76:	ee06 7a90 	vmov	s13, r7
 801cc7a:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 801cc7e:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 801cc82:	ee77 7ae6 	vsub.f32	s15, s15, s13
        HumToSend = intPart*10+decPart;
 801cc86:	eb07 0387 	add.w	r3, r7, r7, lsl #2
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801cc8a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801cc8e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cc92:	ee17 7a90 	vmov	r7, s15
        HumToSend = intPart*10+decPart;
 801cc96:	eb07 0743 	add.w	r7, r7, r3, lsl #1
 801cc9a:	b2bf      	uxth	r7, r7
 801cc9c:	e749      	b.n	801cb32 <HCI_Event_CB+0x23a>
      W2ST_ON_CONNECTION(W2ST_CONNECT_AR);
 801cc9e:	682b      	ldr	r3, [r5, #0]
      startProc(ACTIVITY,INERTIAL_ACQ_ACTIVITY_MS);
 801cca0:	2113      	movs	r1, #19
      W2ST_ON_CONNECTION(W2ST_CONNECT_AR);
 801cca2:	f043 0310 	orr.w	r3, r3, #16
      startProc(ACTIVITY,INERTIAL_ACQ_ACTIVITY_MS);
 801cca6:	2008      	movs	r0, #8
      W2ST_ON_CONNECTION(W2ST_CONNECT_AR);
 801cca8:	602b      	str	r3, [r5, #0]
      startProc(ACTIVITY,INERTIAL_ACQ_ACTIVITY_MS);
 801ccaa:	f7fd ff97 	bl	801abdc <startProc>
 801ccae:	e629      	b.n	801c904 <HCI_Event_CB+0xc>
        BSP_PRESSURE_Get_Press(TargetBoardFeatures.HandlePressSensor,(float *)&SensorValue);
 801ccb0:	a910      	add	r1, sp, #64	; 0x40
 801ccb2:	6920      	ldr	r0, [r4, #16]
 801ccb4:	f001 fa8c 	bl	801e1d0 <BSP_PRESSURE_Get_Press>
        BSP_PRESSURE_Set_One_Shot(TargetBoardFeatures.HandlePressSensor);
 801ccb8:	6920      	ldr	r0, [r4, #16]
 801ccba:	f001 fa9b 	bl	801e1f4 <BSP_PRESSURE_Set_One_Shot>
        MCR_BLUEMS_F2I_2D(SensorValue, intPart, decPart);
 801ccbe:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
 801ccc2:	ed5f 6a1b 	vldr	s13, [pc, #-108]	; 801cc58 <HCI_Event_CB+0x360>
 801ccc6:	eebd 7ae7 	vcvt.s32.f32	s14, s15
        PressToSend=intPart*100+decPart;
 801ccca:	2364      	movs	r3, #100	; 0x64
        MCR_BLUEMS_F2I_2D(SensorValue, intPart, decPart);
 801cccc:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
        PressToSend=intPart*100+decPart;
 801ccd0:	ee17 2a10 	vmov	r2, s14
        MCR_BLUEMS_F2I_2D(SensorValue, intPart, decPart);
 801ccd4:	ee77 7ac6 	vsub.f32	s15, s15, s12
 801ccd8:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801ccdc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cce0:	ee17 8a90 	vmov	r8, s15
        PressToSend=intPart*100+decPart;
 801cce4:	fb03 8802 	mla	r8, r3, r2, r8
 801cce8:	e71a      	b.n	801cb20 <HCI_Event_CB+0x228>
     ActivityRec_Update(Gesture_get_Activity_Code());
 801ccea:	f7f7 f897 	bl	8013e1c <Gesture_get_Activity_Code>
 801ccee:	f7ff f907 	bl	801bf00 <ActivityRec_Update>
 801ccf2:	e669      	b.n	801c9c8 <HCI_Event_CB+0xd0>
      if(BSP_TEMPERATURE_IsInitialized(TargetBoardFeatures.HandleTempSensors[0],&Status)==COMPONENT_OK){
 801ccf4:	a90f      	add	r1, sp, #60	; 0x3c
 801ccf6:	68a0      	ldr	r0, [r4, #8]
 801ccf8:	f001 fb7c 	bl	801e3f4 <BSP_TEMPERATURE_IsInitialized>
 801ccfc:	4681      	mov	r9, r0
 801ccfe:	2800      	cmp	r0, #0
 801cd00:	f47f af1d 	bne.w	801cb3e <HCI_Event_CB+0x246>
        BSP_TEMPERATURE_Get_Temp(TargetBoardFeatures.HandleTempSensors[0],(float *)&SensorValue);
 801cd04:	a910      	add	r1, sp, #64	; 0x40
 801cd06:	68a0      	ldr	r0, [r4, #8]
 801cd08:	f001 fb7c 	bl	801e404 <BSP_TEMPERATURE_Get_Temp>
        BSP_TEMPERATURE_Set_One_Shot(TargetBoardFeatures.HandleTempSensors[0]);
 801cd0c:	68a0      	ldr	r0, [r4, #8]
 801cd0e:	f001 fb8b 	bl	801e428 <BSP_TEMPERATURE_Set_One_Shot>
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801cd12:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
 801cd16:	eebd 7ae7 	vcvt.s32.f32	s14, s15
    int16_t Temp2ToSend=0,Temp1ToSend=0;
 801cd1a:	464a      	mov	r2, r9
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801cd1c:	ee17 6a10 	vmov	r6, s14
 801cd20:	ee06 6a90 	vmov	s13, r6
 801cd24:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 801cd28:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 801cd2c:	ee77 7ae6 	vsub.f32	s15, s15, s13
        Temp1ToSend = intPart*10+decPart;
 801cd30:	eb06 0386 	add.w	r3, r6, r6, lsl #2
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801cd34:	ee67 7a87 	vmul.f32	s15, s15, s14
 801cd38:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cd3c:	ee17 6a90 	vmov	r6, s15
        Temp1ToSend = intPart*10+decPart;
 801cd40:	eb06 0643 	add.w	r6, r6, r3, lsl #1
 801cd44:	b236      	sxth	r6, r6
 801cd46:	e6fc      	b.n	801cb42 <HCI_Event_CB+0x24a>
    BSP_GG_Task(TargetBoardFeatures.HandleGGComponent,&v_mode);
 801cd48:	4cbc      	ldr	r4, [pc, #752]	; (801d03c <HCI_Event_CB+0x744>)
 801cd4a:	f10d 0137 	add.w	r1, sp, #55	; 0x37
 801cd4e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 801cd50:	f7f2 ff4c 	bl	800fbec <BSP_GG_Task>
    BSP_GG_GetVoltage(TargetBoardFeatures.HandleGGComponent, &voltage);
 801cd54:	a90e      	add	r1, sp, #56	; 0x38
 801cd56:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 801cd58:	f7f2 ff60 	bl	800fc1c <BSP_GG_GetVoltage>
    BSP_GG_GetCurrent(TargetBoardFeatures.HandleGGComponent, &current);
 801cd5c:	a910      	add	r1, sp, #64	; 0x40
 801cd5e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 801cd60:	f7f2 ff54 	bl	800fc0c <BSP_GG_GetCurrent>
    BSP_GG_GetSOC(TargetBoardFeatures.HandleGGComponent, &soc);
 801cd64:	a90f      	add	r1, sp, #60	; 0x3c
 801cd66:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 801cd68:	f7f2 ff48 	bl	800fbfc <BSP_GG_GetSOC>
    GG_Update(soc, voltage, current);
 801cd6c:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801cd6e:	e9dd 100e 	ldrd	r1, r0, [sp, #56]	; 0x38
 801cd72:	f7ff fc83 	bl	801c67c <GG_Update>
 801cd76:	e627      	b.n	801c9c8 <HCI_Event_CB+0xd0>
      W2ST_ON_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 801cd78:	682b      	ldr	r3, [r5, #0]
 801cd7a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 801cd7e:	602b      	str	r3, [r5, #0]
      PowerCtrlLock();
 801cd80:	f7fd fb38 	bl	801a3f4 <PowerCtrlLock>
      InitMics(AUDIO_SAMPLING_FREQUENCY);
 801cd84:	f44f 507a 	mov.w	r0, #16000	; 0x3e80
 801cd88:	f7fd fd0e 	bl	801a7a8 <InitMics>
      startProc(AUDIO_SC, 0 /* Not Used for Audio */);
 801cd8c:	2100      	movs	r1, #0
 801cd8e:	2007      	movs	r0, #7
 801cd90:	f7fd ff24 	bl	801abdc <startProc>
 801cd94:	e5b6      	b.n	801c904 <HCI_Event_CB+0xc>
     if (att_data[0] == 01) {
 801cd96:	7b23      	ldrb	r3, [r4, #12]
 801cd98:	2b01      	cmp	r3, #1
 801cd9a:	f000 80f2 	beq.w	801cf82 <HCI_Event_CB+0x68a>
    } else if (att_data[0] == 0) {
 801cd9e:	2b00      	cmp	r3, #0
 801cda0:	f47f adb0 	bne.w	801c904 <HCI_Event_CB+0xc>
       W2ST_OFF_CONNECTION(W2ST_CONNECT_ACC_GYRO_MAG);
 801cda4:	682b      	ldr	r3, [r5, #0]
       stopProc(MOTION);
 801cda6:	2006      	movs	r0, #6
       W2ST_OFF_CONNECTION(W2ST_CONNECT_ACC_GYRO_MAG);
 801cda8:	f023 0304 	bic.w	r3, r3, #4
 801cdac:	602b      	str	r3, [r5, #0]
       stopProc(MOTION);
 801cdae:	f7fd fe75 	bl	801aa9c <stopProc>
 801cdb2:	e5a7      	b.n	801c904 <HCI_Event_CB+0xc>
        W2ST_ON_CONNECTION(W2ST_CONNECT_CONF_EVENT);
 801cdb4:	682b      	ldr	r3, [r5, #0]
 801cdb6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 801cdba:	602b      	str	r3, [r5, #0]
 801cdbc:	e5a2      	b.n	801c904 <HCI_Event_CB+0xc>
    if (att_data[0] == 01) {
 801cdbe:	7b24      	ldrb	r4, [r4, #12]
 801cdc0:	2c01      	cmp	r4, #1
 801cdc2:	f000 80c5 	beq.w	801cf50 <HCI_Event_CB+0x658>
    } else if (att_data[0] == 0) {
 801cdc6:	2c00      	cmp	r4, #0
 801cdc8:	f47f ad9c 	bne.w	801c904 <HCI_Event_CB+0xc>
      W2ST_OFF_CONNECTION(W2ST_CONNECT_ACC_EVENT);
 801cdcc:	682b      	ldr	r3, [r5, #0]
 801cdce:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 801cdd2:	602b      	str	r3, [r5, #0]
      DisableHWMultipleEvents();
 801cdd4:	f7fd fb00 	bl	801a3d8 <DisableHWMultipleEvents>
 801cdd8:	e594      	b.n	801c904 <HCI_Event_CB+0xc>
      W2ST_ON_CONNECTION(W2ST_CONNECT_GG_EVENT);
 801cdda:	682b      	ldr	r3, [r5, #0]
      startProc(BATTERY_INFO,ENV_UPDATE_MS);
 801cddc:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
      W2ST_ON_CONNECTION(W2ST_CONNECT_GG_EVENT);
 801cde0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
      startProc(BATTERY_INFO,ENV_UPDATE_MS);
 801cde4:	200c      	movs	r0, #12
      W2ST_ON_CONNECTION(W2ST_CONNECT_GG_EVENT);
 801cde6:	602b      	str	r3, [r5, #0]
      startProc(BATTERY_INFO,ENV_UPDATE_MS);
 801cde8:	f7fd fef8 	bl	801abdc <startProc>
 801cdec:	e58a      	b.n	801c904 <HCI_Event_CB+0xc>
        BSP_TEMPERATURE_Get_Temp(TargetBoardFeatures.HandleTempSensors[1],(float *)&SensorValue);
 801cdee:	a910      	add	r1, sp, #64	; 0x40
 801cdf0:	68e0      	ldr	r0, [r4, #12]
 801cdf2:	f001 fb07 	bl	801e404 <BSP_TEMPERATURE_Get_Temp>
        BSP_TEMPERATURE_Set_One_Shot(TargetBoardFeatures.HandleTempSensors[1]);
 801cdf6:	68e0      	ldr	r0, [r4, #12]
 801cdf8:	f001 fb16 	bl	801e428 <BSP_TEMPERATURE_Set_One_Shot>
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801cdfc:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
 801ce00:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 801ce04:	ee17 2a10 	vmov	r2, s14
 801ce08:	ee06 2a90 	vmov	s13, r2
 801ce0c:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 801ce10:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 801ce14:	ee77 7ae6 	vsub.f32	s15, s15, s13
        Temp2ToSend = intPart*10+decPart;
 801ce18:	eb02 0382 	add.w	r3, r2, r2, lsl #2
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801ce1c:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ce20:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801ce24:	ee17 2a90 	vmov	r2, s15
        Temp2ToSend = intPart*10+decPart;
 801ce28:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 801ce2c:	b212      	sxth	r2, r2
 801ce2e:	e688      	b.n	801cb42 <HCI_Event_CB+0x24a>
        BSP_TEMPERATURE_Get_Temp(TargetBoardFeatures.HandleTempSensors[0],(float *)&SensorValue);
 801ce30:	a910      	add	r1, sp, #64	; 0x40
 801ce32:	68a0      	ldr	r0, [r4, #8]
 801ce34:	f001 fae6 	bl	801e404 <BSP_TEMPERATURE_Get_Temp>
        BSP_TEMPERATURE_Set_One_Shot(TargetBoardFeatures.HandleTempSensors[0]);
 801ce38:	68a0      	ldr	r0, [r4, #8]
 801ce3a:	f001 faf5 	bl	801e428 <BSP_TEMPERATURE_Set_One_Shot>
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801ce3e:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
 801ce42:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 801ce46:	ee17 6a10 	vmov	r6, s14
 801ce4a:	ee06 6a90 	vmov	s13, r6
 801ce4e:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 801ce52:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 801ce56:	ee77 7ae6 	vsub.f32	s15, s15, s13
        Temp1ToSend = intPart*10+decPart;
 801ce5a:	eb06 0386 	add.w	r3, r6, r6, lsl #2
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 801ce5e:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ce62:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801ce66:	ee17 6a90 	vmov	r6, s15
        Temp1ToSend = intPart*10+decPart;
 801ce6a:	eb06 0643 	add.w	r6, r6, r3, lsl #1
 801ce6e:	b236      	sxth	r6, r6
 801ce70:	e6c0      	b.n	801cbf4 <HCI_Event_CB+0x2fc>
        W2ST_ON_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING);
 801ce72:	682b      	ldr	r3, [r5, #0]
 801ce74:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 801ce78:	602b      	str	r3, [r5, #0]
 801ce7a:	e543      	b.n	801c904 <HCI_Event_CB+0xc>
    if (att_data[0] == 01) {
 801ce7c:	7b23      	ldrb	r3, [r4, #12]
 801ce7e:	2b01      	cmp	r3, #1
 801ce80:	f000 8088 	beq.w	801cf94 <HCI_Event_CB+0x69c>
    } else if (att_data[0] == 0){
 801ce84:	2b00      	cmp	r3, #0
 801ce86:	f47f ad3d 	bne.w	801c904 <HCI_Event_CB+0xc>
      W2ST_OFF_CONNECTION(W2ST_CONNECT_ENV);
 801ce8a:	682b      	ldr	r3, [r5, #0]
      stopProc(ENV);
 801ce8c:	2005      	movs	r0, #5
      W2ST_OFF_CONNECTION(W2ST_CONNECT_ENV);
 801ce8e:	f023 0301 	bic.w	r3, r3, #1
 801ce92:	602b      	str	r3, [r5, #0]
      stopProc(ENV);
 801ce94:	f7fd fe02 	bl	801aa9c <stopProc>
 801ce98:	e534      	b.n	801c904 <HCI_Event_CB+0xc>
    if (att_data[0] == 01) {
 801ce9a:	7b23      	ldrb	r3, [r4, #12]
 801ce9c:	2b01      	cmp	r3, #1
 801ce9e:	f000 8083 	beq.w	801cfa8 <HCI_Event_CB+0x6b0>
    } else if (att_data[0] == 0){
 801cea2:	2b00      	cmp	r3, #0
 801cea4:	f47f ad2e 	bne.w	801c904 <HCI_Event_CB+0xc>
      W2ST_OFF_CONNECTION(W2ST_CONNECT_STD_ERR);
 801cea8:	682b      	ldr	r3, [r5, #0]
 801ceaa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801ceae:	602b      	str	r3, [r5, #0]
 801ceb0:	e528      	b.n	801c904 <HCI_Event_CB+0xc>
    if (att_data[0] == 01) {
 801ceb2:	7b23      	ldrb	r3, [r4, #12]
 801ceb4:	2b01      	cmp	r3, #1
 801ceb6:	f000 80ab 	beq.w	801d010 <HCI_Event_CB+0x718>
    } else if (att_data[0] == 0){
 801ceba:	2b00      	cmp	r3, #0
 801cebc:	f47f ad22 	bne.w	801c904 <HCI_Event_CB+0xc>
      W2ST_OFF_CONNECTION(W2ST_CONNECT_STD_TERM);
 801cec0:	682b      	ldr	r3, [r5, #0]
 801cec2:	f023 0320 	bic.w	r3, r3, #32
 801cec6:	602b      	str	r3, [r5, #0]
 801cec8:	e51c      	b.n	801c904 <HCI_Event_CB+0xc>
    if(SizeOfUpdateBlueFW!=0) {
 801ceca:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 801cecc:	2b00      	cmp	r3, #0
 801cece:	f47f ad19 	bne.w	801c904 <HCI_Event_CB+0xc>
    if(!strncmp("help",(char *)(att_data),4)) {
 801ced2:	2204      	movs	r2, #4
 801ced4:	4639      	mov	r1, r7
 801ced6:	485a      	ldr	r0, [pc, #360]	; (801d040 <HCI_Event_CB+0x748>)
 801ced8:	f002 fb7e 	bl	801f5d8 <strncmp>
 801cedc:	2800      	cmp	r0, #0
 801cede:	f000 8108 	beq.w	801d0f2 <HCI_Event_CB+0x7fa>
    } else if(!strncmp("versionFw",(char *)(att_data),9)) {
 801cee2:	2209      	movs	r2, #9
 801cee4:	4639      	mov	r1, r7
 801cee6:	4857      	ldr	r0, [pc, #348]	; (801d044 <HCI_Event_CB+0x74c>)
 801cee8:	f002 fb76 	bl	801f5d8 <strncmp>
 801ceec:	2800      	cmp	r0, #0
 801ceee:	f000 80ed 	beq.w	801d0cc <HCI_Event_CB+0x7d4>
    } else if(!strncmp("powerstatus",(char *)(att_data),11)) {
 801cef2:	220b      	movs	r2, #11
 801cef4:	4639      	mov	r1, r7
 801cef6:	4854      	ldr	r0, [pc, #336]	; (801d048 <HCI_Event_CB+0x750>)
 801cef8:	f002 fb6e 	bl	801f5d8 <strncmp>
 801cefc:	2800      	cmp	r0, #0
 801cefe:	f040 80af 	bne.w	801d060 <HCI_Event_CB+0x768>
      if(TargetBoardFeatures.HandleGGComponent) {
 801cf02:	4c4e      	ldr	r4, [pc, #312]	; (801d03c <HCI_Event_CB+0x744>)
 801cf04:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 801cf06:	2800      	cmp	r0, #0
 801cf08:	f000 8087 	beq.w	801d01a <HCI_Event_CB+0x722>
        BSP_GG_Task(TargetBoardFeatures.HandleGGComponent,&v_mode);
 801cf0c:	f10d 0137 	add.w	r1, sp, #55	; 0x37
 801cf10:	f7f2 fe6c 	bl	800fbec <BSP_GG_Task>
        BSP_GG_GetVoltage(TargetBoardFeatures.HandleGGComponent, &voltage);
 801cf14:	a90e      	add	r1, sp, #56	; 0x38
 801cf16:	6ba0      	ldr	r0, [r4, #56]	; 0x38
        BytesToWrite =sprintf((char *)BufferToWrite,"Battery %ld%% %ld mV Current=%ld mA\n",soc,voltage,current);
 801cf18:	f8df 813c 	ldr.w	r8, [pc, #316]	; 801d058 <HCI_Event_CB+0x760>
        BSP_GG_GetVoltage(TargetBoardFeatures.HandleGGComponent, &voltage);
 801cf1c:	f7f2 fe7e 	bl	800fc1c <BSP_GG_GetVoltage>
        BSP_GG_GetSOC(TargetBoardFeatures.HandleGGComponent, &soc);
 801cf20:	a90f      	add	r1, sp, #60	; 0x3c
 801cf22:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 801cf24:	f7f2 fe6a 	bl	800fbfc <BSP_GG_GetSOC>
        BSP_GG_GetCurrent(TargetBoardFeatures.HandleGGComponent, &current);
 801cf28:	a910      	add	r1, sp, #64	; 0x40
 801cf2a:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 801cf2c:	f7f2 fe6e 	bl	800fc0c <BSP_GG_GetCurrent>
        BytesToWrite =sprintf((char *)BufferToWrite,"Battery %ld%% %ld mV Current=%ld mA\n",soc,voltage,current);
 801cf30:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801cf32:	9300      	str	r3, [sp, #0]
 801cf34:	4945      	ldr	r1, [pc, #276]	; (801d04c <HCI_Event_CB+0x754>)
 801cf36:	4846      	ldr	r0, [pc, #280]	; (801d050 <HCI_Event_CB+0x758>)
 801cf38:	e9dd 320e 	ldrd	r3, r2, [sp, #56]	; 0x38
 801cf3c:	f002 fb2c 	bl	801f598 <siprintf>
 801cf40:	f8c8 0000 	str.w	r0, [r8]
      Term_Update(BufferToWrite,BytesToWrite);
 801cf44:	f898 1000 	ldrb.w	r1, [r8]
 801cf48:	4841      	ldr	r0, [pc, #260]	; (801d050 <HCI_Event_CB+0x758>)
 801cf4a:	f7fe ffa7 	bl	801be9c <Term_Update>
 801cf4e:	e4d9      	b.n	801c904 <HCI_Event_CB+0xc>
      W2ST_ON_CONNECTION(W2ST_CONNECT_ACC_EVENT);
 801cf50:	682b      	ldr	r3, [r5, #0]
 801cf52:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801cf56:	602b      	str	r3, [r5, #0]
      EnableHWMultipleEvents();
 801cf58:	f7fd fa1c 	bl	801a394 <EnableHWMultipleEvents>
      ResetHWPedometer();
 801cf5c:	f7fd fa02 	bl	801a364 <ResetHWPedometer>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CONF_EVENT)) {
 801cf60:	682b      	ldr	r3, [r5, #0]
 801cf62:	059a      	lsls	r2, r3, #22
 801cf64:	f57f acce 	bpl.w	801c904 <HCI_Event_CB+0xc>
  msg.conf.feature = Feature;
 801cf68:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801cf6c:	f240 136d 	movw	r3, #365	; 0x16d
  SendMsgToHost(&msg);
 801cf70:	a810      	add	r0, sp, #64	; 0x40
  msg.type         = CONF_NOTIFY;
 801cf72:	f88d 4040 	strb.w	r4, [sp, #64]	; 0x40
  msg.conf.feature = Feature;
 801cf76:	9211      	str	r2, [sp, #68]	; 0x44
 801cf78:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
  SendMsgToHost(&msg);
 801cf7c:	f7fd fd74 	bl	801aa68 <SendMsgToHost>
 801cf80:	e4c0      	b.n	801c904 <HCI_Event_CB+0xc>
       W2ST_ON_CONNECTION(W2ST_CONNECT_ACC_GYRO_MAG);
 801cf82:	682b      	ldr	r3, [r5, #0]
       startProc(MOTION, INERTIAL_UPDATE_MS );
 801cf84:	2132      	movs	r1, #50	; 0x32
       W2ST_ON_CONNECTION(W2ST_CONNECT_ACC_GYRO_MAG);
 801cf86:	f043 0304 	orr.w	r3, r3, #4
       startProc(MOTION, INERTIAL_UPDATE_MS );
 801cf8a:	2006      	movs	r0, #6
       W2ST_ON_CONNECTION(W2ST_CONNECT_ACC_GYRO_MAG);
 801cf8c:	602b      	str	r3, [r5, #0]
       startProc(MOTION, INERTIAL_UPDATE_MS );
 801cf8e:	f7fd fe25 	bl	801abdc <startProc>
 801cf92:	e4b7      	b.n	801c904 <HCI_Event_CB+0xc>
      W2ST_ON_CONNECTION(W2ST_CONNECT_ENV);
 801cf94:	682b      	ldr	r3, [r5, #0]
      startProc(ENV,ENV_UPDATE_MS);
 801cf96:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
      W2ST_ON_CONNECTION(W2ST_CONNECT_ENV);
 801cf9a:	f043 0301 	orr.w	r3, r3, #1
      startProc(ENV,ENV_UPDATE_MS);
 801cf9e:	2005      	movs	r0, #5
      W2ST_ON_CONNECTION(W2ST_CONNECT_ENV);
 801cfa0:	602b      	str	r3, [r5, #0]
      startProc(ENV,ENV_UPDATE_MS);
 801cfa2:	f7fd fe1b 	bl	801abdc <startProc>
 801cfa6:	e4ad      	b.n	801c904 <HCI_Event_CB+0xc>
      W2ST_ON_CONNECTION(W2ST_CONNECT_STD_ERR);
 801cfa8:	682b      	ldr	r3, [r5, #0]
 801cfaa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801cfae:	602b      	str	r3, [r5, #0]
 801cfb0:	e4a8      	b.n	801c904 <HCI_Event_CB+0xc>
    switch(att_data[0]) {
 801cfb2:	7b23      	ldrb	r3, [r4, #12]
 801cfb4:	2b01      	cmp	r3, #1
 801cfb6:	f000 82a3 	beq.w	801d500 <HCI_Event_CB+0xc08>
 801cfba:	f0c0 8276 	bcc.w	801d4aa <HCI_Event_CB+0xbb2>
 801cfbe:	2b04      	cmp	r3, #4
 801cfc0:	f47f aca0 	bne.w	801c904 <HCI_Event_CB+0xc>
        SaveDataAnnotation(att_data+1);
 801cfc4:	340d      	adds	r4, #13
 801cfc6:	4620      	mov	r0, r4
 801cfc8:	f7fc fef6 	bl	8019db8 <SaveDataAnnotation>
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801cfcc:	682b      	ldr	r3, [r5, #0]
 801cfce:	065a      	lsls	r2, r3, #25
 801cfd0:	f57f ac98 	bpl.w	801c904 <HCI_Event_CB+0xc>
          BytesToWrite =sprintf((char *)BufferToWrite, "Ann->[%s]\n",att_data+1);
 801cfd4:	491f      	ldr	r1, [pc, #124]	; (801d054 <HCI_Event_CB+0x75c>)
 801cfd6:	481e      	ldr	r0, [pc, #120]	; (801d050 <HCI_Event_CB+0x758>)
 801cfd8:	4622      	mov	r2, r4
 801cfda:	f002 fadd 	bl	801f598 <siprintf>
 801cfde:	4b1e      	ldr	r3, [pc, #120]	; (801d058 <HCI_Event_CB+0x760>)
 801cfe0:	4601      	mov	r1, r0
 801cfe2:	6019      	str	r1, [r3, #0]
          Term_Update(BufferToWrite,BytesToWrite);
 801cfe4:	481a      	ldr	r0, [pc, #104]	; (801d050 <HCI_Event_CB+0x758>)
 801cfe6:	b2c9      	uxtb	r1, r1
 801cfe8:	f7fe ff58 	bl	801be9c <Term_Update>
 801cfec:	e48a      	b.n	801c904 <HCI_Event_CB+0xc>
    if (att_data[0] == 01) {
 801cfee:	7b23      	ldrb	r3, [r4, #12]
 801cff0:	2b01      	cmp	r3, #1
 801cff2:	f000 8311 	beq.w	801d618 <HCI_Event_CB+0xd20>
    } else if (att_data[0] == 0) {
 801cff6:	2b00      	cmp	r3, #0
 801cff8:	f47f ac84 	bne.w	801c904 <HCI_Event_CB+0xc>
      W2ST_OFF_CONNECTION(W2ST_CONNECT_AUDIO_LEVEL);
 801cffc:	682b      	ldr	r3, [r5, #0]
 801cffe:	f023 0308 	bic.w	r3, r3, #8
 801d002:	602b      	str	r3, [r5, #0]
      DeInitMics();
 801d004:	f7fd fbea 	bl	801a7dc <DeInitMics>
      stopProc(AUDIO_LEV);
 801d008:	2009      	movs	r0, #9
 801d00a:	f7fd fd47 	bl	801aa9c <stopProc>
 801d00e:	e479      	b.n	801c904 <HCI_Event_CB+0xc>
      W2ST_ON_CONNECTION(W2ST_CONNECT_STD_TERM);
 801d010:	682b      	ldr	r3, [r5, #0]
 801d012:	f043 0320 	orr.w	r3, r3, #32
 801d016:	602b      	str	r3, [r5, #0]
 801d018:	e474      	b.n	801c904 <HCI_Event_CB+0xc>
        BytesToWrite =sprintf((char *)BufferToWrite,"Battery not present\n");
 801d01a:	4c10      	ldr	r4, [pc, #64]	; (801d05c <HCI_Event_CB+0x764>)
 801d01c:	4d0c      	ldr	r5, [pc, #48]	; (801d050 <HCI_Event_CB+0x758>)
 801d01e:	f8df 8038 	ldr.w	r8, [pc, #56]	; 801d058 <HCI_Event_CB+0x760>
 801d022:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801d024:	6028      	str	r0, [r5, #0]
 801d026:	7926      	ldrb	r6, [r4, #4]
 801d028:	6820      	ldr	r0, [r4, #0]
 801d02a:	6069      	str	r1, [r5, #4]
 801d02c:	2114      	movs	r1, #20
 801d02e:	60aa      	str	r2, [r5, #8]
 801d030:	60eb      	str	r3, [r5, #12]
 801d032:	6128      	str	r0, [r5, #16]
 801d034:	752e      	strb	r6, [r5, #20]
 801d036:	f8c8 1000 	str.w	r1, [r8]
 801d03a:	e783      	b.n	801cf44 <HCI_Event_CB+0x64c>
 801d03c:	20011458 	.word	0x20011458
 801d040:	08075a10 	.word	0x08075a10
 801d044:	08075afc 	.word	0x08075afc
 801d048:	08075b30 	.word	0x08075b30
 801d04c:	08075b3c 	.word	0x08075b3c
 801d050:	20013174 	.word	0x20013174
 801d054:	08075e48 	.word	0x08075e48
 801d058:	200132a0 	.word	0x200132a0
 801d05c:	08075b64 	.word	0x08075b64
    } else if(!strncmp("info",(char *)(att_data),4)) {
 801d060:	2204      	movs	r2, #4
 801d062:	4639      	mov	r1, r7
 801d064:	48b6      	ldr	r0, [pc, #728]	; (801d340 <HCI_Event_CB+0xa48>)
 801d066:	f002 fab7 	bl	801f5d8 <strncmp>
 801d06a:	2800      	cmp	r0, #0
 801d06c:	f000 83a4 	beq.w	801d7b8 <HCI_Event_CB+0xec0>
    } else if(!strncmp("upgradeFw",(char *)(att_data),9)) {
 801d070:	2209      	movs	r2, #9
 801d072:	4639      	mov	r1, r7
 801d074:	48b3      	ldr	r0, [pc, #716]	; (801d344 <HCI_Event_CB+0xa4c>)
 801d076:	f002 faaf 	bl	801f5d8 <strncmp>
 801d07a:	4680      	mov	r8, r0
 801d07c:	2800      	cmp	r0, #0
 801d07e:	f000 81f0 	beq.w	801d462 <HCI_Event_CB+0xb6a>
    } else if(!strncmp("uid",(char *)(att_data),3)) {
 801d082:	2203      	movs	r2, #3
 801d084:	4639      	mov	r1, r7
 801d086:	48b0      	ldr	r0, [pc, #704]	; (801d348 <HCI_Event_CB+0xa50>)
 801d088:	f002 faa6 	bl	801f5d8 <strncmp>
 801d08c:	2800      	cmp	r0, #0
 801d08e:	f000 811a 	beq.w	801d2c6 <HCI_Event_CB+0x9ce>
    } else if(!strncmp("setName ",(char *)(att_data),8)) {
 801d092:	2208      	movs	r2, #8
 801d094:	4639      	mov	r1, r7
 801d096:	48ad      	ldr	r0, [pc, #692]	; (801d34c <HCI_Event_CB+0xa54>)
 801d098:	f002 fa9e 	bl	801f5d8 <strncmp>
 801d09c:	2800      	cmp	r0, #0
 801d09e:	f040 80f6 	bne.w	801d28e <HCI_Event_CB+0x996>
      int32_t NameLength= data_length -1;
 801d0a2:	1e73      	subs	r3, r6, #1
      if(NameLength > 8) {
 801d0a4:	2b08      	cmp	r3, #8
 801d0a6:	f340 80dc 	ble.w	801d262 <HCI_Event_CB+0x96a>
        if((NameLength - 8) > 7) {
 801d0aa:	2b0f      	cmp	r3, #15
 801d0ac:	f300 80c1 	bgt.w	801d232 <HCI_Event_CB+0x93a>
 801d0b0:	f8df 82b0 	ldr.w	r8, [pc, #688]	; 801d364 <HCI_Event_CB+0xa6c>
          NameLength= NameLength - 8;
 801d0b4:	3e09      	subs	r6, #9
          NodeName[i]= att_data[i+7];
 801d0b6:	4aa6      	ldr	r2, [pc, #664]	; (801d350 <HCI_Event_CB+0xa58>)
 801d0b8:	3413      	adds	r4, #19
        for(i=1;i<NameLength+1;i++) {
 801d0ba:	2301      	movs	r3, #1
 801d0bc:	42b3      	cmp	r3, r6
 801d0be:	f300 8099 	bgt.w	801d1f4 <HCI_Event_CB+0x8fc>
          NodeName[i]= att_data[i+7];
 801d0c2:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 801d0c6:	5499      	strb	r1, [r3, r2]
        for(i=1;i<NameLength+1;i++) {
 801d0c8:	3301      	adds	r3, #1
 801d0ca:	e7f7      	b.n	801d0bc <HCI_Event_CB+0x7c4>
      BytesToWrite =sprintf((char *)BufferToWrite,"%s_%s_%c.%c.%c\r\n",
 801d0cc:	2330      	movs	r3, #48	; 0x30
 801d0ce:	2231      	movs	r2, #49	; 0x31
 801d0d0:	e9cd 3301 	strd	r3, r3, [sp, #4]
 801d0d4:	9200      	str	r2, [sp, #0]
 801d0d6:	4b9f      	ldr	r3, [pc, #636]	; (801d354 <HCI_Event_CB+0xa5c>)
 801d0d8:	4a9f      	ldr	r2, [pc, #636]	; (801d358 <HCI_Event_CB+0xa60>)
 801d0da:	49a0      	ldr	r1, [pc, #640]	; (801d35c <HCI_Event_CB+0xa64>)
 801d0dc:	48a0      	ldr	r0, [pc, #640]	; (801d360 <HCI_Event_CB+0xa68>)
 801d0de:	f002 fa5b 	bl	801f598 <siprintf>
 801d0e2:	2318      	movs	r3, #24
 801d0e4:	4a9f      	ldr	r2, [pc, #636]	; (801d364 <HCI_Event_CB+0xa6c>)
      Term_Update(BufferToWrite,BytesToWrite);
 801d0e6:	489e      	ldr	r0, [pc, #632]	; (801d360 <HCI_Event_CB+0xa68>)
      BytesToWrite =sprintf((char *)BufferToWrite,"%s_%s_%c.%c.%c\r\n",
 801d0e8:	6013      	str	r3, [r2, #0]
      Term_Update(BufferToWrite,BytesToWrite);
 801d0ea:	4619      	mov	r1, r3
 801d0ec:	f7fe fed6 	bl	801be9c <Term_Update>
 801d0f0:	e408      	b.n	801c904 <HCI_Event_CB+0xc>
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d0f2:	4d9d      	ldr	r5, [pc, #628]	; (801d368 <HCI_Event_CB+0xa70>)
 801d0f4:	4c9a      	ldr	r4, [pc, #616]	; (801d360 <HCI_Event_CB+0xa68>)
 801d0f6:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 801d0fa:	4626      	mov	r6, r4
 801d0fc:	462f      	mov	r7, r5
 801d0fe:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 801d100:	4567      	cmp	r7, ip
 801d102:	6030      	str	r0, [r6, #0]
 801d104:	6071      	str	r1, [r6, #4]
 801d106:	60b2      	str	r2, [r6, #8]
 801d108:	60f3      	str	r3, [r6, #12]
 801d10a:	463d      	mov	r5, r7
 801d10c:	f106 0610 	add.w	r6, r6, #16
 801d110:	d1f4      	bne.n	801d0fc <HCI_Event_CB+0x804>
 801d112:	463b      	mov	r3, r7
 801d114:	cb03      	ldmia	r3!, {r0, r1}
 801d116:	223a      	movs	r2, #58	; 0x3a
 801d118:	6071      	str	r1, [r6, #4]
 801d11a:	f8df 8248 	ldr.w	r8, [pc, #584]	; 801d364 <HCI_Event_CB+0xa6c>
 801d11e:	8819      	ldrh	r1, [r3, #0]
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d120:	4d92      	ldr	r5, [pc, #584]	; (801d36c <HCI_Event_CB+0xa74>)
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d122:	789b      	ldrb	r3, [r3, #2]
 801d124:	6030      	str	r0, [r6, #0]
 801d126:	8131      	strh	r1, [r6, #8]
 801d128:	72b3      	strb	r3, [r6, #10]
      Term_Update(BufferToWrite,BytesToWrite);
 801d12a:	4611      	mov	r1, r2
 801d12c:	488c      	ldr	r0, [pc, #560]	; (801d360 <HCI_Event_CB+0xa68>)
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d12e:	4e8c      	ldr	r6, [pc, #560]	; (801d360 <HCI_Event_CB+0xa68>)
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d130:	f8c8 2000 	str.w	r2, [r8]
      Term_Update(BufferToWrite,BytesToWrite);
 801d134:	f7fe feb2 	bl	801be9c <Term_Update>
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d138:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 801d13c:	462f      	mov	r7, r5
 801d13e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 801d140:	4567      	cmp	r7, ip
 801d142:	6030      	str	r0, [r6, #0]
 801d144:	6071      	str	r1, [r6, #4]
 801d146:	60b2      	str	r2, [r6, #8]
 801d148:	60f3      	str	r3, [r6, #12]
 801d14a:	463d      	mov	r5, r7
 801d14c:	f106 0610 	add.w	r6, r6, #16
 801d150:	d1f4      	bne.n	801d13c <HCI_Event_CB+0x844>
 801d152:	463b      	mov	r3, r7
 801d154:	cb03      	ldmia	r3!, {r0, r1}
 801d156:	223a      	movs	r2, #58	; 0x3a
 801d158:	6071      	str	r1, [r6, #4]
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d15a:	4d85      	ldr	r5, [pc, #532]	; (801d370 <HCI_Event_CB+0xa78>)
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d15c:	8819      	ldrh	r1, [r3, #0]
 801d15e:	789b      	ldrb	r3, [r3, #2]
 801d160:	6030      	str	r0, [r6, #0]
 801d162:	8131      	strh	r1, [r6, #8]
 801d164:	72b3      	strb	r3, [r6, #10]
      Term_Update(BufferToWrite,BytesToWrite);
 801d166:	487e      	ldr	r0, [pc, #504]	; (801d360 <HCI_Event_CB+0xa68>)
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d168:	4e7d      	ldr	r6, [pc, #500]	; (801d360 <HCI_Event_CB+0xa68>)
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d16a:	f8c8 2000 	str.w	r2, [r8]
      Term_Update(BufferToWrite,BytesToWrite);
 801d16e:	4611      	mov	r1, r2
 801d170:	f7fe fe94 	bl	801be9c <Term_Update>
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d174:	f105 0c20 	add.w	ip, r5, #32
 801d178:	462f      	mov	r7, r5
 801d17a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 801d17c:	4567      	cmp	r7, ip
 801d17e:	6030      	str	r0, [r6, #0]
 801d180:	6071      	str	r1, [r6, #4]
 801d182:	60b2      	str	r2, [r6, #8]
 801d184:	60f3      	str	r3, [r6, #12]
 801d186:	463d      	mov	r5, r7
 801d188:	f106 0610 	add.w	r6, r6, #16
 801d18c:	d1f4      	bne.n	801d178 <HCI_Event_CB+0x880>
 801d18e:	cd03      	ldmia	r5!, {r0, r1}
 801d190:	2328      	movs	r3, #40	; 0x28
 801d192:	782a      	ldrb	r2, [r5, #0]
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d194:	4d77      	ldr	r5, [pc, #476]	; (801d374 <HCI_Event_CB+0xa7c>)
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d196:	6030      	str	r0, [r6, #0]
 801d198:	6071      	str	r1, [r6, #4]
 801d19a:	7232      	strb	r2, [r6, #8]
      Term_Update(BufferToWrite,BytesToWrite);
 801d19c:	4619      	mov	r1, r3
 801d19e:	4870      	ldr	r0, [pc, #448]	; (801d360 <HCI_Event_CB+0xa68>)
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d1a0:	f8c8 3000 	str.w	r3, [r8]
      Term_Update(BufferToWrite,BytesToWrite);
 801d1a4:	f7fe fe7a 	bl	801be9c <Term_Update>
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d1a8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d1aa:	6020      	str	r0, [r4, #0]
 801d1ac:	6061      	str	r1, [r4, #4]
 801d1ae:	60a2      	str	r2, [r4, #8]
 801d1b0:	cd07      	ldmia	r5!, {r0, r1, r2}
 801d1b2:	882d      	ldrh	r5, [r5, #0]
 801d1b4:	83a5      	strh	r5, [r4, #28]
 801d1b6:	261d      	movs	r6, #29
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d1b8:	4d6f      	ldr	r5, [pc, #444]	; (801d378 <HCI_Event_CB+0xa80>)
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d1ba:	6120      	str	r0, [r4, #16]
 801d1bc:	6161      	str	r1, [r4, #20]
 801d1be:	60e3      	str	r3, [r4, #12]
      Term_Update(BufferToWrite,BytesToWrite);
 801d1c0:	4631      	mov	r1, r6
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d1c2:	61a2      	str	r2, [r4, #24]
      Term_Update(BufferToWrite,BytesToWrite);
 801d1c4:	4866      	ldr	r0, [pc, #408]	; (801d360 <HCI_Event_CB+0xa68>)
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d1c6:	f8c8 6000 	str.w	r6, [r8]
      Term_Update(BufferToWrite,BytesToWrite);
 801d1ca:	f7fe fe67 	bl	801be9c <Term_Update>
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d1ce:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d1d0:	6020      	str	r0, [r4, #0]
 801d1d2:	6061      	str	r1, [r4, #4]
 801d1d4:	60a2      	str	r2, [r4, #8]
 801d1d6:	cd07      	ldmia	r5!, {r0, r1, r2}
 801d1d8:	882d      	ldrh	r5, [r5, #0]
 801d1da:	6120      	str	r0, [r4, #16]
 801d1dc:	6161      	str	r1, [r4, #20]
 801d1de:	60e3      	str	r3, [r4, #12]
      Term_Update(BufferToWrite,BytesToWrite);
 801d1e0:	4631      	mov	r1, r6
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d1e2:	83a5      	strh	r5, [r4, #28]
 801d1e4:	61a2      	str	r2, [r4, #24]
      Term_Update(BufferToWrite,BytesToWrite);
 801d1e6:	485e      	ldr	r0, [pc, #376]	; (801d360 <HCI_Event_CB+0xa68>)
      BytesToWrite =sprintf((char *)BufferToWrite,
 801d1e8:	f8c8 6000 	str.w	r6, [r8]
      Term_Update(BufferToWrite,BytesToWrite);
 801d1ec:	f7fe fe56 	bl	801be9c <Term_Update>
 801d1f0:	f7ff bb88 	b.w	801c904 <HCI_Event_CB+0xc>
 801d1f4:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
          NodeName[i]= ' ';
 801d1f8:	4955      	ldr	r1, [pc, #340]	; (801d350 <HCI_Event_CB+0xa58>)
 801d1fa:	1c73      	adds	r3, r6, #1
 801d1fc:	2220      	movs	r2, #32
        for(;i<8;i++) {
 801d1fe:	2b07      	cmp	r3, #7
 801d200:	dc02      	bgt.n	801d208 <HCI_Event_CB+0x910>
          NodeName[i]= ' ';
 801d202:	545a      	strb	r2, [r3, r1]
        for(;i<8;i++) {
 801d204:	3301      	adds	r3, #1
 801d206:	e7fa      	b.n	801d1fe <HCI_Event_CB+0x906>
        MDM_SaveGMD(GMD_NODE_NAME,(void *)&NodeName);
 801d208:	4951      	ldr	r1, [pc, #324]	; (801d350 <HCI_Event_CB+0xa58>)
 801d20a:	2007      	movs	r0, #7
 801d20c:	f7fb fa8a 	bl	8018724 <MDM_SaveGMD>
        NecessityToSaveMetaDataManager=1;
 801d210:	4b5a      	ldr	r3, [pc, #360]	; (801d37c <HCI_Event_CB+0xa84>)
        BytesToWrite =sprintf((char *)BufferToWrite,"New NodeName= %s\n",NodeName);
 801d212:	4a4f      	ldr	r2, [pc, #316]	; (801d350 <HCI_Event_CB+0xa58>)
 801d214:	495a      	ldr	r1, [pc, #360]	; (801d380 <HCI_Event_CB+0xa88>)
 801d216:	4852      	ldr	r0, [pc, #328]	; (801d360 <HCI_Event_CB+0xa68>)
        NecessityToSaveMetaDataManager=1;
 801d218:	2401      	movs	r4, #1
 801d21a:	601c      	str	r4, [r3, #0]
        BytesToWrite =sprintf((char *)BufferToWrite,"SD File Name =%s\n",DefaultDataFileName);
 801d21c:	f002 f9bc 	bl	801f598 <siprintf>
 801d220:	4603      	mov	r3, r0
        Term_Update(BufferToWrite,BytesToWrite);
 801d222:	b2c1      	uxtb	r1, r0
 801d224:	484e      	ldr	r0, [pc, #312]	; (801d360 <HCI_Event_CB+0xa68>)
        BytesToWrite =sprintf((char *)BufferToWrite,"SD File Name =%s\n",DefaultDataFileName);
 801d226:	f8c8 3000 	str.w	r3, [r8]
        Term_Update(BufferToWrite,BytesToWrite);
 801d22a:	f7fe fe37 	bl	801be9c <Term_Update>
 801d22e:	f7ff bb69 	b.w	801c904 <HCI_Event_CB+0xc>
          BytesToWrite =sprintf((char *)BufferToWrite,"NodeName too long\n");
 801d232:	4d54      	ldr	r5, [pc, #336]	; (801d384 <HCI_Event_CB+0xa8c>)
 801d234:	4e4a      	ldr	r6, [pc, #296]	; (801d360 <HCI_Event_CB+0xa68>)
 801d236:	f8df 812c 	ldr.w	r8, [pc, #300]	; 801d364 <HCI_Event_CB+0xa6c>
 801d23a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d23c:	2712      	movs	r7, #18
 801d23e:	f8b5 c000 	ldrh.w	ip, [r5]
 801d242:	78ad      	ldrb	r5, [r5, #2]
 801d244:	6030      	str	r0, [r6, #0]
 801d246:	6071      	str	r1, [r6, #4]
 801d248:	60b2      	str	r2, [r6, #8]
          Term_Update(BufferToWrite,BytesToWrite);
 801d24a:	4630      	mov	r0, r6
          BytesToWrite =sprintf((char *)BufferToWrite,"NodeName too long\n");
 801d24c:	60f3      	str	r3, [r6, #12]
 801d24e:	f8a6 c010 	strh.w	ip, [r6, #16]
 801d252:	74b5      	strb	r5, [r6, #18]
          Term_Update(BufferToWrite,BytesToWrite);
 801d254:	4639      	mov	r1, r7
          BytesToWrite =sprintf((char *)BufferToWrite,"NodeName too long\n");
 801d256:	f8c8 7000 	str.w	r7, [r8]
          NameLength= 7;
 801d25a:	2607      	movs	r6, #7
          Term_Update(BufferToWrite,BytesToWrite);
 801d25c:	f7fe fe1e 	bl	801be9c <Term_Update>
 801d260:	e729      	b.n	801d0b6 <HCI_Event_CB+0x7be>
        BytesToWrite =sprintf((char *)BufferToWrite,"Node Name missing\n");
 801d262:	4c49      	ldr	r4, [pc, #292]	; (801d388 <HCI_Event_CB+0xa90>)
 801d264:	4d3e      	ldr	r5, [pc, #248]	; (801d360 <HCI_Event_CB+0xa68>)
 801d266:	4f3f      	ldr	r7, [pc, #252]	; (801d364 <HCI_Event_CB+0xa6c>)
 801d268:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801d26a:	2612      	movs	r6, #18
 801d26c:	f8b4 c000 	ldrh.w	ip, [r4]
 801d270:	78a4      	ldrb	r4, [r4, #2]
 801d272:	6028      	str	r0, [r5, #0]
 801d274:	6069      	str	r1, [r5, #4]
 801d276:	60aa      	str	r2, [r5, #8]
        Term_Update(BufferToWrite,BytesToWrite);
 801d278:	4628      	mov	r0, r5
        BytesToWrite =sprintf((char *)BufferToWrite,"Node Name missing\n");
 801d27a:	60eb      	str	r3, [r5, #12]
        Term_Update(BufferToWrite,BytesToWrite);
 801d27c:	4631      	mov	r1, r6
        BytesToWrite =sprintf((char *)BufferToWrite,"Node Name missing\n");
 801d27e:	f8a5 c010 	strh.w	ip, [r5, #16]
 801d282:	74ac      	strb	r4, [r5, #18]
 801d284:	603e      	str	r6, [r7, #0]
        Term_Update(BufferToWrite,BytesToWrite);
 801d286:	f7fe fe09 	bl	801be9c <Term_Update>
 801d28a:	f7ff bb3b 	b.w	801c904 <HCI_Event_CB+0xc>
    } else if(!strncmp("SDName ",(char *)(att_data),7)) {
 801d28e:	2207      	movs	r2, #7
 801d290:	4639      	mov	r1, r7
 801d292:	483e      	ldr	r0, [pc, #248]	; (801d38c <HCI_Event_CB+0xa94>)
 801d294:	f002 f9a0 	bl	801f5d8 <strncmp>
 801d298:	2800      	cmp	r0, #0
 801d29a:	f040 80d1 	bne.w	801d440 <HCI_Event_CB+0xb48>
      int32_t NameLength= data_length -1;
 801d29e:	1e73      	subs	r3, r6, #1
      if(NameLength > 7) {
 801d2a0:	2b07      	cmp	r3, #7
 801d2a2:	f340 80a3 	ble.w	801d3ec <HCI_Event_CB+0xaf4>
        if((NameLength - 7) > 10) {
 801d2a6:	2b11      	cmp	r3, #17
 801d2a8:	f300 8086 	bgt.w	801d3b8 <HCI_Event_CB+0xac0>
 801d2ac:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 801d364 <HCI_Event_CB+0xa6c>
          NameLength= NameLength - 7;
 801d2b0:	3e08      	subs	r6, #8
 801d2b2:	4837      	ldr	r0, [pc, #220]	; (801d390 <HCI_Event_CB+0xa98>)
 801d2b4:	3412      	adds	r4, #18
        for(i=0;i<NameLength;i++) {
 801d2b6:	2300      	movs	r3, #0
 801d2b8:	42b3      	cmp	r3, r6
 801d2ba:	da38      	bge.n	801d32e <HCI_Event_CB+0xa36>
          DefaultDataFileName[i]= att_data[i+7];
 801d2bc:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 801d2c0:	54c2      	strb	r2, [r0, r3]
        for(i=0;i<NameLength;i++) {
 801d2c2:	3301      	adds	r3, #1
 801d2c4:	e7f8      	b.n	801d2b8 <HCI_Event_CB+0x9c0>
      uint32_t MCU_ID = STM32_MCU_ID[0]&0xFFF;
 801d2c6:	4a33      	ldr	r2, [pc, #204]	; (801d394 <HCI_Event_CB+0xa9c>)
                            uid[ 3],uid[ 2],uid[ 1],uid[ 0],
 801d2c8:	4b33      	ldr	r3, [pc, #204]	; (801d398 <HCI_Event_CB+0xaa0>)
      uint32_t MCU_ID = STM32_MCU_ID[0]&0xFFF;
 801d2ca:	6811      	ldr	r1, [r2, #0]
                            uid[ 3],uid[ 2],uid[ 1],uid[ 0],
 801d2cc:	4a33      	ldr	r2, [pc, #204]	; (801d39c <HCI_Event_CB+0xaa4>)
                            uid[11],uid[ 10],uid[9],uid[8],
 801d2ce:	4d34      	ldr	r5, [pc, #208]	; (801d3a0 <HCI_Event_CB+0xaa8>)
      BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 801d2d0:	781b      	ldrb	r3, [r3, #0]
 801d2d2:	7812      	ldrb	r2, [r2, #0]
                            uid[11],uid[ 10],uid[9],uid[8],
 801d2d4:	4c33      	ldr	r4, [pc, #204]	; (801d3a4 <HCI_Event_CB+0xaac>)
 801d2d6:	4834      	ldr	r0, [pc, #208]	; (801d3a8 <HCI_Event_CB+0xab0>)
      uint32_t MCU_ID = STM32_MCU_ID[0]&0xFFF;
 801d2d8:	f3c1 010b 	ubfx	r1, r1, #0, #12
      BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 801d2dc:	910a      	str	r1, [sp, #40]	; 0x28
 801d2de:	7829      	ldrb	r1, [r5, #0]
 801d2e0:	9109      	str	r1, [sp, #36]	; 0x24
 801d2e2:	7821      	ldrb	r1, [r4, #0]
 801d2e4:	9108      	str	r1, [sp, #32]
 801d2e6:	7800      	ldrb	r0, [r0, #0]
                            uid[11],uid[ 10],uid[9],uid[8],
 801d2e8:	4930      	ldr	r1, [pc, #192]	; (801d3ac <HCI_Event_CB+0xab4>)
      BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 801d2ea:	9007      	str	r0, [sp, #28]
 801d2ec:	7808      	ldrb	r0, [r1, #0]
 801d2ee:	9006      	str	r0, [sp, #24]
 801d2f0:	f811 0c07 	ldrb.w	r0, [r1, #-7]
 801d2f4:	9005      	str	r0, [sp, #20]
 801d2f6:	f811 0c06 	ldrb.w	r0, [r1, #-6]
 801d2fa:	9004      	str	r0, [sp, #16]
 801d2fc:	f811 0c05 	ldrb.w	r0, [r1, #-5]
 801d300:	9003      	str	r0, [sp, #12]
 801d302:	f811 0c04 	ldrb.w	r0, [r1, #-4]
 801d306:	9002      	str	r0, [sp, #8]
 801d308:	f811 0c0b 	ldrb.w	r0, [r1, #-11]
 801d30c:	9001      	str	r0, [sp, #4]
                            uid[ 3],uid[ 2],uid[ 1],uid[ 0],
 801d30e:	390a      	subs	r1, #10
      BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 801d310:	4813      	ldr	r0, [pc, #76]	; (801d360 <HCI_Event_CB+0xa68>)
 801d312:	7809      	ldrb	r1, [r1, #0]
 801d314:	9100      	str	r1, [sp, #0]
 801d316:	4926      	ldr	r1, [pc, #152]	; (801d3b0 <HCI_Event_CB+0xab8>)
 801d318:	f002 f93e 	bl	801f598 <siprintf>
 801d31c:	231d      	movs	r3, #29
 801d31e:	4a11      	ldr	r2, [pc, #68]	; (801d364 <HCI_Event_CB+0xa6c>)
      Term_Update(BufferToWrite,BytesToWrite);
 801d320:	480f      	ldr	r0, [pc, #60]	; (801d360 <HCI_Event_CB+0xa68>)
      BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 801d322:	6013      	str	r3, [r2, #0]
      Term_Update(BufferToWrite,BytesToWrite);
 801d324:	4619      	mov	r1, r3
 801d326:	f7fe fdb9 	bl	801be9c <Term_Update>
 801d32a:	f7ff baeb 	b.w	801c904 <HCI_Event_CB+0xc>
        DefaultDataFileName[i]='\0';
 801d32e:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
 801d332:	2300      	movs	r3, #0
 801d334:	5583      	strb	r3, [r0, r6]
        BytesToWrite =sprintf((char *)BufferToWrite,"SD File Name =%s\n",DefaultDataFileName);
 801d336:	4a16      	ldr	r2, [pc, #88]	; (801d390 <HCI_Event_CB+0xa98>)
 801d338:	491e      	ldr	r1, [pc, #120]	; (801d3b4 <HCI_Event_CB+0xabc>)
 801d33a:	4809      	ldr	r0, [pc, #36]	; (801d360 <HCI_Event_CB+0xa68>)
 801d33c:	e76e      	b.n	801d21c <HCI_Event_CB+0x924>
 801d33e:	bf00      	nop
 801d340:	08075b7c 	.word	0x08075b7c
 801d344:	08075c30 	.word	0x08075c30
 801d348:	08075c3c 	.word	0x08075c3c
 801d34c:	08075c78 	.word	0x08075c78
 801d350:	20012708 	.word	0x20012708
 801d354:	08075b08 	.word	0x08075b08
 801d358:	08075b14 	.word	0x08075b14
 801d35c:	08075b1c 	.word	0x08075b1c
 801d360:	20013174 	.word	0x20013174
 801d364:	200132a0 	.word	0x200132a0
 801d368:	08075a18 	.word	0x08075a18
 801d36c:	08075a54 	.word	0x08075a54
 801d370:	08075a90 	.word	0x08075a90
 801d374:	08075abc 	.word	0x08075abc
 801d378:	08075adc 	.word	0x08075adc
 801d37c:	2000e028 	.word	0x2000e028
 801d380:	08075c98 	.word	0x08075c98
 801d384:	08075c84 	.word	0x08075c84
 801d388:	08075cac 	.word	0x08075cac
 801d38c:	08075cc0 	.word	0x08075cc0
 801d390:	2001144c 	.word	0x2001144c
 801d394:	e0042000 	.word	0xe0042000
 801d398:	1fff7592 	.word	0x1fff7592
 801d39c:	1fff7593 	.word	0x1fff7593
 801d3a0:	1fff7598 	.word	0x1fff7598
 801d3a4:	1fff7599 	.word	0x1fff7599
 801d3a8:	1fff759a 	.word	0x1fff759a
 801d3ac:	1fff759b 	.word	0x1fff759b
 801d3b0:	08075c40 	.word	0x08075c40
 801d3b4:	08075ce0 	.word	0x08075ce0
          BytesToWrite =sprintf((char *)BufferToWrite,"SD File Name too long\n");
 801d3b8:	4dc5      	ldr	r5, [pc, #788]	; (801d6d0 <HCI_Event_CB+0xdd8>)
 801d3ba:	4ec6      	ldr	r6, [pc, #792]	; (801d6d4 <HCI_Event_CB+0xddc>)
 801d3bc:	f8df 831c 	ldr.w	r8, [pc, #796]	; 801d6dc <HCI_Event_CB+0xde4>
 801d3c0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d3c2:	2716      	movs	r7, #22
 801d3c4:	6030      	str	r0, [r6, #0]
 801d3c6:	f8b5 c004 	ldrh.w	ip, [r5, #4]
 801d3ca:	6828      	ldr	r0, [r5, #0]
 801d3cc:	79ad      	ldrb	r5, [r5, #6]
 801d3ce:	6071      	str	r1, [r6, #4]
 801d3d0:	6130      	str	r0, [r6, #16]
 801d3d2:	60b2      	str	r2, [r6, #8]
          Term_Update(BufferToWrite,BytesToWrite);
 801d3d4:	4630      	mov	r0, r6
          BytesToWrite =sprintf((char *)BufferToWrite,"SD File Name too long\n");
 801d3d6:	60f3      	str	r3, [r6, #12]
 801d3d8:	f8a6 c014 	strh.w	ip, [r6, #20]
 801d3dc:	75b5      	strb	r5, [r6, #22]
          Term_Update(BufferToWrite,BytesToWrite);
 801d3de:	4639      	mov	r1, r7
          BytesToWrite =sprintf((char *)BufferToWrite,"SD File Name too long\n");
 801d3e0:	f8c8 7000 	str.w	r7, [r8]
          NameLength= 10;
 801d3e4:	260a      	movs	r6, #10
          Term_Update(BufferToWrite,BytesToWrite);
 801d3e6:	f7fe fd59 	bl	801be9c <Term_Update>
 801d3ea:	e762      	b.n	801d2b2 <HCI_Event_CB+0x9ba>
        BytesToWrite =sprintf((char *)BufferToWrite,"File Name missing\n");
 801d3ec:	4dba      	ldr	r5, [pc, #744]	; (801d6d8 <HCI_Event_CB+0xde0>)
 801d3ee:	4cb9      	ldr	r4, [pc, #740]	; (801d6d4 <HCI_Event_CB+0xddc>)
 801d3f0:	4eba      	ldr	r6, [pc, #744]	; (801d6dc <HCI_Event_CB+0xde4>)
 801d3f2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d3f4:	f8b5 c000 	ldrh.w	ip, [r5]
 801d3f8:	78ad      	ldrb	r5, [r5, #2]
 801d3fa:	74a5      	strb	r5, [r4, #18]
 801d3fc:	2712      	movs	r7, #18
        BytesToWrite =sprintf((char *)BufferToWrite,"Use: SDName 'xxxxxxx'\n");
 801d3fe:	4db8      	ldr	r5, [pc, #736]	; (801d6e0 <HCI_Event_CB+0xde8>)
        BytesToWrite =sprintf((char *)BufferToWrite,"File Name missing\n");
 801d400:	6020      	str	r0, [r4, #0]
 801d402:	6061      	str	r1, [r4, #4]
 801d404:	60a2      	str	r2, [r4, #8]
        Term_Update(BufferToWrite,BytesToWrite);
 801d406:	4639      	mov	r1, r7
        BytesToWrite =sprintf((char *)BufferToWrite,"File Name missing\n");
 801d408:	60e3      	str	r3, [r4, #12]
 801d40a:	f8a4 c010 	strh.w	ip, [r4, #16]
        Term_Update(BufferToWrite,BytesToWrite);
 801d40e:	4620      	mov	r0, r4
        BytesToWrite =sprintf((char *)BufferToWrite,"File Name missing\n");
 801d410:	6037      	str	r7, [r6, #0]
        Term_Update(BufferToWrite,BytesToWrite);
 801d412:	f7fe fd43 	bl	801be9c <Term_Update>
        BytesToWrite =sprintf((char *)BufferToWrite,"Use: SDName 'xxxxxxx'\n");
 801d416:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d418:	2716      	movs	r7, #22
 801d41a:	f8b5 c004 	ldrh.w	ip, [r5, #4]
 801d41e:	6020      	str	r0, [r4, #0]
 801d420:	6828      	ldr	r0, [r5, #0]
 801d422:	79ad      	ldrb	r5, [r5, #6]
 801d424:	6061      	str	r1, [r4, #4]
 801d426:	6120      	str	r0, [r4, #16]
 801d428:	60a2      	str	r2, [r4, #8]
        Term_Update(BufferToWrite,BytesToWrite);
 801d42a:	4620      	mov	r0, r4
 801d42c:	4639      	mov	r1, r7
        BytesToWrite =sprintf((char *)BufferToWrite,"Use: SDName 'xxxxxxx'\n");
 801d42e:	60e3      	str	r3, [r4, #12]
 801d430:	f8a4 c014 	strh.w	ip, [r4, #20]
 801d434:	75a5      	strb	r5, [r4, #22]
 801d436:	6037      	str	r7, [r6, #0]
        Term_Update(BufferToWrite,BytesToWrite);
 801d438:	f7fe fd30 	bl	801be9c <Term_Update>
 801d43c:	f7ff ba62 	b.w	801c904 <HCI_Event_CB+0xc>
    } else if(!strncmp("setDate",(char *)(att_data),7)) {
 801d440:	2207      	movs	r2, #7
 801d442:	4639      	mov	r1, r7
 801d444:	48a7      	ldr	r0, [pc, #668]	; (801d6e4 <HCI_Event_CB+0xdec>)
 801d446:	f002 f8c7 	bl	801f5d8 <strncmp>
 801d44a:	2800      	cmp	r0, #0
 801d44c:	f040 8206 	bne.w	801d85c <HCI_Event_CB+0xf64>
      if(NameLength == 19) {
 801d450:	2e14      	cmp	r6, #20
 801d452:	f000 8165 	beq.w	801d720 <HCI_Event_CB+0xe28>
      Term_Update(att_data,data_length);
 801d456:	4631      	mov	r1, r6
 801d458:	4638      	mov	r0, r7
 801d45a:	f7fe fd1f 	bl	801be9c <Term_Update>
 801d45e:	f7ff ba51 	b.w	801c904 <HCI_Event_CB+0xc>
      SizeOfUpdateBlueFW=atoi((char *)(att_data+9));
 801d462:	f104 0015 	add.w	r0, r4, #21
 801d466:	f001 fb0a 	bl	801ea7e <atoi>
      PointerByte[0]=att_data[ 9];
 801d46a:	7d63      	ldrb	r3, [r4, #21]
 801d46c:	f885 3054 	strb.w	r3, [r5, #84]	; 0x54
          int ret = aci_l2cap_connection_parameter_update_request(connection_handle,
 801d470:	f44f 71c8 	mov.w	r1, #400	; 0x190
 801d474:	f8b5 0058 	ldrh.w	r0, [r5, #88]	; 0x58
      PointerByte[1]=att_data[10];
 801d478:	f894 c016 	ldrb.w	ip, [r4, #22]
          int ret = aci_l2cap_connection_parameter_update_request(connection_handle,
 801d47c:	9100      	str	r1, [sp, #0]
      PointerByte[2]=att_data[11];
 801d47e:	7de7      	ldrb	r7, [r4, #23]
      PointerByte[3]=att_data[12];
 801d480:	7e26      	ldrb	r6, [r4, #24]
      PointerByte[2]=att_data[11];
 801d482:	f885 7056 	strb.w	r7, [r5, #86]	; 0x56
          int ret = aci_l2cap_connection_parameter_update_request(connection_handle,
 801d486:	220a      	movs	r2, #10
      PointerByte[3]=att_data[12];
 801d488:	f885 6057 	strb.w	r6, [r5, #87]	; 0x57
          int ret = aci_l2cap_connection_parameter_update_request(connection_handle,
 801d48c:	4643      	mov	r3, r8
      PointerByte[1]=att_data[10];
 801d48e:	f885 c055 	strb.w	ip, [r5, #85]	; 0x55
          int ret = aci_l2cap_connection_parameter_update_request(connection_handle,
 801d492:	4611      	mov	r1, r2
        PointerByte[0]=att_data[13];
 801d494:	f894 8019 	ldrb.w	r8, [r4, #25]
        PointerByte[1]=att_data[14];
 801d498:	7ea7      	ldrb	r7, [r4, #26]
        PointerByte[2]=att_data[15];
 801d49a:	7ee6      	ldrb	r6, [r4, #27]
        PointerByte[3]=att_data[16];
 801d49c:	7f25      	ldrb	r5, [r4, #28]
          int ret = aci_l2cap_connection_parameter_update_request(connection_handle,
 801d49e:	f7fb fac1 	bl	8018a24 <aci_l2cap_connection_parameter_update_request>
          if (ret != BLE_STATUS_SUCCESS) {
 801d4a2:	2800      	cmp	r0, #0
 801d4a4:	f000 81cb 	beq.w	801d83e <HCI_Event_CB+0xf46>
 801d4a8:	e7fe      	b.n	801d4a8 <HCI_Event_CB+0xbb0>
        if(SD_Card_FeaturesMask & (FEATURE_MASK_TEMP1 |
 801d4aa:	f8df a270 	ldr.w	sl, [pc, #624]	; 801d71c <HCI_Event_CB+0xe24>
 801d4ae:	f8da 3000 	ldr.w	r3, [sl]
 801d4b2:	f413 0f7d 	tst.w	r3, #16580608	; 0xfd0000
 801d4b6:	d11c      	bne.n	801d4f2 <HCI_Event_CB+0xbfa>
       } else if(SD_Card_FeaturesMask == FEATURE_MASK_BLUEVOICE) {
 801d4b8:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 801d4bc:	d101      	bne.n	801d4c2 <HCI_Event_CB+0xbca>
          SD_CardLoggingMemsStop();
 801d4be:	f7fc f897 	bl	80195f0 <SD_CardLoggingMemsStop>
        if(SD_Card_FeaturesMask & FEATURE_MASK_BLUEVOICE) {
 801d4c2:	f8da 3000 	ldr.w	r3, [sl]
 801d4c6:	011c      	lsls	r4, r3, #4
 801d4c8:	d50a      	bpl.n	801d4e0 <HCI_Event_CB+0xbe8>
          osDelay(100);
 801d4ca:	2064      	movs	r0, #100	; 0x64
 801d4cc:	f7f8 feb0 	bl	8016230 <osDelay>
          SD_Card_FeaturesMask &= ~FEATURE_MASK_BLUEVOICE;
 801d4d0:	f8da 3000 	ldr.w	r3, [sl]
 801d4d4:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
 801d4d8:	f8ca 3000 	str.w	r3, [sl]
          SD_CardLoggingAudioStop();
 801d4dc:	f7fc f91a 	bl	8019714 <SD_CardLoggingAudioStop>
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 801d4e0:	682b      	ldr	r3, [r5, #0]
 801d4e2:	055f      	lsls	r7, r3, #21
 801d4e4:	f57f aa0e 	bpl.w	801c904 <HCI_Event_CB+0xc>
          SDLog_Update(SD_CARD_LOGGING_STOP);
 801d4e8:	2000      	movs	r0, #0
 801d4ea:	f7ff f927 	bl	801c73c <SDLog_Update>
 801d4ee:	f7ff ba09 	b.w	801c904 <HCI_Event_CB+0xc>
          SD_Card_FeaturesMask &= ~(FEATURE_MASK_TEMP1 |
 801d4f2:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 801d4f6:	f8ca 3000 	str.w	r3, [sl]
          SD_CardLoggingMemsStop();
 801d4fa:	f7fc f879 	bl	80195f0 <SD_CardLoggingMemsStop>
 801d4fe:	e7e0      	b.n	801d4c2 <HCI_Event_CB+0xbca>
          p8_SampleRateIneFeatures[0] = att_data[7];
 801d500:	4b79      	ldr	r3, [pc, #484]	; (801d6e8 <HCI_Event_CB+0xdf0>)
 801d502:	7ce1      	ldrb	r1, [r4, #19]
          p8_SampleRateIneFeatures[1] = att_data[8];
 801d504:	7d22      	ldrb	r2, [r4, #20]
          p8_Feature[0] = att_data[1];
 801d506:	f8df a214 	ldr.w	sl, [pc, #532]	; 801d71c <HCI_Event_CB+0xe24>
 801d50a:	f894 e00d 	ldrb.w	lr, [r4, #13]
          p8_Feature[1] = att_data[2];
 801d50e:	f894 c00e 	ldrb.w	ip, [r4, #14]
          p8_SampleRateIneFeatures[0] = att_data[7];
 801d512:	7019      	strb	r1, [r3, #0]
          p8_SampleRateIneFeatures[1] = att_data[8];
 801d514:	705a      	strb	r2, [r3, #1]
          p8_Feature[2] = att_data[3];
 801d516:	7be1      	ldrb	r1, [r4, #15]
          p8_Feature[3] = att_data[4];
 801d518:	7c22      	ldrb	r2, [r4, #16]
          p8_Feature[0] = att_data[1];
 801d51a:	f88a e000 	strb.w	lr, [sl]
          p8_Feature[1] = att_data[2];
 801d51e:	f88a c001 	strb.w	ip, [sl, #1]
          RoundedInertialWakeUpTimer = (int32_t) round(1000.0/(SampleRateIneFeatures/10));
 801d522:	8818      	ldrh	r0, [r3, #0]
          p8_Feature[3] = att_data[4];
 801d524:	f88a 2003 	strb.w	r2, [sl, #3]
          RoundedInertialWakeUpTimer = (int32_t) round(1000.0/(SampleRateIneFeatures/10));
 801d528:	230a      	movs	r3, #10
          p8_SampleRateEnvFeatures[0] = att_data[5];
 801d52a:	7c62      	ldrb	r2, [r4, #17]
          RoundedInertialWakeUpTimer = (int32_t) round(1000.0/(SampleRateIneFeatures/10));
 801d52c:	fbb0 f0f3 	udiv	r0, r0, r3
          p8_Feature[2] = att_data[3];
 801d530:	f88a 1002 	strb.w	r1, [sl, #2]
          p8_SampleRateEnvFeatures[1] = att_data[6];
 801d534:	7ca3      	ldrb	r3, [r4, #18]
          p8_SampleRateEnvFeatures[0] = att_data[5];
 801d536:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
          p8_SampleRateEnvFeatures[1] = att_data[6];
 801d53a:	f88d 3041 	strb.w	r3, [sp, #65]	; 0x41
          RoundedInertialWakeUpTimer = (int32_t) round(1000.0/(SampleRateIneFeatures/10));
 801d53e:	f7e9 fef9 	bl	8007334 <__aeabi_i2d>
 801d542:	4602      	mov	r2, r0
 801d544:	460b      	mov	r3, r1
 801d546:	2000      	movs	r0, #0
 801d548:	4968      	ldr	r1, [pc, #416]	; (801d6ec <HCI_Event_CB+0xdf4>)
 801d54a:	f7ea f887 	bl	800765c <__aeabi_ddiv>
 801d54e:	ec41 0b10 	vmov	d0, r0, r1
 801d552:	f004 f86b 	bl	802162c <round>
 801d556:	ec51 0b10 	vmov	r0, r1, d0
 801d55a:	f7ea fa05 	bl	8007968 <__aeabi_d2iz>
 801d55e:	4b64      	ldr	r3, [pc, #400]	; (801d6f0 <HCI_Event_CB+0xdf8>)
 801d560:	6018      	str	r0, [r3, #0]
 801d562:	4683      	mov	fp, r0
          RoundCounterEnvironmental  = (int32_t) round((10000.0/RoundedInertialWakeUpTimer)/SampleRateEnvFeatures);
 801d564:	f7e9 fed6 	bl	8007314 <__aeabi_ui2d>
 801d568:	4602      	mov	r2, r0
 801d56a:	460b      	mov	r3, r1
 801d56c:	a156      	add	r1, pc, #344	; (adr r1, 801d6c8 <HCI_Event_CB+0xdd0>)
 801d56e:	e9d1 0100 	ldrd	r0, r1, [r1]
 801d572:	f7ea f873 	bl	800765c <__aeabi_ddiv>
 801d576:	4680      	mov	r8, r0
 801d578:	f8bd 0040 	ldrh.w	r0, [sp, #64]	; 0x40
 801d57c:	4689      	mov	r9, r1
 801d57e:	f7e9 fed9 	bl	8007334 <__aeabi_i2d>
 801d582:	4602      	mov	r2, r0
 801d584:	460b      	mov	r3, r1
 801d586:	4640      	mov	r0, r8
 801d588:	4649      	mov	r1, r9
 801d58a:	f7ea f867 	bl	800765c <__aeabi_ddiv>
 801d58e:	ec41 0b10 	vmov	d0, r0, r1
 801d592:	f004 f84b 	bl	802162c <round>
 801d596:	ec51 0b10 	vmov	r0, r1, d0
 801d59a:	f7ea f9e5 	bl	8007968 <__aeabi_d2iz>
 801d59e:	4b55      	ldr	r3, [pc, #340]	; (801d6f4 <HCI_Event_CB+0xdfc>)
            BytesToWrite =sprintf((char *)BufferToWrite,"setMicVol Correct =%ld\n",
 801d5a0:	f8df 8138 	ldr.w	r8, [pc, #312]	; 801d6dc <HCI_Event_CB+0xde4>
          RoundCounterEnvironmental  = (int32_t) round((10000.0/RoundedInertialWakeUpTimer)/SampleRateEnvFeatures);
 801d5a4:	6018      	str	r0, [r3, #0]
          RoundedEnvironmentalFreq   = (int32_t) round(10000.0/(RoundCounterEnvironmental*RoundedInertialWakeUpTimer));
 801d5a6:	fb00 f00b 	mul.w	r0, r0, fp
 801d5aa:	f7e9 feb3 	bl	8007314 <__aeabi_ui2d>
 801d5ae:	4602      	mov	r2, r0
 801d5b0:	460b      	mov	r3, r1
 801d5b2:	a145      	add	r1, pc, #276	; (adr r1, 801d6c8 <HCI_Event_CB+0xdd0>)
 801d5b4:	e9d1 0100 	ldrd	r0, r1, [r1]
 801d5b8:	f7ea f850 	bl	800765c <__aeabi_ddiv>
 801d5bc:	ec41 0b10 	vmov	d0, r0, r1
 801d5c0:	f004 f834 	bl	802162c <round>
 801d5c4:	ec51 0b10 	vmov	r0, r1, d0
 801d5c8:	f7ea f9ce 	bl	8007968 <__aeabi_d2iz>
            TargetBoardFeatures.AudioVolume = AudioVolume;
 801d5cc:	f994 3015 	ldrsb.w	r3, [r4, #21]
          RoundedEnvironmentalFreq   = (int32_t) round(10000.0/(RoundCounterEnvironmental*RoundedInertialWakeUpTimer));
 801d5d0:	4a49      	ldr	r2, [pc, #292]	; (801d6f8 <HCI_Event_CB+0xe00>)
            TargetBoardFeatures.AudioVolume = AudioVolume;
 801d5d2:	4c4a      	ldr	r4, [pc, #296]	; (801d6fc <HCI_Event_CB+0xe04>)
          RoundedEnvironmentalFreq   = (int32_t) round(10000.0/(RoundCounterEnvironmental*RoundedInertialWakeUpTimer));
 801d5d4:	6010      	str	r0, [r2, #0]
            BytesToWrite =sprintf((char *)BufferToWrite,"setMicVol Correct =%ld\n",
 801d5d6:	494a      	ldr	r1, [pc, #296]	; (801d700 <HCI_Event_CB+0xe08>)
 801d5d8:	483e      	ldr	r0, [pc, #248]	; (801d6d4 <HCI_Event_CB+0xddc>)
            TargetBoardFeatures.AudioVolume = AudioVolume;
 801d5da:	63e3      	str	r3, [r4, #60]	; 0x3c
            BytesToWrite =sprintf((char *)BufferToWrite,"setMicVol Correct =%ld\n",
 801d5dc:	461a      	mov	r2, r3
 801d5de:	f001 ffdb 	bl	801f598 <siprintf>
 801d5e2:	4603      	mov	r3, r0
            Term_Update(BufferToWrite,BytesToWrite);
 801d5e4:	b2c1      	uxtb	r1, r0
 801d5e6:	483b      	ldr	r0, [pc, #236]	; (801d6d4 <HCI_Event_CB+0xddc>)
            BytesToWrite =sprintf((char *)BufferToWrite,"setMicVol Correct =%ld\n",
 801d5e8:	f8c8 3000 	str.w	r3, [r8]
            Term_Update(BufferToWrite,BytesToWrite);
 801d5ec:	f7fe fc56 	bl	801be9c <Term_Update>
        if(data_length>10) {
 801d5f0:	2e0a      	cmp	r6, #10
 801d5f2:	d93f      	bls.n	801d674 <HCI_Event_CB+0xd7c>
 801d5f4:	4843      	ldr	r0, [pc, #268]	; (801d704 <HCI_Event_CB+0xe0c>)
 801d5f6:	3e0a      	subs	r6, #10
 801d5f8:	2300      	movs	r3, #0
          for(Count=0;Count<(data_length-10);Count++) {
 801d5fa:	b2da      	uxtb	r2, r3
 801d5fc:	42b2      	cmp	r2, r6
            DefaultDataFileName[Count]=att_data[Count+9];
 801d5fe:	eb07 0102 	add.w	r1, r7, r2
 801d602:	f103 0301 	add.w	r3, r3, #1
          for(Count=0;Count<(data_length-10);Count++) {
 801d606:	da24      	bge.n	801d652 <HCI_Event_CB+0xd5a>
            DefaultDataFileName[Count]=att_data[Count+9];
 801d608:	7a49      	ldrb	r1, [r1, #9]
 801d60a:	5481      	strb	r1, [r0, r2]
 801d60c:	e7f5      	b.n	801d5fa <HCI_Event_CB+0xd02>
    ConfigCommandParsing(att_data, data_length);
 801d60e:	4638      	mov	r0, r7
 801d610:	f7fe fa1c 	bl	801ba4c <ConfigCommandParsing.isra.3>
 801d614:	f7ff b976 	b.w	801c904 <HCI_Event_CB+0xc>
      W2ST_ON_CONNECTION(W2ST_CONNECT_AUDIO_LEVEL);
 801d618:	682b      	ldr	r3, [r5, #0]
      InitMics(AUDIO_SAMPLING_FREQUENCY);
 801d61a:	f44f 507a 	mov.w	r0, #16000	; 0x3e80
      W2ST_ON_CONNECTION(W2ST_CONNECT_AUDIO_LEVEL);
 801d61e:	f043 0308 	orr.w	r3, r3, #8
 801d622:	602b      	str	r3, [r5, #0]
      InitMics(AUDIO_SAMPLING_FREQUENCY);
 801d624:	f7fd f8c0 	bl	801a7a8 <InitMics>
      for(Count=0;Count<TargetBoardFeatures.NumMicSensors;Count++) {
 801d628:	4b34      	ldr	r3, [pc, #208]	; (801d6fc <HCI_Event_CB+0xe04>)
 801d62a:	4937      	ldr	r1, [pc, #220]	; (801d708 <HCI_Event_CB+0xe10>)
 801d62c:	6b5c      	ldr	r4, [r3, #52]	; 0x34
        RMS_Ch[Count]=0;
 801d62e:	4837      	ldr	r0, [pc, #220]	; (801d70c <HCI_Event_CB+0xe14>)
 801d630:	2200      	movs	r2, #0
      for(Count=0;Count<TargetBoardFeatures.NumMicSensors;Count++) {
 801d632:	2300      	movs	r3, #0
 801d634:	e005      	b.n	801d642 <HCI_Event_CB+0xd4a>
        RMS_Ch[Count]=0;
 801d636:	eb00 0583 	add.w	r5, r0, r3, lsl #2
        DBNOISE_Value_Old_Ch[Count] =0;
 801d63a:	f841 2b04 	str.w	r2, [r1], #4
        RMS_Ch[Count]=0;
 801d63e:	602a      	str	r2, [r5, #0]
      for(Count=0;Count<TargetBoardFeatures.NumMicSensors;Count++) {
 801d640:	3301      	adds	r3, #1
 801d642:	42a3      	cmp	r3, r4
 801d644:	dbf7      	blt.n	801d636 <HCI_Event_CB+0xd3e>
      startProc(AUDIO_LEV,MICS_DB_UPDATE_MS);
 801d646:	2132      	movs	r1, #50	; 0x32
 801d648:	2009      	movs	r0, #9
 801d64a:	f7fd fac7 	bl	801abdc <startProc>
 801d64e:	f7ff b959 	b.w	801c904 <HCI_Event_CB+0xc>
          if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801d652:	682b      	ldr	r3, [r5, #0]
          DefaultDataFileName[Count] ='\0';
 801d654:	2100      	movs	r1, #0
 801d656:	5481      	strb	r1, [r0, r2]
          if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801d658:	0658      	lsls	r0, r3, #25
 801d65a:	d50b      	bpl.n	801d674 <HCI_Event_CB+0xd7c>
            BytesToWrite =sprintf((char *)BufferToWrite, "FileName %s\n",DefaultDataFileName);
 801d65c:	492c      	ldr	r1, [pc, #176]	; (801d710 <HCI_Event_CB+0xe18>)
 801d65e:	4a29      	ldr	r2, [pc, #164]	; (801d704 <HCI_Event_CB+0xe0c>)
 801d660:	481c      	ldr	r0, [pc, #112]	; (801d6d4 <HCI_Event_CB+0xddc>)
 801d662:	f001 ff99 	bl	801f598 <siprintf>
 801d666:	4603      	mov	r3, r0
            Term_Update(BufferToWrite,BytesToWrite);
 801d668:	b2c1      	uxtb	r1, r0
 801d66a:	481a      	ldr	r0, [pc, #104]	; (801d6d4 <HCI_Event_CB+0xddc>)
            BytesToWrite =sprintf((char *)BufferToWrite, "FileName %s\n",DefaultDataFileName);
 801d66c:	f8c8 3000 	str.w	r3, [r8]
            Term_Update(BufferToWrite,BytesToWrite);
 801d670:	f7fe fc14 	bl	801be9c <Term_Update>
           ((SD_Card_FeaturesMask&FEATURE_MASK_GRYO )!=0) |
 801d674:	f8da 3000 	ldr.w	r3, [sl]
        if(((SD_Card_FeaturesMask&FEATURE_MASK_TEMP1 )!=0) |
 801d678:	f413 0f7d 	tst.w	r3, #16580608	; 0xfd0000
 801d67c:	d11e      	bne.n	801d6bc <HCI_Event_CB+0xdc4>
         } else if (SD_Card_FeaturesMask==FEATURE_MASK_BLUEVOICE) {
 801d67e:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 801d682:	d102      	bne.n	801d68a <HCI_Event_CB+0xd92>
           SD_CardLoggingMemsStart(1);
 801d684:	2001      	movs	r0, #1
 801d686:	f7fc f8cb 	bl	8019820 <SD_CardLoggingMemsStart>
        if(SD_Card_FeaturesMask&FEATURE_MASK_BLUEVOICE) {
 801d68a:	f8da 3000 	ldr.w	r3, [sl]
 801d68e:	0119      	lsls	r1, r3, #4
 801d690:	d504      	bpl.n	801d69c <HCI_Event_CB+0xda4>
          osDelay(100);
 801d692:	2064      	movs	r0, #100	; 0x64
 801d694:	f7f8 fdcc 	bl	8016230 <osDelay>
          SD_CardLoggingAudioStart();
 801d698:	f7fc fa1c 	bl	8019ad4 <SD_CardLoggingAudioStart>
        if(SD_LogAudio_Enabled | SD_LogMems_Enabled) {
 801d69c:	4a1d      	ldr	r2, [pc, #116]	; (801d714 <HCI_Event_CB+0xe1c>)
 801d69e:	4b1e      	ldr	r3, [pc, #120]	; (801d718 <HCI_Event_CB+0xe20>)
 801d6a0:	6812      	ldr	r2, [r2, #0]
 801d6a2:	681b      	ldr	r3, [r3, #0]
 801d6a4:	4313      	orrs	r3, r2
 801d6a6:	f43f a92d 	beq.w	801c904 <HCI_Event_CB+0xc>
          if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 801d6aa:	682b      	ldr	r3, [r5, #0]
 801d6ac:	055b      	lsls	r3, r3, #21
 801d6ae:	f57f a929 	bpl.w	801c904 <HCI_Event_CB+0xc>
            SDLog_Update(SD_CARD_LOGGING_START);
 801d6b2:	2001      	movs	r0, #1
 801d6b4:	f7ff f842 	bl	801c73c <SDLog_Update>
 801d6b8:	f7ff b924 	b.w	801c904 <HCI_Event_CB+0xc>
          SD_CardLoggingMemsStart(0);
 801d6bc:	2000      	movs	r0, #0
 801d6be:	f7fc f8af 	bl	8019820 <SD_CardLoggingMemsStart>
 801d6c2:	e7e2      	b.n	801d68a <HCI_Event_CB+0xd92>
 801d6c4:	f3af 8000 	nop.w
 801d6c8:	00000000 	.word	0x00000000
 801d6cc:	40c38800 	.word	0x40c38800
 801d6d0:	08075cc8 	.word	0x08075cc8
 801d6d4:	20013174 	.word	0x20013174
 801d6d8:	08075cf4 	.word	0x08075cf4
 801d6dc:	200132a0 	.word	0x200132a0
 801d6e0:	08075d08 	.word	0x08075d08
 801d6e4:	08075d20 	.word	0x08075d20
 801d6e8:	200014a4 	.word	0x200014a4
 801d6ec:	408f4000 	.word	0x408f4000
 801d6f0:	200014ac 	.word	0x200014ac
 801d6f4:	200014a0 	.word	0x200014a0
 801d6f8:	200014a8 	.word	0x200014a8
 801d6fc:	20011458 	.word	0x20011458
 801d700:	08075dd0 	.word	0x08075dd0
 801d704:	2001144c 	.word	0x2001144c
 801d708:	200114bc 	.word	0x200114bc
 801d70c:	200114c0 	.word	0x200114c0
 801d710:	08075e38 	.word	0x08075e38
 801d714:	2000f074 	.word	0x2000f074
 801d718:	2000f2e0 	.word	0x2000f2e0
 801d71c:	2000f2dc 	.word	0x2000f2dc
        StartDate.Date=  ((att_data[11] - 48) * 16) + (att_data[12] - 48);
 801d720:	7de7      	ldrb	r7, [r4, #23]
 801d722:	7e25      	ldrb	r5, [r4, #24]
        StartDate.Month= ((att_data[14] - 48) * 16) + (att_data[15] - 48);
 801d724:	7ea6      	ldrb	r6, [r4, #26]
 801d726:	7ee1      	ldrb	r1, [r4, #27]
        StartDate.WeekDay= att_data[9] - 48;
 801d728:	7d62      	ldrb	r2, [r4, #21]
        StartDate.Year=  ((att_data[17] - 48) * 16) + (att_data[18] - 48);
 801d72a:	7fa3      	ldrb	r3, [r4, #30]
 801d72c:	7f60      	ldrb	r0, [r4, #29]
        StartDate.Date=  ((att_data[11] - 48) * 16) + (att_data[12] - 48);
 801d72e:	eb05 1507 	add.w	r5, r5, r7, lsl #4
        StartDate.Month= ((att_data[14] - 48) * 16) + (att_data[15] - 48);
 801d732:	eb01 1406 	add.w	r4, r1, r6, lsl #4
        StartDate.Date=  ((att_data[11] - 48) * 16) + (att_data[12] - 48);
 801d736:	b2ed      	uxtb	r5, r5
        if( ((StartDate.WeekDay  > 0x00) && (StartDate.WeekDay  < 0x08)) &&
 801d738:	f1a2 0631 	sub.w	r6, r2, #49	; 0x31
        StartDate.Month= ((att_data[14] - 48) * 16) + (att_data[15] - 48);
 801d73c:	b2e4      	uxtb	r4, r4
        StartDate.Year=  ((att_data[17] - 48) * 16) + (att_data[18] - 48);
 801d73e:	3b30      	subs	r3, #48	; 0x30
 801d740:	eb03 1300 	add.w	r3, r3, r0, lsl #4
        StartDate.Date=  ((att_data[11] - 48) * 16) + (att_data[12] - 48);
 801d744:	f1a5 0130 	sub.w	r1, r5, #48	; 0x30
        StartDate.WeekDay= att_data[9] - 48;
 801d748:	f1a2 0030 	sub.w	r0, r2, #48	; 0x30
        StartDate.Month= ((att_data[14] - 48) * 16) + (att_data[15] - 48);
 801d74c:	f1a4 0730 	sub.w	r7, r4, #48	; 0x30
        if( ((StartDate.WeekDay  > 0x00) && (StartDate.WeekDay  < 0x08)) &&
 801d750:	2e06      	cmp	r6, #6
        StartDate.Date=  ((att_data[11] - 48) * 16) + (att_data[12] - 48);
 801d752:	b2c9      	uxtb	r1, r1
        StartDate.Month= ((att_data[14] - 48) * 16) + (att_data[15] - 48);
 801d754:	b2fa      	uxtb	r2, r7
        StartDate.Year=  ((att_data[17] - 48) * 16) + (att_data[18] - 48);
 801d756:	b2db      	uxtb	r3, r3
        StartDate.WeekDay= att_data[9] - 48;
 801d758:	b2c0      	uxtb	r0, r0
        if( ((StartDate.WeekDay  > 0x00) && (StartDate.WeekDay  < 0x08)) &&
 801d75a:	d808      	bhi.n	801d76e <HCI_Event_CB+0xe76>
 801d75c:	3d31      	subs	r5, #49	; 0x31
 801d75e:	2d30      	cmp	r5, #48	; 0x30
 801d760:	d805      	bhi.n	801d76e <HCI_Event_CB+0xe76>
            ((StartDate.Date     > 0x00) && (StartDate.Date     < 0x32)) &&
 801d762:	3c31      	subs	r4, #49	; 0x31
 801d764:	2c11      	cmp	r4, #17
 801d766:	d802      	bhi.n	801d76e <HCI_Event_CB+0xe76>
            ((StartDate.Month    > 0x00) && (StartDate.Month    < 0x13)) &&
 801d768:	2b98      	cmp	r3, #152	; 0x98
 801d76a:	f240 80fb 	bls.w	801d964 <HCI_Event_CB+0x106c>
          BytesToWrite =sprintf((char *)BufferToWrite,"Date format not correct\n");
 801d76e:	4db3      	ldr	r5, [pc, #716]	; (801da3c <HCI_Event_CB+0x1144>)
 801d770:	4cb3      	ldr	r4, [pc, #716]	; (801da40 <HCI_Event_CB+0x1148>)
 801d772:	4eb4      	ldr	r6, [pc, #720]	; (801da44 <HCI_Event_CB+0x114c>)
 801d774:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d776:	6020      	str	r0, [r4, #0]
 801d778:	6061      	str	r1, [r4, #4]
 801d77a:	cd03      	ldmia	r5!, {r0, r1}
 801d77c:	782d      	ldrb	r5, [r5, #0]
 801d77e:	7625      	strb	r5, [r4, #24]
 801d780:	2718      	movs	r7, #24
          BytesToWrite =sprintf((char *)BufferToWrite,"setDate wd/dd/mm/yy\n");
 801d782:	4db1      	ldr	r5, [pc, #708]	; (801da48 <HCI_Event_CB+0x1150>)
          BytesToWrite =sprintf((char *)BufferToWrite,"Date format not correct\n");
 801d784:	6120      	str	r0, [r4, #16]
 801d786:	6161      	str	r1, [r4, #20]
 801d788:	60a2      	str	r2, [r4, #8]
          Term_Update(BufferToWrite,BytesToWrite);
 801d78a:	4639      	mov	r1, r7
          BytesToWrite =sprintf((char *)BufferToWrite,"Date format not correct\n");
 801d78c:	60e3      	str	r3, [r4, #12]
          Term_Update(BufferToWrite,BytesToWrite);
 801d78e:	4620      	mov	r0, r4
          BytesToWrite =sprintf((char *)BufferToWrite,"Date format not correct\n");
 801d790:	6037      	str	r7, [r6, #0]
          Term_Update(BufferToWrite,BytesToWrite);
 801d792:	f7fe fb83 	bl	801be9c <Term_Update>
          BytesToWrite =sprintf((char *)BufferToWrite,"setDate wd/dd/mm/yy\n");
 801d796:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d798:	2714      	movs	r7, #20
 801d79a:	6020      	str	r0, [r4, #0]
 801d79c:	6828      	ldr	r0, [r5, #0]
 801d79e:	792d      	ldrb	r5, [r5, #4]
 801d7a0:	6061      	str	r1, [r4, #4]
 801d7a2:	6120      	str	r0, [r4, #16]
 801d7a4:	60a2      	str	r2, [r4, #8]
          Term_Update(BufferToWrite,BytesToWrite);
 801d7a6:	4620      	mov	r0, r4
 801d7a8:	4639      	mov	r1, r7
          BytesToWrite =sprintf((char *)BufferToWrite,"setDate wd/dd/mm/yy\n");
 801d7aa:	60e3      	str	r3, [r4, #12]
 801d7ac:	7525      	strb	r5, [r4, #20]
 801d7ae:	6037      	str	r7, [r6, #0]
          Term_Update(BufferToWrite,BytesToWrite);
 801d7b0:	f7fe fb74 	bl	801be9c <Term_Update>
 801d7b4:	f7ff b8a6 	b.w	801c904 <HCI_Event_CB+0xc>
      BytesToWrite =sprintf((char *)BufferToWrite,"\r\nSTMicroelectronics %s:\n"
 801d7b8:	4ca1      	ldr	r4, [pc, #644]	; (801da40 <HCI_Event_CB+0x1148>)
 801d7ba:	4aa4      	ldr	r2, [pc, #656]	; (801da4c <HCI_Event_CB+0x1154>)
 801d7bc:	49a4      	ldr	r1, [pc, #656]	; (801da50 <HCI_Event_CB+0x1158>)
 801d7be:	4ea1      	ldr	r6, [pc, #644]	; (801da44 <HCI_Event_CB+0x114c>)
      BytesToWrite =sprintf((char *)BufferToWrite,"\t(HAL %ld.%ld.%ld_%ld)\n"
 801d7c0:	4fa4      	ldr	r7, [pc, #656]	; (801da54 <HCI_Event_CB+0x115c>)
      BytesToWrite =sprintf((char *)BufferToWrite,"\r\nSTMicroelectronics %s:\n"
 801d7c2:	2330      	movs	r3, #48	; 0x30
 801d7c4:	e9cd 3300 	strd	r3, r3, [sp]
 801d7c8:	4620      	mov	r0, r4
 801d7ca:	2331      	movs	r3, #49	; 0x31
 801d7cc:	f001 fee4 	bl	801f598 <siprintf>
 801d7d0:	234e      	movs	r3, #78	; 0x4e
      Term_Update(BufferToWrite,BytesToWrite);
 801d7d2:	4619      	mov	r1, r3
 801d7d4:	4620      	mov	r0, r4
      BytesToWrite =sprintf((char *)BufferToWrite,"\r\nSTMicroelectronics %s:\n"
 801d7d6:	6033      	str	r3, [r6, #0]
      Term_Update(BufferToWrite,BytesToWrite);
 801d7d8:	f7fe fb60 	bl	801be9c <Term_Update>
          HAL_GetHalVersion() >>24,
 801d7dc:	f7f2 fe9c 	bl	8010518 <HAL_GetHalVersion>
 801d7e0:	4680      	mov	r8, r0
          (HAL_GetHalVersion() >>16)&0xFF,
 801d7e2:	f7f2 fe99 	bl	8010518 <HAL_GetHalVersion>
 801d7e6:	4681      	mov	r9, r0
          (HAL_GetHalVersion() >> 8)&0xFF,
 801d7e8:	f7f2 fe96 	bl	8010518 <HAL_GetHalVersion>
 801d7ec:	4605      	mov	r5, r0
           HAL_GetHalVersion()      &0xFF,
 801d7ee:	f7f2 fe93 	bl	8010518 <HAL_GetHalVersion>
      BytesToWrite =sprintf((char *)BufferToWrite,"\t(HAL %ld.%ld.%ld_%ld)\n"
 801d7f2:	4999      	ldr	r1, [pc, #612]	; (801da58 <HCI_Event_CB+0x1160>)
 801d7f4:	f3c5 2507 	ubfx	r5, r5, #8, #8
 801d7f8:	b2c0      	uxtb	r0, r0
 801d7fa:	e9cd 5000 	strd	r5, r0, [sp]
 801d7fe:	ea4f 6218 	mov.w	r2, r8, lsr #24
 801d802:	e9cd 1702 	strd	r1, r7, [sp, #8]
 801d806:	f3c9 4307 	ubfx	r3, r9, #16, #8
 801d80a:	4994      	ldr	r1, [pc, #592]	; (801da5c <HCI_Event_CB+0x1164>)
      BytesToWrite =sprintf((char *)BufferToWrite,"\tEnabled AR NN_GMP\n");
 801d80c:	4d94      	ldr	r5, [pc, #592]	; (801da60 <HCI_Event_CB+0x1168>)
      BytesToWrite =sprintf((char *)BufferToWrite,"\t(HAL %ld.%ld.%ld_%ld)\n"
 801d80e:	4620      	mov	r0, r4
 801d810:	f001 fec2 	bl	801f598 <siprintf>
 801d814:	4603      	mov	r3, r0
      Term_Update(BufferToWrite,BytesToWrite);
 801d816:	b2c1      	uxtb	r1, r0
 801d818:	4620      	mov	r0, r4
      BytesToWrite =sprintf((char *)BufferToWrite,"\t(HAL %ld.%ld.%ld_%ld)\n"
 801d81a:	6033      	str	r3, [r6, #0]
      Term_Update(BufferToWrite,BytesToWrite);
 801d81c:	f7fe fb3e 	bl	801be9c <Term_Update>
      BytesToWrite =sprintf((char *)BufferToWrite,"\tEnabled AR NN_GMP\n");
 801d820:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d822:	6020      	str	r0, [r4, #0]
 801d824:	6828      	ldr	r0, [r5, #0]
 801d826:	6120      	str	r0, [r4, #16]
 801d828:	2713      	movs	r7, #19
 801d82a:	6061      	str	r1, [r4, #4]
          BytesToWrite =sprintf((char *)BufferToWrite,"setTime hh:mm:ss\n");
 801d82c:	60a2      	str	r2, [r4, #8]
 801d82e:	60e3      	str	r3, [r4, #12]
          Term_Update(BufferToWrite,BytesToWrite);
 801d830:	4620      	mov	r0, r4
 801d832:	4639      	mov	r1, r7
          BytesToWrite =sprintf((char *)BufferToWrite,"setTime hh:mm:ss\n");
 801d834:	6037      	str	r7, [r6, #0]
          Term_Update(BufferToWrite,BytesToWrite);
 801d836:	f7fe fb31 	bl	801be9c <Term_Update>
 801d83a:	f7ff b863 	b.w	801c904 <HCI_Event_CB+0xc>
        BufferToWrite[0] = PointerByte[0];
 801d83e:	4b80      	ldr	r3, [pc, #512]	; (801da40 <HCI_Event_CB+0x1148>)
        BytesToWrite = 4;
 801d840:	4c80      	ldr	r4, [pc, #512]	; (801da44 <HCI_Event_CB+0x114c>)
        BufferToWrite[0] = PointerByte[0];
 801d842:	f883 8000 	strb.w	r8, [r3]
        BytesToWrite = 4;
 801d846:	2204      	movs	r2, #4
        Term_Update(BufferToWrite,BytesToWrite);
 801d848:	4618      	mov	r0, r3
 801d84a:	4611      	mov	r1, r2
        BufferToWrite[1] = PointerByte[1];
 801d84c:	705f      	strb	r7, [r3, #1]
        BufferToWrite[2] = PointerByte[2];
 801d84e:	709e      	strb	r6, [r3, #2]
        BufferToWrite[3] = PointerByte[3];
 801d850:	70dd      	strb	r5, [r3, #3]
        BytesToWrite = 4;
 801d852:	6022      	str	r2, [r4, #0]
        Term_Update(BufferToWrite,BytesToWrite);
 801d854:	f7fe fb22 	bl	801be9c <Term_Update>
 801d858:	f7ff b854 	b.w	801c904 <HCI_Event_CB+0xc>
    } else if(!strncmp("setTime",(char *)(att_data),7)) {
 801d85c:	2207      	movs	r2, #7
 801d85e:	4639      	mov	r1, r7
 801d860:	4880      	ldr	r0, [pc, #512]	; (801da64 <HCI_Event_CB+0x116c>)
 801d862:	f001 feb9 	bl	801f5d8 <strncmp>
 801d866:	2800      	cmp	r0, #0
 801d868:	d135      	bne.n	801d8d6 <HCI_Event_CB+0xfde>
      if(NameLength == 16) {
 801d86a:	2e11      	cmp	r6, #17
 801d86c:	f47f adf3 	bne.w	801d456 <HCI_Event_CB+0xb5e>
        StartTime.Hours=   ((att_data[8]  - 48) * 16) + (att_data[9]  - 48);
 801d870:	7d60      	ldrb	r0, [r4, #21]
 801d872:	7d26      	ldrb	r6, [r4, #20]
        StartTime.Minutes= ((att_data[11] - 48) * 16) + (att_data[12] - 48);
 801d874:	7e21      	ldrb	r1, [r4, #24]
        StartTime.Seconds= ((att_data[14] - 48) * 16) + (att_data[15] - 48);
 801d876:	7ee2      	ldrb	r2, [r4, #27]
        StartTime.Minutes= ((att_data[11] - 48) * 16) + (att_data[12] - 48);
 801d878:	7de5      	ldrb	r5, [r4, #23]
        StartTime.Seconds= ((att_data[14] - 48) * 16) + (att_data[15] - 48);
 801d87a:	7ea3      	ldrb	r3, [r4, #26]
        StartTime.Hours=   ((att_data[8]  - 48) * 16) + (att_data[9]  - 48);
 801d87c:	3830      	subs	r0, #48	; 0x30
 801d87e:	eb00 1006 	add.w	r0, r0, r6, lsl #4
        StartTime.Minutes= ((att_data[11] - 48) * 16) + (att_data[12] - 48);
 801d882:	3930      	subs	r1, #48	; 0x30
        StartTime.Seconds= ((att_data[14] - 48) * 16) + (att_data[15] - 48);
 801d884:	3a30      	subs	r2, #48	; 0x30
        StartTime.Hours=   ((att_data[8]  - 48) * 16) + (att_data[9]  - 48);
 801d886:	b2c0      	uxtb	r0, r0
        StartTime.Minutes= ((att_data[11] - 48) * 16) + (att_data[12] - 48);
 801d888:	eb01 1105 	add.w	r1, r1, r5, lsl #4
        StartTime.Seconds= ((att_data[14] - 48) * 16) + (att_data[15] - 48);
 801d88c:	eb02 1203 	add.w	r2, r2, r3, lsl #4
        if( (StartTime.Hours   < 0x24) &&
 801d890:	2823      	cmp	r0, #35	; 0x23
        StartTime.Minutes= ((att_data[11] - 48) * 16) + (att_data[12] - 48);
 801d892:	b2c9      	uxtb	r1, r1
        StartTime.Seconds= ((att_data[14] - 48) * 16) + (att_data[15] - 48);
 801d894:	b2d2      	uxtb	r2, r2
        if( (StartTime.Hours   < 0x24) &&
 801d896:	d803      	bhi.n	801d8a0 <HCI_Event_CB+0xfa8>
 801d898:	295f      	cmp	r1, #95	; 0x5f
 801d89a:	d801      	bhi.n	801d8a0 <HCI_Event_CB+0xfa8>
            (StartTime.Minutes < 0x60) &&
 801d89c:	2a5f      	cmp	r2, #95	; 0x5f
 801d89e:	d977      	bls.n	801d990 <HCI_Event_CB+0x1098>
          BytesToWrite =sprintf((char *)BufferToWrite,"Time format not correct\n");
 801d8a0:	4d71      	ldr	r5, [pc, #452]	; (801da68 <HCI_Event_CB+0x1170>)
 801d8a2:	4c67      	ldr	r4, [pc, #412]	; (801da40 <HCI_Event_CB+0x1148>)
 801d8a4:	4e67      	ldr	r6, [pc, #412]	; (801da44 <HCI_Event_CB+0x114c>)
 801d8a6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d8a8:	6020      	str	r0, [r4, #0]
 801d8aa:	6061      	str	r1, [r4, #4]
 801d8ac:	cd03      	ldmia	r5!, {r0, r1}
 801d8ae:	782d      	ldrb	r5, [r5, #0]
 801d8b0:	7625      	strb	r5, [r4, #24]
 801d8b2:	2718      	movs	r7, #24
          BytesToWrite =sprintf((char *)BufferToWrite,"setTime hh:mm:ss\n");
 801d8b4:	4d6d      	ldr	r5, [pc, #436]	; (801da6c <HCI_Event_CB+0x1174>)
          BytesToWrite =sprintf((char *)BufferToWrite,"Time format not correct\n");
 801d8b6:	6120      	str	r0, [r4, #16]
 801d8b8:	6161      	str	r1, [r4, #20]
 801d8ba:	60a2      	str	r2, [r4, #8]
          Term_Update(BufferToWrite,BytesToWrite);
 801d8bc:	4639      	mov	r1, r7
          BytesToWrite =sprintf((char *)BufferToWrite,"Time format not correct\n");
 801d8be:	60e3      	str	r3, [r4, #12]
          Term_Update(BufferToWrite,BytesToWrite);
 801d8c0:	4620      	mov	r0, r4
          BytesToWrite =sprintf((char *)BufferToWrite,"Time format not correct\n");
 801d8c2:	6037      	str	r7, [r6, #0]
          Term_Update(BufferToWrite,BytesToWrite);
 801d8c4:	f7fe faea 	bl	801be9c <Term_Update>
          BytesToWrite =sprintf((char *)BufferToWrite,"setTime hh:mm:ss\n");
 801d8c8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d8ca:	6061      	str	r1, [r4, #4]
 801d8cc:	8829      	ldrh	r1, [r5, #0]
 801d8ce:	6020      	str	r0, [r4, #0]
 801d8d0:	2711      	movs	r7, #17
 801d8d2:	8221      	strh	r1, [r4, #16]
 801d8d4:	e7aa      	b.n	801d82c <HCI_Event_CB+0xf34>
    } else if(!strncmp("setMicVol",(char *)(att_data),9)) {
 801d8d6:	2209      	movs	r2, #9
 801d8d8:	4639      	mov	r1, r7
 801d8da:	4865      	ldr	r0, [pc, #404]	; (801da70 <HCI_Event_CB+0x1178>)
 801d8dc:	f001 fe7c 	bl	801f5d8 <strncmp>
 801d8e0:	2800      	cmp	r0, #0
 801d8e2:	f000 80a0 	beq.w	801da26 <HCI_Event_CB+0x112e>
    } else if(!strncmp("MemsStart",(char *)(att_data),9)) {
 801d8e6:	2209      	movs	r2, #9
 801d8e8:	4639      	mov	r1, r7
 801d8ea:	4862      	ldr	r0, [pc, #392]	; (801da74 <HCI_Event_CB+0x117c>)
 801d8ec:	f001 fe74 	bl	801f5d8 <strncmp>
 801d8f0:	2800      	cmp	r0, #0
 801d8f2:	f000 808a 	beq.w	801da0a <HCI_Event_CB+0x1112>
      } else if(!strncmp("MemsStop",(char *)(att_data),8)) {
 801d8f6:	2208      	movs	r2, #8
 801d8f8:	4639      	mov	r1, r7
 801d8fa:	485f      	ldr	r0, [pc, #380]	; (801da78 <HCI_Event_CB+0x1180>)
 801d8fc:	f001 fe6c 	bl	801f5d8 <strncmp>
 801d900:	2800      	cmp	r0, #0
 801d902:	d07a      	beq.n	801d9fa <HCI_Event_CB+0x1102>
      } else if(!strncmp("AudioStart",(char *)(att_data),10)) {
 801d904:	220a      	movs	r2, #10
 801d906:	4639      	mov	r1, r7
 801d908:	485c      	ldr	r0, [pc, #368]	; (801da7c <HCI_Event_CB+0x1184>)
 801d90a:	f001 fe65 	bl	801f5d8 <strncmp>
 801d90e:	2800      	cmp	r0, #0
 801d910:	d065      	beq.n	801d9de <HCI_Event_CB+0x10e6>
      } else if(!strncmp("AudioStop",(char *)(att_data),9)) {
 801d912:	2209      	movs	r2, #9
 801d914:	4639      	mov	r1, r7
 801d916:	485a      	ldr	r0, [pc, #360]	; (801da80 <HCI_Event_CB+0x1188>)
 801d918:	f001 fe5e 	bl	801f5d8 <strncmp>
 801d91c:	2800      	cmp	r0, #0
 801d91e:	d052      	beq.n	801d9c6 <HCI_Event_CB+0x10ce>
      } else if(!strncmp("AudioMemsStart",(char *)(att_data),14)) {
 801d920:	220e      	movs	r2, #14
 801d922:	4639      	mov	r1, r7
 801d924:	4857      	ldr	r0, [pc, #348]	; (801da84 <HCI_Event_CB+0x118c>)
 801d926:	f001 fe57 	bl	801f5d8 <strncmp>
 801d92a:	2800      	cmp	r0, #0
 801d92c:	d034      	beq.n	801d998 <HCI_Event_CB+0x10a0>
      } else if(!strncmp("AudioMemsStop",(char *)(att_data),13)) {
 801d92e:	220d      	movs	r2, #13
 801d930:	4639      	mov	r1, r7
 801d932:	4855      	ldr	r0, [pc, #340]	; (801da88 <HCI_Event_CB+0x1190>)
 801d934:	f001 fe50 	bl	801f5d8 <strncmp>
 801d938:	2800      	cmp	r0, #0
 801d93a:	f47f ad8c 	bne.w	801d456 <HCI_Event_CB+0xb5e>
        SD_Card_FeaturesMask &= ~(FEATURE_MASK_BLUEVOICE   |
 801d93e:	4a53      	ldr	r2, [pc, #332]	; (801da8c <HCI_Event_CB+0x1194>)
 801d940:	6813      	ldr	r3, [r2, #0]
 801d942:	f023 630f 	bic.w	r3, r3, #149946368	; 0x8f00000
 801d946:	f423 2350 	bic.w	r3, r3, #851968	; 0xd0000
 801d94a:	6013      	str	r3, [r2, #0]
        SD_CardLoggingMemsStop();
 801d94c:	f7fb fe50 	bl	80195f0 <SD_CardLoggingMemsStop>
        osDelay(100);
 801d950:	2064      	movs	r0, #100	; 0x64
 801d952:	f7f8 fc6d 	bl	8016230 <osDelay>
        SD_CardLoggingAudioStop();
 801d956:	f7fb fedd 	bl	8019714 <SD_CardLoggingAudioStop>
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 801d95a:	682b      	ldr	r3, [r5, #0]
 801d95c:	055d      	lsls	r5, r3, #21
 801d95e:	f57e afd1 	bpl.w	801c904 <HCI_Event_CB+0xc>
 801d962:	e5c1      	b.n	801d4e8 <HCI_Event_CB+0xbf0>
          RTC_DataConfig(StartDate.WeekDay, StartDate.Date, StartDate.Month, StartDate.Year);
 801d964:	f7fd fb7c 	bl	801b060 <RTC_DataConfig>
          BytesToWrite =sprintf((char *)BufferToWrite,"Date format Correct\n");
 801d968:	4c49      	ldr	r4, [pc, #292]	; (801da90 <HCI_Event_CB+0x1198>)
          BytesToWrite =sprintf((char *)BufferToWrite,"Time format Correct\n");
 801d96a:	4d35      	ldr	r5, [pc, #212]	; (801da40 <HCI_Event_CB+0x1148>)
 801d96c:	4f35      	ldr	r7, [pc, #212]	; (801da44 <HCI_Event_CB+0x114c>)
 801d96e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801d970:	2614      	movs	r6, #20
 801d972:	6028      	str	r0, [r5, #0]
 801d974:	6820      	ldr	r0, [r4, #0]
 801d976:	7924      	ldrb	r4, [r4, #4]
 801d978:	6069      	str	r1, [r5, #4]
 801d97a:	6128      	str	r0, [r5, #16]
 801d97c:	60aa      	str	r2, [r5, #8]
          Term_Update(BufferToWrite,BytesToWrite);
 801d97e:	4628      	mov	r0, r5
 801d980:	4631      	mov	r1, r6
          BytesToWrite =sprintf((char *)BufferToWrite,"Time format Correct\n");
 801d982:	60eb      	str	r3, [r5, #12]
 801d984:	752c      	strb	r4, [r5, #20]
 801d986:	603e      	str	r6, [r7, #0]
          Term_Update(BufferToWrite,BytesToWrite);
 801d988:	f7fe fa88 	bl	801be9c <Term_Update>
 801d98c:	f7fe bfba 	b.w	801c904 <HCI_Event_CB+0xc>
          RTC_TimeConfig(StartTime.Hours, StartTime.Minutes, StartTime.Seconds);
 801d990:	f7fd fb7c 	bl	801b08c <RTC_TimeConfig>
          BytesToWrite =sprintf((char *)BufferToWrite,"Time format Correct\n");
 801d994:	4c3f      	ldr	r4, [pc, #252]	; (801da94 <HCI_Event_CB+0x119c>)
 801d996:	e7e8      	b.n	801d96a <HCI_Event_CB+0x1072>
        SD_Card_FeaturesMask |= FEATURE_MASK_BLUEVOICE   |
 801d998:	4a3c      	ldr	r2, [pc, #240]	; (801da8c <HCI_Event_CB+0x1194>)
 801d99a:	6813      	ldr	r3, [r2, #0]
 801d99c:	f043 630f 	orr.w	r3, r3, #149946368	; 0x8f00000
 801d9a0:	f443 2350 	orr.w	r3, r3, #851968	; 0xd0000
 801d9a4:	6013      	str	r3, [r2, #0]
        SD_CardLoggingMemsStart(0);
 801d9a6:	f7fb ff3b 	bl	8019820 <SD_CardLoggingMemsStart>
        osDelay(100);
 801d9aa:	2064      	movs	r0, #100	; 0x64
 801d9ac:	f7f8 fc40 	bl	8016230 <osDelay>
        SD_CardLoggingAudioStart();
 801d9b0:	f7fc f890 	bl	8019ad4 <SD_CardLoggingAudioStart>
        if(SD_LogAudio_Enabled & SD_LogMems_Enabled) {
 801d9b4:	4a38      	ldr	r2, [pc, #224]	; (801da98 <HCI_Event_CB+0x11a0>)
 801d9b6:	4b39      	ldr	r3, [pc, #228]	; (801da9c <HCI_Event_CB+0x11a4>)
 801d9b8:	6812      	ldr	r2, [r2, #0]
 801d9ba:	681b      	ldr	r3, [r3, #0]
 801d9bc:	421a      	tst	r2, r3
 801d9be:	f47f ae74 	bne.w	801d6aa <HCI_Event_CB+0xdb2>
 801d9c2:	f7fe bf9f 	b.w	801c904 <HCI_Event_CB+0xc>
        SD_Card_FeaturesMask &= ~FEATURE_MASK_BLUEVOICE;
 801d9c6:	4a31      	ldr	r2, [pc, #196]	; (801da8c <HCI_Event_CB+0x1194>)
 801d9c8:	6813      	ldr	r3, [r2, #0]
 801d9ca:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
 801d9ce:	6013      	str	r3, [r2, #0]
        SD_CardLoggingAudioStop();
 801d9d0:	f7fb fea0 	bl	8019714 <SD_CardLoggingAudioStop>
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 801d9d4:	682b      	ldr	r3, [r5, #0]
 801d9d6:	055e      	lsls	r6, r3, #21
 801d9d8:	f57e af94 	bpl.w	801c904 <HCI_Event_CB+0xc>
 801d9dc:	e584      	b.n	801d4e8 <HCI_Event_CB+0xbf0>
        SD_Card_FeaturesMask |= FEATURE_MASK_BLUEVOICE;
 801d9de:	4a2b      	ldr	r2, [pc, #172]	; (801da8c <HCI_Event_CB+0x1194>)
 801d9e0:	6813      	ldr	r3, [r2, #0]
 801d9e2:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 801d9e6:	6013      	str	r3, [r2, #0]
        SD_CardLoggingAudioStart();
 801d9e8:	f7fc f874 	bl	8019ad4 <SD_CardLoggingAudioStart>
        if(SD_LogAudio_Enabled) {
 801d9ec:	4b2a      	ldr	r3, [pc, #168]	; (801da98 <HCI_Event_CB+0x11a0>)
 801d9ee:	681b      	ldr	r3, [r3, #0]
 801d9f0:	2b00      	cmp	r3, #0
 801d9f2:	f47f ae5a 	bne.w	801d6aa <HCI_Event_CB+0xdb2>
 801d9f6:	f7fe bf85 	b.w	801c904 <HCI_Event_CB+0xc>
        SD_Card_FeaturesMask &= ~(FEATURE_MASK_TEMP1 |
 801d9fa:	4a24      	ldr	r2, [pc, #144]	; (801da8c <HCI_Event_CB+0x1194>)
 801d9fc:	6813      	ldr	r3, [r2, #0]
 801d9fe:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 801da02:	6013      	str	r3, [r2, #0]
        SD_CardLoggingMemsStop();
 801da04:	f7fb fdf4 	bl	80195f0 <SD_CardLoggingMemsStop>
 801da08:	e56a      	b.n	801d4e0 <HCI_Event_CB+0xbe8>
        SD_Card_FeaturesMask |= FEATURE_MASK_TEMP1 |
 801da0a:	4a20      	ldr	r2, [pc, #128]	; (801da8c <HCI_Event_CB+0x1194>)
 801da0c:	6813      	ldr	r3, [r2, #0]
 801da0e:	f443 037d 	orr.w	r3, r3, #16580608	; 0xfd0000
 801da12:	6013      	str	r3, [r2, #0]
        SD_CardLoggingMemsStart(0);
 801da14:	f7fb ff04 	bl	8019820 <SD_CardLoggingMemsStart>
        if(SD_LogMems_Enabled) {
 801da18:	4b20      	ldr	r3, [pc, #128]	; (801da9c <HCI_Event_CB+0x11a4>)
 801da1a:	681b      	ldr	r3, [r3, #0]
 801da1c:	2b00      	cmp	r3, #0
 801da1e:	f47f ae44 	bne.w	801d6aa <HCI_Event_CB+0xdb2>
 801da22:	f7fe bf6f 	b.w	801c904 <HCI_Event_CB+0xc>
      int32_t AudioVolume = atoi((char *)(att_data+9));
 801da26:	f104 0015 	add.w	r0, r4, #21
 801da2a:	f001 f828 	bl	801ea7e <atoi>
        TargetBoardFeatures.AudioVolume = AudioVolume;
 801da2e:	4b1c      	ldr	r3, [pc, #112]	; (801daa0 <HCI_Event_CB+0x11a8>)
        BytesToWrite =sprintf((char *)BufferToWrite,"setMicVol Correct =%ld\n",
 801da30:	491c      	ldr	r1, [pc, #112]	; (801daa4 <HCI_Event_CB+0x11ac>)
      int32_t AudioVolume = atoi((char *)(att_data+9));
 801da32:	4602      	mov	r2, r0
        TargetBoardFeatures.AudioVolume = AudioVolume;
 801da34:	63da      	str	r2, [r3, #60]	; 0x3c
        BytesToWrite =sprintf((char *)BufferToWrite,"setMicVol Correct =%ld\n",
 801da36:	4802      	ldr	r0, [pc, #8]	; (801da40 <HCI_Event_CB+0x1148>)
 801da38:	f7ff bacf 	b.w	801cfda <HCI_Event_CB+0x6e2>
 801da3c:	08075d40 	.word	0x08075d40
 801da40:	20013174 	.word	0x20013174
 801da44:	200132a0 	.word	0x200132a0
 801da48:	08075d5c 	.word	0x08075d5c
 801da4c:	08075b08 	.word	0x08075b08
 801da50:	08075b84 	.word	0x08075b84
 801da54:	08075c04 	.word	0x08075c04
 801da58:	08075c10 	.word	0x08075c10
 801da5c:	08075bd0 	.word	0x08075bd0
 801da60:	08075c1c 	.word	0x08075c1c
 801da64:	08075d74 	.word	0x08075d74
 801da68:	08075d94 	.word	0x08075d94
 801da6c:	08075db0 	.word	0x08075db0
 801da70:	08075dc4 	.word	0x08075dc4
 801da74:	08075de8 	.word	0x08075de8
 801da78:	08075df4 	.word	0x08075df4
 801da7c:	08075e00 	.word	0x08075e00
 801da80:	08075e0c 	.word	0x08075e0c
 801da84:	08075e18 	.word	0x08075e18
 801da88:	08075e28 	.word	0x08075e28
 801da8c:	2000f2dc 	.word	0x2000f2dc
 801da90:	08075d28 	.word	0x08075d28
 801da94:	08075d7c 	.word	0x08075d7c
 801da98:	2000f074 	.word	0x2000f074
 801da9c:	2000f2e0 	.word	0x2000f2e0
 801daa0:	20011458 	.word	0x20011458
 801daa4:	08075dd0 	.word	0x08075dd0

0801daa8 <HAL_RTC_MspInit>:
  *        order to modify the RTC Clock source, as consequence RTC registers (including 
  *        the backup registers) and RCC_CSR register are set to their reset values.  
  * @retval None
  */
void HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc)
{
 801daa8:	b530      	push	{r4, r5, lr}
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_PeriphCLKInitTypeDef  PeriphClkInitStruct;

  __HAL_RCC_PWR_CLK_ENABLE();
 801daaa:	4c1f      	ldr	r4, [pc, #124]	; (801db28 <HAL_RTC_MspInit+0x80>)
 801daac:	6da3      	ldr	r3, [r4, #88]	; 0x58
 801daae:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 801dab2:	65a3      	str	r3, [r4, #88]	; 0x58
 801dab4:	6da3      	ldr	r3, [r4, #88]	; 0x58
{
 801dab6:	b0b5      	sub	sp, #212	; 0xd4
  __HAL_RCC_PWR_CLK_ENABLE();
 801dab8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 801dabc:	9300      	str	r3, [sp, #0]
 801dabe:	9b00      	ldr	r3, [sp, #0]
  HAL_PWR_DisableBkUpAccess();
 801dac0:	f7f4 f8e6 	bl	8011c90 <HAL_PWR_DisableBkUpAccess>


  /*##-1- Configure the RTC clock source ######################################*/
  /* -a- Enable LSI Oscillator */
  RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_LSI;
 801dac4:	2108      	movs	r1, #8
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 801dac6:	2200      	movs	r2, #0
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 801dac8:	2301      	movs	r3, #1
  if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 801daca:	a801      	add	r0, sp, #4
  RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_LSI;
 801dacc:	9101      	str	r1, [sp, #4]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 801dace:	920b      	str	r2, [sp, #44]	; 0x2c
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 801dad0:	9306      	str	r3, [sp, #24]
  if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 801dad2:	f7f4 f9d7 	bl	8011e84 <HAL_RCC_OscConfig>
 801dad6:	b100      	cbz	r0, 801dada <HAL_RTC_MspInit+0x32>
 801dad8:	e7fe      	b.n	801dad8 <HAL_RTC_MspInit+0x30>
  {
    while(1);
  }

  /* -b- Select LSI as RTC clock source */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 801dada:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 801dade:	f44f 7300 	mov.w	r3, #512	; 0x200
  if(HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801dae2:	a812      	add	r0, sp, #72	; 0x48
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 801dae4:	9212      	str	r2, [sp, #72]	; 0x48
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 801dae6:	9333      	str	r3, [sp, #204]	; 0xcc
  if(HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801dae8:	f7f4 fe14 	bl	8012714 <HAL_RCCEx_PeriphCLKConfig>
 801daec:	4605      	mov	r5, r0
 801daee:	b100      	cbz	r0, 801daf2 <HAL_RTC_MspInit+0x4a>
 801daf0:	e7fe      	b.n	801daf0 <HAL_RTC_MspInit+0x48>
  { 
    while(1);
  }
  HAL_PWR_EnableBkUpAccess();
 801daf2:	f7f4 f8c5 	bl	8011c80 <HAL_PWR_EnableBkUpAccess>
  
  /*##-2- Enable the RTC peripheral Clock ####################################*/
  /* Enable RTC Clock */
  __HAL_RCC_RTC_ENABLE();
 801daf6:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 801dafa:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 801dafe:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
  
  /*##-3- Configure the NVIC for RTC Wake up ###################################*/
  HAL_NVIC_SetPriority(RTC_WKUP_IRQn, 0x00, 0);
 801db02:	462a      	mov	r2, r5
 801db04:	4629      	mov	r1, r5
 801db06:	2003      	movs	r0, #3
 801db08:	f7f2 fd1c 	bl	8010544 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(RTC_WKUP_IRQn);
 801db0c:	2003      	movs	r0, #3
 801db0e:	f7f2 fd4f 	bl	80105b0 <HAL_NVIC_EnableIRQ>
  
  /*##-4- Configure the NVIC for RTC Alarm ###################################*/
  HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0x0F, 0);
 801db12:	462a      	mov	r2, r5
 801db14:	210f      	movs	r1, #15
 801db16:	2029      	movs	r0, #41	; 0x29
 801db18:	f7f2 fd14 	bl	8010544 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);}
 801db1c:	2029      	movs	r0, #41	; 0x29
 801db1e:	f7f2 fd47 	bl	80105b0 <HAL_NVIC_EnableIRQ>
 801db22:	b035      	add	sp, #212	; 0xd4
 801db24:	bd30      	pop	{r4, r5, pc}
 801db26:	bf00      	nop
 801db28:	40021000 	.word	0x40021000

0801db2c <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 801db2c:	4770      	bx	lr
 801db2e:	bf00      	nop

0801db30 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 801db30:	e7fe      	b.n	801db30 <HardFault_Handler>
 801db32:	bf00      	nop

0801db34 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 801db34:	e7fe      	b.n	801db34 <MemManage_Handler>
 801db36:	bf00      	nop

0801db38 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 801db38:	e7fe      	b.n	801db38 <BusFault_Handler>
 801db3a:	bf00      	nop

0801db3c <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 801db3c:	e7fe      	b.n	801db3c <UsageFault_Handler>
 801db3e:	bf00      	nop

0801db40 <DebugMon_Handler>:
 801db40:	4770      	bx	lr
 801db42:	bf00      	nop

0801db44 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 801db44:	b508      	push	{r3, lr}
  osSystickHandler();
 801db46:	f7f8 fdb9 	bl	80166bc <osSystickHandler>
  HAL_IncTick();
}
 801db4a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_IncTick();
 801db4e:	f7f2 bcc5 	b.w	80104dc <HAL_IncTick>
 801db52:	bf00      	nop

0801db54 <DMA2_Channel2_IRQHandler>:
  * @param  None
  * @retval None
  */
void DMA2_Channel2_IRQHandler(void)
{
  HAL_DMA_IRQHandler(SPI_SD_Handle.hdmatx);
 801db54:	4b01      	ldr	r3, [pc, #4]	; (801db5c <DMA2_Channel2_IRQHandler+0x8>)
 801db56:	6d58      	ldr	r0, [r3, #84]	; 0x54
 801db58:	f7f3 b8d6 	b.w	8010d08 <HAL_DMA_IRQHandler>
 801db5c:	200103ec 	.word	0x200103ec

0801db60 <RTC_Alarm_IRQHandler>:
  * @param  None
  * @retval None
  */
void RTC_Alarm_IRQHandler(void)
{
  HAL_RTC_AlarmIRQHandler(&RtcHandle);
 801db60:	4801      	ldr	r0, [pc, #4]	; (801db68 <RTC_Alarm_IRQHandler+0x8>)
 801db62:	f7f5 b863 	b.w	8012c2c <HAL_RTC_AlarmIRQHandler>
 801db66:	bf00      	nop
 801db68:	20013278 	.word	0x20013278

0801db6c <DMA1_Channel4_IRQHandler>:
  * @param None
  * @retval None
  */
void AUDIO_IN_DFSDM_DMA_1st_CH_IRQHandler(void)
{ 
  HAL_DMA_IRQHandler(&hdma_dfsdmReg_FLT[0]);
 801db6c:	4801      	ldr	r0, [pc, #4]	; (801db74 <DMA1_Channel4_IRQHandler+0x8>)
 801db6e:	f7f3 b8cb 	b.w	8010d08 <HAL_DMA_IRQHandler>
 801db72:	bf00      	nop
 801db74:	20010498 	.word	0x20010498

0801db78 <EXTI3_IRQHandler>:
* @param  None
* @retval None
*/
void EXTI3_IRQHandler(void)
{
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3);
 801db78:	2008      	movs	r0, #8
 801db7a:	f7f3 bd01 	b.w	8011580 <HAL_GPIO_EXTI_IRQHandler>
 801db7e:	bf00      	nop

0801db80 <EXTI9_5_IRQHandler>:
  * @param  None
  * @retval None
  */
void BNRG_SPI_EXTI_IRQHandler(void)
{
  HAL_GPIO_EXTI_IRQHandler(BNRG_SPI_EXTI_PIN);
 801db80:	2020      	movs	r0, #32
 801db82:	f7f3 bcfd 	b.w	8011580 <HAL_GPIO_EXTI_IRQHandler>
 801db86:	bf00      	nop

0801db88 <EXTI2_IRQHandler>:
  * @param  None
  * @retval None
  */
void EXTI2_IRQHandler( void ) /* change */
{
  HAL_GPIO_EXTI_IRQHandler(LSM6DSM_INT2_PIN);
 801db88:	2004      	movs	r0, #4
 801db8a:	f7f3 bcf9 	b.w	8011580 <HAL_GPIO_EXTI_IRQHandler>
 801db8e:	bf00      	nop

0801db90 <RTC_WKUP_IRQHandler>:
  * @param  None
  * @retval None
  */
void RTC_WKUP_IRQHandler(void)
{
  HAL_RTCEx_WakeUpTimerIRQHandler(&RtcHandle);
 801db90:	4801      	ldr	r0, [pc, #4]	; (801db98 <RTC_WKUP_IRQHandler+0x8>)
 801db92:	f7f5 bb11 	b.w	80131b8 <HAL_RTCEx_WakeUpTimerIRQHandler>
 801db96:	bf00      	nop
 801db98:	20013278 	.word	0x20013278

0801db9c <HAL_SPI_MspInit>:
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
  GPIO_InitTypeDef GPIO_InitStruct;
  if(hspi->Instance==BNRG_SPI_INSTANCE)
 801db9c:	6802      	ldr	r2, [r0, #0]
 801db9e:	4b51      	ldr	r3, [pc, #324]	; (801dce4 <HAL_SPI_MspInit+0x148>)
 801dba0:	429a      	cmp	r2, r3
 801dba2:	d000      	beq.n	801dba6 <HAL_SPI_MspInit+0xa>
 801dba4:	4770      	bx	lr
  {
    /* Enable peripherals clock */
    
    /* Enable GPIO Ports Clock */  
    BNRG_SPI_RESET_CLK_ENABLE();
 801dba6:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
{
 801dbaa:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    BNRG_SPI_RESET_CLK_ENABLE();
 801dbae:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    GPIO_InitStruct.Pin = BNRG_SPI_RESET_PIN;
    GPIO_InitStruct.Mode = BNRG_SPI_RESET_MODE;
    GPIO_InitStruct.Pull = BNRG_SPI_RESET_PULL;
    GPIO_InitStruct.Speed = BNRG_SPI_RESET_SPEED;
    GPIO_InitStruct.Alternate = BNRG_SPI_RESET_ALTERNATE;
    HAL_GPIO_Init(BNRG_SPI_RESET_PORT, &GPIO_InitStruct);	
 801dbb0:	484d      	ldr	r0, [pc, #308]	; (801dce8 <HAL_SPI_MspInit+0x14c>)
    BNRG_SPI_RESET_CLK_ENABLE();
 801dbb2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 801dbb6:	64da      	str	r2, [r3, #76]	; 0x4c
 801dbb8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 801dbba:	b08d      	sub	sp, #52	; 0x34
    BNRG_SPI_RESET_CLK_ENABLE();
 801dbbc:	f002 0280 	and.w	r2, r2, #128	; 0x80
 801dbc0:	9200      	str	r2, [sp, #0]
 801dbc2:	9a00      	ldr	r2, [sp, #0]
    BNRG_SPI_SCLK_CLK_ENABLE();
 801dbc4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801dbc6:	f042 0201 	orr.w	r2, r2, #1
 801dbca:	64da      	str	r2, [r3, #76]	; 0x4c
 801dbcc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801dbce:	f002 0201 	and.w	r2, r2, #1
 801dbd2:	9201      	str	r2, [sp, #4]
 801dbd4:	9a01      	ldr	r2, [sp, #4]
    BNRG_SPI_MISO_CLK_ENABLE();
 801dbd6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801dbd8:	f042 0201 	orr.w	r2, r2, #1
 801dbdc:	64da      	str	r2, [r3, #76]	; 0x4c
 801dbde:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801dbe0:	f002 0201 	and.w	r2, r2, #1
 801dbe4:	9202      	str	r2, [sp, #8]
 801dbe6:	9a02      	ldr	r2, [sp, #8]
    BNRG_SPI_MOSI_CLK_ENABLE();
 801dbe8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801dbea:	f042 0201 	orr.w	r2, r2, #1
 801dbee:	64da      	str	r2, [r3, #76]	; 0x4c
 801dbf0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801dbf2:	f002 0201 	and.w	r2, r2, #1
 801dbf6:	9203      	str	r2, [sp, #12]
 801dbf8:	9a03      	ldr	r2, [sp, #12]
    BNRG_SPI_CS_CLK_ENABLE();
 801dbfa:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801dbfc:	f042 0202 	orr.w	r2, r2, #2
 801dc00:	64da      	str	r2, [r3, #76]	; 0x4c
 801dc02:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801dc04:	f002 0202 	and.w	r2, r2, #2
 801dc08:	9204      	str	r2, [sp, #16]
 801dc0a:	9a04      	ldr	r2, [sp, #16]
    BNRG_SPI_IRQ_CLK_ENABLE();
 801dc0c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801dc0e:	f042 0204 	orr.w	r2, r2, #4
 801dc12:	64da      	str	r2, [r3, #76]	; 0x4c
 801dc14:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801dc16:	f002 0204 	and.w	r2, r2, #4
 801dc1a:	9205      	str	r2, [sp, #20]
 801dc1c:	9a05      	ldr	r2, [sp, #20]
    BNRG_SPI_CLK_ENABLE();
 801dc1e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 801dc20:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 801dc24:	661a      	str	r2, [r3, #96]	; 0x60
 801dc26:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 801dc28:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    GPIO_InitStruct.Speed = BNRG_SPI_RESET_SPEED;
 801dc2c:	2400      	movs	r4, #0
    GPIO_InitStruct.Pin = BNRG_SPI_RESET_PIN;
 801dc2e:	2501      	movs	r5, #1
    BNRG_SPI_CLK_ENABLE();
 801dc30:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(BNRG_SPI_RESET_PORT, &GPIO_InitStruct);	
 801dc32:	a907      	add	r1, sp, #28
    BNRG_SPI_CLK_ENABLE();
 801dc34:	9b06      	ldr	r3, [sp, #24]
    GPIO_InitStruct.Alternate = BNRG_SPI_RESET_ALTERNATE;
 801dc36:	940b      	str	r4, [sp, #44]	; 0x2c
    GPIO_InitStruct.Mode = BNRG_SPI_RESET_MODE;
 801dc38:	e9cd 5507 	strd	r5, r5, [sp, #28]
    GPIO_InitStruct.Speed = BNRG_SPI_RESET_SPEED;
 801dc3c:	e9cd 5409 	strd	r5, r4, [sp, #36]	; 0x24
    HAL_GPIO_Init(BNRG_SPI_RESET_PORT, &GPIO_InitStruct);	
 801dc40:	f7f3 fad0 	bl	80111e4 <HAL_GPIO_Init>
    HAL_GPIO_WritePin(BNRG_SPI_RESET_PORT, BNRG_SPI_RESET_PIN, GPIO_PIN_RESET);	/*Added to avoid spurious interrupt from the BlueNRG */
 801dc44:	4622      	mov	r2, r4
 801dc46:	4629      	mov	r1, r5
 801dc48:	4827      	ldr	r0, [pc, #156]	; (801dce8 <HAL_SPI_MspInit+0x14c>)
 801dc4a:	f7f3 fc8f 	bl	801156c <HAL_GPIO_WritePin>
    
    /* SCLK */
    GPIO_InitStruct.Pin = BNRG_SPI_SCLK_PIN;
    GPIO_InitStruct.Mode = BNRG_SPI_SCLK_MODE;
    GPIO_InitStruct.Pull = BNRG_SPI_SCLK_PULL;
    GPIO_InitStruct.Speed = BNRG_SPI_SCLK_SPEED;
 801dc4e:	2603      	movs	r6, #3
    GPIO_InitStruct.Mode = BNRG_SPI_SCLK_MODE;
 801dc50:	f04f 0802 	mov.w	r8, #2
    GPIO_InitStruct.Alternate = BNRG_SPI_SCLK_ALTERNATE;
 801dc54:	2705      	movs	r7, #5
    GPIO_InitStruct.Pin = BNRG_SPI_SCLK_PIN;
 801dc56:	f04f 0920 	mov.w	r9, #32
    HAL_GPIO_Init(BNRG_SPI_SCLK_PORT, &GPIO_InitStruct); 
 801dc5a:	a907      	add	r1, sp, #28
 801dc5c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Mode = BNRG_SPI_SCLK_MODE;
 801dc60:	e9cd 9807 	strd	r9, r8, [sp, #28]
    GPIO_InitStruct.Speed = BNRG_SPI_SCLK_SPEED;
 801dc64:	e9cd 8609 	strd	r8, r6, [sp, #36]	; 0x24
    GPIO_InitStruct.Alternate = BNRG_SPI_SCLK_ALTERNATE;
 801dc68:	970b      	str	r7, [sp, #44]	; 0x2c
    HAL_GPIO_Init(BNRG_SPI_SCLK_PORT, &GPIO_InitStruct); 
 801dc6a:	f7f3 fabb 	bl	80111e4 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = BNRG_SPI_MISO_PIN;
    GPIO_InitStruct.Mode = BNRG_SPI_MISO_MODE;
    GPIO_InitStruct.Pull = BNRG_SPI_MISO_PULL;
    GPIO_InitStruct.Speed = BNRG_SPI_MISO_SPEED;
    GPIO_InitStruct.Alternate = BNRG_SPI_MISO_ALTERNATE;
    HAL_GPIO_Init(BNRG_SPI_MISO_PORT, &GPIO_InitStruct);
 801dc6e:	a907      	add	r1, sp, #28
    GPIO_InitStruct.Pin = BNRG_SPI_MISO_PIN;
 801dc70:	2340      	movs	r3, #64	; 0x40
    HAL_GPIO_Init(BNRG_SPI_MISO_PORT, &GPIO_InitStruct);
 801dc72:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Pull = BNRG_SPI_MISO_PULL;
 801dc76:	e9cd 8408 	strd	r8, r4, [sp, #32]
    GPIO_InitStruct.Pin = BNRG_SPI_MISO_PIN;
 801dc7a:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Alternate = BNRG_SPI_MISO_ALTERNATE;
 801dc7c:	e9cd 670a 	strd	r6, r7, [sp, #40]	; 0x28
    HAL_GPIO_Init(BNRG_SPI_MISO_PORT, &GPIO_InitStruct);
 801dc80:	f7f3 fab0 	bl	80111e4 <HAL_GPIO_Init>
    
    /* MOSI */
    GPIO_InitStruct.Pin = BNRG_SPI_MOSI_PIN;
 801dc84:	2380      	movs	r3, #128	; 0x80
    GPIO_InitStruct.Mode = BNRG_SPI_MOSI_MODE;
    GPIO_InitStruct.Pull = BNRG_SPI_MOSI_PULL;
    GPIO_InitStruct.Speed = BNRG_SPI_MOSI_SPEED;
    GPIO_InitStruct.Alternate = BNRG_SPI_MOSI_ALTERNATE;
    HAL_GPIO_Init(BNRG_SPI_MOSI_PORT, &GPIO_InitStruct);
 801dc86:	a907      	add	r1, sp, #28
 801dc88:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Pin = BNRG_SPI_MOSI_PIN;
 801dc8c:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Pull = BNRG_SPI_MOSI_PULL;
 801dc8e:	e9cd 8408 	strd	r8, r4, [sp, #32]
    GPIO_InitStruct.Alternate = BNRG_SPI_MOSI_ALTERNATE;
 801dc92:	e9cd 670a 	strd	r6, r7, [sp, #40]	; 0x28
    
    /* NSS/CSN/CS */
    GPIO_InitStruct.Pin = BNRG_SPI_CS_PIN;
 801dc96:	f04f 0804 	mov.w	r8, #4
    HAL_GPIO_Init(BNRG_SPI_MOSI_PORT, &GPIO_InitStruct);
 801dc9a:	f7f3 faa3 	bl	80111e4 <HAL_GPIO_Init>
    GPIO_InitStruct.Mode = BNRG_SPI_CS_MODE;
    GPIO_InitStruct.Pull = BNRG_SPI_CS_PULL;
    GPIO_InitStruct.Speed = BNRG_SPI_CS_SPEED;
    GPIO_InitStruct.Alternate = BNRG_SPI_CS_ALTERNATE;
    HAL_GPIO_Init(BNRG_SPI_CS_PORT, &GPIO_InitStruct);
 801dc9e:	a907      	add	r1, sp, #28
 801dca0:	4812      	ldr	r0, [pc, #72]	; (801dcec <HAL_SPI_MspInit+0x150>)
    GPIO_InitStruct.Pin = BNRG_SPI_CS_PIN;
 801dca2:	f8cd 801c 	str.w	r8, [sp, #28]
    GPIO_InitStruct.Pull = BNRG_SPI_CS_PULL;
 801dca6:	e9cd 5508 	strd	r5, r5, [sp, #32]
    GPIO_InitStruct.Alternate = BNRG_SPI_CS_ALTERNATE;
 801dcaa:	e9cd 640a 	strd	r6, r4, [sp, #40]	; 0x28
    HAL_GPIO_Init(BNRG_SPI_CS_PORT, &GPIO_InitStruct);
 801dcae:	f7f3 fa99 	bl	80111e4 <HAL_GPIO_Init>
    HAL_GPIO_WritePin(BNRG_SPI_CS_PORT, BNRG_SPI_CS_PIN, GPIO_PIN_SET);
 801dcb2:	462a      	mov	r2, r5
 801dcb4:	4641      	mov	r1, r8
 801dcb6:	480d      	ldr	r0, [pc, #52]	; (801dcec <HAL_SPI_MspInit+0x150>)
 801dcb8:	f7f3 fc58 	bl	801156c <HAL_GPIO_WritePin>
    
    /* IRQ -- INPUT */
    GPIO_InitStruct.Pin = BNRG_SPI_IRQ_PIN;
    GPIO_InitStruct.Mode = BNRG_SPI_IRQ_MODE;
 801dcbc:	4b0c      	ldr	r3, [pc, #48]	; (801dcf0 <HAL_SPI_MspInit+0x154>)
    GPIO_InitStruct.Pull = BNRG_SPI_IRQ_PULL;
    GPIO_InitStruct.Speed = BNRG_SPI_IRQ_SPEED;
    GPIO_InitStruct.Alternate = BNRG_SPI_IRQ_ALTERNATE;
    HAL_GPIO_Init(BNRG_SPI_IRQ_PORT, &GPIO_InitStruct);
 801dcbe:	480d      	ldr	r0, [pc, #52]	; (801dcf4 <HAL_SPI_MspInit+0x158>)
    GPIO_InitStruct.Mode = BNRG_SPI_IRQ_MODE;
 801dcc0:	9308      	str	r3, [sp, #32]
    HAL_GPIO_Init(BNRG_SPI_IRQ_PORT, &GPIO_InitStruct);
 801dcc2:	a907      	add	r1, sp, #28
    GPIO_InitStruct.Pin = BNRG_SPI_IRQ_PIN;
 801dcc4:	f8cd 901c 	str.w	r9, [sp, #28]
    GPIO_InitStruct.Speed = BNRG_SPI_IRQ_SPEED;
 801dcc8:	e9cd 4609 	strd	r4, r6, [sp, #36]	; 0x24
    GPIO_InitStruct.Alternate = BNRG_SPI_IRQ_ALTERNATE;
 801dccc:	940b      	str	r4, [sp, #44]	; 0x2c
    HAL_GPIO_Init(BNRG_SPI_IRQ_PORT, &GPIO_InitStruct);
 801dcce:	f7f3 fa89 	bl	80111e4 <HAL_GPIO_Init>
    
    /* Configure the NVIC for SPI */
#ifndef PRIORITY_RTOS
    HAL_NVIC_SetPriority(BNRG_SPI_EXTI_IRQn, 3, 0);    
#else
    HAL_NVIC_SetPriority(BNRG_SPI_EXTI_IRQn, 5, 0);    
 801dcd2:	4622      	mov	r2, r4
 801dcd4:	4639      	mov	r1, r7
 801dcd6:	2017      	movs	r0, #23
 801dcd8:	f7f2 fc34 	bl	8010544 <HAL_NVIC_SetPriority>
#endif
    //    HAL_NVIC_EnableIRQ(BNRG_SPI_EXTI_IRQn);
  }
}
 801dcdc:	b00d      	add	sp, #52	; 0x34
 801dcde:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801dce2:	bf00      	nop
 801dce4:	40013000 	.word	0x40013000
 801dce8:	48001c00 	.word	0x48001c00
 801dcec:	48000400 	.word	0x48000400
 801dcf0:	10110000 	.word	0x10110000
 801dcf4:	48000800 	.word	0x48000800

0801dcf8 <BNRG_SPI_Init>:
*         Expansion Board.
* @param  None
* @retval None
*/
void BNRG_SPI_Init(void)
{
 801dcf8:	b430      	push	{r4, r5}
  SpiHandle.Instance = BNRG_SPI_INSTANCE;
 801dcfa:	4b0d      	ldr	r3, [pc, #52]	; (801dd30 <BNRG_SPI_Init+0x38>)
 801dcfc:	4a0d      	ldr	r2, [pc, #52]	; (801dd34 <BNRG_SPI_Init+0x3c>)
 801dcfe:	601a      	str	r2, [r3, #0]
  SpiHandle.Init.Mode = BNRG_SPI_MODE;
 801dd00:	f44f 7082 	mov.w	r0, #260	; 0x104
  SpiHandle.Init.Direction = BNRG_SPI_DIRECTION;
  SpiHandle.Init.DataSize = BNRG_SPI_DATASIZE;
 801dd04:	f44f 62e0 	mov.w	r2, #1792	; 0x700
  SpiHandle.Init.CLKPolarity = BNRG_SPI_CLKPOLARITY;
  SpiHandle.Init.CLKPhase = BNRG_SPI_CLKPHASE;
  SpiHandle.Init.NSS = BNRG_SPI_NSS;
 801dd08:	f44f 7500 	mov.w	r5, #512	; 0x200
  SpiHandle.Init.FirstBit = BNRG_SPI_FIRSTBIT;
  SpiHandle.Init.TIMode = BNRG_SPI_TIMODE;
  SpiHandle.Init.CRCPolynomial = BNRG_SPI_CRCPOLYNOMIAL;
 801dd0c:	2407      	movs	r4, #7
  SpiHandle.Init.BaudRatePrescaler = BNRG_SPI_BAUDRATEPRESCALER;
 801dd0e:	2118      	movs	r1, #24
  SpiHandle.Init.Mode = BNRG_SPI_MODE;
 801dd10:	6058      	str	r0, [r3, #4]
  SpiHandle.Init.DataSize = BNRG_SPI_DATASIZE;
 801dd12:	60da      	str	r2, [r3, #12]
  SpiHandle.Init.NSS = BNRG_SPI_NSS;
 801dd14:	619d      	str	r5, [r3, #24]
  SpiHandle.Init.Direction = BNRG_SPI_DIRECTION;
 801dd16:	2200      	movs	r2, #0
  SpiHandle.Init.CRCPolynomial = BNRG_SPI_CRCPOLYNOMIAL;
 801dd18:	62dc      	str	r4, [r3, #44]	; 0x2c
  SpiHandle.Init.CRCCalculation = BNRG_SPI_CRCCALCULATION;
  
  HAL_SPI_Init(&SpiHandle);
 801dd1a:	4618      	mov	r0, r3
}
 801dd1c:	bc30      	pop	{r4, r5}
  SpiHandle.Init.BaudRatePrescaler = BNRG_SPI_BAUDRATEPRESCALER;
 801dd1e:	61d9      	str	r1, [r3, #28]
  SpiHandle.Init.Direction = BNRG_SPI_DIRECTION;
 801dd20:	609a      	str	r2, [r3, #8]
  SpiHandle.Init.CLKPhase = BNRG_SPI_CLKPHASE;
 801dd22:	e9c3 2204 	strd	r2, r2, [r3, #16]
  SpiHandle.Init.TIMode = BNRG_SPI_TIMODE;
 801dd26:	e9c3 2208 	strd	r2, r2, [r3, #32]
  SpiHandle.Init.CRCCalculation = BNRG_SPI_CRCCALCULATION;
 801dd2a:	629a      	str	r2, [r3, #40]	; 0x28
  HAL_SPI_Init(&SpiHandle);
 801dd2c:	f7f5 bb02 	b.w	8013334 <HAL_SPI_Init>
 801dd30:	200132a8 	.word	0x200132a8
 801dd34:	40013000 	.word	0x40013000

0801dd38 <BlueNRG_RST>:
* @brief  Resets the BlueNRG.
* @param  None
* @retval None
*/
void BlueNRG_RST(void)
{
 801dd38:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(BNRG_SPI_RESET_PORT, BNRG_SPI_RESET_PIN, GPIO_PIN_RESET);
 801dd3a:	4c09      	ldr	r4, [pc, #36]	; (801dd60 <BlueNRG_RST+0x28>)
 801dd3c:	2200      	movs	r2, #0
 801dd3e:	4620      	mov	r0, r4
 801dd40:	2101      	movs	r1, #1
 801dd42:	f7f3 fc13 	bl	801156c <HAL_GPIO_WritePin>
  HAL_Delay(5);
 801dd46:	2005      	movs	r0, #5
 801dd48:	f7fd f9de 	bl	801b108 <HAL_Delay>
  HAL_GPIO_WritePin(BNRG_SPI_RESET_PORT, BNRG_SPI_RESET_PIN, GPIO_PIN_SET);
 801dd4c:	2201      	movs	r2, #1
 801dd4e:	4620      	mov	r0, r4
 801dd50:	4611      	mov	r1, r2
 801dd52:	f7f3 fc0b 	bl	801156c <HAL_GPIO_WritePin>
  HAL_Delay(5);
 801dd56:	2005      	movs	r0, #5
}
 801dd58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_Delay(5);
 801dd5c:	f7fd b9d4 	b.w	801b108 <HAL_Delay>
 801dd60:	48001c00 	.word	0x48001c00

0801dd64 <BlueNRG_DataPresent>:
* @param  None
* @retval 1 if data are present, 0 otherwise
*/
// FIXME: find a better way to handle this return value (bool type? TRUE and FALSE)
uint8_t BlueNRG_DataPresent(void)
{
 801dd64:	b508      	push	{r3, lr}
  if (HAL_GPIO_ReadPin(BNRG_SPI_EXTI_PORT, BNRG_SPI_EXTI_PIN) == GPIO_PIN_SET)
 801dd66:	2120      	movs	r1, #32
 801dd68:	4804      	ldr	r0, [pc, #16]	; (801dd7c <BlueNRG_DataPresent+0x18>)
 801dd6a:	f7f3 fbf9 	bl	8011560 <HAL_GPIO_ReadPin>
    return 1;
  else  
    return 0;
} /* end BlueNRG_DataPresent() */
 801dd6e:	f1a0 0001 	sub.w	r0, r0, #1
 801dd72:	fab0 f080 	clz	r0, r0
 801dd76:	0940      	lsrs	r0, r0, #5
 801dd78:	bd08      	pop	{r3, pc}
 801dd7a:	bf00      	nop
 801dd7c:	48000800 	.word	0x48000800

0801dd80 <BlueNRG_SPI_Read_All>:
* @param  buff_size: Buffer size
* @retval int32_t  : Number of read bytes
*/
int32_t BlueNRG_SPI_Read_All(uint8_t *buffer,
                             uint8_t buff_size)
{
 801dd80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint16_t byte_count;
  uint8_t len = 0;
  uint8_t char_ff = 0xff;
  volatile uint8_t read_char;
  
  uint8_t header_master[HEADER_SIZE] = {0x0b, 0x00, 0x00, 0x00, 0x00};
 801dd84:	2400      	movs	r4, #0
{
 801dd86:	b088      	sub	sp, #32
  uint8_t char_ff = 0xff;
 801dd88:	f04f 0cff 	mov.w	ip, #255	; 0xff
  uint8_t header_master[HEADER_SIZE] = {0x0b, 0x00, 0x00, 0x00, 0x00};
 801dd8c:	230b      	movs	r3, #11
  uint8_t header_slave[HEADER_SIZE];
  
  /* CS reset */
  HAL_GPIO_WritePin(BNRG_SPI_CS_PORT, BNRG_SPI_CS_PIN, GPIO_PIN_RESET);
 801dd8e:	4622      	mov	r2, r4
{
 801dd90:	4607      	mov	r7, r0
 801dd92:	460e      	mov	r6, r1
  HAL_GPIO_WritePin(BNRG_SPI_CS_PORT, BNRG_SPI_CS_PIN, GPIO_PIN_RESET);
 801dd94:	4826      	ldr	r0, [pc, #152]	; (801de30 <BlueNRG_SPI_Read_All+0xb0>)
  uint8_t char_ff = 0xff;
 801dd96:	f88d c00a 	strb.w	ip, [sp, #10]
  HAL_GPIO_WritePin(BNRG_SPI_CS_PORT, BNRG_SPI_CS_PIN, GPIO_PIN_RESET);
 801dd9a:	2104      	movs	r1, #4
  
  /* Read the header */  
  HAL_SPI_TransmitReceive(&SpiHandle, header_master, header_slave, HEADER_SIZE, TIMEOUT_DURATION);
 801dd9c:	250f      	movs	r5, #15
  uint8_t header_master[HEADER_SIZE] = {0x0b, 0x00, 0x00, 0x00, 0x00};
 801dd9e:	9304      	str	r3, [sp, #16]
 801dda0:	f88d 4014 	strb.w	r4, [sp, #20]
  HAL_GPIO_WritePin(BNRG_SPI_CS_PORT, BNRG_SPI_CS_PIN, GPIO_PIN_RESET);
 801dda4:	f7f3 fbe2 	bl	801156c <HAL_GPIO_WritePin>
  HAL_SPI_TransmitReceive(&SpiHandle, header_master, header_slave, HEADER_SIZE, TIMEOUT_DURATION);
 801dda8:	2305      	movs	r3, #5
 801ddaa:	9500      	str	r5, [sp, #0]
 801ddac:	aa06      	add	r2, sp, #24
 801ddae:	a904      	add	r1, sp, #16
 801ddb0:	4820      	ldr	r0, [pc, #128]	; (801de34 <BlueNRG_SPI_Read_All+0xb4>)
 801ddb2:	f7f5 fc0d 	bl	80135d0 <HAL_SPI_TransmitReceive>
  
  if (header_slave[0] == 0x02) {
 801ddb6:	f89d 3018 	ldrb.w	r3, [sp, #24]
 801ddba:	2b02      	cmp	r3, #2
 801ddbc:	d014      	beq.n	801dde8 <BlueNRG_SPI_Read_All+0x68>
        buffer[len] = read_char;
      }
    }    
  }
  /* Release CS line */
  HAL_GPIO_WritePin(BNRG_SPI_CS_PORT, BNRG_SPI_CS_PIN, GPIO_PIN_SET);
 801ddbe:	2201      	movs	r2, #1
 801ddc0:	2104      	movs	r1, #4
 801ddc2:	481b      	ldr	r0, [pc, #108]	; (801de30 <BlueNRG_SPI_Read_All+0xb0>)
 801ddc4:	f7f3 fbd2 	bl	801156c <HAL_GPIO_WritePin>
  
  // Add a small delay to give time to the BlueNRG to set the IRQ pin low
  // to avoid a useless SPI read at the end of the transaction
  for(volatile int i = 0; i < 2; i++)__NOP();
 801ddc8:	2300      	movs	r3, #0
 801ddca:	9303      	str	r3, [sp, #12]
 801ddcc:	9b03      	ldr	r3, [sp, #12]
 801ddce:	2b01      	cmp	r3, #1
 801ddd0:	dc06      	bgt.n	801dde0 <BlueNRG_SPI_Read_All+0x60>
  __ASM volatile ("nop");
 801ddd2:	bf00      	nop
 801ddd4:	9b03      	ldr	r3, [sp, #12]
 801ddd6:	3301      	adds	r3, #1
 801ddd8:	9303      	str	r3, [sp, #12]
 801ddda:	9b03      	ldr	r3, [sp, #12]
 801dddc:	2b01      	cmp	r3, #1
 801ddde:	ddf8      	ble.n	801ddd2 <BlueNRG_SPI_Read_All+0x52>
    PRINT_CSV("\n");
  }
#endif
  
  return len;   
}
 801dde0:	4620      	mov	r0, r4
 801dde2:	b008      	add	sp, #32
 801dde4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    byte_count = (header_slave[4]<<8)|header_slave[3];
 801dde8:	f89d 201c 	ldrb.w	r2, [sp, #28]
 801ddec:	f89d 301b 	ldrb.w	r3, [sp, #27]
    if (byte_count > 0) {
 801ddf0:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
 801ddf4:	d018      	beq.n	801de28 <BlueNRG_SPI_Read_All+0xa8>
 801ddf6:	429e      	cmp	r6, r3
 801ddf8:	bf28      	it	cs
 801ddfa:	461e      	movcs	r6, r3
      for (len = 0; len < byte_count; len++){
 801ddfc:	b1b6      	cbz	r6, 801de2c <BlueNRG_SPI_Read_All+0xac>
        HAL_SPI_TransmitReceive(&SpiHandle, &char_ff, (uint8_t*)&read_char, 1, TIMEOUT_DURATION);
 801ddfe:	f8df 8034 	ldr.w	r8, [pc, #52]	; 801de34 <BlueNRG_SPI_Read_All+0xb4>
  __ASM volatile ("cpsid i" : : : "memory");
 801de02:	b672      	cpsid	i
 801de04:	2301      	movs	r3, #1
 801de06:	9500      	str	r5, [sp, #0]
 801de08:	f10d 020b 	add.w	r2, sp, #11
 801de0c:	f10d 010a 	add.w	r1, sp, #10
 801de10:	4640      	mov	r0, r8
 801de12:	f7f5 fbdd 	bl	80135d0 <HAL_SPI_TransmitReceive>
  __ASM volatile ("cpsie i" : : : "memory");
 801de16:	b662      	cpsie	i
        buffer[len] = read_char;
 801de18:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801de1c:	553b      	strb	r3, [r7, r4]
      for (len = 0; len < byte_count; len++){
 801de1e:	3401      	adds	r4, #1
 801de20:	b2e4      	uxtb	r4, r4
 801de22:	42b4      	cmp	r4, r6
 801de24:	d3ed      	bcc.n	801de02 <BlueNRG_SPI_Read_All+0x82>
 801de26:	e7ca      	b.n	801ddbe <BlueNRG_SPI_Read_All+0x3e>
 801de28:	461c      	mov	r4, r3
 801de2a:	e7c8      	b.n	801ddbe <BlueNRG_SPI_Read_All+0x3e>
 801de2c:	4634      	mov	r4, r6
 801de2e:	e7c6      	b.n	801ddbe <BlueNRG_SPI_Read_All+0x3e>
 801de30:	48000400 	.word	0x48000400
 801de34:	200132a8 	.word	0x200132a8

0801de38 <BlueNRG_SPI_Write>:
* @param  Nb_bytes2: Size of second data buffer to be written
* @retval Number of read bytes
*/
int32_t BlueNRG_SPI_Write(SPI_HandleTypeDef *hspi, uint8_t* data1,
                          uint8_t* data2, uint8_t Nb_bytes1, uint8_t Nb_bytes2)
{  
 801de38:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801de3c:	b0c7      	sub	sp, #284	; 0x11c
  
#ifdef ENABLE_SPI_FIX
  spi_fix_enabled = 1;
#endif //ENABLE_SPI_FIX
  
  unsigned char header_master[HEADER_SIZE] = {0x0a, 0x00, 0x00, 0x00, 0x00};
 801de3e:	f04f 0c0a 	mov.w	ip, #10
 801de42:	2500      	movs	r5, #0
{  
 801de44:	4607      	mov	r7, r0
  unsigned char header_slave[HEADER_SIZE]  = {0xaa, 0x00, 0x00, 0x00, 0x00};
 801de46:	24aa      	movs	r4, #170	; 0xaa
* @param  None
* @retval None
*/
void Disable_SPI_IRQ(void)
{ 
  HAL_NVIC_DisableIRQ(BNRG_SPI_EXTI_IRQn);
 801de48:	2017      	movs	r0, #23
{  
 801de4a:	4689      	mov	r9, r1
 801de4c:	4690      	mov	r8, r2
 801de4e:	461e      	mov	r6, r3
  unsigned char header_master[HEADER_SIZE] = {0x0a, 0x00, 0x00, 0x00, 0x00};
 801de50:	f8cd c008 	str.w	ip, [sp, #8]
  unsigned char header_slave[HEADER_SIZE]  = {0xaa, 0x00, 0x00, 0x00, 0x00};
 801de54:	9404      	str	r4, [sp, #16]
  unsigned char header_master[HEADER_SIZE] = {0x0a, 0x00, 0x00, 0x00, 0x00};
 801de56:	f88d 500c 	strb.w	r5, [sp, #12]
  unsigned char header_slave[HEADER_SIZE]  = {0xaa, 0x00, 0x00, 0x00, 0x00};
 801de5a:	f88d 5014 	strb.w	r5, [sp, #20]
{  
 801de5e:	f89d 4138 	ldrb.w	r4, [sp, #312]	; 0x138
  HAL_NVIC_DisableIRQ(BNRG_SPI_EXTI_IRQn);
 801de62:	f7f2 fbb1 	bl	80105c8 <HAL_NVIC_DisableIRQ>
  HAL_GPIO_WritePin(BNRG_SPI_CS_PORT, BNRG_SPI_CS_PIN, GPIO_PIN_RESET);
 801de66:	462a      	mov	r2, r5
 801de68:	2104      	movs	r1, #4
 801de6a:	481f      	ldr	r0, [pc, #124]	; (801dee8 <BlueNRG_SPI_Write+0xb0>)
 801de6c:	f7f3 fb7e 	bl	801156c <HAL_GPIO_WritePin>
  __ASM volatile ("cpsid i" : : : "memory");
 801de70:	b672      	cpsid	i
  HAL_SPI_TransmitReceive(hspi, header_master, header_slave, HEADER_SIZE, TIMEOUT_DURATION);
 801de72:	250f      	movs	r5, #15
 801de74:	a902      	add	r1, sp, #8
 801de76:	9500      	str	r5, [sp, #0]
 801de78:	aa04      	add	r2, sp, #16
 801de7a:	4638      	mov	r0, r7
 801de7c:	2305      	movs	r3, #5
 801de7e:	f7f5 fba7 	bl	80135d0 <HAL_SPI_TransmitReceive>
  __ASM volatile ("cpsie i" : : : "memory");
 801de82:	b662      	cpsie	i
  if (header_slave[0] == 0x02) {
 801de84:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801de88:	2b02      	cmp	r3, #2
 801de8a:	d127      	bne.n	801dedc <BlueNRG_SPI_Write+0xa4>
    if (header_slave[1] >= (Nb_bytes1+Nb_bytes2)) {
 801de8c:	f89d 2011 	ldrb.w	r2, [sp, #17]
 801de90:	1933      	adds	r3, r6, r4
 801de92:	429a      	cmp	r2, r3
 801de94:	db25      	blt.n	801dee2 <BlueNRG_SPI_Write+0xaa>
      if (Nb_bytes1 > 0) {
 801de96:	b9be      	cbnz	r6, 801dec8 <BlueNRG_SPI_Write+0x90>
      if (Nb_bytes2 > 0) {
 801de98:	b154      	cbz	r4, 801deb0 <BlueNRG_SPI_Write+0x78>
  __ASM volatile ("cpsid i" : : : "memory");
 801de9a:	b672      	cpsid	i
        HAL_SPI_TransmitReceive(hspi, data2, read_char_buf, Nb_bytes2, TIMEOUT_DURATION);
 801de9c:	220f      	movs	r2, #15
 801de9e:	9200      	str	r2, [sp, #0]
 801dea0:	4623      	mov	r3, r4
 801dea2:	4641      	mov	r1, r8
 801dea4:	4638      	mov	r0, r7
 801dea6:	aa06      	add	r2, sp, #24
 801dea8:	f7f5 fb92 	bl	80135d0 <HAL_SPI_TransmitReceive>
  __ASM volatile ("cpsie i" : : : "memory");
 801deac:	b662      	cpsie	i
  int32_t result = 0;
 801deae:	2400      	movs	r4, #0
  HAL_GPIO_WritePin(BNRG_SPI_CS_PORT, BNRG_SPI_CS_PIN, GPIO_PIN_SET);
 801deb0:	2201      	movs	r2, #1
 801deb2:	2104      	movs	r1, #4
 801deb4:	480c      	ldr	r0, [pc, #48]	; (801dee8 <BlueNRG_SPI_Write+0xb0>)
 801deb6:	f7f3 fb59 	bl	801156c <HAL_GPIO_WritePin>
  HAL_NVIC_EnableIRQ(BNRG_SPI_EXTI_IRQn);  
 801deba:	2017      	movs	r0, #23
 801debc:	f7f2 fb78 	bl	80105b0 <HAL_NVIC_EnableIRQ>
}
 801dec0:	4620      	mov	r0, r4
 801dec2:	b047      	add	sp, #284	; 0x11c
 801dec4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 801dec8:	b672      	cpsid	i
        HAL_SPI_TransmitReceive(hspi, data1, read_char_buf, Nb_bytes1, TIMEOUT_DURATION);
 801deca:	9500      	str	r5, [sp, #0]
 801decc:	4633      	mov	r3, r6
 801dece:	4649      	mov	r1, r9
 801ded0:	aa06      	add	r2, sp, #24
 801ded2:	4638      	mov	r0, r7
 801ded4:	f7f5 fb7c 	bl	80135d0 <HAL_SPI_TransmitReceive>
  __ASM volatile ("cpsie i" : : : "memory");
 801ded8:	b662      	cpsie	i
 801deda:	e7dd      	b.n	801de98 <BlueNRG_SPI_Write+0x60>
    result = -1;
 801dedc:	f04f 34ff 	mov.w	r4, #4294967295
 801dee0:	e7e6      	b.n	801deb0 <BlueNRG_SPI_Write+0x78>
      result = -2;
 801dee2:	f06f 0401 	mvn.w	r4, #1
 801dee6:	e7e3      	b.n	801deb0 <BlueNRG_SPI_Write+0x78>
 801dee8:	48000400 	.word	0x48000400

0801deec <Hal_Write_Serial>:
{
 801deec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801def0:	b084      	sub	sp, #16
 801def2:	4615      	mov	r5, r2
 801def4:	461c      	mov	r4, r3
 801def6:	4680      	mov	r8, r0
 801def8:	460f      	mov	r7, r1
  Timer_Set(&t, CLOCK_SECOND/10);
 801defa:	a802      	add	r0, sp, #8
 801defc:	2164      	movs	r1, #100	; 0x64
 801defe:	f7fa fe89 	bl	8018c14 <Timer_Set>
    if(BlueNRG_SPI_Write(&SpiHandle, (uint8_t *)data1,(uint8_t *)data2, n_bytes1, n_bytes2)==0) break;
 801df02:	4e0a      	ldr	r6, [pc, #40]	; (801df2c <Hal_Write_Serial+0x40>)
 801df04:	b2ed      	uxtb	r5, r5
 801df06:	b2e4      	uxtb	r4, r4
 801df08:	e003      	b.n	801df12 <Hal_Write_Serial+0x26>
    if(Timer_Expired(&t)){
 801df0a:	a802      	add	r0, sp, #8
 801df0c:	f7fa fe8a 	bl	8018c24 <Timer_Expired>
 801df10:	b940      	cbnz	r0, 801df24 <Hal_Write_Serial+0x38>
    if(BlueNRG_SPI_Write(&SpiHandle, (uint8_t *)data1,(uint8_t *)data2, n_bytes1, n_bytes2)==0) break;
 801df12:	9400      	str	r4, [sp, #0]
 801df14:	462b      	mov	r3, r5
 801df16:	463a      	mov	r2, r7
 801df18:	4641      	mov	r1, r8
 801df1a:	4630      	mov	r0, r6
 801df1c:	f7ff ff8c 	bl	801de38 <BlueNRG_SPI_Write>
 801df20:	2800      	cmp	r0, #0
 801df22:	d1f2      	bne.n	801df0a <Hal_Write_Serial+0x1e>
}
 801df24:	b004      	add	sp, #16
 801df26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801df2a:	bf00      	nop
 801df2c:	200132a8 	.word	0x200132a8

0801df30 <Enable_SPI_IRQ>:
  HAL_NVIC_EnableIRQ(BNRG_SPI_EXTI_IRQn);  
 801df30:	2017      	movs	r0, #23
 801df32:	f7f2 bb3d 	b.w	80105b0 <HAL_NVIC_EnableIRQ>
 801df36:	bf00      	nop

0801df38 <Disable_SPI_IRQ>:
  HAL_NVIC_DisableIRQ(BNRG_SPI_EXTI_IRQn);
 801df38:	2017      	movs	r0, #23
 801df3a:	f7f2 bb45 	b.w	80105c8 <HAL_NVIC_DisableIRQ>
 801df3e:	bf00      	nop

0801df40 <Clear_SPI_EXTI_Flag>:
* @param  None
* @retval None
*/
void Clear_SPI_EXTI_Flag(void)
{  
  __HAL_GPIO_EXTI_CLEAR_IT(BNRG_SPI_EXTI_PIN);  
 801df40:	4b01      	ldr	r3, [pc, #4]	; (801df48 <Clear_SPI_EXTI_Flag+0x8>)
 801df42:	2220      	movs	r2, #32
 801df44:	615a      	str	r2, [r3, #20]
}
 801df46:	4770      	bx	lr
 801df48:	40010400 	.word	0x40010400

0801df4c <BSP_HTS221_HUMIDITY_Init>:
}



static DrvStatusTypeDef BSP_HTS221_HUMIDITY_Init( void **handle )
{
 801df4c:	b570      	push	{r4, r5, r6, lr}
  HUMIDITY_Drv_t *driver = NULL;
  
  if(HUMIDITY_SensorHandle[ HTS221_H_0 ].isInitialized == 1)
 801df4e:	4c1c      	ldr	r4, [pc, #112]	; (801dfc0 <BSP_HTS221_HUMIDITY_Init+0x74>)
 801df50:	7963      	ldrb	r3, [r4, #5]
 801df52:	2b01      	cmp	r3, #1
 801df54:	d022      	beq.n	801df9c <BSP_HTS221_HUMIDITY_Init+0x50>
 801df56:	4606      	mov	r6, r0
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
  }
  
  if ( Sensor_IO_I2C_Init() == COMPONENT_ERROR )
 801df58:	f7f0 f896 	bl	800e088 <Sensor_IO_I2C_Init>
 801df5c:	2801      	cmp	r0, #1
 801df5e:	d01d      	beq.n	801df9c <BSP_HTS221_HUMIDITY_Init+0x50>
  HUMIDITY_SensorHandle[ HTS221_H_0 ].isCombo       = 1;
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pData         = ( void * )&HUMIDITY_Data[ HTS221_H_0 ];
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pVTable       = ( void * )&HTS221_H_Drv;
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pExtVTable    = 0;
  
  HTS221_H_0_Data.comboData = &HTS221_Combo_Data[0];
 801df60:	4623      	mov	r3, r4
 801df62:	4a18      	ldr	r2, [pc, #96]	; (801dfc4 <BSP_HTS221_HUMIDITY_Init+0x78>)
 801df64:	f843 2f1c 	str.w	r2, [r3, #28]!
  HUMIDITY_SensorHandle[ HTS221_H_0 ].who_am_i      = HTS221_WHO_AM_I_VAL;
 801df68:	25bc      	movs	r5, #188	; 0xbc
  HUMIDITY_Data[ HTS221_H_0 ].pComponentData = ( void * )&HTS221_H_0_Data;
 801df6a:	6163      	str	r3, [r4, #20]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pVTable       = ( void * )&HTS221_H_Drv;
 801df6c:	4b16      	ldr	r3, [pc, #88]	; (801dfc8 <BSP_HTS221_HUMIDITY_Init+0x7c>)
  HUMIDITY_SensorHandle[ HTS221_H_0 ].who_am_i      = HTS221_WHO_AM_I_VAL;
 801df6e:	8025      	strh	r5, [r4, #0]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pExtVTable    = 0;
 801df70:	2500      	movs	r5, #0
 801df72:	e9c4 3503 	strd	r3, r5, [r4, #12]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].ifType        = 0; // I2C interface
 801df76:	20be      	movs	r0, #190	; 0xbe
  HUMIDITY_SensorHandle[ HTS221_H_0 ].instance      = HTS221_H_0;
 801df78:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pData         = ( void * )&HUMIDITY_Data[ HTS221_H_0 ];
 801df7c:	f104 0214 	add.w	r2, r4, #20
  HUMIDITY_SensorHandle[ HTS221_H_0 ].ifType        = 0; // I2C interface
 801df80:	70a0      	strb	r0, [r4, #2]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pData         = ( void * )&HUMIDITY_Data[ HTS221_H_0 ];
 801df82:	e9c4 1201 	strd	r1, r2, [r4, #4]
  HUMIDITY_Data[ HTS221_H_0 ].pExtData       = 0;
 801df86:	61a5      	str	r5, [r4, #24]
  
  *handle = (void *)&HUMIDITY_SensorHandle[ HTS221_H_0 ];
 801df88:	6034      	str	r4, [r6, #0]
  
  driver = ( HUMIDITY_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;
  
  if ( driver->Init == NULL )
 801df8a:	68e3      	ldr	r3, [r4, #12]
 801df8c:	681b      	ldr	r3, [r3, #0]
 801df8e:	b17b      	cbz	r3, 801dfb0 <BSP_HTS221_HUMIDITY_Init+0x64>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }
  
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 801df90:	4620      	mov	r0, r4
 801df92:	4798      	blx	r3
 801df94:	2801      	cmp	r0, #1
 801df96:	d003      	beq.n	801dfa0 <BSP_HTS221_HUMIDITY_Init+0x54>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
 801df98:	4628      	mov	r0, r5
}
 801df9a:	bd70      	pop	{r4, r5, r6, pc}
    return COMPONENT_ERROR;
 801df9c:	2001      	movs	r0, #1
}
 801df9e:	bd70      	pop	{r4, r5, r6, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 801dfa0:	6833      	ldr	r3, [r6, #0]
 801dfa2:	601d      	str	r5, [r3, #0]
 801dfa4:	605d      	str	r5, [r3, #4]
 801dfa6:	609d      	str	r5, [r3, #8]
 801dfa8:	60dd      	str	r5, [r3, #12]
 801dfaa:	611d      	str	r5, [r3, #16]
    *handle = NULL;
 801dfac:	6035      	str	r5, [r6, #0]
}
 801dfae:	bd70      	pop	{r4, r5, r6, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 801dfb0:	e9c4 3300 	strd	r3, r3, [r4]
 801dfb4:	e9c4 3302 	strd	r3, r3, [r4, #8]
 801dfb8:	6123      	str	r3, [r4, #16]
    return COMPONENT_ERROR;
 801dfba:	2001      	movs	r0, #1
    *handle = NULL;
 801dfbc:	6033      	str	r3, [r6, #0]
}
 801dfbe:	bd70      	pop	{r4, r5, r6, pc}
 801dfc0:	2001008c 	.word	0x2001008c
 801dfc4:	200103d8 	.word	0x200103d8
 801dfc8:	20000034 	.word	0x20000034

0801dfcc <BSP_HUMIDITY_Init>:
{
 801dfcc:	b508      	push	{r3, lr}
  *handle = NULL;
 801dfce:	2300      	movs	r3, #0
 801dfd0:	600b      	str	r3, [r1, #0]
      if( BSP_HTS221_HUMIDITY_Init(handle)  == COMPONENT_ERROR )
 801dfd2:	4608      	mov	r0, r1
 801dfd4:	f7ff ffba 	bl	801df4c <BSP_HTS221_HUMIDITY_Init>
}
 801dfd8:	f1a0 0001 	sub.w	r0, r0, #1
 801dfdc:	fab0 f080 	clz	r0, r0
 801dfe0:	0940      	lsrs	r0, r0, #5
 801dfe2:	bd08      	pop	{r3, pc}

0801dfe4 <BSP_HUMIDITY_Sensor_Enable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  HUMIDITY_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 801dfe4:	b150      	cbz	r0, 801dffc <BSP_HUMIDITY_Sensor_Enable+0x18>
{
 801dfe6:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( HUMIDITY_Drv_t * )ctx->pVTable;
  
  if ( driver->Sensor_Enable == NULL )
 801dfe8:	68c3      	ldr	r3, [r0, #12]
 801dfea:	689b      	ldr	r3, [r3, #8]
 801dfec:	b143      	cbz	r3, 801e000 <BSP_HUMIDITY_Sensor_Enable+0x1c>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 801dfee:	4798      	blx	r3
    return COMPONENT_ERROR;
 801dff0:	f1a0 0001 	sub.w	r0, r0, #1
 801dff4:	fab0 f080 	clz	r0, r0
 801dff8:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 801dffa:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 801dffc:	2001      	movs	r0, #1
}
 801dffe:	4770      	bx	lr
    return COMPONENT_ERROR;
 801e000:	2001      	movs	r0, #1
}
 801e002:	bd08      	pop	{r3, pc}

0801e004 <BSP_HUMIDITY_Sensor_Disable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  HUMIDITY_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 801e004:	b150      	cbz	r0, 801e01c <BSP_HUMIDITY_Sensor_Disable+0x18>
{
 801e006:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( HUMIDITY_Drv_t * )ctx->pVTable;
  
  if ( driver->Sensor_Disable == NULL )
 801e008:	68c3      	ldr	r3, [r0, #12]
 801e00a:	68db      	ldr	r3, [r3, #12]
 801e00c:	b143      	cbz	r3, 801e020 <BSP_HUMIDITY_Sensor_Disable+0x1c>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Sensor_Disable( ctx ) == COMPONENT_ERROR )
 801e00e:	4798      	blx	r3
    return COMPONENT_ERROR;
 801e010:	f1a0 0001 	sub.w	r0, r0, #1
 801e014:	fab0 f080 	clz	r0, r0
 801e018:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 801e01a:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 801e01c:	2001      	movs	r0, #1
}
 801e01e:	4770      	bx	lr
    return COMPONENT_ERROR;
 801e020:	2001      	movs	r0, #1
}
 801e022:	bd08      	pop	{r3, pc}

0801e024 <BSP_HUMIDITY_IsInitialized>:
 */
DrvStatusTypeDef BSP_HUMIDITY_IsInitialized( void *handle, uint8_t *status )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 801e024:	b120      	cbz	r0, 801e030 <BSP_HUMIDITY_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  if ( status == NULL )
 801e026:	b119      	cbz	r1, 801e030 <BSP_HUMIDITY_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  *status = ctx->isInitialized;
 801e028:	7943      	ldrb	r3, [r0, #5]
 801e02a:	700b      	strb	r3, [r1, #0]
  
  return COMPONENT_OK;
 801e02c:	2000      	movs	r0, #0
 801e02e:	4770      	bx	lr
    return COMPONENT_ERROR;
 801e030:	2001      	movs	r0, #1
}
 801e032:	4770      	bx	lr

0801e034 <BSP_HUMIDITY_Get_Hum>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  HUMIDITY_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 801e034:	b158      	cbz	r0, 801e04e <BSP_HUMIDITY_Get_Hum+0x1a>
{
 801e036:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( HUMIDITY_Drv_t * )ctx->pVTable;
  
  if ( humidity == NULL )
 801e038:	b159      	cbz	r1, 801e052 <BSP_HUMIDITY_Get_Hum+0x1e>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Hum == NULL )
 801e03a:	68c3      	ldr	r3, [r0, #12]
 801e03c:	699b      	ldr	r3, [r3, #24]
 801e03e:	b143      	cbz	r3, 801e052 <BSP_HUMIDITY_Get_Hum+0x1e>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Hum( ctx, humidity ) == COMPONENT_ERROR )
 801e040:	4798      	blx	r3
    return COMPONENT_ERROR;
 801e042:	f1a0 0001 	sub.w	r0, r0, #1
 801e046:	fab0 f080 	clz	r0, r0
 801e04a:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 801e04c:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 801e04e:	2001      	movs	r0, #1
}
 801e050:	4770      	bx	lr
    return COMPONENT_ERROR;
 801e052:	2001      	movs	r0, #1
}
 801e054:	bd08      	pop	{r3, pc}
 801e056:	bf00      	nop

0801e058 <BSP_HUMIDITY_Set_One_Shot>:
DrvStatusTypeDef BSP_HUMIDITY_Set_One_Shot( void *handle )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 801e058:	b188      	cbz	r0, 801e07e <BSP_HUMIDITY_Set_One_Shot+0x26>
{
 801e05a:	b510      	push	{r4, lr}
  switch(ctx->who_am_i)
  {
    case HTS221_WHO_AM_I_VAL:
	default:
	{ 
      if ( HTS221_Set_Odr(handle, HTS221_ODR_ONE_SHOT)==HTS221_ERROR )
 801e05c:	2100      	movs	r1, #0
 801e05e:	4604      	mov	r4, r0
 801e060:	f7ea f882 	bl	8008168 <HTS221_Set_Odr>
 801e064:	2801      	cmp	r0, #1
 801e066:	d008      	beq.n	801e07a <BSP_HUMIDITY_Set_One_Shot+0x22>
      {
        return COMPONENT_ERROR;
      }

      if ( HTS221_StartOneShotMeasurement(handle)==HTS221_ERROR )
 801e068:	4620      	mov	r0, r4
 801e06a:	f7ea f827 	bl	80080bc <HTS221_StartOneShotMeasurement>
    return COMPONENT_ERROR;
 801e06e:	f1a0 0001 	sub.w	r0, r0, #1
 801e072:	fab0 f080 	clz	r0, r0
 801e076:	0940      	lsrs	r0, r0, #5
      break;
    }
  }
  
  return COMPONENT_OK;
}
 801e078:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 801e07a:	2001      	movs	r0, #1
}
 801e07c:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 801e07e:	2001      	movs	r0, #1
}
 801e080:	4770      	bx	lr
 801e082:	bf00      	nop

0801e084 <BSP_LPS22HB_PRESSURE_Init>:
  
  return COMPONENT_OK;
}

static DrvStatusTypeDef BSP_LPS22HB_PRESSURE_Init( void **handle )
{
 801e084:	b5f0      	push	{r4, r5, r6, r7, lr}
  PRESSURE_Drv_t *driver = NULL;
  uint8_t data = 0x01;
  
  if(PRESSURE_SensorHandle[ LPS22HB_P_0 ].isInitialized == 1)
 801e086:	4c34      	ldr	r4, [pc, #208]	; (801e158 <BSP_LPS22HB_PRESSURE_Init+0xd4>)
 801e088:	7963      	ldrb	r3, [r4, #5]
  uint8_t data = 0x01;
 801e08a:	2501      	movs	r5, #1
{
 801e08c:	b083      	sub	sp, #12
  if(PRESSURE_SensorHandle[ LPS22HB_P_0 ].isInitialized == 1)
 801e08e:	42ab      	cmp	r3, r5
  uint8_t data = 0x01;
 801e090:	f88d 5007 	strb.w	r5, [sp, #7]
  if(PRESSURE_SensorHandle[ LPS22HB_P_0 ].isInitialized == 1)
 801e094:	d037      	beq.n	801e106 <BSP_LPS22HB_PRESSURE_Init+0x82>
 801e096:	4606      	mov	r6, r0
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
  }
  
  if ( Sensor_IO_SPI_Init() == COMPONENT_ERROR )
 801e098:	f7ef fffe 	bl	800e098 <Sensor_IO_SPI_Init>
 801e09c:	2801      	cmp	r0, #1
 801e09e:	d032      	beq.n	801e106 <BSP_LPS22HB_PRESSURE_Init+0x82>
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].isCombo       = 1;
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pData         = ( void * )&PRESSURE_Data[ LPS22HB_P_0 ];
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pVTable       = ( void * )&LPS22HB_P_Drv;
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pExtVTable    = 0;
      
  LPS22HB_P_0_Data.comboData = &LPS22HB_Combo_Data[0];
 801e0a0:	4623      	mov	r3, r4
 801e0a2:	4f2e      	ldr	r7, [pc, #184]	; (801e15c <BSP_LPS22HB_PRESSURE_Init+0xd8>)
 801e0a4:	f843 7f1c 	str.w	r7, [r3, #28]!
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].spiDevice     = LPS22HB;
 801e0a8:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  PRESSURE_Data[ LPS22HB_P_0 ].pComponentData = ( void * )&LPS22HB_P_0_Data;
 801e0ac:	6163      	str	r3, [r4, #20]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].spiDevice     = LPS22HB;
 801e0ae:	6062      	str	r2, [r4, #4]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pData         = ( void * )&PRESSURE_Data[ LPS22HB_P_0 ];
 801e0b0:	f104 0314 	add.w	r3, r4, #20
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pVTable       = ( void * )&LPS22HB_P_Drv;
 801e0b4:	4a2a      	ldr	r2, [pc, #168]	; (801e160 <BSP_LPS22HB_PRESSURE_Init+0xdc>)
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pData         = ( void * )&PRESSURE_Data[ LPS22HB_P_0 ];
 801e0b6:	60a3      	str	r3, [r4, #8]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].who_am_i      = LPS22HB_WHO_AM_I_VAL;
 801e0b8:	492a      	ldr	r1, [pc, #168]	; (801e164 <BSP_LPS22HB_PRESSURE_Init+0xe0>)
 801e0ba:	6021      	str	r1, [r4, #0]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pExtVTable    = 0;
 801e0bc:	2300      	movs	r3, #0
 801e0be:	e9c4 2303 	strd	r2, r3, [r4, #12]
  PRESSURE_Data[ LPS22HB_P_0 ].pExtData       = 0;
 801e0c2:	61a3      	str	r3, [r4, #24]
      
  *handle = (void *)&PRESSURE_SensorHandle[ LPS22HB_P_0 ];
  
  Sensor_IO_SPI_CS_Init(*handle);
 801e0c4:	4620      	mov	r0, r4
  *handle = (void *)&PRESSURE_SensorHandle[ LPS22HB_P_0 ];
 801e0c6:	6034      	str	r4, [r6, #0]
  Sensor_IO_SPI_CS_Init(*handle);
 801e0c8:	f7f0 f8d4 	bl	800e274 <Sensor_IO_SPI_CS_Init>
  
  if(LPS22HB_Combo_Data[0].isTempInitialized == 0)
 801e0cc:	787b      	ldrb	r3, [r7, #1]
 801e0ce:	b193      	cbz	r3, 801e0f6 <BSP_LPS22HB_PRESSURE_Init+0x72>
    {
      return COMPONENT_ERROR;
    }
  }
  
  driver = ( PRESSURE_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;
 801e0d0:	6830      	ldr	r0, [r6, #0]
  
  if ( driver->Init == NULL )
 801e0d2:	68c3      	ldr	r3, [r0, #12]
 801e0d4:	681b      	ldr	r3, [r3, #0]
 801e0d6:	2b00      	cmp	r3, #0
 801e0d8:	d036      	beq.n	801e148 <BSP_LPS22HB_PRESSURE_Init+0xc4>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }
  
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 801e0da:	4798      	blx	r3
 801e0dc:	2801      	cmp	r0, #1
 801e0de:	d015      	beq.n	801e10c <BSP_LPS22HB_PRESSURE_Init+0x88>
    *handle = NULL;
    return COMPONENT_ERROR;
  }
  
  /* Disable I2C interface */
  if ( LPS22HB_Set_I2C( *handle, LPS22HB_DISABLE ) == LPS22HB_ERROR )
 801e0e0:	6830      	ldr	r0, [r6, #0]
 801e0e2:	2100      	movs	r1, #0
 801e0e4:	f7ea fbc6 	bl	8008874 <LPS22HB_Set_I2C>
    return COMPONENT_ERROR;
 801e0e8:	f1a0 0001 	sub.w	r0, r0, #1
 801e0ec:	fab0 f080 	clz	r0, r0
 801e0f0:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 801e0f2:	b003      	add	sp, #12
 801e0f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( Sensor_IO_Write(*handle, LPS22HB_CTRL_REG1, &data, 1) )
 801e0f6:	f10d 0207 	add.w	r2, sp, #7
 801e0fa:	462b      	mov	r3, r5
 801e0fc:	2110      	movs	r1, #16
 801e0fe:	6830      	ldr	r0, [r6, #0]
 801e100:	f7f0 f9b0 	bl	800e464 <Sensor_IO_Write>
 801e104:	b158      	cbz	r0, 801e11e <BSP_LPS22HB_PRESSURE_Init+0x9a>
    return COMPONENT_ERROR;
 801e106:	2001      	movs	r0, #1
}
 801e108:	b003      	add	sp, #12
 801e10a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 801e10c:	6832      	ldr	r2, [r6, #0]
 801e10e:	2300      	movs	r3, #0
 801e110:	6013      	str	r3, [r2, #0]
 801e112:	6053      	str	r3, [r2, #4]
 801e114:	6093      	str	r3, [r2, #8]
 801e116:	60d3      	str	r3, [r2, #12]
 801e118:	6113      	str	r3, [r2, #16]
    *handle = NULL;
 801e11a:	6033      	str	r3, [r6, #0]
    return COMPONENT_ERROR;
 801e11c:	e7f4      	b.n	801e108 <BSP_LPS22HB_PRESSURE_Init+0x84>
    if(LPS22HB_SwResetAndMemoryBoot(*handle))
 801e11e:	6830      	ldr	r0, [r6, #0]
 801e120:	f7ea fb22 	bl	8008768 <LPS22HB_SwResetAndMemoryBoot>
 801e124:	2800      	cmp	r0, #0
 801e126:	d1ee      	bne.n	801e106 <BSP_LPS22HB_PRESSURE_Init+0x82>
    HAL_Delay(1000);
 801e128:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 801e12c:	f7fc ffec 	bl	801b108 <HAL_Delay>
    if( Sensor_IO_Write(*handle, LPS22HB_CTRL_REG1, &data, 1) )
 801e130:	f10d 0207 	add.w	r2, sp, #7
 801e134:	462b      	mov	r3, r5
 801e136:	2110      	movs	r1, #16
 801e138:	6830      	ldr	r0, [r6, #0]
    data = 0x01;
 801e13a:	f88d 5007 	strb.w	r5, [sp, #7]
    if( Sensor_IO_Write(*handle, LPS22HB_CTRL_REG1, &data, 1) )
 801e13e:	f7f0 f991 	bl	800e464 <Sensor_IO_Write>
 801e142:	2800      	cmp	r0, #0
 801e144:	d0c4      	beq.n	801e0d0 <BSP_LPS22HB_PRESSURE_Init+0x4c>
 801e146:	e7de      	b.n	801e106 <BSP_LPS22HB_PRESSURE_Init+0x82>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 801e148:	6003      	str	r3, [r0, #0]
 801e14a:	6043      	str	r3, [r0, #4]
 801e14c:	6083      	str	r3, [r0, #8]
 801e14e:	60c3      	str	r3, [r0, #12]
 801e150:	6103      	str	r3, [r0, #16]
    return COMPONENT_ERROR;
 801e152:	2001      	movs	r0, #1
    *handle = NULL;
 801e154:	6033      	str	r3, [r6, #0]
    return COMPONENT_ERROR;
 801e156:	e7d7      	b.n	801e108 <BSP_LPS22HB_PRESSURE_Init+0x84>
 801e158:	200100ac 	.word	0x200100ac
 801e15c:	200103dc 	.word	0x200103dc
 801e160:	20000114 	.word	0x20000114
 801e164:	03ba01b1 	.word	0x03ba01b1

0801e168 <BSP_PRESSURE_Init>:
{
 801e168:	b508      	push	{r3, lr}
  *handle = NULL;
 801e16a:	2300      	movs	r3, #0
 801e16c:	600b      	str	r3, [r1, #0]
      if( BSP_LPS22HB_PRESSURE_Init(handle) == COMPONENT_ERROR )
 801e16e:	4608      	mov	r0, r1
 801e170:	f7ff ff88 	bl	801e084 <BSP_LPS22HB_PRESSURE_Init>
}
 801e174:	f1a0 0001 	sub.w	r0, r0, #1
 801e178:	fab0 f080 	clz	r0, r0
 801e17c:	0940      	lsrs	r0, r0, #5
 801e17e:	bd08      	pop	{r3, pc}

0801e180 <BSP_PRESSURE_Sensor_Enable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  PRESSURE_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 801e180:	b150      	cbz	r0, 801e198 <BSP_PRESSURE_Sensor_Enable+0x18>
{
 801e182:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( PRESSURE_Drv_t * )ctx->pVTable;
  
  if ( driver->Sensor_Enable == NULL )
 801e184:	68c3      	ldr	r3, [r0, #12]
 801e186:	689b      	ldr	r3, [r3, #8]
 801e188:	b143      	cbz	r3, 801e19c <BSP_PRESSURE_Sensor_Enable+0x1c>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 801e18a:	4798      	blx	r3
    return COMPONENT_ERROR;
 801e18c:	f1a0 0001 	sub.w	r0, r0, #1
 801e190:	fab0 f080 	clz	r0, r0
 801e194:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 801e196:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 801e198:	2001      	movs	r0, #1
}
 801e19a:	4770      	bx	lr
    return COMPONENT_ERROR;
 801e19c:	2001      	movs	r0, #1
}
 801e19e:	bd08      	pop	{r3, pc}

0801e1a0 <BSP_PRESSURE_Sensor_Disable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  PRESSURE_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 801e1a0:	b150      	cbz	r0, 801e1b8 <BSP_PRESSURE_Sensor_Disable+0x18>
{
 801e1a2:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( PRESSURE_Drv_t * )ctx->pVTable;
  
  if ( driver->Sensor_Disable == NULL )
 801e1a4:	68c3      	ldr	r3, [r0, #12]
 801e1a6:	68db      	ldr	r3, [r3, #12]
 801e1a8:	b143      	cbz	r3, 801e1bc <BSP_PRESSURE_Sensor_Disable+0x1c>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Sensor_Disable( ctx ) == COMPONENT_ERROR )
 801e1aa:	4798      	blx	r3
    return COMPONENT_ERROR;
 801e1ac:	f1a0 0001 	sub.w	r0, r0, #1
 801e1b0:	fab0 f080 	clz	r0, r0
 801e1b4:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 801e1b6:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 801e1b8:	2001      	movs	r0, #1
}
 801e1ba:	4770      	bx	lr
    return COMPONENT_ERROR;
 801e1bc:	2001      	movs	r0, #1
}
 801e1be:	bd08      	pop	{r3, pc}

0801e1c0 <BSP_PRESSURE_IsInitialized>:
 */
DrvStatusTypeDef BSP_PRESSURE_IsInitialized( void *handle, uint8_t *status )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 801e1c0:	b120      	cbz	r0, 801e1cc <BSP_PRESSURE_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  if ( status == NULL )
 801e1c2:	b119      	cbz	r1, 801e1cc <BSP_PRESSURE_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  *status = ctx->isInitialized;
 801e1c4:	7943      	ldrb	r3, [r0, #5]
 801e1c6:	700b      	strb	r3, [r1, #0]
  
  return COMPONENT_OK;
 801e1c8:	2000      	movs	r0, #0
 801e1ca:	4770      	bx	lr
    return COMPONENT_ERROR;
 801e1cc:	2001      	movs	r0, #1
}
 801e1ce:	4770      	bx	lr

0801e1d0 <BSP_PRESSURE_Get_Press>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  PRESSURE_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 801e1d0:	b158      	cbz	r0, 801e1ea <BSP_PRESSURE_Get_Press+0x1a>
{
 801e1d2:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( PRESSURE_Drv_t * )ctx->pVTable;
  
  if ( pressure == NULL )
 801e1d4:	b159      	cbz	r1, 801e1ee <BSP_PRESSURE_Get_Press+0x1e>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Press == NULL )
 801e1d6:	68c3      	ldr	r3, [r0, #12]
 801e1d8:	699b      	ldr	r3, [r3, #24]
 801e1da:	b143      	cbz	r3, 801e1ee <BSP_PRESSURE_Get_Press+0x1e>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Press( ctx, pressure ) == COMPONENT_ERROR )
 801e1dc:	4798      	blx	r3
    return COMPONENT_ERROR;
 801e1de:	f1a0 0001 	sub.w	r0, r0, #1
 801e1e2:	fab0 f080 	clz	r0, r0
 801e1e6:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 801e1e8:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 801e1ea:	2001      	movs	r0, #1
}
 801e1ec:	4770      	bx	lr
    return COMPONENT_ERROR;
 801e1ee:	2001      	movs	r0, #1
}
 801e1f0:	bd08      	pop	{r3, pc}
 801e1f2:	bf00      	nop

0801e1f4 <BSP_PRESSURE_Set_One_Shot>:
DrvStatusTypeDef BSP_PRESSURE_Set_One_Shot( void *handle )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 801e1f4:	b188      	cbz	r0, 801e21a <BSP_PRESSURE_Set_One_Shot+0x26>
{
 801e1f6:	b510      	push	{r4, lr}
  switch(ctx->who_am_i)
  {
    case LPS22HB_WHO_AM_I_VAL:
	default:
	{
      if ( LPS22HB_Set_Odr(handle, LPS22HB_ODR_ONE_SHOT)==LPS22HB_ERROR )
 801e1f8:	2100      	movs	r1, #0
 801e1fa:	4604      	mov	r4, r0
 801e1fc:	f7ea fa1a 	bl	8008634 <LPS22HB_Set_Odr>
 801e200:	2801      	cmp	r0, #1
 801e202:	d008      	beq.n	801e216 <BSP_PRESSURE_Set_One_Shot+0x22>
      {
        return COMPONENT_ERROR;
      }

      if ( LPS22HB_StartOneShotMeasurement(handle)==LPS22HB_ERROR )
 801e204:	4620      	mov	r0, r4
 801e206:	f7ea fb59 	bl	80088bc <LPS22HB_StartOneShotMeasurement>
    return COMPONENT_ERROR;
 801e20a:	f1a0 0001 	sub.w	r0, r0, #1
 801e20e:	fab0 f080 	clz	r0, r0
 801e212:	0940      	lsrs	r0, r0, #5
      break;
    }
  }
  
  return COMPONENT_OK;
}
 801e214:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 801e216:	2001      	movs	r0, #1
}
 801e218:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 801e21a:	2001      	movs	r0, #1
}
 801e21c:	4770      	bx	lr
 801e21e:	bf00      	nop

0801e220 <BSP_LPS22HB_TEMPERATURE_Init>:
}



static DrvStatusTypeDef BSP_LPS22HB_TEMPERATURE_Init( void **handle )
{
 801e220:	b5f0      	push	{r4, r5, r6, r7, lr}
  TEMPERATURE_Drv_t *driver = NULL;
  uint8_t data = 0x01;
  
  if(TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].isInitialized == 1)
 801e222:	4c2f      	ldr	r4, [pc, #188]	; (801e2e0 <BSP_LPS22HB_TEMPERATURE_Init+0xc0>)
 801e224:	7963      	ldrb	r3, [r4, #5]
  uint8_t data = 0x01;
 801e226:	2501      	movs	r5, #1
{
 801e228:	b083      	sub	sp, #12
  if(TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].isInitialized == 1)
 801e22a:	42ab      	cmp	r3, r5
  uint8_t data = 0x01;
 801e22c:	f88d 5007 	strb.w	r5, [sp, #7]
  if(TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].isInitialized == 1)
 801e230:	d02e      	beq.n	801e290 <BSP_LPS22HB_TEMPERATURE_Init+0x70>
 801e232:	4606      	mov	r6, r0
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
  }
  
  if ( Sensor_IO_SPI_Init() == COMPONENT_ERROR )
 801e234:	f7ef ff30 	bl	800e098 <Sensor_IO_SPI_Init>
 801e238:	2801      	cmp	r0, #1
 801e23a:	d029      	beq.n	801e290 <BSP_LPS22HB_TEMPERATURE_Init+0x70>
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].isCombo       = 1;
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ LPS22HB_T_0 ];
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pVTable       = ( void * )&LPS22HB_T_Drv;
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pExtVTable    = 0;
      
  LPS22HB_T_0_Data.comboData = &LPS22HB_Combo_Data[0];
 801e23c:	4623      	mov	r3, r4
 801e23e:	4f29      	ldr	r7, [pc, #164]	; (801e2e4 <BSP_LPS22HB_TEMPERATURE_Init+0xc4>)
 801e240:	f843 7f38 	str.w	r7, [r3, #56]!
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].spiDevice     = LPS22HB;
 801e244:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  TEMPERATURE_Data[ LPS22HB_T_0 ].pComponentData = ( void * )&LPS22HB_T_0_Data;
 801e248:	62a3      	str	r3, [r4, #40]	; 0x28
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].spiDevice     = LPS22HB;
 801e24a:	6062      	str	r2, [r4, #4]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ LPS22HB_T_0 ];
 801e24c:	f104 0328 	add.w	r3, r4, #40	; 0x28
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pVTable       = ( void * )&LPS22HB_T_Drv;
 801e250:	4a25      	ldr	r2, [pc, #148]	; (801e2e8 <BSP_LPS22HB_TEMPERATURE_Init+0xc8>)
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ LPS22HB_T_0 ];
 801e252:	60a3      	str	r3, [r4, #8]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].who_am_i      = LPS22HB_WHO_AM_I_VAL;
 801e254:	4925      	ldr	r1, [pc, #148]	; (801e2ec <BSP_LPS22HB_TEMPERATURE_Init+0xcc>)
 801e256:	6021      	str	r1, [r4, #0]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pExtVTable    = 0;
 801e258:	2300      	movs	r3, #0
 801e25a:	e9c4 2303 	strd	r2, r3, [r4, #12]
  TEMPERATURE_Data[ LPS22HB_T_0 ].pExtData       = 0;
 801e25e:	62e3      	str	r3, [r4, #44]	; 0x2c
      
  *handle = (void *)&TEMPERATURE_SensorHandle[ LPS22HB_T_0 ];
  
  Sensor_IO_SPI_CS_Init(*handle);
 801e260:	4620      	mov	r0, r4
  *handle = (void *)&TEMPERATURE_SensorHandle[ LPS22HB_T_0 ];
 801e262:	6034      	str	r4, [r6, #0]
  Sensor_IO_SPI_CS_Init(*handle);
 801e264:	f7f0 f806 	bl	800e274 <Sensor_IO_SPI_CS_Init>
  
  if(LPS22HB_Combo_Data[0].isPressInitialized == 0)
 801e268:	783b      	ldrb	r3, [r7, #0]
 801e26a:	b14b      	cbz	r3, 801e280 <BSP_LPS22HB_TEMPERATURE_Init+0x60>
    {
      return COMPONENT_ERROR;
    }
  }
  
  driver = ( TEMPERATURE_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;
 801e26c:	6830      	ldr	r0, [r6, #0]
  
  if ( driver->Init == NULL )
 801e26e:	68c3      	ldr	r3, [r0, #12]
 801e270:	681b      	ldr	r3, [r3, #0]
 801e272:	b36b      	cbz	r3, 801e2d0 <BSP_LPS22HB_TEMPERATURE_Init+0xb0>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }
  
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 801e274:	4798      	blx	r3
 801e276:	2801      	cmp	r0, #1
 801e278:	d021      	beq.n	801e2be <BSP_LPS22HB_TEMPERATURE_Init+0x9e>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
 801e27a:	2000      	movs	r0, #0
  
}
 801e27c:	b003      	add	sp, #12
 801e27e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( Sensor_IO_Write(*handle, LPS22HB_CTRL_REG1, &data, 1) )
 801e280:	f10d 0207 	add.w	r2, sp, #7
 801e284:	462b      	mov	r3, r5
 801e286:	2110      	movs	r1, #16
 801e288:	6830      	ldr	r0, [r6, #0]
 801e28a:	f7f0 f8eb 	bl	800e464 <Sensor_IO_Write>
 801e28e:	b110      	cbz	r0, 801e296 <BSP_LPS22HB_TEMPERATURE_Init+0x76>
    return COMPONENT_ERROR;
 801e290:	2001      	movs	r0, #1
}
 801e292:	b003      	add	sp, #12
 801e294:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(LPS22HB_SwResetAndMemoryBoot(*handle))
 801e296:	6830      	ldr	r0, [r6, #0]
 801e298:	f7ea fa66 	bl	8008768 <LPS22HB_SwResetAndMemoryBoot>
 801e29c:	2800      	cmp	r0, #0
 801e29e:	d1f7      	bne.n	801e290 <BSP_LPS22HB_TEMPERATURE_Init+0x70>
    HAL_Delay(100);
 801e2a0:	2064      	movs	r0, #100	; 0x64
 801e2a2:	f7fc ff31 	bl	801b108 <HAL_Delay>
    if( Sensor_IO_Write(*handle, LPS22HB_CTRL_REG1, &data, 1) )
 801e2a6:	f10d 0207 	add.w	r2, sp, #7
 801e2aa:	462b      	mov	r3, r5
 801e2ac:	2110      	movs	r1, #16
 801e2ae:	6830      	ldr	r0, [r6, #0]
    data = 0x01;
 801e2b0:	f88d 5007 	strb.w	r5, [sp, #7]
    if( Sensor_IO_Write(*handle, LPS22HB_CTRL_REG1, &data, 1) )
 801e2b4:	f7f0 f8d6 	bl	800e464 <Sensor_IO_Write>
 801e2b8:	2800      	cmp	r0, #0
 801e2ba:	d0d7      	beq.n	801e26c <BSP_LPS22HB_TEMPERATURE_Init+0x4c>
 801e2bc:	e7e8      	b.n	801e290 <BSP_LPS22HB_TEMPERATURE_Init+0x70>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 801e2be:	6832      	ldr	r2, [r6, #0]
 801e2c0:	2300      	movs	r3, #0
 801e2c2:	6013      	str	r3, [r2, #0]
 801e2c4:	6053      	str	r3, [r2, #4]
 801e2c6:	6093      	str	r3, [r2, #8]
 801e2c8:	60d3      	str	r3, [r2, #12]
 801e2ca:	6113      	str	r3, [r2, #16]
    *handle = NULL;
 801e2cc:	6033      	str	r3, [r6, #0]
    return COMPONENT_ERROR;
 801e2ce:	e7e0      	b.n	801e292 <BSP_LPS22HB_TEMPERATURE_Init+0x72>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 801e2d0:	6003      	str	r3, [r0, #0]
 801e2d2:	6043      	str	r3, [r0, #4]
 801e2d4:	6083      	str	r3, [r0, #8]
 801e2d6:	60c3      	str	r3, [r0, #12]
 801e2d8:	6103      	str	r3, [r0, #16]
    return COMPONENT_ERROR;
 801e2da:	2001      	movs	r0, #1
    *handle = NULL;
 801e2dc:	6033      	str	r3, [r6, #0]
    return COMPONENT_ERROR;
 801e2de:	e7d8      	b.n	801e292 <BSP_LPS22HB_TEMPERATURE_Init+0x72>
 801e2e0:	200100cc 	.word	0x200100cc
 801e2e4:	200103dc 	.word	0x200103dc
 801e2e8:	200000e0 	.word	0x200000e0
 801e2ec:	03ba01b1 	.word	0x03ba01b1

0801e2f0 <BSP_HTS221_TEMPERATURE_Init>:



static DrvStatusTypeDef BSP_HTS221_TEMPERATURE_Init( void **handle )
{
 801e2f0:	b570      	push	{r4, r5, r6, lr}
  TEMPERATURE_Drv_t *driver = NULL;
  
  if(TEMPERATURE_SensorHandle[ HTS221_T_0 ].isInitialized == 1)
 801e2f2:	4c1c      	ldr	r4, [pc, #112]	; (801e364 <BSP_HTS221_TEMPERATURE_Init+0x74>)
 801e2f4:	7e63      	ldrb	r3, [r4, #25]
 801e2f6:	2b01      	cmp	r3, #1
 801e2f8:	d022      	beq.n	801e340 <BSP_HTS221_TEMPERATURE_Init+0x50>
 801e2fa:	4606      	mov	r6, r0
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
  }
  
  if ( Sensor_IO_I2C_Init() == COMPONENT_ERROR )
 801e2fc:	f7ef fec4 	bl	800e088 <Sensor_IO_I2C_Init>
 801e300:	2801      	cmp	r0, #1
 801e302:	d01d      	beq.n	801e340 <BSP_HTS221_TEMPERATURE_Init+0x50>
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].isCombo       = 1;
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ HTS221_T_0 ];
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pVTable       = ( void * )&HTS221_T_Drv;
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pExtVTable    = 0;
  
  HTS221_T_0_Data.comboData = &HTS221_Combo_Data[0];
 801e304:	4623      	mov	r3, r4
 801e306:	4a18      	ldr	r2, [pc, #96]	; (801e368 <BSP_HTS221_TEMPERATURE_Init+0x78>)
 801e308:	f843 2f3c 	str.w	r2, [r3, #60]!
  TEMPERATURE_Data[ HTS221_T_0 ].pComponentData = ( void * )&HTS221_T_0_Data;
 801e30c:	6323      	str	r3, [r4, #48]	; 0x30
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pVTable       = ( void * )&HTS221_T_Drv;
 801e30e:	4b17      	ldr	r3, [pc, #92]	; (801e36c <BSP_HTS221_TEMPERATURE_Init+0x7c>)
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].instance      = HTS221_T_0;
 801e310:	4917      	ldr	r1, [pc, #92]	; (801e370 <BSP_HTS221_TEMPERATURE_Init+0x80>)
 801e312:	61a1      	str	r1, [r4, #24]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ HTS221_T_0 ];
 801e314:	f104 0230 	add.w	r2, r4, #48	; 0x30
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].who_am_i      = HTS221_WHO_AM_I_VAL;
 801e318:	25bc      	movs	r5, #188	; 0xbc
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].ifType        = 0; // I2C interface
 801e31a:	20be      	movs	r0, #190	; 0xbe
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pVTable       = ( void * )&HTS221_T_Drv;
 801e31c:	e9c4 2307 	strd	r2, r3, [r4, #28]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].who_am_i      = HTS221_WHO_AM_I_VAL;
 801e320:	82a5      	strh	r5, [r4, #20]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].ifType        = 0; // I2C interface
 801e322:	75a0      	strb	r0, [r4, #22]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pExtVTable    = 0;
 801e324:	2500      	movs	r5, #0
  TEMPERATURE_Data[ HTS221_T_0 ].pExtData       = 0;
  
  *handle = (void *)&TEMPERATURE_SensorHandle[ HTS221_T_0 ];
 801e326:	f104 0014 	add.w	r0, r4, #20
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pExtVTable    = 0;
 801e32a:	6265      	str	r5, [r4, #36]	; 0x24
  TEMPERATURE_Data[ HTS221_T_0 ].pExtData       = 0;
 801e32c:	6365      	str	r5, [r4, #52]	; 0x34
  *handle = (void *)&TEMPERATURE_SensorHandle[ HTS221_T_0 ];
 801e32e:	6030      	str	r0, [r6, #0]
  
  driver = ( TEMPERATURE_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;
  
  if ( driver->Init == NULL )
 801e330:	6a23      	ldr	r3, [r4, #32]
 801e332:	681b      	ldr	r3, [r3, #0]
 801e334:	b173      	cbz	r3, 801e354 <BSP_HTS221_TEMPERATURE_Init+0x64>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }
  
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 801e336:	4798      	blx	r3
 801e338:	2801      	cmp	r0, #1
 801e33a:	d003      	beq.n	801e344 <BSP_HTS221_TEMPERATURE_Init+0x54>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
 801e33c:	4628      	mov	r0, r5
}
 801e33e:	bd70      	pop	{r4, r5, r6, pc}
    return COMPONENT_ERROR;
 801e340:	2001      	movs	r0, #1
}
 801e342:	bd70      	pop	{r4, r5, r6, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 801e344:	6833      	ldr	r3, [r6, #0]
 801e346:	601d      	str	r5, [r3, #0]
 801e348:	605d      	str	r5, [r3, #4]
 801e34a:	609d      	str	r5, [r3, #8]
 801e34c:	60dd      	str	r5, [r3, #12]
 801e34e:	611d      	str	r5, [r3, #16]
    *handle = NULL;
 801e350:	6035      	str	r5, [r6, #0]
}
 801e352:	bd70      	pop	{r4, r5, r6, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 801e354:	6163      	str	r3, [r4, #20]
 801e356:	e9c0 3301 	strd	r3, r3, [r0, #4]
 801e35a:	e9c0 3303 	strd	r3, r3, [r0, #12]
    return COMPONENT_ERROR;
 801e35e:	2001      	movs	r0, #1
    *handle = NULL;
 801e360:	6033      	str	r3, [r6, #0]
}
 801e362:	bd70      	pop	{r4, r5, r6, pc}
 801e364:	200100cc 	.word	0x200100cc
 801e368:	200103d8 	.word	0x200103d8
 801e36c:	20000000 	.word	0x20000000
 801e370:	01000001 	.word	0x01000001

0801e374 <BSP_TEMPERATURE_Init>:
{
 801e374:	b538      	push	{r3, r4, r5, lr}
  *handle = NULL;
 801e376:	2400      	movs	r4, #0
{
 801e378:	460d      	mov	r5, r1
  *handle = NULL;
 801e37a:	600c      	str	r4, [r1, #0]
  switch(id)
 801e37c:	b180      	cbz	r0, 801e3a0 <BSP_TEMPERATURE_Init+0x2c>
 801e37e:	2801      	cmp	r0, #1
      if(BSP_HTS221_TEMPERATURE_Init(handle) == COMPONENT_ERROR )
 801e380:	4608      	mov	r0, r1
  switch(id)
 801e382:	d005      	beq.n	801e390 <BSP_TEMPERATURE_Init+0x1c>
      if(BSP_HTS221_TEMPERATURE_Init(handle) == COMPONENT_ERROR )
 801e384:	f7ff ffb4 	bl	801e2f0 <BSP_HTS221_TEMPERATURE_Init>
 801e388:	2801      	cmp	r0, #1
 801e38a:	d009      	beq.n	801e3a0 <BSP_TEMPERATURE_Init+0x2c>
  return COMPONENT_OK;
 801e38c:	4620      	mov	r0, r4
}
 801e38e:	bd38      	pop	{r3, r4, r5, pc}
      if(BSP_HTS221_TEMPERATURE_Init(handle) == COMPONENT_ERROR )
 801e390:	f7ff ffae 	bl	801e2f0 <BSP_HTS221_TEMPERATURE_Init>
          return COMPONENT_ERROR;
 801e394:	f1a0 0001 	sub.w	r0, r0, #1
 801e398:	fab0 f080 	clz	r0, r0
 801e39c:	0940      	lsrs	r0, r0, #5
}
 801e39e:	bd38      	pop	{r3, r4, r5, pc}
      if(BSP_LPS22HB_TEMPERATURE_Init(handle) == COMPONENT_ERROR )
 801e3a0:	4628      	mov	r0, r5
 801e3a2:	f7ff ff3d 	bl	801e220 <BSP_LPS22HB_TEMPERATURE_Init>
          return COMPONENT_ERROR;
 801e3a6:	f1a0 0001 	sub.w	r0, r0, #1
 801e3aa:	fab0 f080 	clz	r0, r0
 801e3ae:	0940      	lsrs	r0, r0, #5
}
 801e3b0:	bd38      	pop	{r3, r4, r5, pc}
 801e3b2:	bf00      	nop

0801e3b4 <BSP_TEMPERATURE_Sensor_Enable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  TEMPERATURE_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 801e3b4:	b150      	cbz	r0, 801e3cc <BSP_TEMPERATURE_Sensor_Enable+0x18>
{
 801e3b6:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( TEMPERATURE_Drv_t * )ctx->pVTable;
  
  if ( driver->Sensor_Enable == NULL )
 801e3b8:	68c3      	ldr	r3, [r0, #12]
 801e3ba:	689b      	ldr	r3, [r3, #8]
 801e3bc:	b143      	cbz	r3, 801e3d0 <BSP_TEMPERATURE_Sensor_Enable+0x1c>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 801e3be:	4798      	blx	r3
    return COMPONENT_ERROR;
 801e3c0:	f1a0 0001 	sub.w	r0, r0, #1
 801e3c4:	fab0 f080 	clz	r0, r0
 801e3c8:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 801e3ca:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 801e3cc:	2001      	movs	r0, #1
}
 801e3ce:	4770      	bx	lr
    return COMPONENT_ERROR;
 801e3d0:	2001      	movs	r0, #1
}
 801e3d2:	bd08      	pop	{r3, pc}

0801e3d4 <BSP_TEMPERATURE_Sensor_Disable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  TEMPERATURE_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 801e3d4:	b150      	cbz	r0, 801e3ec <BSP_TEMPERATURE_Sensor_Disable+0x18>
{
 801e3d6:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( TEMPERATURE_Drv_t * )ctx->pVTable;
  
  if ( driver->Sensor_Disable == NULL )
 801e3d8:	68c3      	ldr	r3, [r0, #12]
 801e3da:	68db      	ldr	r3, [r3, #12]
 801e3dc:	b143      	cbz	r3, 801e3f0 <BSP_TEMPERATURE_Sensor_Disable+0x1c>
  {
    return COMPONENT_ERROR;
  }
  
  if ( driver->Sensor_Disable( ctx ) == COMPONENT_ERROR )
 801e3de:	4798      	blx	r3
    return COMPONENT_ERROR;
 801e3e0:	f1a0 0001 	sub.w	r0, r0, #1
 801e3e4:	fab0 f080 	clz	r0, r0
 801e3e8:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 801e3ea:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 801e3ec:	2001      	movs	r0, #1
}
 801e3ee:	4770      	bx	lr
    return COMPONENT_ERROR;
 801e3f0:	2001      	movs	r0, #1
}
 801e3f2:	bd08      	pop	{r3, pc}

0801e3f4 <BSP_TEMPERATURE_IsInitialized>:
 */
DrvStatusTypeDef BSP_TEMPERATURE_IsInitialized( void *handle, uint8_t *status )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 801e3f4:	b120      	cbz	r0, 801e400 <BSP_TEMPERATURE_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  if ( status == NULL )
 801e3f6:	b119      	cbz	r1, 801e400 <BSP_TEMPERATURE_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }
  
  *status = ctx->isInitialized;
 801e3f8:	7943      	ldrb	r3, [r0, #5]
 801e3fa:	700b      	strb	r3, [r1, #0]
  
  return COMPONENT_OK;
 801e3fc:	2000      	movs	r0, #0
 801e3fe:	4770      	bx	lr
    return COMPONENT_ERROR;
 801e400:	2001      	movs	r0, #1
}
 801e402:	4770      	bx	lr

0801e404 <BSP_TEMPERATURE_Get_Temp>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  TEMPERATURE_Drv_t *driver = NULL;
  
  if(ctx == NULL)
 801e404:	b158      	cbz	r0, 801e41e <BSP_TEMPERATURE_Get_Temp+0x1a>
{
 801e406:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }
  
  driver = ( TEMPERATURE_Drv_t * )ctx->pVTable;
  
  if ( temperature == NULL )
 801e408:	b159      	cbz	r1, 801e422 <BSP_TEMPERATURE_Get_Temp+0x1e>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Temp == NULL )
 801e40a:	68c3      	ldr	r3, [r0, #12]
 801e40c:	699b      	ldr	r3, [r3, #24]
 801e40e:	b143      	cbz	r3, 801e422 <BSP_TEMPERATURE_Get_Temp+0x1e>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Temp( ctx, temperature ) == COMPONENT_ERROR )
 801e410:	4798      	blx	r3
    return COMPONENT_ERROR;
 801e412:	f1a0 0001 	sub.w	r0, r0, #1
 801e416:	fab0 f080 	clz	r0, r0
 801e41a:	0940      	lsrs	r0, r0, #5
  {
    return COMPONENT_ERROR;
  }
  
  return COMPONENT_OK;
}
 801e41c:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 801e41e:	2001      	movs	r0, #1
}
 801e420:	4770      	bx	lr
    return COMPONENT_ERROR;
 801e422:	2001      	movs	r0, #1
}
 801e424:	bd08      	pop	{r3, pc}
 801e426:	bf00      	nop

0801e428 <BSP_TEMPERATURE_Set_One_Shot>:
DrvStatusTypeDef BSP_TEMPERATURE_Set_One_Shot( void *handle )
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  
  if(ctx == NULL)
 801e428:	b310      	cbz	r0, 801e470 <BSP_TEMPERATURE_Set_One_Shot+0x48>
{
 801e42a:	b510      	push	{r4, lr}
  {
    return COMPONENT_ERROR;
  }
  
  switch(ctx->who_am_i)
 801e42c:	7803      	ldrb	r3, [r0, #0]
 801e42e:	2bb1      	cmp	r3, #177	; 0xb1
 801e430:	4604      	mov	r4, r0
  {
    case LPS22HB_WHO_AM_I_VAL:
	{
      if ( LPS22HB_Set_Odr(handle, LPS22HB_ODR_ONE_SHOT)==LPS22HB_ERROR )
 801e432:	f04f 0100 	mov.w	r1, #0
  switch(ctx->who_am_i)
 801e436:	d10c      	bne.n	801e452 <BSP_TEMPERATURE_Set_One_Shot+0x2a>
      if ( LPS22HB_Set_Odr(handle, LPS22HB_ODR_ONE_SHOT)==LPS22HB_ERROR )
 801e438:	f7ea f8fc 	bl	8008634 <LPS22HB_Set_Odr>
 801e43c:	2801      	cmp	r0, #1
 801e43e:	d015      	beq.n	801e46c <BSP_TEMPERATURE_Set_One_Shot+0x44>
      {
        return COMPONENT_ERROR;
      }

      if ( LPS22HB_StartOneShotMeasurement(handle)==LPS22HB_ERROR )
 801e440:	4620      	mov	r0, r4
 801e442:	f7ea fa3b 	bl	80088bc <LPS22HB_StartOneShotMeasurement>
    return COMPONENT_ERROR;
 801e446:	f1a0 0001 	sub.w	r0, r0, #1
 801e44a:	fab0 f080 	clz	r0, r0
 801e44e:	0940      	lsrs	r0, r0, #5
      break;
    }
  }
  
  return COMPONENT_OK;
}
 801e450:	bd10      	pop	{r4, pc}
      if ( HTS221_Set_Odr(handle, HTS221_ODR_ONE_SHOT)==HTS221_ERROR )
 801e452:	f7e9 fe89 	bl	8008168 <HTS221_Set_Odr>
 801e456:	2801      	cmp	r0, #1
 801e458:	d008      	beq.n	801e46c <BSP_TEMPERATURE_Set_One_Shot+0x44>
      if ( HTS221_StartOneShotMeasurement(handle)==HTS221_ERROR )
 801e45a:	4620      	mov	r0, r4
 801e45c:	f7e9 fe2e 	bl	80080bc <HTS221_StartOneShotMeasurement>
    return COMPONENT_ERROR;
 801e460:	f1a0 0001 	sub.w	r0, r0, #1
 801e464:	fab0 f080 	clz	r0, r0
 801e468:	0940      	lsrs	r0, r0, #5
}
 801e46a:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 801e46c:	2001      	movs	r0, #1
}
 801e46e:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 801e470:	2001      	movs	r0, #1
}
 801e472:	4770      	bx	lr

0801e474 <aci_gap_init_IDB05A1>:

#define MIN(a,b)            ((a) < (b) )? (a) : (b)
#define MAX(a,b)            ((a) > (b) )? (a) : (b)

tBleStatus aci_gap_init_IDB05A1(uint8_t role, uint8_t privacy_enabled, uint8_t device_name_char_len, uint16_t* service_handle, uint16_t* dev_name_char_handle, uint16_t* appearance_char_handle)
{
 801e474:	b570      	push	{r4, r5, r6, lr}
 801e476:	b08a      	sub	sp, #40	; 0x28
 
  cp.role = role;
  cp.privacy_enabled = privacy_enabled;
  cp.device_name_char_len = device_name_char_len;
    
  Osal_MemSet(&resp, 0, sizeof(resp));
 801e478:	ac02      	add	r4, sp, #8
  cp.role = role;
 801e47a:	f88d 0004 	strb.w	r0, [sp, #4]
  cp.privacy_enabled = privacy_enabled;
 801e47e:	f88d 1005 	strb.w	r1, [sp, #5]
  cp.device_name_char_len = device_name_char_len;
 801e482:	f88d 2006 	strb.w	r2, [sp, #6]
  Osal_MemSet(&resp, 0, sizeof(resp));
 801e486:	4620      	mov	r0, r4
 801e488:	2207      	movs	r2, #7
 801e48a:	2100      	movs	r1, #0
{
 801e48c:	461e      	mov	r6, r3
  Osal_MemSet(&resp, 0, sizeof(resp));
 801e48e:	f7fa fbd9 	bl	8018c44 <Osal_MemSet>
  
  Osal_MemSet(&rq, 0, sizeof(rq));
 801e492:	2218      	movs	r2, #24
 801e494:	2100      	movs	r1, #0
 801e496:	a804      	add	r0, sp, #16
 801e498:	f7fa fbd4 	bl	8018c44 <Osal_MemSet>
  rq.ogf = OGF_VENDOR_CMD;
 801e49c:	4d13      	ldr	r5, [pc, #76]	; (801e4ec <aci_gap_init_IDB05A1+0x78>)
  rq.ocf = OCF_GAP_INIT;
  rq.cparam = &cp;
  rq.clen = sizeof(cp);
  rq.rparam = &resp;
 801e49e:	9408      	str	r4, [sp, #32]
  rq.clen = sizeof(cp);
 801e4a0:	2203      	movs	r2, #3
  rq.rlen = GAP_INIT_RP_SIZE;
 801e4a2:	2307      	movs	r3, #7
  
  if (hci_send_req(&rq, FALSE) < 0)
 801e4a4:	a804      	add	r0, sp, #16
  rq.cparam = &cp;
 801e4a6:	ac01      	add	r4, sp, #4
  if (hci_send_req(&rq, FALSE) < 0)
 801e4a8:	2100      	movs	r1, #0
  rq.ogf = OGF_VENDOR_CMD;
 801e4aa:	9504      	str	r5, [sp, #16]
  rq.clen = sizeof(cp);
 801e4ac:	e9cd 4206 	strd	r4, r2, [sp, #24]
  rq.rlen = GAP_INIT_RP_SIZE;
 801e4b0:	9309      	str	r3, [sp, #36]	; 0x24
  if (hci_send_req(&rq, FALSE) < 0)
 801e4b2:	f000 f9cd 	bl	801e850 <hci_send_req>
 801e4b6:	2800      	cmp	r0, #0
 801e4b8:	db15      	blt.n	801e4e6 <aci_gap_init_IDB05A1+0x72>
    return BLE_STATUS_TIMEOUT;
  
  if (resp.status) {
 801e4ba:	f89d 0008 	ldrb.w	r0, [sp, #8]
 801e4be:	b980      	cbnz	r0, 801e4e2 <aci_gap_init_IDB05A1+0x6e>
    return resp.status;
  }
  
  *service_handle = btohs(resp.service_handle);
 801e4c0:	9902      	ldr	r1, [sp, #8]
  *dev_name_char_handle = btohs(resp.dev_name_char_handle);
 801e4c2:	f89d 200b 	ldrb.w	r2, [sp, #11]
 801e4c6:	f89d 400c 	ldrb.w	r4, [sp, #12]
  *appearance_char_handle = btohs(resp.appearance_char_handle);
 801e4ca:	9b03      	ldr	r3, [sp, #12]
  *service_handle = btohs(resp.service_handle);
 801e4cc:	f3c1 210f 	ubfx	r1, r1, #8, #16
 801e4d0:	8031      	strh	r1, [r6, #0]
  *dev_name_char_handle = btohs(resp.dev_name_char_handle);
 801e4d2:	990e      	ldr	r1, [sp, #56]	; 0x38
 801e4d4:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
 801e4d8:	800a      	strh	r2, [r1, #0]
  *appearance_char_handle = btohs(resp.appearance_char_handle);
 801e4da:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801e4dc:	f3c3 230f 	ubfx	r3, r3, #8, #16
 801e4e0:	8013      	strh	r3, [r2, #0]
  
  return 0;
}
 801e4e2:	b00a      	add	sp, #40	; 0x28
 801e4e4:	bd70      	pop	{r4, r5, r6, pc}
    return BLE_STATUS_TIMEOUT;
 801e4e6:	20ff      	movs	r0, #255	; 0xff
}
 801e4e8:	b00a      	add	sp, #40	; 0x28
 801e4ea:	bd70      	pop	{r4, r5, r6, pc}
 801e4ec:	008a003f 	.word	0x008a003f

0801e4f0 <aci_gap_set_discoverable>:

tBleStatus aci_gap_set_discoverable(uint8_t AdvType, uint16_t AdvIntervMin, uint16_t AdvIntervMax,
                             uint8_t OwnAddrType, uint8_t AdvFilterPolicy, uint8_t LocalNameLen,
                             const char *LocalName, uint8_t ServiceUUIDLen, uint8_t* ServiceUUIDList,
                             uint16_t SlaveConnIntervMin, uint16_t SlaveConnIntervMax)
{
 801e4f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 801e4f2:	b095      	sub	sp, #84	; 0x54
 801e4f4:	f89d 506c 	ldrb.w	r5, [sp, #108]	; 0x6c
 801e4f8:	f89d 4074 	ldrb.w	r4, [sp, #116]	; 0x74
 801e4fc:	f8ad 1006 	strh.w	r1, [sp, #6]
  struct hci_request rq;
  uint8_t status;    
  uint8_t buffer[40];
  uint8_t indx = 0;
  
  if ((LocalNameLen+ServiceUUIDLen+14) > sizeof(buffer))
 801e500:	1929      	adds	r1, r5, r4
 801e502:	291a      	cmp	r1, #26
{
 801e504:	f8ad 2004 	strh.w	r2, [sp, #4]
 801e508:	f89d 7068 	ldrb.w	r7, [sp, #104]	; 0x68
  if ((LocalNameLen+ServiceUUIDLen+14) > sizeof(buffer))
 801e50c:	dc52      	bgt.n	801e5b4 <aci_gap_set_discoverable+0xc4>
 801e50e:	461e      	mov	r6, r3

  buffer[indx] = AdvType;
  indx++;
  
  AdvIntervMin = htobs(AdvIntervMin);
  Osal_MemCpy(buffer + indx, &AdvIntervMin, 2);
 801e510:	2202      	movs	r2, #2
 801e512:	4603      	mov	r3, r0
 801e514:	f10d 0106 	add.w	r1, sp, #6
 801e518:	f10d 0029 	add.w	r0, sp, #41	; 0x29
  buffer[indx] = AdvType;
 801e51c:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
  Osal_MemCpy(buffer + indx, &AdvIntervMin, 2);
 801e520:	f7fa fb8e 	bl	8018c40 <Osal_MemCpy>
  indx +=  2;
    
  AdvIntervMax = htobs(AdvIntervMax);
  Osal_MemCpy(buffer + indx, &AdvIntervMax, 2);
 801e524:	2202      	movs	r2, #2
 801e526:	a901      	add	r1, sp, #4
 801e528:	f10d 002b 	add.w	r0, sp, #43	; 0x2b
 801e52c:	f7fa fb88 	bl	8018c40 <Osal_MemCpy>
  indx++;
    
  buffer[indx] = LocalNameLen;
  indx++;
    
  Osal_MemCpy(buffer + indx, LocalName, LocalNameLen);
 801e530:	462a      	mov	r2, r5
 801e532:	991c      	ldr	r1, [sp, #112]	; 0x70
  buffer[indx] = OwnAddrType;
 801e534:	f88d 602d 	strb.w	r6, [sp, #45]	; 0x2d
  Osal_MemCpy(buffer + indx, LocalName, LocalNameLen);
 801e538:	a80c      	add	r0, sp, #48	; 0x30
  buffer[indx] = LocalNameLen;
 801e53a:	f88d 502f 	strb.w	r5, [sp, #47]	; 0x2f
  buffer[indx] = AdvFilterPolicy;
 801e53e:	f88d 702e 	strb.w	r7, [sp, #46]	; 0x2e
  Osal_MemCpy(buffer + indx, LocalName, LocalNameLen);
 801e542:	f7fa fb7d 	bl	8018c40 <Osal_MemCpy>
  indx +=  LocalNameLen;
 801e546:	f105 0308 	add.w	r3, r5, #8
  
  buffer[indx] = ServiceUUIDLen;
 801e54a:	aa14      	add	r2, sp, #80	; 0x50
 801e54c:	fa52 f383 	uxtab	r3, r2, r3
  indx++;
 801e550:	3509      	adds	r5, #9
 801e552:	b2ed      	uxtb	r5, r5
  buffer[indx] = ServiceUUIDLen;
 801e554:	f803 4c28 	strb.w	r4, [r3, #-40]
  Osal_MemCpy(buffer + indx, &AdvIntervMin, 2);
 801e558:	ae0a      	add	r6, sp, #40	; 0x28

  Osal_MemCpy(buffer + indx, ServiceUUIDList, ServiceUUIDLen);
 801e55a:	4622      	mov	r2, r4
  indx +=  ServiceUUIDLen;  
 801e55c:	442c      	add	r4, r5
 801e55e:	b2e4      	uxtb	r4, r4
  Osal_MemCpy(buffer + indx, ServiceUUIDList, ServiceUUIDLen);
 801e560:	1970      	adds	r0, r6, r5
 801e562:	991e      	ldr	r1, [sp, #120]	; 0x78
  SlaveConnIntervMax = htobs(SlaveConnIntervMax);
  Osal_MemCpy(buffer + indx, &SlaveConnIntervMax, 2);
  indx +=  2;    

  Osal_MemSet(&rq, 0, sizeof(rq));
  rq.ogf = OGF_VENDOR_CMD;
 801e564:	4d16      	ldr	r5, [pc, #88]	; (801e5c0 <aci_gap_set_discoverable+0xd0>)
  Osal_MemCpy(buffer + indx, ServiceUUIDList, ServiceUUIDLen);
 801e566:	f7fa fb6b 	bl	8018c40 <Osal_MemCpy>
  Osal_MemCpy(buffer + indx, &SlaveConnIntervMin, 2);
 801e56a:	1930      	adds	r0, r6, r4
 801e56c:	2202      	movs	r2, #2
 801e56e:	a91f      	add	r1, sp, #124	; 0x7c
 801e570:	f7fa fb66 	bl	8018c40 <Osal_MemCpy>
  indx +=  2;
 801e574:	1ca0      	adds	r0, r4, #2
  Osal_MemCpy(buffer + indx, &SlaveConnIntervMax, 2);
 801e576:	2202      	movs	r2, #2
 801e578:	a920      	add	r1, sp, #128	; 0x80
 801e57a:	fa56 f080 	uxtab	r0, r6, r0
 801e57e:	f7fa fb5f 	bl	8018c40 <Osal_MemCpy>
  indx +=  2;    
 801e582:	3404      	adds	r4, #4
  Osal_MemSet(&rq, 0, sizeof(rq));
 801e584:	2218      	movs	r2, #24
 801e586:	2100      	movs	r1, #0
 801e588:	a804      	add	r0, sp, #16
 801e58a:	f7fa fb5b 	bl	8018c44 <Osal_MemSet>
  rq.ocf = OCF_GAP_SET_DISCOVERABLE;
  rq.cparam = (void *)buffer;
  rq.clen = indx;
 801e58e:	b2e4      	uxtb	r4, r4
  rq.rparam = &status;
 801e590:	f10d 020f 	add.w	r2, sp, #15
  rq.rlen = 1;
 801e594:	2301      	movs	r3, #1

  if (hci_send_req(&rq, FALSE) < 0)
 801e596:	a804      	add	r0, sp, #16
 801e598:	2100      	movs	r1, #0
  rq.cparam = (void *)buffer;
 801e59a:	9606      	str	r6, [sp, #24]
  rq.clen = indx;
 801e59c:	9407      	str	r4, [sp, #28]
  rq.ogf = OGF_VENDOR_CMD;
 801e59e:	9504      	str	r5, [sp, #16]
  rq.rlen = 1;
 801e5a0:	e9cd 2308 	strd	r2, r3, [sp, #32]
  if (hci_send_req(&rq, FALSE) < 0)
 801e5a4:	f000 f954 	bl	801e850 <hci_send_req>
 801e5a8:	2800      	cmp	r0, #0
 801e5aa:	db06      	blt.n	801e5ba <aci_gap_set_discoverable+0xca>
    return BLE_STATUS_TIMEOUT;

  if (status) {
 801e5ac:	f89d 000f 	ldrb.w	r0, [sp, #15]
    return status;
  }

  return 0;
}
 801e5b0:	b015      	add	sp, #84	; 0x54
 801e5b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return BLE_STATUS_INVALID_PARAMS;
 801e5b4:	2042      	movs	r0, #66	; 0x42
}
 801e5b6:	b015      	add	sp, #84	; 0x54
 801e5b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return BLE_STATUS_TIMEOUT;
 801e5ba:	20ff      	movs	r0, #255	; 0xff
}
 801e5bc:	b015      	add	sp, #84	; 0x54
 801e5be:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e5c0:	0083003f 	.word	0x0083003f

0801e5c4 <aci_gap_set_auth_requirement>:
                                        uint8_t min_encryption_key_size,
                                        uint8_t max_encryption_key_size,
                                        uint8_t use_fixed_pin,
                                        uint32_t fixed_pin,
                                        uint8_t bonding_mode)
{
 801e5c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801e5c8:	b08e      	sub	sp, #56	; 0x38
 801e5ca:	4614      	mov	r4, r2
  struct hci_request rq;
  gap_set_auth_requirement_cp cp;    
  uint8_t status;
    
  cp.mitm_mode = mitm_mode;
 801e5cc:	f88d 001c 	strb.w	r0, [sp, #28]
  cp.oob_enable = oob_enable;
 801e5d0:	f88d 101d 	strb.w	r1, [sp, #29]
  Osal_MemCpy(cp.oob_data, oob_data, 16);
 801e5d4:	2210      	movs	r2, #16
 801e5d6:	4621      	mov	r1, r4
 801e5d8:	f10d 001e 	add.w	r0, sp, #30
{
 801e5dc:	f89d 405c 	ldrb.w	r4, [sp, #92]	; 0x5c
 801e5e0:	9d16      	ldr	r5, [sp, #88]	; 0x58
 801e5e2:	f89d 7050 	ldrb.w	r7, [sp, #80]	; 0x50
 801e5e6:	f89d 6054 	ldrb.w	r6, [sp, #84]	; 0x54
 801e5ea:	4698      	mov	r8, r3
  Osal_MemCpy(cp.oob_data, oob_data, 16);
 801e5ec:	f7fa fb28 	bl	8018c40 <Osal_MemCpy>
  cp.min_encryption_key_size = min_encryption_key_size;
  cp.max_encryption_key_size = max_encryption_key_size;
  cp.use_fixed_pin = use_fixed_pin;
  cp.fixed_pin = htobl(fixed_pin);
  cp.bonding_mode = bonding_mode;
 801e5f0:	f88d 4035 	strb.w	r4, [sp, #53]	; 0x35

  Osal_MemSet(&rq, 0, sizeof(rq));
 801e5f4:	a801      	add	r0, sp, #4
  Osal_MemCpy(cp.oob_data, oob_data, 16);
 801e5f6:	ac07      	add	r4, sp, #28
  Osal_MemSet(&rq, 0, sizeof(rq));
 801e5f8:	2218      	movs	r2, #24
 801e5fa:	2100      	movs	r1, #0
  cp.fixed_pin = htobl(fixed_pin);
 801e5fc:	f8cd 5031 	str.w	r5, [sp, #49]	; 0x31
  cp.min_encryption_key_size = min_encryption_key_size;
 801e600:	f88d 802e 	strb.w	r8, [sp, #46]	; 0x2e
  cp.max_encryption_key_size = max_encryption_key_size;
 801e604:	f88d 702f 	strb.w	r7, [sp, #47]	; 0x2f
  cp.use_fixed_pin = use_fixed_pin;
 801e608:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
  rq.ogf = OGF_VENDOR_CMD;
 801e60c:	4d0b      	ldr	r5, [pc, #44]	; (801e63c <aci_gap_set_auth_requirement+0x78>)
  Osal_MemSet(&rq, 0, sizeof(rq));
 801e60e:	f7fa fb19 	bl	8018c44 <Osal_MemSet>
  rq.ocf = OCF_GAP_SET_AUTH_REQUIREMENT;
  rq.cparam = &cp;
 801e612:	9403      	str	r4, [sp, #12]
  rq.clen = sizeof(cp);
  rq.rparam = &status;
 801e614:	f10d 0203 	add.w	r2, sp, #3
  rq.rlen = 1;
 801e618:	2301      	movs	r3, #1

  if (hci_send_req(&rq, FALSE) < 0)
 801e61a:	a801      	add	r0, sp, #4
  rq.clen = sizeof(cp);
 801e61c:	241a      	movs	r4, #26
  if (hci_send_req(&rq, FALSE) < 0)
 801e61e:	2100      	movs	r1, #0
  rq.ogf = OGF_VENDOR_CMD;
 801e620:	9501      	str	r5, [sp, #4]
  rq.rparam = &status;
 801e622:	e9cd 4204 	strd	r4, r2, [sp, #16]
  rq.rlen = 1;
 801e626:	9306      	str	r3, [sp, #24]
  if (hci_send_req(&rq, FALSE) < 0)
 801e628:	f000 f912 	bl	801e850 <hci_send_req>
 801e62c:	2800      	cmp	r0, #0
    return BLE_STATUS_TIMEOUT;

  if (status) {
 801e62e:	bfac      	ite	ge
 801e630:	f89d 0003 	ldrbge.w	r0, [sp, #3]
    return BLE_STATUS_TIMEOUT;
 801e634:	20ff      	movlt	r0, #255	; 0xff
    return status;
  }
    
  return 0;
}
 801e636:	b00e      	add	sp, #56	; 0x38
 801e638:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801e63c:	0086003f 	.word	0x0086003f

0801e640 <aci_gap_update_adv_data>:
  struct hci_request rq;
  uint8_t status;
  uint8_t buffer[32];
  uint8_t indx = 0;
    
  if (AdvLen > (sizeof(buffer)-1))
 801e640:	281f      	cmp	r0, #31
 801e642:	d824      	bhi.n	801e68e <aci_gap_update_adv_data+0x4e>
{
 801e644:	b570      	push	{r4, r5, r6, lr}
 801e646:	b090      	sub	sp, #64	; 0x40
    return BLE_STATUS_INVALID_PARAMS;

  buffer[indx] = AdvLen;
 801e648:	ad10      	add	r5, sp, #64	; 0x40
 801e64a:	4604      	mov	r4, r0
  indx++;
    
  Osal_MemCpy(buffer + indx, AdvData, AdvLen);
 801e64c:	4602      	mov	r2, r0
 801e64e:	f10d 0021 	add.w	r0, sp, #33	; 0x21
  buffer[indx] = AdvLen;
 801e652:	f805 4d20 	strb.w	r4, [r5, #-32]!
  Osal_MemCpy(buffer + indx, AdvData, AdvLen);
 801e656:	f7fa faf3 	bl	8018c40 <Osal_MemCpy>
  indx +=  AdvLen;
 801e65a:	3401      	adds	r4, #1
    
  Osal_MemSet(&rq, 0, sizeof(rq));
 801e65c:	2218      	movs	r2, #24
 801e65e:	2100      	movs	r1, #0
 801e660:	a802      	add	r0, sp, #8
 801e662:	f7fa faef 	bl	8018c44 <Osal_MemSet>
  rq.ogf = OGF_VENDOR_CMD;
  rq.ocf = OCF_GAP_UPDATE_ADV_DATA;
  rq.cparam = (void *)buffer;
  rq.clen = indx;
 801e666:	b2e4      	uxtb	r4, r4
  rq.rparam = &status;
 801e668:	f10d 0207 	add.w	r2, sp, #7
  rq.rlen = 1;
 801e66c:	2301      	movs	r3, #1
    
  if (hci_send_req(&rq, FALSE) < 0)
 801e66e:	a802      	add	r0, sp, #8
  rq.ogf = OGF_VENDOR_CMD;
 801e670:	4e09      	ldr	r6, [pc, #36]	; (801e698 <aci_gap_update_adv_data+0x58>)
  rq.cparam = (void *)buffer;
 801e672:	9504      	str	r5, [sp, #16]
  if (hci_send_req(&rq, FALSE) < 0)
 801e674:	2100      	movs	r1, #0
  rq.clen = indx;
 801e676:	9405      	str	r4, [sp, #20]
  rq.ogf = OGF_VENDOR_CMD;
 801e678:	9602      	str	r6, [sp, #8]
  rq.rlen = 1;
 801e67a:	e9cd 2306 	strd	r2, r3, [sp, #24]
  if (hci_send_req(&rq, FALSE) < 0)
 801e67e:	f000 f8e7 	bl	801e850 <hci_send_req>
 801e682:	2800      	cmp	r0, #0
 801e684:	db05      	blt.n	801e692 <aci_gap_update_adv_data+0x52>
    return BLE_STATUS_TIMEOUT;
    
  return status;
 801e686:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 801e68a:	b010      	add	sp, #64	; 0x40
 801e68c:	bd70      	pop	{r4, r5, r6, pc}
    return BLE_STATUS_INVALID_PARAMS;
 801e68e:	2042      	movs	r0, #66	; 0x42
}
 801e690:	4770      	bx	lr
    return BLE_STATUS_TIMEOUT;
 801e692:	20ff      	movs	r0, #255	; 0xff
}
 801e694:	b010      	add	sp, #64	; 0x40
 801e696:	bd70      	pop	{r4, r5, r6, pc}
 801e698:	008e003f 	.word	0x008e003f

0801e69c <aci_hal_set_tx_power_level>:
  
  return 0;
}

tBleStatus aci_hal_set_tx_power_level(uint8_t en_high_power, uint8_t pa_level)
{
 801e69c:	b530      	push	{r4, r5, lr}
 801e69e:	b089      	sub	sp, #36	; 0x24
  uint8_t status;
    
  cp.en_high_power = en_high_power;
  cp.pa_level = pa_level;

  Osal_MemSet(&rq, 0, sizeof(rq));
 801e6a0:	2218      	movs	r2, #24
  cp.en_high_power = en_high_power;
 801e6a2:	f88d 0004 	strb.w	r0, [sp, #4]
  cp.pa_level = pa_level;
 801e6a6:	f88d 1005 	strb.w	r1, [sp, #5]
  Osal_MemSet(&rq, 0, sizeof(rq));
 801e6aa:	a802      	add	r0, sp, #8
 801e6ac:	2100      	movs	r1, #0
 801e6ae:	f7fa fac9 	bl	8018c44 <Osal_MemSet>
  rq.ogf = OGF_VENDOR_CMD;
 801e6b2:	4b0b      	ldr	r3, [pc, #44]	; (801e6e0 <aci_hal_set_tx_power_level+0x44>)
 801e6b4:	9302      	str	r3, [sp, #8]
  rq.ocf = OCF_HAL_SET_TX_POWER_LEVEL;
  rq.cparam = &cp;
  rq.clen = HAL_SET_TX_POWER_LEVEL_CP_SIZE;
  rq.rparam = &status;
 801e6b6:	f10d 0203 	add.w	r2, sp, #3
  rq.rlen = 1;
 801e6ba:	2301      	movs	r3, #1

  if (hci_send_req(&rq, FALSE) < 0)
 801e6bc:	a802      	add	r0, sp, #8
  rq.cparam = &cp;
 801e6be:	ad01      	add	r5, sp, #4
  rq.clen = HAL_SET_TX_POWER_LEVEL_CP_SIZE;
 801e6c0:	2402      	movs	r4, #2
  if (hci_send_req(&rq, FALSE) < 0)
 801e6c2:	2100      	movs	r1, #0
  rq.clen = HAL_SET_TX_POWER_LEVEL_CP_SIZE;
 801e6c4:	e9cd 5404 	strd	r5, r4, [sp, #16]
  rq.rlen = 1;
 801e6c8:	e9cd 2306 	strd	r2, r3, [sp, #24]
  if (hci_send_req(&rq, FALSE) < 0)
 801e6cc:	f000 f8c0 	bl	801e850 <hci_send_req>
 801e6d0:	2800      	cmp	r0, #0
    return BLE_STATUS_TIMEOUT;

  return status;
 801e6d2:	bfac      	ite	ge
 801e6d4:	f89d 0003 	ldrbge.w	r0, [sp, #3]
    return BLE_STATUS_TIMEOUT;
 801e6d8:	20ff      	movlt	r0, #255	; 0xff
}
 801e6da:	b009      	add	sp, #36	; 0x24
 801e6dc:	bd30      	pop	{r4, r5, pc}
 801e6de:	bf00      	nop
 801e6e0:	000f003f 	.word	0x000f003f

0801e6e4 <move_list.constprop.1>:
  Osal_MemCpy(header+1, &hc, sizeof(hc));
  
  hci_write(header, param, sizeof(header), plen);
}

static void move_list(tListNode * dest_list, tListNode * src_list)
 801e6e4:	b530      	push	{r4, r5, lr}
 801e6e6:	4604      	mov	r4, r0
 801e6e8:	b083      	sub	sp, #12
{
  pListNode tmp_node;
  
  while(!list_is_empty(src_list)){
    list_remove_tail(src_list, &tmp_node);
    list_insert_head(dest_list, tmp_node);
 801e6ea:	4d08      	ldr	r5, [pc, #32]	; (801e70c <move_list.constprop.1+0x28>)
 801e6ec:	e006      	b.n	801e6fc <move_list.constprop.1+0x18>
    list_remove_tail(src_list, &tmp_node);
 801e6ee:	4620      	mov	r0, r4
 801e6f0:	f7fa fa64 	bl	8018bbc <list_remove_tail>
    list_insert_head(dest_list, tmp_node);
 801e6f4:	9901      	ldr	r1, [sp, #4]
 801e6f6:	4628      	mov	r0, r5
 801e6f8:	f7fa fa2e 	bl	8018b58 <list_insert_head>
  while(!list_is_empty(src_list)){
 801e6fc:	4620      	mov	r0, r4
 801e6fe:	f7fa fa1f 	bl	8018b40 <list_is_empty>
    list_remove_tail(src_list, &tmp_node);
 801e702:	a901      	add	r1, sp, #4
  while(!list_is_empty(src_list)){
 801e704:	2800      	cmp	r0, #0
 801e706:	d0f2      	beq.n	801e6ee <move_list.constprop.1+0xa>
  }
}
 801e708:	b003      	add	sp, #12
 801e70a:	bd30      	pop	{r4, r5, pc}
 801e70c:	20013314 	.word	0x20013314

0801e710 <HCI_Init>:
  list_init_head (&hciReadPktPool);
 801e710:	4809      	ldr	r0, [pc, #36]	; (801e738 <HCI_Init+0x28>)
{
 801e712:	b570      	push	{r4, r5, r6, lr}
    list_insert_tail(&hciReadPktPool, (tListNode *)&hciReadPacketBuffer[index]);
 801e714:	4606      	mov	r6, r0
  list_init_head (&hciReadPktPool);
 801e716:	f7fa fa0f 	bl	8018b38 <list_init_head>
  list_init_head (&hciReadPktRxQueue);
 801e71a:	4808      	ldr	r0, [pc, #32]	; (801e73c <HCI_Init+0x2c>)
 801e71c:	4c08      	ldr	r4, [pc, #32]	; (801e740 <HCI_Init+0x30>)
 801e71e:	f7fa fa0b 	bl	8018b38 <list_init_head>
 801e722:	f504 752f 	add.w	r5, r4, #700	; 0x2bc
    list_insert_tail(&hciReadPktPool, (tListNode *)&hciReadPacketBuffer[index]);
 801e726:	4621      	mov	r1, r4
 801e728:	4630      	mov	r0, r6
 801e72a:	348c      	adds	r4, #140	; 0x8c
 801e72c:	f7fa fa20 	bl	8018b70 <list_insert_tail>
  for (index = 0; index < HCI_READ_PACKET_NUM_MAX; index++)
 801e730:	42a5      	cmp	r5, r4
 801e732:	d1f8      	bne.n	801e726 <HCI_Init+0x16>
}
 801e734:	bd70      	pop	{r4, r5, r6, pc}
 801e736:	bf00      	nop
 801e738:	2001330c 	.word	0x2001330c
 801e73c:	20013314 	.word	0x20013314
 801e740:	20010110 	.word	0x20010110

0801e744 <HCI_Isr>:
{
 801e744:	b5f0      	push	{r4, r5, r6, r7, lr}
 801e746:	b083      	sub	sp, #12
  tHciDataPacket * hciReadPacket = NULL;
 801e748:	ad02      	add	r5, sp, #8
 801e74a:	2300      	movs	r3, #0
 801e74c:	f845 3d04 	str.w	r3, [r5, #-4]!
    if (list_is_empty (&hciReadPktPool) == FALSE){
 801e750:	4c18      	ldr	r4, [pc, #96]	; (801e7b4 <HCI_Isr+0x70>)
          list_insert_tail(&hciReadPktRxQueue, (tListNode *)hciReadPacket);
 801e752:	4e19      	ldr	r6, [pc, #100]	; (801e7b8 <HCI_Isr+0x74>)
  Clear_SPI_EXTI_Flag();
 801e754:	f7ff fbf4 	bl	801df40 <Clear_SPI_EXTI_Flag>
  while(BlueNRG_DataPresent()){        
 801e758:	e010      	b.n	801e77c <HCI_Isr+0x38>
        hciReadPacket->data_len = data_len;
 801e75a:	9a01      	ldr	r2, [sp, #4]
  if(hci_pckt[HCI_PCK_TYPE_OFFSET] != HCI_EVENT_PKT)
 801e75c:	7a11      	ldrb	r1, [r2, #8]
        hciReadPacket->data_len = data_len;
 801e75e:	f882 3088 	strb.w	r3, [r2, #136]	; 0x88
  if(hci_pckt[HCI_PCK_TYPE_OFFSET] != HCI_EVENT_PKT)
 801e762:	2904      	cmp	r1, #4
  if(hci_pckt[EVENT_PARAMETER_TOT_LEN_OFFSET] != hciReadPacket->data_len - (1+HCI_EVENT_HDR_SIZE))
 801e764:	f1a3 0303 	sub.w	r3, r3, #3
          list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);          
 801e768:	4611      	mov	r1, r2
  if(hci_pckt[HCI_PCK_TYPE_OFFSET] != HCI_EVENT_PKT)
 801e76a:	d11c      	bne.n	801e7a6 <HCI_Isr+0x62>
  if(hci_pckt[EVENT_PARAMETER_TOT_LEN_OFFSET] != hciReadPacket->data_len - (1+HCI_EVENT_HDR_SIZE))
 801e76c:	7a97      	ldrb	r7, [r2, #10]
 801e76e:	429f      	cmp	r7, r3
 801e770:	d119      	bne.n	801e7a6 <HCI_Isr+0x62>
          list_insert_tail(&hciReadPktRxQueue, (tListNode *)hciReadPacket);
 801e772:	4630      	mov	r0, r6
 801e774:	f7fa f9fc 	bl	8018b70 <list_insert_tail>
    Clear_SPI_EXTI_Flag();
 801e778:	f7ff fbe2 	bl	801df40 <Clear_SPI_EXTI_Flag>
  while(BlueNRG_DataPresent()){        
 801e77c:	f7ff faf2 	bl	801dd64 <BlueNRG_DataPresent>
 801e780:	b1b0      	cbz	r0, 801e7b0 <HCI_Isr+0x6c>
    if (list_is_empty (&hciReadPktPool) == FALSE){
 801e782:	4620      	mov	r0, r4
 801e784:	f7fa f9dc 	bl	8018b40 <list_is_empty>
      list_remove_head (&hciReadPktPool, (tListNode **)&hciReadPacket);
 801e788:	4629      	mov	r1, r5
    if (list_is_empty (&hciReadPktPool) == FALSE){
 801e78a:	b978      	cbnz	r0, 801e7ac <HCI_Isr+0x68>
      list_remove_head (&hciReadPktPool, (tListNode **)&hciReadPacket);
 801e78c:	4620      	mov	r0, r4
 801e78e:	f7fa f9fb 	bl	8018b88 <list_remove_head>
      data_len = BlueNRG_SPI_Read_All(hciReadPacket->dataBuff, HCI_READ_PACKET_SIZE);
 801e792:	9801      	ldr	r0, [sp, #4]
 801e794:	2180      	movs	r1, #128	; 0x80
 801e796:	3008      	adds	r0, #8
 801e798:	f7ff faf2 	bl	801dd80 <BlueNRG_SPI_Read_All>
 801e79c:	b2c3      	uxtb	r3, r0
          list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);          
 801e79e:	4620      	mov	r0, r4
      if(data_len > 0){                    
 801e7a0:	2b00      	cmp	r3, #0
 801e7a2:	d1da      	bne.n	801e75a <HCI_Isr+0x16>
        list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);
 801e7a4:	9901      	ldr	r1, [sp, #4]
 801e7a6:	f7fa f9d7 	bl	8018b58 <list_insert_head>
 801e7aa:	e7e5      	b.n	801e778 <HCI_Isr+0x34>
      Clear_SPI_EXTI_Flag();
 801e7ac:	f7ff fbc8 	bl	801df40 <Clear_SPI_EXTI_Flag>
}
 801e7b0:	b003      	add	sp, #12
 801e7b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e7b4:	2001330c 	.word	0x2001330c
 801e7b8:	20013314 	.word	0x20013314

0801e7bc <HCI_Process>:
{
 801e7bc:	b530      	push	{r4, r5, lr}
 801e7be:	b083      	sub	sp, #12
  tHciDataPacket * hciReadPacket = NULL;
 801e7c0:	2300      	movs	r3, #0
 801e7c2:	9301      	str	r3, [sp, #4]
  Disable_SPI_IRQ();
 801e7c4:	f7ff fbb8 	bl	801df38 <Disable_SPI_IRQ>
  uint8_t list_empty = list_is_empty(&hciReadPktRxQueue);        
 801e7c8:	4810      	ldr	r0, [pc, #64]	; (801e80c <HCI_Process+0x50>)
 801e7ca:	f7fa f9b9 	bl	8018b40 <list_is_empty>
  while(list_empty == FALSE)
 801e7ce:	b9b0      	cbnz	r0, 801e7fe <HCI_Process+0x42>
    list_remove_head (&hciReadPktRxQueue, (tListNode **)&hciReadPacket);
 801e7d0:	4c0e      	ldr	r4, [pc, #56]	; (801e80c <HCI_Process+0x50>)
    list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);
 801e7d2:	4d0f      	ldr	r5, [pc, #60]	; (801e810 <HCI_Process+0x54>)
    list_remove_head (&hciReadPktRxQueue, (tListNode **)&hciReadPacket);
 801e7d4:	a901      	add	r1, sp, #4
 801e7d6:	4620      	mov	r0, r4
 801e7d8:	f7fa f9d6 	bl	8018b88 <list_remove_head>
    Enable_SPI_IRQ();
 801e7dc:	f7ff fba8 	bl	801df30 <Enable_SPI_IRQ>
    HCI_Event_CB(hciReadPacket->dataBuff);
 801e7e0:	9801      	ldr	r0, [sp, #4]
 801e7e2:	3008      	adds	r0, #8
 801e7e4:	f7fe f888 	bl	801c8f8 <HCI_Event_CB>
    Disable_SPI_IRQ();
 801e7e8:	f7ff fba6 	bl	801df38 <Disable_SPI_IRQ>
    list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);
 801e7ec:	4628      	mov	r0, r5
 801e7ee:	9901      	ldr	r1, [sp, #4]
 801e7f0:	f7fa f9be 	bl	8018b70 <list_insert_tail>
    list_empty = list_is_empty(&hciReadPktRxQueue);
 801e7f4:	4620      	mov	r0, r4
 801e7f6:	f7fa f9a3 	bl	8018b40 <list_is_empty>
  while(list_empty == FALSE)
 801e7fa:	2800      	cmp	r0, #0
 801e7fc:	d0ea      	beq.n	801e7d4 <HCI_Process+0x18>
  HCI_Isr();
 801e7fe:	f7ff ffa1 	bl	801e744 <HCI_Isr>
  Enable_SPI_IRQ();    
 801e802:	f7ff fb95 	bl	801df30 <Enable_SPI_IRQ>
}
 801e806:	b003      	add	sp, #12
 801e808:	bd30      	pop	{r4, r5, pc}
 801e80a:	bf00      	nop
 801e80c:	20013314 	.word	0x20013314
 801e810:	2001330c 	.word	0x2001330c

0801e814 <hci_send_cmd>:
{
 801e814:	b530      	push	{r4, r5, lr}
  hc.opcode = htobs(cmd_opcode_pack(ogf, ocf));
 801e816:	f3c1 0109 	ubfx	r1, r1, #0, #10
{
 801e81a:	b083      	sub	sp, #12
  hc.opcode = htobs(cmd_opcode_pack(ogf, ocf));
 801e81c:	ea41 2080 	orr.w	r0, r1, r0, lsl #10
{
 801e820:	4614      	mov	r4, r2
 801e822:	461d      	mov	r5, r3
  Osal_MemCpy(header+1, &hc, sizeof(hc));
 801e824:	4669      	mov	r1, sp
  header[0] = HCI_COMMAND_PKT;
 801e826:	2301      	movs	r3, #1
  hc.opcode = htobs(cmd_opcode_pack(ogf, ocf));
 801e828:	f8ad 0000 	strh.w	r0, [sp]
  Osal_MemCpy(header+1, &hc, sizeof(hc));
 801e82c:	2203      	movs	r2, #3
 801e82e:	f10d 0005 	add.w	r0, sp, #5
  header[0] = HCI_COMMAND_PKT;
 801e832:	f88d 3004 	strb.w	r3, [sp, #4]
  hc.plen= plen;
 801e836:	f88d 4002 	strb.w	r4, [sp, #2]
  Osal_MemCpy(header+1, &hc, sizeof(hc));
 801e83a:	f7fa fa01 	bl	8018c40 <Osal_MemCpy>
  Hal_Write_Serial(data1, data2, n_bytes1, n_bytes2);
 801e83e:	4623      	mov	r3, r4
 801e840:	4629      	mov	r1, r5
 801e842:	a801      	add	r0, sp, #4
 801e844:	2204      	movs	r2, #4
 801e846:	f7ff fb51 	bl	801deec <Hal_Write_Serial>
}
 801e84a:	b003      	add	sp, #12
 801e84c:	bd30      	pop	{r4, r5, pc}
 801e84e:	bf00      	nop

0801e850 <hci_send_req>:
  
  Enable_SPI_IRQ();
}

int hci_send_req(struct hci_request *r, BOOL async)
{
 801e850:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801e854:	4606      	mov	r6, r0
 801e856:	b087      	sub	sp, #28
  uint16_t opcode = htobs(cmd_opcode_pack(r->ogf, r->ocf));
  hci_event_pckt *event_pckt;
  hci_uart_pckt *hci_hdr;
  int to = DEFAULT_TIMEOUT;
  struct timer t;
  tHciDataPacket * hciReadPacket = NULL;
 801e858:	2300      	movs	r3, #0
  tListNode hciTempQueue;
  
  list_init_head(&hciTempQueue);
 801e85a:	a804      	add	r0, sp, #16
{
 801e85c:	4688      	mov	r8, r1
  tHciDataPacket * hciReadPacket = NULL;
 801e85e:	9301      	str	r3, [sp, #4]
  uint16_t opcode = htobs(cmd_opcode_pack(r->ogf, r->ocf));
 801e860:	8877      	ldrh	r7, [r6, #2]
 801e862:	f8b6 9000 	ldrh.w	r9, [r6]
  while(list_get_size(&hciReadPktPool) < HCI_READ_PACKET_NUM_MAX/2){
 801e866:	4c5e      	ldr	r4, [pc, #376]	; (801e9e0 <hci_send_req+0x190>)
    list_remove_head(&hciReadPktRxQueue, (tListNode **)&pckt);    
 801e868:	4d5e      	ldr	r5, [pc, #376]	; (801e9e4 <hci_send_req+0x194>)
  list_init_head(&hciTempQueue);
 801e86a:	f7fa f965 	bl	8018b38 <list_init_head>
  Disable_SPI_IRQ();
 801e86e:	f7ff fb63 	bl	801df38 <Disable_SPI_IRQ>
 801e872:	e007      	b.n	801e884 <hci_send_req+0x34>
    list_remove_head(&hciReadPktRxQueue, (tListNode **)&pckt);    
 801e874:	f7fa f988 	bl	8018b88 <list_remove_head>
    list_insert_tail(&hciReadPktPool, (tListNode *)pckt);
 801e878:	9902      	ldr	r1, [sp, #8]
 801e87a:	4620      	mov	r0, r4
 801e87c:	f7fa f978 	bl	8018b70 <list_insert_tail>
    HCI_Isr();
 801e880:	f7ff ff60 	bl	801e744 <HCI_Isr>
  while(list_get_size(&hciReadPktPool) < HCI_READ_PACKET_NUM_MAX/2){
 801e884:	4620      	mov	r0, r4
 801e886:	f7fa f9b3 	bl	8018bf0 <list_get_size>
 801e88a:	2801      	cmp	r0, #1
    list_remove_head(&hciReadPktRxQueue, (tListNode **)&pckt);    
 801e88c:	a902      	add	r1, sp, #8
 801e88e:	4628      	mov	r0, r5
  while(list_get_size(&hciReadPktPool) < HCI_READ_PACKET_NUM_MAX/2){
 801e890:	ddf0      	ble.n	801e874 <hci_send_req+0x24>
  Enable_SPI_IRQ();
 801e892:	f7ff fb4d 	bl	801df30 <Enable_SPI_IRQ>

  free_event_list();
  
  hci_send_cmd(r->ogf, r->ocf, r->clen, r->cparam);
 801e896:	68b3      	ldr	r3, [r6, #8]
 801e898:	7b32      	ldrb	r2, [r6, #12]
 801e89a:	8871      	ldrh	r1, [r6, #2]
 801e89c:	8830      	ldrh	r0, [r6, #0]
 801e89e:	f7ff ffb9 	bl	801e814 <hci_send_cmd>
  
  if(async){
 801e8a2:	f1b8 0f00 	cmp.w	r8, #0
 801e8a6:	d004      	beq.n	801e8b2 <hci_send_req+0x62>
    return 0;
 801e8a8:	2400      	movs	r4, #0
  list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket); 
  move_list(&hciReadPktRxQueue, &hciTempQueue);
  
  Enable_SPI_IRQ();
  return 0;
}
 801e8aa:	4620      	mov	r0, r4
 801e8ac:	b007      	add	sp, #28
 801e8ae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  uint16_t opcode = htobs(cmd_opcode_pack(r->ogf, r->ocf));
 801e8b2:	f3c7 0709 	ubfx	r7, r7, #0, #10
 801e8b6:	ea47 2789 	orr.w	r7, r7, r9, lsl #10
  Timer_Set(&t, to);
 801e8ba:	a802      	add	r0, sp, #8
 801e8bc:	2164      	movs	r1, #100	; 0x64
  uint16_t opcode = htobs(cmd_opcode_pack(r->ogf, r->ocf));
 801e8be:	b2bf      	uxth	r7, r7
  Timer_Set(&t, to);
 801e8c0:	f7fa f9a8 	bl	8018c14 <Timer_Set>
  return list_is_empty(&hciReadPktRxQueue);
 801e8c4:	4d47      	ldr	r5, [pc, #284]	; (801e9e4 <hci_send_req+0x194>)
    if(list_is_empty(&hciReadPktPool) && list_is_empty(&hciReadPktRxQueue)){
 801e8c6:	f8df 8118 	ldr.w	r8, [pc, #280]	; 801e9e0 <hci_send_req+0x190>
 801e8ca:	e003      	b.n	801e8d4 <hci_send_req+0x84>
  return list_is_empty(&hciReadPktRxQueue);
 801e8cc:	4628      	mov	r0, r5
 801e8ce:	f7fa f937 	bl	8018b40 <list_is_empty>
      if(!HCI_Queue_Empty()){
 801e8d2:	b1a8      	cbz	r0, 801e900 <hci_send_req+0xb0>
      if(Timer_Expired(&t)){
 801e8d4:	a802      	add	r0, sp, #8
 801e8d6:	f7fa f9a5 	bl	8018c24 <Timer_Expired>
 801e8da:	4604      	mov	r4, r0
 801e8dc:	2800      	cmp	r0, #0
 801e8de:	d0f5      	beq.n	801e8cc <hci_send_req+0x7c>
 801e8e0:	9901      	ldr	r1, [sp, #4]
  if(hciReadPacket!=NULL){
 801e8e2:	b111      	cbz	r1, 801e8ea <hci_send_req+0x9a>
    list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);
 801e8e4:	483e      	ldr	r0, [pc, #248]	; (801e9e0 <hci_send_req+0x190>)
 801e8e6:	f7fa f937 	bl	8018b58 <list_insert_head>
  move_list(&hciReadPktRxQueue, &hciTempQueue);  
 801e8ea:	a804      	add	r0, sp, #16
 801e8ec:	f7ff fefa 	bl	801e6e4 <move_list.constprop.1>
  Enable_SPI_IRQ();
 801e8f0:	f7ff fb1e 	bl	801df30 <Enable_SPI_IRQ>
  return -1;
 801e8f4:	f04f 34ff 	mov.w	r4, #4294967295
}
 801e8f8:	4620      	mov	r0, r4
 801e8fa:	b007      	add	sp, #28
 801e8fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    Disable_SPI_IRQ();
 801e900:	f7ff fb1a 	bl	801df38 <Disable_SPI_IRQ>
    list_remove_head(&hciReadPktRxQueue, (tListNode **)&hciReadPacket);    
 801e904:	a901      	add	r1, sp, #4
 801e906:	4628      	mov	r0, r5
 801e908:	f7fa f93e 	bl	8018b88 <list_remove_head>
    hci_hdr = (void *)hciReadPacket->dataBuff;
 801e90c:	9901      	ldr	r1, [sp, #4]
    if(hci_hdr->type == HCI_EVENT_PKT){
 801e90e:	7a0b      	ldrb	r3, [r1, #8]
 801e910:	2b04      	cmp	r3, #4
 801e912:	d12c      	bne.n	801e96e <hci_send_req+0x11e>
    switch (event_pckt->evt) {
 801e914:	7a4b      	ldrb	r3, [r1, #9]
    len = hciReadPacket->data_len - (1 + HCI_EVENT_HDR_SIZE);
 801e916:	f891 c088 	ldrb.w	ip, [r1, #136]	; 0x88
    switch (event_pckt->evt) {
 801e91a:	2b0f      	cmp	r3, #15
 801e91c:	d01d      	beq.n	801e95a <hci_send_req+0x10a>
 801e91e:	d941      	bls.n	801e9a4 <hci_send_req+0x154>
 801e920:	2b10      	cmp	r3, #16
 801e922:	d0df      	beq.n	801e8e4 <hci_send_req+0x94>
 801e924:	2b3e      	cmp	r3, #62	; 0x3e
 801e926:	d122      	bne.n	801e96e <hci_send_req+0x11e>
      if (me->subevent != r->event)
 801e928:	7aca      	ldrb	r2, [r1, #11]
 801e92a:	6873      	ldr	r3, [r6, #4]
 801e92c:	429a      	cmp	r2, r3
 801e92e:	d11e      	bne.n	801e96e <hci_send_req+0x11e>
      Osal_MemCpy(r->rparam, me->data, r->rlen);
 801e930:	e9d6 0304 	ldrd	r0, r3, [r6, #16]
      len -= 1;
 801e934:	f1ac 0204 	sub.w	r2, ip, #4
      r->rlen = MIN(len, r->rlen);
 801e938:	429a      	cmp	r2, r3
 801e93a:	bfa8      	it	ge
 801e93c:	461a      	movge	r2, r3
      Osal_MemCpy(r->rparam, me->data, r->rlen);
 801e93e:	310c      	adds	r1, #12
      r->rlen = MIN(len, r->rlen);
 801e940:	6172      	str	r2, [r6, #20]
      Osal_MemCpy(r->rparam, me->data, r->rlen);
 801e942:	f7fa f97d 	bl	8018c40 <Osal_MemCpy>
  list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket); 
 801e946:	9901      	ldr	r1, [sp, #4]
 801e948:	4825      	ldr	r0, [pc, #148]	; (801e9e0 <hci_send_req+0x190>)
 801e94a:	f7fa f905 	bl	8018b58 <list_insert_head>
  move_list(&hciReadPktRxQueue, &hciTempQueue);
 801e94e:	a804      	add	r0, sp, #16
 801e950:	f7ff fec8 	bl	801e6e4 <move_list.constprop.1>
  Enable_SPI_IRQ();
 801e954:	f7ff faec 	bl	801df30 <Enable_SPI_IRQ>
  return 0;
 801e958:	e7a7      	b.n	801e8aa <hci_send_req+0x5a>
      if (cs->opcode != opcode)
 801e95a:	f8b1 300d 	ldrh.w	r3, [r1, #13]
 801e95e:	42bb      	cmp	r3, r7
 801e960:	d1c0      	bne.n	801e8e4 <hci_send_req+0x94>
      if (r->event != EVT_CMD_STATUS) {
 801e962:	6873      	ldr	r3, [r6, #4]
 801e964:	2b0f      	cmp	r3, #15
 801e966:	d02e      	beq.n	801e9c6 <hci_send_req+0x176>
        if (cs->status) {
 801e968:	7acb      	ldrb	r3, [r1, #11]
 801e96a:	2b00      	cmp	r3, #0
 801e96c:	d1ba      	bne.n	801e8e4 <hci_send_req+0x94>
    if(list_is_empty(&hciReadPktPool) && list_is_empty(&hciReadPktRxQueue)){
 801e96e:	4640      	mov	r0, r8
 801e970:	f7fa f8e6 	bl	8018b40 <list_is_empty>
 801e974:	b950      	cbnz	r0, 801e98c <hci_send_req+0x13c>
    list_insert_tail(&hciTempQueue, (tListNode *)hciReadPacket);
 801e976:	9901      	ldr	r1, [sp, #4]
 801e978:	a804      	add	r0, sp, #16
 801e97a:	f7fa f8f9 	bl	8018b70 <list_insert_tail>
      hciReadPacket=NULL;
 801e97e:	2300      	movs	r3, #0
 801e980:	9301      	str	r3, [sp, #4]
    HCI_Isr();
 801e982:	f7ff fedf 	bl	801e744 <HCI_Isr>
    Enable_SPI_IRQ();
 801e986:	f7ff fad3 	bl	801df30 <Enable_SPI_IRQ>
  while(1) {
 801e98a:	e7a3      	b.n	801e8d4 <hci_send_req+0x84>
    if(list_is_empty(&hciReadPktPool) && list_is_empty(&hciReadPktRxQueue)){
 801e98c:	4628      	mov	r0, r5
 801e98e:	f7fa f8d7 	bl	8018b40 <list_is_empty>
 801e992:	2800      	cmp	r0, #0
 801e994:	d0ef      	beq.n	801e976 <hci_send_req+0x126>
      list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);
 801e996:	9901      	ldr	r1, [sp, #4]
 801e998:	4640      	mov	r0, r8
 801e99a:	f7fa f8e9 	bl	8018b70 <list_insert_tail>
      hciReadPacket=NULL;
 801e99e:	2300      	movs	r3, #0
 801e9a0:	9301      	str	r3, [sp, #4]
 801e9a2:	e7ee      	b.n	801e982 <hci_send_req+0x132>
    switch (event_pckt->evt) {
 801e9a4:	2b0e      	cmp	r3, #14
 801e9a6:	d1e2      	bne.n	801e96e <hci_send_req+0x11e>
      if (cc->opcode != opcode)
 801e9a8:	898b      	ldrh	r3, [r1, #12]
 801e9aa:	42bb      	cmp	r3, r7
 801e9ac:	d19a      	bne.n	801e8e4 <hci_send_req+0x94>
      Osal_MemCpy(r->rparam, ptr, r->rlen);
 801e9ae:	e9d6 0304 	ldrd	r0, r3, [r6, #16]
      len -= EVT_CMD_COMPLETE_SIZE;
 801e9b2:	f1ac 0206 	sub.w	r2, ip, #6
      r->rlen = MIN(len, r->rlen);
 801e9b6:	429a      	cmp	r2, r3
 801e9b8:	bfa8      	it	ge
 801e9ba:	461a      	movge	r2, r3
      Osal_MemCpy(r->rparam, ptr, r->rlen);
 801e9bc:	310e      	adds	r1, #14
      r->rlen = MIN(len, r->rlen);
 801e9be:	6172      	str	r2, [r6, #20]
      Osal_MemCpy(r->rparam, ptr, r->rlen);
 801e9c0:	f7fa f93e 	bl	8018c40 <Osal_MemCpy>
      goto done;
 801e9c4:	e7bf      	b.n	801e946 <hci_send_req+0xf6>
      Osal_MemCpy(r->rparam, ptr, r->rlen);
 801e9c6:	e9d6 0304 	ldrd	r0, r3, [r6, #16]
    len = hciReadPacket->data_len - (1 + HCI_EVENT_HDR_SIZE);
 801e9ca:	f1ac 0203 	sub.w	r2, ip, #3
      r->rlen = MIN(len, r->rlen);
 801e9ce:	429a      	cmp	r2, r3
 801e9d0:	bfa8      	it	ge
 801e9d2:	461a      	movge	r2, r3
      Osal_MemCpy(r->rparam, ptr, r->rlen);
 801e9d4:	310b      	adds	r1, #11
      r->rlen = MIN(len, r->rlen);
 801e9d6:	6172      	str	r2, [r6, #20]
      Osal_MemCpy(r->rparam, ptr, r->rlen);
 801e9d8:	f7fa f932 	bl	8018c40 <Osal_MemCpy>
      goto done;
 801e9dc:	e7b3      	b.n	801e946 <hci_send_req+0xf6>
 801e9de:	bf00      	nop
 801e9e0:	2001330c 	.word	0x2001330c
 801e9e4:	20013314 	.word	0x20013314

0801e9e8 <arm_dot_prod_f32>:
 801e9e8:	b4f0      	push	{r4, r5, r6, r7}
 801e9ea:	0897      	lsrs	r7, r2, #2
 801e9ec:	eddf 5a20 	vldr	s11, [pc, #128]	; 801ea70 <arm_dot_prod_f32+0x88>
 801e9f0:	d02d      	beq.n	801ea4e <arm_dot_prod_f32+0x66>
 801e9f2:	f100 0510 	add.w	r5, r0, #16
 801e9f6:	f101 0410 	add.w	r4, r1, #16
 801e9fa:	463e      	mov	r6, r7
 801e9fc:	ed54 7a04 	vldr	s15, [r4, #-16]
 801ea00:	ed15 6a04 	vldr	s12, [r5, #-16]
 801ea04:	ed55 6a03 	vldr	s13, [r5, #-12]
 801ea08:	ed54 3a03 	vldr	s7, [r4, #-12]
 801ea0c:	ed15 7a02 	vldr	s14, [r5, #-8]
 801ea10:	ed14 4a02 	vldr	s8, [r4, #-8]
 801ea14:	ed15 5a01 	vldr	s10, [r5, #-4]
 801ea18:	ed54 4a01 	vldr	s9, [r4, #-4]
 801ea1c:	ee26 6a27 	vmul.f32	s12, s12, s15
 801ea20:	ee66 6aa3 	vmul.f32	s13, s13, s7
 801ea24:	ee76 7a25 	vadd.f32	s15, s12, s11
 801ea28:	ee27 7a04 	vmul.f32	s14, s14, s8
 801ea2c:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801ea30:	ee65 5a24 	vmul.f32	s11, s10, s9
 801ea34:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ea38:	3e01      	subs	r6, #1
 801ea3a:	f105 0510 	add.w	r5, r5, #16
 801ea3e:	ee75 5aa7 	vadd.f32	s11, s11, s15
 801ea42:	f104 0410 	add.w	r4, r4, #16
 801ea46:	d1d9      	bne.n	801e9fc <arm_dot_prod_f32+0x14>
 801ea48:	013f      	lsls	r7, r7, #4
 801ea4a:	4438      	add	r0, r7
 801ea4c:	4439      	add	r1, r7
 801ea4e:	f012 0203 	ands.w	r2, r2, #3
 801ea52:	d009      	beq.n	801ea68 <arm_dot_prod_f32+0x80>
 801ea54:	ecf0 7a01 	vldmia	r0!, {s15}
 801ea58:	ecb1 7a01 	vldmia	r1!, {s14}
 801ea5c:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ea60:	3a01      	subs	r2, #1
 801ea62:	ee75 5aa7 	vadd.f32	s11, s11, s15
 801ea66:	d1f5      	bne.n	801ea54 <arm_dot_prod_f32+0x6c>
 801ea68:	edc3 5a00 	vstr	s11, [r3]
 801ea6c:	bcf0      	pop	{r4, r5, r6, r7}
 801ea6e:	4770      	bx	lr
 801ea70:	00000000 	.word	0x00000000

0801ea74 <__aeabi_memclr>:
 801ea74:	2200      	movs	r2, #0
 801ea76:	f7e8 ba63 	b.w	8006f40 <__aeabi_memset>

0801ea7a <__aeabi_memcpy>:
 801ea7a:	f000 b84e 	b.w	801eb1a <memcpy>

0801ea7e <atoi>:
 801ea7e:	220a      	movs	r2, #10
 801ea80:	2100      	movs	r1, #0
 801ea82:	f000 be37 	b.w	801f6f4 <strtol>
	...

0801ea88 <__errno>:
 801ea88:	4b01      	ldr	r3, [pc, #4]	; (801ea90 <__errno+0x8>)
 801ea8a:	6818      	ldr	r0, [r3, #0]
 801ea8c:	4770      	bx	lr
 801ea8e:	bf00      	nop
 801ea90:	20001558 	.word	0x20001558

0801ea94 <__libc_init_array>:
 801ea94:	b570      	push	{r4, r5, r6, lr}
 801ea96:	4e0d      	ldr	r6, [pc, #52]	; (801eacc <__libc_init_array+0x38>)
 801ea98:	4c0d      	ldr	r4, [pc, #52]	; (801ead0 <__libc_init_array+0x3c>)
 801ea9a:	1ba4      	subs	r4, r4, r6
 801ea9c:	10a4      	asrs	r4, r4, #2
 801ea9e:	2500      	movs	r5, #0
 801eaa0:	42a5      	cmp	r5, r4
 801eaa2:	d109      	bne.n	801eab8 <__libc_init_array+0x24>
 801eaa4:	4e0b      	ldr	r6, [pc, #44]	; (801ead4 <__libc_init_array+0x40>)
 801eaa6:	4c0c      	ldr	r4, [pc, #48]	; (801ead8 <__libc_init_array+0x44>)
 801eaa8:	f003 ffa2 	bl	80229f0 <_init>
 801eaac:	1ba4      	subs	r4, r4, r6
 801eaae:	10a4      	asrs	r4, r4, #2
 801eab0:	2500      	movs	r5, #0
 801eab2:	42a5      	cmp	r5, r4
 801eab4:	d105      	bne.n	801eac2 <__libc_init_array+0x2e>
 801eab6:	bd70      	pop	{r4, r5, r6, pc}
 801eab8:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 801eabc:	4798      	blx	r3
 801eabe:	3501      	adds	r5, #1
 801eac0:	e7ee      	b.n	801eaa0 <__libc_init_array+0xc>
 801eac2:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 801eac6:	4798      	blx	r3
 801eac8:	3501      	adds	r5, #1
 801eaca:	e7f2      	b.n	801eab2 <__libc_init_array+0x1e>
 801eacc:	08076188 	.word	0x08076188
 801ead0:	08076188 	.word	0x08076188
 801ead4:	08076188 	.word	0x08076188
 801ead8:	0807618c 	.word	0x0807618c

0801eadc <malloc>:
 801eadc:	4b02      	ldr	r3, [pc, #8]	; (801eae8 <malloc+0xc>)
 801eade:	4601      	mov	r1, r0
 801eae0:	6818      	ldr	r0, [r3, #0]
 801eae2:	f000 b87b 	b.w	801ebdc <_malloc_r>
 801eae6:	bf00      	nop
 801eae8:	20001558 	.word	0x20001558

0801eaec <free>:
 801eaec:	4b02      	ldr	r3, [pc, #8]	; (801eaf8 <free+0xc>)
 801eaee:	4601      	mov	r1, r0
 801eaf0:	6818      	ldr	r0, [r3, #0]
 801eaf2:	f000 b825 	b.w	801eb40 <_free_r>
 801eaf6:	bf00      	nop
 801eaf8:	20001558 	.word	0x20001558

0801eafc <memcmp>:
 801eafc:	b530      	push	{r4, r5, lr}
 801eafe:	2400      	movs	r4, #0
 801eb00:	42a2      	cmp	r2, r4
 801eb02:	d101      	bne.n	801eb08 <memcmp+0xc>
 801eb04:	2000      	movs	r0, #0
 801eb06:	e007      	b.n	801eb18 <memcmp+0x1c>
 801eb08:	5d03      	ldrb	r3, [r0, r4]
 801eb0a:	3401      	adds	r4, #1
 801eb0c:	190d      	adds	r5, r1, r4
 801eb0e:	f815 5c01 	ldrb.w	r5, [r5, #-1]
 801eb12:	42ab      	cmp	r3, r5
 801eb14:	d0f4      	beq.n	801eb00 <memcmp+0x4>
 801eb16:	1b58      	subs	r0, r3, r5
 801eb18:	bd30      	pop	{r4, r5, pc}

0801eb1a <memcpy>:
 801eb1a:	b510      	push	{r4, lr}
 801eb1c:	1e43      	subs	r3, r0, #1
 801eb1e:	440a      	add	r2, r1
 801eb20:	4291      	cmp	r1, r2
 801eb22:	d100      	bne.n	801eb26 <memcpy+0xc>
 801eb24:	bd10      	pop	{r4, pc}
 801eb26:	f811 4b01 	ldrb.w	r4, [r1], #1
 801eb2a:	f803 4f01 	strb.w	r4, [r3, #1]!
 801eb2e:	e7f7      	b.n	801eb20 <memcpy+0x6>

0801eb30 <memset>:
 801eb30:	4402      	add	r2, r0
 801eb32:	4603      	mov	r3, r0
 801eb34:	4293      	cmp	r3, r2
 801eb36:	d100      	bne.n	801eb3a <memset+0xa>
 801eb38:	4770      	bx	lr
 801eb3a:	f803 1b01 	strb.w	r1, [r3], #1
 801eb3e:	e7f9      	b.n	801eb34 <memset+0x4>

0801eb40 <_free_r>:
 801eb40:	b538      	push	{r3, r4, r5, lr}
 801eb42:	4605      	mov	r5, r0
 801eb44:	2900      	cmp	r1, #0
 801eb46:	d045      	beq.n	801ebd4 <_free_r+0x94>
 801eb48:	f851 3c04 	ldr.w	r3, [r1, #-4]
 801eb4c:	1f0c      	subs	r4, r1, #4
 801eb4e:	2b00      	cmp	r3, #0
 801eb50:	bfb8      	it	lt
 801eb52:	18e4      	addlt	r4, r4, r3
 801eb54:	f001 fd16 	bl	8020584 <__malloc_lock>
 801eb58:	4a1f      	ldr	r2, [pc, #124]	; (801ebd8 <_free_r+0x98>)
 801eb5a:	6813      	ldr	r3, [r2, #0]
 801eb5c:	4610      	mov	r0, r2
 801eb5e:	b933      	cbnz	r3, 801eb6e <_free_r+0x2e>
 801eb60:	6063      	str	r3, [r4, #4]
 801eb62:	6014      	str	r4, [r2, #0]
 801eb64:	4628      	mov	r0, r5
 801eb66:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801eb6a:	f001 bd0c 	b.w	8020586 <__malloc_unlock>
 801eb6e:	42a3      	cmp	r3, r4
 801eb70:	d90c      	bls.n	801eb8c <_free_r+0x4c>
 801eb72:	6821      	ldr	r1, [r4, #0]
 801eb74:	1862      	adds	r2, r4, r1
 801eb76:	4293      	cmp	r3, r2
 801eb78:	bf04      	itt	eq
 801eb7a:	681a      	ldreq	r2, [r3, #0]
 801eb7c:	685b      	ldreq	r3, [r3, #4]
 801eb7e:	6063      	str	r3, [r4, #4]
 801eb80:	bf04      	itt	eq
 801eb82:	1852      	addeq	r2, r2, r1
 801eb84:	6022      	streq	r2, [r4, #0]
 801eb86:	6004      	str	r4, [r0, #0]
 801eb88:	e7ec      	b.n	801eb64 <_free_r+0x24>
 801eb8a:	4613      	mov	r3, r2
 801eb8c:	685a      	ldr	r2, [r3, #4]
 801eb8e:	b10a      	cbz	r2, 801eb94 <_free_r+0x54>
 801eb90:	42a2      	cmp	r2, r4
 801eb92:	d9fa      	bls.n	801eb8a <_free_r+0x4a>
 801eb94:	6819      	ldr	r1, [r3, #0]
 801eb96:	1858      	adds	r0, r3, r1
 801eb98:	42a0      	cmp	r0, r4
 801eb9a:	d10b      	bne.n	801ebb4 <_free_r+0x74>
 801eb9c:	6820      	ldr	r0, [r4, #0]
 801eb9e:	4401      	add	r1, r0
 801eba0:	1858      	adds	r0, r3, r1
 801eba2:	4282      	cmp	r2, r0
 801eba4:	6019      	str	r1, [r3, #0]
 801eba6:	d1dd      	bne.n	801eb64 <_free_r+0x24>
 801eba8:	6810      	ldr	r0, [r2, #0]
 801ebaa:	6852      	ldr	r2, [r2, #4]
 801ebac:	605a      	str	r2, [r3, #4]
 801ebae:	4401      	add	r1, r0
 801ebb0:	6019      	str	r1, [r3, #0]
 801ebb2:	e7d7      	b.n	801eb64 <_free_r+0x24>
 801ebb4:	d902      	bls.n	801ebbc <_free_r+0x7c>
 801ebb6:	230c      	movs	r3, #12
 801ebb8:	602b      	str	r3, [r5, #0]
 801ebba:	e7d3      	b.n	801eb64 <_free_r+0x24>
 801ebbc:	6820      	ldr	r0, [r4, #0]
 801ebbe:	1821      	adds	r1, r4, r0
 801ebc0:	428a      	cmp	r2, r1
 801ebc2:	bf04      	itt	eq
 801ebc4:	6811      	ldreq	r1, [r2, #0]
 801ebc6:	6852      	ldreq	r2, [r2, #4]
 801ebc8:	6062      	str	r2, [r4, #4]
 801ebca:	bf04      	itt	eq
 801ebcc:	1809      	addeq	r1, r1, r0
 801ebce:	6021      	streq	r1, [r4, #0]
 801ebd0:	605c      	str	r4, [r3, #4]
 801ebd2:	e7c7      	b.n	801eb64 <_free_r+0x24>
 801ebd4:	bd38      	pop	{r3, r4, r5, pc}
 801ebd6:	bf00      	nop
 801ebd8:	200103d0 	.word	0x200103d0

0801ebdc <_malloc_r>:
 801ebdc:	b570      	push	{r4, r5, r6, lr}
 801ebde:	1ccd      	adds	r5, r1, #3
 801ebe0:	f025 0503 	bic.w	r5, r5, #3
 801ebe4:	3508      	adds	r5, #8
 801ebe6:	2d0c      	cmp	r5, #12
 801ebe8:	bf38      	it	cc
 801ebea:	250c      	movcc	r5, #12
 801ebec:	2d00      	cmp	r5, #0
 801ebee:	4606      	mov	r6, r0
 801ebf0:	db01      	blt.n	801ebf6 <_malloc_r+0x1a>
 801ebf2:	42a9      	cmp	r1, r5
 801ebf4:	d903      	bls.n	801ebfe <_malloc_r+0x22>
 801ebf6:	230c      	movs	r3, #12
 801ebf8:	6033      	str	r3, [r6, #0]
 801ebfa:	2000      	movs	r0, #0
 801ebfc:	bd70      	pop	{r4, r5, r6, pc}
 801ebfe:	f001 fcc1 	bl	8020584 <__malloc_lock>
 801ec02:	4a21      	ldr	r2, [pc, #132]	; (801ec88 <_malloc_r+0xac>)
 801ec04:	6814      	ldr	r4, [r2, #0]
 801ec06:	4621      	mov	r1, r4
 801ec08:	b991      	cbnz	r1, 801ec30 <_malloc_r+0x54>
 801ec0a:	4c20      	ldr	r4, [pc, #128]	; (801ec8c <_malloc_r+0xb0>)
 801ec0c:	6823      	ldr	r3, [r4, #0]
 801ec0e:	b91b      	cbnz	r3, 801ec18 <_malloc_r+0x3c>
 801ec10:	4630      	mov	r0, r6
 801ec12:	f000 fcb1 	bl	801f578 <_sbrk_r>
 801ec16:	6020      	str	r0, [r4, #0]
 801ec18:	4629      	mov	r1, r5
 801ec1a:	4630      	mov	r0, r6
 801ec1c:	f000 fcac 	bl	801f578 <_sbrk_r>
 801ec20:	1c43      	adds	r3, r0, #1
 801ec22:	d124      	bne.n	801ec6e <_malloc_r+0x92>
 801ec24:	230c      	movs	r3, #12
 801ec26:	6033      	str	r3, [r6, #0]
 801ec28:	4630      	mov	r0, r6
 801ec2a:	f001 fcac 	bl	8020586 <__malloc_unlock>
 801ec2e:	e7e4      	b.n	801ebfa <_malloc_r+0x1e>
 801ec30:	680b      	ldr	r3, [r1, #0]
 801ec32:	1b5b      	subs	r3, r3, r5
 801ec34:	d418      	bmi.n	801ec68 <_malloc_r+0x8c>
 801ec36:	2b0b      	cmp	r3, #11
 801ec38:	d90f      	bls.n	801ec5a <_malloc_r+0x7e>
 801ec3a:	600b      	str	r3, [r1, #0]
 801ec3c:	50cd      	str	r5, [r1, r3]
 801ec3e:	18cc      	adds	r4, r1, r3
 801ec40:	4630      	mov	r0, r6
 801ec42:	f001 fca0 	bl	8020586 <__malloc_unlock>
 801ec46:	f104 000b 	add.w	r0, r4, #11
 801ec4a:	1d23      	adds	r3, r4, #4
 801ec4c:	f020 0007 	bic.w	r0, r0, #7
 801ec50:	1ac3      	subs	r3, r0, r3
 801ec52:	d0d3      	beq.n	801ebfc <_malloc_r+0x20>
 801ec54:	425a      	negs	r2, r3
 801ec56:	50e2      	str	r2, [r4, r3]
 801ec58:	e7d0      	b.n	801ebfc <_malloc_r+0x20>
 801ec5a:	428c      	cmp	r4, r1
 801ec5c:	684b      	ldr	r3, [r1, #4]
 801ec5e:	bf16      	itet	ne
 801ec60:	6063      	strne	r3, [r4, #4]
 801ec62:	6013      	streq	r3, [r2, #0]
 801ec64:	460c      	movne	r4, r1
 801ec66:	e7eb      	b.n	801ec40 <_malloc_r+0x64>
 801ec68:	460c      	mov	r4, r1
 801ec6a:	6849      	ldr	r1, [r1, #4]
 801ec6c:	e7cc      	b.n	801ec08 <_malloc_r+0x2c>
 801ec6e:	1cc4      	adds	r4, r0, #3
 801ec70:	f024 0403 	bic.w	r4, r4, #3
 801ec74:	42a0      	cmp	r0, r4
 801ec76:	d005      	beq.n	801ec84 <_malloc_r+0xa8>
 801ec78:	1a21      	subs	r1, r4, r0
 801ec7a:	4630      	mov	r0, r6
 801ec7c:	f000 fc7c 	bl	801f578 <_sbrk_r>
 801ec80:	3001      	adds	r0, #1
 801ec82:	d0cf      	beq.n	801ec24 <_malloc_r+0x48>
 801ec84:	6025      	str	r5, [r4, #0]
 801ec86:	e7db      	b.n	801ec40 <_malloc_r+0x64>
 801ec88:	200103d0 	.word	0x200103d0
 801ec8c:	200103d4 	.word	0x200103d4

0801ec90 <__cvt>:
 801ec90:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 801ec94:	ec55 4b10 	vmov	r4, r5, d0
 801ec98:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 801ec9a:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
 801ec9e:	2d00      	cmp	r5, #0
 801eca0:	460e      	mov	r6, r1
 801eca2:	4691      	mov	r9, r2
 801eca4:	4619      	mov	r1, r3
 801eca6:	bfb8      	it	lt
 801eca8:	4622      	movlt	r2, r4
 801ecaa:	462b      	mov	r3, r5
 801ecac:	f027 0720 	bic.w	r7, r7, #32
 801ecb0:	bfbb      	ittet	lt
 801ecb2:	f105 4300 	addlt.w	r3, r5, #2147483648	; 0x80000000
 801ecb6:	461d      	movlt	r5, r3
 801ecb8:	2300      	movge	r3, #0
 801ecba:	232d      	movlt	r3, #45	; 0x2d
 801ecbc:	bfb8      	it	lt
 801ecbe:	4614      	movlt	r4, r2
 801ecc0:	2f46      	cmp	r7, #70	; 0x46
 801ecc2:	700b      	strb	r3, [r1, #0]
 801ecc4:	d004      	beq.n	801ecd0 <__cvt+0x40>
 801ecc6:	2f45      	cmp	r7, #69	; 0x45
 801ecc8:	d100      	bne.n	801eccc <__cvt+0x3c>
 801ecca:	3601      	adds	r6, #1
 801eccc:	2102      	movs	r1, #2
 801ecce:	e000      	b.n	801ecd2 <__cvt+0x42>
 801ecd0:	2103      	movs	r1, #3
 801ecd2:	ab03      	add	r3, sp, #12
 801ecd4:	9301      	str	r3, [sp, #4]
 801ecd6:	ab02      	add	r3, sp, #8
 801ecd8:	9300      	str	r3, [sp, #0]
 801ecda:	4632      	mov	r2, r6
 801ecdc:	4653      	mov	r3, sl
 801ecde:	ec45 4b10 	vmov	d0, r4, r5
 801ece2:	f000 fda9 	bl	801f838 <_dtoa_r>
 801ece6:	2f47      	cmp	r7, #71	; 0x47
 801ece8:	4680      	mov	r8, r0
 801ecea:	d102      	bne.n	801ecf2 <__cvt+0x62>
 801ecec:	f019 0f01 	tst.w	r9, #1
 801ecf0:	d026      	beq.n	801ed40 <__cvt+0xb0>
 801ecf2:	2f46      	cmp	r7, #70	; 0x46
 801ecf4:	eb08 0906 	add.w	r9, r8, r6
 801ecf8:	d111      	bne.n	801ed1e <__cvt+0x8e>
 801ecfa:	f898 3000 	ldrb.w	r3, [r8]
 801ecfe:	2b30      	cmp	r3, #48	; 0x30
 801ed00:	d10a      	bne.n	801ed18 <__cvt+0x88>
 801ed02:	2200      	movs	r2, #0
 801ed04:	2300      	movs	r3, #0
 801ed06:	4620      	mov	r0, r4
 801ed08:	4629      	mov	r1, r5
 801ed0a:	f7e8 fde5 	bl	80078d8 <__aeabi_dcmpeq>
 801ed0e:	b918      	cbnz	r0, 801ed18 <__cvt+0x88>
 801ed10:	f1c6 0601 	rsb	r6, r6, #1
 801ed14:	f8ca 6000 	str.w	r6, [sl]
 801ed18:	f8da 3000 	ldr.w	r3, [sl]
 801ed1c:	4499      	add	r9, r3
 801ed1e:	2200      	movs	r2, #0
 801ed20:	2300      	movs	r3, #0
 801ed22:	4620      	mov	r0, r4
 801ed24:	4629      	mov	r1, r5
 801ed26:	f7e8 fdd7 	bl	80078d8 <__aeabi_dcmpeq>
 801ed2a:	b938      	cbnz	r0, 801ed3c <__cvt+0xac>
 801ed2c:	2230      	movs	r2, #48	; 0x30
 801ed2e:	9b03      	ldr	r3, [sp, #12]
 801ed30:	454b      	cmp	r3, r9
 801ed32:	d205      	bcs.n	801ed40 <__cvt+0xb0>
 801ed34:	1c59      	adds	r1, r3, #1
 801ed36:	9103      	str	r1, [sp, #12]
 801ed38:	701a      	strb	r2, [r3, #0]
 801ed3a:	e7f8      	b.n	801ed2e <__cvt+0x9e>
 801ed3c:	f8cd 900c 	str.w	r9, [sp, #12]
 801ed40:	9b03      	ldr	r3, [sp, #12]
 801ed42:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801ed44:	eba3 0308 	sub.w	r3, r3, r8
 801ed48:	4640      	mov	r0, r8
 801ed4a:	6013      	str	r3, [r2, #0]
 801ed4c:	b004      	add	sp, #16
 801ed4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0801ed52 <__exponent>:
 801ed52:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801ed54:	2900      	cmp	r1, #0
 801ed56:	4604      	mov	r4, r0
 801ed58:	bfba      	itte	lt
 801ed5a:	4249      	neglt	r1, r1
 801ed5c:	232d      	movlt	r3, #45	; 0x2d
 801ed5e:	232b      	movge	r3, #43	; 0x2b
 801ed60:	2909      	cmp	r1, #9
 801ed62:	f804 2b02 	strb.w	r2, [r4], #2
 801ed66:	7043      	strb	r3, [r0, #1]
 801ed68:	dd20      	ble.n	801edac <__exponent+0x5a>
 801ed6a:	f10d 0307 	add.w	r3, sp, #7
 801ed6e:	461f      	mov	r7, r3
 801ed70:	260a      	movs	r6, #10
 801ed72:	fb91 f5f6 	sdiv	r5, r1, r6
 801ed76:	fb06 1115 	mls	r1, r6, r5, r1
 801ed7a:	3130      	adds	r1, #48	; 0x30
 801ed7c:	2d09      	cmp	r5, #9
 801ed7e:	f803 1c01 	strb.w	r1, [r3, #-1]
 801ed82:	f103 32ff 	add.w	r2, r3, #4294967295
 801ed86:	4629      	mov	r1, r5
 801ed88:	dc09      	bgt.n	801ed9e <__exponent+0x4c>
 801ed8a:	3130      	adds	r1, #48	; 0x30
 801ed8c:	3b02      	subs	r3, #2
 801ed8e:	f802 1c01 	strb.w	r1, [r2, #-1]
 801ed92:	42bb      	cmp	r3, r7
 801ed94:	4622      	mov	r2, r4
 801ed96:	d304      	bcc.n	801eda2 <__exponent+0x50>
 801ed98:	1a10      	subs	r0, r2, r0
 801ed9a:	b003      	add	sp, #12
 801ed9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801ed9e:	4613      	mov	r3, r2
 801eda0:	e7e7      	b.n	801ed72 <__exponent+0x20>
 801eda2:	f813 2b01 	ldrb.w	r2, [r3], #1
 801eda6:	f804 2b01 	strb.w	r2, [r4], #1
 801edaa:	e7f2      	b.n	801ed92 <__exponent+0x40>
 801edac:	2330      	movs	r3, #48	; 0x30
 801edae:	4419      	add	r1, r3
 801edb0:	7083      	strb	r3, [r0, #2]
 801edb2:	1d02      	adds	r2, r0, #4
 801edb4:	70c1      	strb	r1, [r0, #3]
 801edb6:	e7ef      	b.n	801ed98 <__exponent+0x46>

0801edb8 <_printf_float>:
 801edb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801edbc:	b08d      	sub	sp, #52	; 0x34
 801edbe:	460c      	mov	r4, r1
 801edc0:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
 801edc4:	4616      	mov	r6, r2
 801edc6:	461f      	mov	r7, r3
 801edc8:	4605      	mov	r5, r0
 801edca:	f001 fbbb 	bl	8020544 <_localeconv_r>
 801edce:	6803      	ldr	r3, [r0, #0]
 801edd0:	9304      	str	r3, [sp, #16]
 801edd2:	4618      	mov	r0, r3
 801edd4:	f7e8 f901 	bl	8006fda <strlen>
 801edd8:	2300      	movs	r3, #0
 801edda:	930a      	str	r3, [sp, #40]	; 0x28
 801eddc:	f8d8 3000 	ldr.w	r3, [r8]
 801ede0:	9005      	str	r0, [sp, #20]
 801ede2:	3307      	adds	r3, #7
 801ede4:	f023 0307 	bic.w	r3, r3, #7
 801ede8:	f103 0208 	add.w	r2, r3, #8
 801edec:	f894 a018 	ldrb.w	sl, [r4, #24]
 801edf0:	f8d4 b000 	ldr.w	fp, [r4]
 801edf4:	f8c8 2000 	str.w	r2, [r8]
 801edf8:	e9d3 2300 	ldrd	r2, r3, [r3]
 801edfc:	e9c4 2312 	strd	r2, r3, [r4, #72]	; 0x48
 801ee00:	e9d4 8912 	ldrd	r8, r9, [r4, #72]	; 0x48
 801ee04:	f029 4300 	bic.w	r3, r9, #2147483648	; 0x80000000
 801ee08:	9307      	str	r3, [sp, #28]
 801ee0a:	f8cd 8018 	str.w	r8, [sp, #24]
 801ee0e:	f04f 32ff 	mov.w	r2, #4294967295
 801ee12:	4ba7      	ldr	r3, [pc, #668]	; (801f0b0 <_printf_float+0x2f8>)
 801ee14:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801ee18:	f7e8 fd90 	bl	800793c <__aeabi_dcmpun>
 801ee1c:	bb70      	cbnz	r0, 801ee7c <_printf_float+0xc4>
 801ee1e:	f04f 32ff 	mov.w	r2, #4294967295
 801ee22:	4ba3      	ldr	r3, [pc, #652]	; (801f0b0 <_printf_float+0x2f8>)
 801ee24:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801ee28:	f7e8 fd6a 	bl	8007900 <__aeabi_dcmple>
 801ee2c:	bb30      	cbnz	r0, 801ee7c <_printf_float+0xc4>
 801ee2e:	2200      	movs	r2, #0
 801ee30:	2300      	movs	r3, #0
 801ee32:	4640      	mov	r0, r8
 801ee34:	4649      	mov	r1, r9
 801ee36:	f7e8 fd59 	bl	80078ec <__aeabi_dcmplt>
 801ee3a:	b110      	cbz	r0, 801ee42 <_printf_float+0x8a>
 801ee3c:	232d      	movs	r3, #45	; 0x2d
 801ee3e:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 801ee42:	4a9c      	ldr	r2, [pc, #624]	; (801f0b4 <_printf_float+0x2fc>)
 801ee44:	4b9c      	ldr	r3, [pc, #624]	; (801f0b8 <_printf_float+0x300>)
 801ee46:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
 801ee4a:	bf8c      	ite	hi
 801ee4c:	4690      	movhi	r8, r2
 801ee4e:	4698      	movls	r8, r3
 801ee50:	2303      	movs	r3, #3
 801ee52:	f02b 0204 	bic.w	r2, fp, #4
 801ee56:	6123      	str	r3, [r4, #16]
 801ee58:	6022      	str	r2, [r4, #0]
 801ee5a:	f04f 0900 	mov.w	r9, #0
 801ee5e:	9700      	str	r7, [sp, #0]
 801ee60:	4633      	mov	r3, r6
 801ee62:	aa0b      	add	r2, sp, #44	; 0x2c
 801ee64:	4621      	mov	r1, r4
 801ee66:	4628      	mov	r0, r5
 801ee68:	f000 f9e6 	bl	801f238 <_printf_common>
 801ee6c:	3001      	adds	r0, #1
 801ee6e:	f040 808d 	bne.w	801ef8c <_printf_float+0x1d4>
 801ee72:	f04f 30ff 	mov.w	r0, #4294967295
 801ee76:	b00d      	add	sp, #52	; 0x34
 801ee78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801ee7c:	4642      	mov	r2, r8
 801ee7e:	464b      	mov	r3, r9
 801ee80:	4640      	mov	r0, r8
 801ee82:	4649      	mov	r1, r9
 801ee84:	f7e8 fd5a 	bl	800793c <__aeabi_dcmpun>
 801ee88:	b110      	cbz	r0, 801ee90 <_printf_float+0xd8>
 801ee8a:	4a8c      	ldr	r2, [pc, #560]	; (801f0bc <_printf_float+0x304>)
 801ee8c:	4b8c      	ldr	r3, [pc, #560]	; (801f0c0 <_printf_float+0x308>)
 801ee8e:	e7da      	b.n	801ee46 <_printf_float+0x8e>
 801ee90:	6861      	ldr	r1, [r4, #4]
 801ee92:	1c4b      	adds	r3, r1, #1
 801ee94:	f44b 6280 	orr.w	r2, fp, #1024	; 0x400
 801ee98:	a80a      	add	r0, sp, #40	; 0x28
 801ee9a:	d13e      	bne.n	801ef1a <_printf_float+0x162>
 801ee9c:	2306      	movs	r3, #6
 801ee9e:	6063      	str	r3, [r4, #4]
 801eea0:	2300      	movs	r3, #0
 801eea2:	e9cd 0302 	strd	r0, r3, [sp, #8]
 801eea6:	ab09      	add	r3, sp, #36	; 0x24
 801eea8:	9300      	str	r3, [sp, #0]
 801eeaa:	ec49 8b10 	vmov	d0, r8, r9
 801eeae:	f10d 0323 	add.w	r3, sp, #35	; 0x23
 801eeb2:	6022      	str	r2, [r4, #0]
 801eeb4:	f8cd a004 	str.w	sl, [sp, #4]
 801eeb8:	6861      	ldr	r1, [r4, #4]
 801eeba:	4628      	mov	r0, r5
 801eebc:	f7ff fee8 	bl	801ec90 <__cvt>
 801eec0:	f00a 03df 	and.w	r3, sl, #223	; 0xdf
 801eec4:	2b47      	cmp	r3, #71	; 0x47
 801eec6:	4680      	mov	r8, r0
 801eec8:	d109      	bne.n	801eede <_printf_float+0x126>
 801eeca:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801eecc:	1cd8      	adds	r0, r3, #3
 801eece:	db02      	blt.n	801eed6 <_printf_float+0x11e>
 801eed0:	6862      	ldr	r2, [r4, #4]
 801eed2:	4293      	cmp	r3, r2
 801eed4:	dd47      	ble.n	801ef66 <_printf_float+0x1ae>
 801eed6:	f1aa 0a02 	sub.w	sl, sl, #2
 801eeda:	fa5f fa8a 	uxtb.w	sl, sl
 801eede:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 801eee2:	9909      	ldr	r1, [sp, #36]	; 0x24
 801eee4:	d824      	bhi.n	801ef30 <_printf_float+0x178>
 801eee6:	3901      	subs	r1, #1
 801eee8:	4652      	mov	r2, sl
 801eeea:	f104 0050 	add.w	r0, r4, #80	; 0x50
 801eeee:	9109      	str	r1, [sp, #36]	; 0x24
 801eef0:	f7ff ff2f 	bl	801ed52 <__exponent>
 801eef4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801eef6:	1813      	adds	r3, r2, r0
 801eef8:	2a01      	cmp	r2, #1
 801eefa:	4681      	mov	r9, r0
 801eefc:	6123      	str	r3, [r4, #16]
 801eefe:	dc02      	bgt.n	801ef06 <_printf_float+0x14e>
 801ef00:	6822      	ldr	r2, [r4, #0]
 801ef02:	07d1      	lsls	r1, r2, #31
 801ef04:	d501      	bpl.n	801ef0a <_printf_float+0x152>
 801ef06:	3301      	adds	r3, #1
 801ef08:	6123      	str	r3, [r4, #16]
 801ef0a:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 801ef0e:	2b00      	cmp	r3, #0
 801ef10:	d0a5      	beq.n	801ee5e <_printf_float+0xa6>
 801ef12:	232d      	movs	r3, #45	; 0x2d
 801ef14:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 801ef18:	e7a1      	b.n	801ee5e <_printf_float+0xa6>
 801ef1a:	f1ba 0f67 	cmp.w	sl, #103	; 0x67
 801ef1e:	f000 8177 	beq.w	801f210 <_printf_float+0x458>
 801ef22:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
 801ef26:	d1bb      	bne.n	801eea0 <_printf_float+0xe8>
 801ef28:	2900      	cmp	r1, #0
 801ef2a:	d1b9      	bne.n	801eea0 <_printf_float+0xe8>
 801ef2c:	2301      	movs	r3, #1
 801ef2e:	e7b6      	b.n	801ee9e <_printf_float+0xe6>
 801ef30:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 801ef34:	d119      	bne.n	801ef6a <_printf_float+0x1b2>
 801ef36:	2900      	cmp	r1, #0
 801ef38:	6863      	ldr	r3, [r4, #4]
 801ef3a:	dd0c      	ble.n	801ef56 <_printf_float+0x19e>
 801ef3c:	6121      	str	r1, [r4, #16]
 801ef3e:	b913      	cbnz	r3, 801ef46 <_printf_float+0x18e>
 801ef40:	6822      	ldr	r2, [r4, #0]
 801ef42:	07d2      	lsls	r2, r2, #31
 801ef44:	d502      	bpl.n	801ef4c <_printf_float+0x194>
 801ef46:	3301      	adds	r3, #1
 801ef48:	440b      	add	r3, r1
 801ef4a:	6123      	str	r3, [r4, #16]
 801ef4c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801ef4e:	65a3      	str	r3, [r4, #88]	; 0x58
 801ef50:	f04f 0900 	mov.w	r9, #0
 801ef54:	e7d9      	b.n	801ef0a <_printf_float+0x152>
 801ef56:	b913      	cbnz	r3, 801ef5e <_printf_float+0x1a6>
 801ef58:	6822      	ldr	r2, [r4, #0]
 801ef5a:	07d0      	lsls	r0, r2, #31
 801ef5c:	d501      	bpl.n	801ef62 <_printf_float+0x1aa>
 801ef5e:	3302      	adds	r3, #2
 801ef60:	e7f3      	b.n	801ef4a <_printf_float+0x192>
 801ef62:	2301      	movs	r3, #1
 801ef64:	e7f1      	b.n	801ef4a <_printf_float+0x192>
 801ef66:	f04f 0a67 	mov.w	sl, #103	; 0x67
 801ef6a:	e9dd 3209 	ldrd	r3, r2, [sp, #36]	; 0x24
 801ef6e:	4293      	cmp	r3, r2
 801ef70:	db05      	blt.n	801ef7e <_printf_float+0x1c6>
 801ef72:	6822      	ldr	r2, [r4, #0]
 801ef74:	6123      	str	r3, [r4, #16]
 801ef76:	07d1      	lsls	r1, r2, #31
 801ef78:	d5e8      	bpl.n	801ef4c <_printf_float+0x194>
 801ef7a:	3301      	adds	r3, #1
 801ef7c:	e7e5      	b.n	801ef4a <_printf_float+0x192>
 801ef7e:	2b00      	cmp	r3, #0
 801ef80:	bfd4      	ite	le
 801ef82:	f1c3 0302 	rsble	r3, r3, #2
 801ef86:	2301      	movgt	r3, #1
 801ef88:	4413      	add	r3, r2
 801ef8a:	e7de      	b.n	801ef4a <_printf_float+0x192>
 801ef8c:	6823      	ldr	r3, [r4, #0]
 801ef8e:	055a      	lsls	r2, r3, #21
 801ef90:	d407      	bmi.n	801efa2 <_printf_float+0x1ea>
 801ef92:	6923      	ldr	r3, [r4, #16]
 801ef94:	4642      	mov	r2, r8
 801ef96:	4631      	mov	r1, r6
 801ef98:	4628      	mov	r0, r5
 801ef9a:	47b8      	blx	r7
 801ef9c:	3001      	adds	r0, #1
 801ef9e:	d12b      	bne.n	801eff8 <_printf_float+0x240>
 801efa0:	e767      	b.n	801ee72 <_printf_float+0xba>
 801efa2:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 801efa6:	f240 80dc 	bls.w	801f162 <_printf_float+0x3aa>
 801efaa:	2200      	movs	r2, #0
 801efac:	2300      	movs	r3, #0
 801efae:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
 801efb2:	f7e8 fc91 	bl	80078d8 <__aeabi_dcmpeq>
 801efb6:	2800      	cmp	r0, #0
 801efb8:	d033      	beq.n	801f022 <_printf_float+0x26a>
 801efba:	2301      	movs	r3, #1
 801efbc:	4a41      	ldr	r2, [pc, #260]	; (801f0c4 <_printf_float+0x30c>)
 801efbe:	4631      	mov	r1, r6
 801efc0:	4628      	mov	r0, r5
 801efc2:	47b8      	blx	r7
 801efc4:	3001      	adds	r0, #1
 801efc6:	f43f af54 	beq.w	801ee72 <_printf_float+0xba>
 801efca:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 801efce:	429a      	cmp	r2, r3
 801efd0:	db02      	blt.n	801efd8 <_printf_float+0x220>
 801efd2:	6823      	ldr	r3, [r4, #0]
 801efd4:	07d8      	lsls	r0, r3, #31
 801efd6:	d50f      	bpl.n	801eff8 <_printf_float+0x240>
 801efd8:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 801efdc:	4631      	mov	r1, r6
 801efde:	4628      	mov	r0, r5
 801efe0:	47b8      	blx	r7
 801efe2:	3001      	adds	r0, #1
 801efe4:	f43f af45 	beq.w	801ee72 <_printf_float+0xba>
 801efe8:	f04f 0800 	mov.w	r8, #0
 801efec:	f104 091a 	add.w	r9, r4, #26
 801eff0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801eff2:	3b01      	subs	r3, #1
 801eff4:	4543      	cmp	r3, r8
 801eff6:	dc09      	bgt.n	801f00c <_printf_float+0x254>
 801eff8:	6823      	ldr	r3, [r4, #0]
 801effa:	079b      	lsls	r3, r3, #30
 801effc:	f100 8103 	bmi.w	801f206 <_printf_float+0x44e>
 801f000:	68e0      	ldr	r0, [r4, #12]
 801f002:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801f004:	4298      	cmp	r0, r3
 801f006:	bfb8      	it	lt
 801f008:	4618      	movlt	r0, r3
 801f00a:	e734      	b.n	801ee76 <_printf_float+0xbe>
 801f00c:	2301      	movs	r3, #1
 801f00e:	464a      	mov	r2, r9
 801f010:	4631      	mov	r1, r6
 801f012:	4628      	mov	r0, r5
 801f014:	47b8      	blx	r7
 801f016:	3001      	adds	r0, #1
 801f018:	f43f af2b 	beq.w	801ee72 <_printf_float+0xba>
 801f01c:	f108 0801 	add.w	r8, r8, #1
 801f020:	e7e6      	b.n	801eff0 <_printf_float+0x238>
 801f022:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f024:	2b00      	cmp	r3, #0
 801f026:	dc2b      	bgt.n	801f080 <_printf_float+0x2c8>
 801f028:	2301      	movs	r3, #1
 801f02a:	4a26      	ldr	r2, [pc, #152]	; (801f0c4 <_printf_float+0x30c>)
 801f02c:	4631      	mov	r1, r6
 801f02e:	4628      	mov	r0, r5
 801f030:	47b8      	blx	r7
 801f032:	3001      	adds	r0, #1
 801f034:	f43f af1d 	beq.w	801ee72 <_printf_float+0xba>
 801f038:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f03a:	b923      	cbnz	r3, 801f046 <_printf_float+0x28e>
 801f03c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801f03e:	b913      	cbnz	r3, 801f046 <_printf_float+0x28e>
 801f040:	6823      	ldr	r3, [r4, #0]
 801f042:	07d9      	lsls	r1, r3, #31
 801f044:	d5d8      	bpl.n	801eff8 <_printf_float+0x240>
 801f046:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 801f04a:	4631      	mov	r1, r6
 801f04c:	4628      	mov	r0, r5
 801f04e:	47b8      	blx	r7
 801f050:	3001      	adds	r0, #1
 801f052:	f43f af0e 	beq.w	801ee72 <_printf_float+0xba>
 801f056:	f04f 0900 	mov.w	r9, #0
 801f05a:	f104 0a1a 	add.w	sl, r4, #26
 801f05e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f060:	425b      	negs	r3, r3
 801f062:	454b      	cmp	r3, r9
 801f064:	dc01      	bgt.n	801f06a <_printf_float+0x2b2>
 801f066:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801f068:	e794      	b.n	801ef94 <_printf_float+0x1dc>
 801f06a:	2301      	movs	r3, #1
 801f06c:	4652      	mov	r2, sl
 801f06e:	4631      	mov	r1, r6
 801f070:	4628      	mov	r0, r5
 801f072:	47b8      	blx	r7
 801f074:	3001      	adds	r0, #1
 801f076:	f43f aefc 	beq.w	801ee72 <_printf_float+0xba>
 801f07a:	f109 0901 	add.w	r9, r9, #1
 801f07e:	e7ee      	b.n	801f05e <_printf_float+0x2a6>
 801f080:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801f082:	6da3      	ldr	r3, [r4, #88]	; 0x58
 801f084:	429a      	cmp	r2, r3
 801f086:	bfa8      	it	ge
 801f088:	461a      	movge	r2, r3
 801f08a:	2a00      	cmp	r2, #0
 801f08c:	4691      	mov	r9, r2
 801f08e:	dd07      	ble.n	801f0a0 <_printf_float+0x2e8>
 801f090:	4613      	mov	r3, r2
 801f092:	4631      	mov	r1, r6
 801f094:	4642      	mov	r2, r8
 801f096:	4628      	mov	r0, r5
 801f098:	47b8      	blx	r7
 801f09a:	3001      	adds	r0, #1
 801f09c:	f43f aee9 	beq.w	801ee72 <_printf_float+0xba>
 801f0a0:	f104 031a 	add.w	r3, r4, #26
 801f0a4:	f04f 0b00 	mov.w	fp, #0
 801f0a8:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 801f0ac:	9306      	str	r3, [sp, #24]
 801f0ae:	e015      	b.n	801f0dc <_printf_float+0x324>
 801f0b0:	7fefffff 	.word	0x7fefffff
 801f0b4:	08075e7c 	.word	0x08075e7c
 801f0b8:	08075e78 	.word	0x08075e78
 801f0bc:	08075e84 	.word	0x08075e84
 801f0c0:	08075e80 	.word	0x08075e80
 801f0c4:	08075e88 	.word	0x08075e88
 801f0c8:	2301      	movs	r3, #1
 801f0ca:	9a06      	ldr	r2, [sp, #24]
 801f0cc:	4631      	mov	r1, r6
 801f0ce:	4628      	mov	r0, r5
 801f0d0:	47b8      	blx	r7
 801f0d2:	3001      	adds	r0, #1
 801f0d4:	f43f aecd 	beq.w	801ee72 <_printf_float+0xba>
 801f0d8:	f10b 0b01 	add.w	fp, fp, #1
 801f0dc:	f8d4 a058 	ldr.w	sl, [r4, #88]	; 0x58
 801f0e0:	ebaa 0309 	sub.w	r3, sl, r9
 801f0e4:	455b      	cmp	r3, fp
 801f0e6:	dcef      	bgt.n	801f0c8 <_printf_float+0x310>
 801f0e8:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 801f0ec:	429a      	cmp	r2, r3
 801f0ee:	44d0      	add	r8, sl
 801f0f0:	db15      	blt.n	801f11e <_printf_float+0x366>
 801f0f2:	6823      	ldr	r3, [r4, #0]
 801f0f4:	07da      	lsls	r2, r3, #31
 801f0f6:	d412      	bmi.n	801f11e <_printf_float+0x366>
 801f0f8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801f0fa:	9909      	ldr	r1, [sp, #36]	; 0x24
 801f0fc:	eba3 020a 	sub.w	r2, r3, sl
 801f100:	eba3 0a01 	sub.w	sl, r3, r1
 801f104:	4592      	cmp	sl, r2
 801f106:	bfa8      	it	ge
 801f108:	4692      	movge	sl, r2
 801f10a:	f1ba 0f00 	cmp.w	sl, #0
 801f10e:	dc0e      	bgt.n	801f12e <_printf_float+0x376>
 801f110:	f04f 0800 	mov.w	r8, #0
 801f114:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 801f118:	f104 091a 	add.w	r9, r4, #26
 801f11c:	e019      	b.n	801f152 <_printf_float+0x39a>
 801f11e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 801f122:	4631      	mov	r1, r6
 801f124:	4628      	mov	r0, r5
 801f126:	47b8      	blx	r7
 801f128:	3001      	adds	r0, #1
 801f12a:	d1e5      	bne.n	801f0f8 <_printf_float+0x340>
 801f12c:	e6a1      	b.n	801ee72 <_printf_float+0xba>
 801f12e:	4653      	mov	r3, sl
 801f130:	4642      	mov	r2, r8
 801f132:	4631      	mov	r1, r6
 801f134:	4628      	mov	r0, r5
 801f136:	47b8      	blx	r7
 801f138:	3001      	adds	r0, #1
 801f13a:	d1e9      	bne.n	801f110 <_printf_float+0x358>
 801f13c:	e699      	b.n	801ee72 <_printf_float+0xba>
 801f13e:	2301      	movs	r3, #1
 801f140:	464a      	mov	r2, r9
 801f142:	4631      	mov	r1, r6
 801f144:	4628      	mov	r0, r5
 801f146:	47b8      	blx	r7
 801f148:	3001      	adds	r0, #1
 801f14a:	f43f ae92 	beq.w	801ee72 <_printf_float+0xba>
 801f14e:	f108 0801 	add.w	r8, r8, #1
 801f152:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 801f156:	1a9b      	subs	r3, r3, r2
 801f158:	eba3 030a 	sub.w	r3, r3, sl
 801f15c:	4543      	cmp	r3, r8
 801f15e:	dcee      	bgt.n	801f13e <_printf_float+0x386>
 801f160:	e74a      	b.n	801eff8 <_printf_float+0x240>
 801f162:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801f164:	2a01      	cmp	r2, #1
 801f166:	dc01      	bgt.n	801f16c <_printf_float+0x3b4>
 801f168:	07db      	lsls	r3, r3, #31
 801f16a:	d53a      	bpl.n	801f1e2 <_printf_float+0x42a>
 801f16c:	2301      	movs	r3, #1
 801f16e:	4642      	mov	r2, r8
 801f170:	4631      	mov	r1, r6
 801f172:	4628      	mov	r0, r5
 801f174:	47b8      	blx	r7
 801f176:	3001      	adds	r0, #1
 801f178:	f43f ae7b 	beq.w	801ee72 <_printf_float+0xba>
 801f17c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 801f180:	4631      	mov	r1, r6
 801f182:	4628      	mov	r0, r5
 801f184:	47b8      	blx	r7
 801f186:	3001      	adds	r0, #1
 801f188:	f108 0801 	add.w	r8, r8, #1
 801f18c:	f43f ae71 	beq.w	801ee72 <_printf_float+0xba>
 801f190:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801f192:	2200      	movs	r2, #0
 801f194:	f103 3aff 	add.w	sl, r3, #4294967295
 801f198:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
 801f19c:	2300      	movs	r3, #0
 801f19e:	f7e8 fb9b 	bl	80078d8 <__aeabi_dcmpeq>
 801f1a2:	b9c8      	cbnz	r0, 801f1d8 <_printf_float+0x420>
 801f1a4:	4653      	mov	r3, sl
 801f1a6:	4642      	mov	r2, r8
 801f1a8:	4631      	mov	r1, r6
 801f1aa:	4628      	mov	r0, r5
 801f1ac:	47b8      	blx	r7
 801f1ae:	3001      	adds	r0, #1
 801f1b0:	d10e      	bne.n	801f1d0 <_printf_float+0x418>
 801f1b2:	e65e      	b.n	801ee72 <_printf_float+0xba>
 801f1b4:	2301      	movs	r3, #1
 801f1b6:	4652      	mov	r2, sl
 801f1b8:	4631      	mov	r1, r6
 801f1ba:	4628      	mov	r0, r5
 801f1bc:	47b8      	blx	r7
 801f1be:	3001      	adds	r0, #1
 801f1c0:	f43f ae57 	beq.w	801ee72 <_printf_float+0xba>
 801f1c4:	f108 0801 	add.w	r8, r8, #1
 801f1c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801f1ca:	3b01      	subs	r3, #1
 801f1cc:	4543      	cmp	r3, r8
 801f1ce:	dcf1      	bgt.n	801f1b4 <_printf_float+0x3fc>
 801f1d0:	464b      	mov	r3, r9
 801f1d2:	f104 0250 	add.w	r2, r4, #80	; 0x50
 801f1d6:	e6de      	b.n	801ef96 <_printf_float+0x1de>
 801f1d8:	f04f 0800 	mov.w	r8, #0
 801f1dc:	f104 0a1a 	add.w	sl, r4, #26
 801f1e0:	e7f2      	b.n	801f1c8 <_printf_float+0x410>
 801f1e2:	2301      	movs	r3, #1
 801f1e4:	e7df      	b.n	801f1a6 <_printf_float+0x3ee>
 801f1e6:	2301      	movs	r3, #1
 801f1e8:	464a      	mov	r2, r9
 801f1ea:	4631      	mov	r1, r6
 801f1ec:	4628      	mov	r0, r5
 801f1ee:	47b8      	blx	r7
 801f1f0:	3001      	adds	r0, #1
 801f1f2:	f43f ae3e 	beq.w	801ee72 <_printf_float+0xba>
 801f1f6:	f108 0801 	add.w	r8, r8, #1
 801f1fa:	68e3      	ldr	r3, [r4, #12]
 801f1fc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801f1fe:	1a9b      	subs	r3, r3, r2
 801f200:	4543      	cmp	r3, r8
 801f202:	dcf0      	bgt.n	801f1e6 <_printf_float+0x42e>
 801f204:	e6fc      	b.n	801f000 <_printf_float+0x248>
 801f206:	f04f 0800 	mov.w	r8, #0
 801f20a:	f104 0919 	add.w	r9, r4, #25
 801f20e:	e7f4      	b.n	801f1fa <_printf_float+0x442>
 801f210:	2900      	cmp	r1, #0
 801f212:	f43f ae8b 	beq.w	801ef2c <_printf_float+0x174>
 801f216:	2300      	movs	r3, #0
 801f218:	e9cd 0302 	strd	r0, r3, [sp, #8]
 801f21c:	ab09      	add	r3, sp, #36	; 0x24
 801f21e:	9300      	str	r3, [sp, #0]
 801f220:	ec49 8b10 	vmov	d0, r8, r9
 801f224:	6022      	str	r2, [r4, #0]
 801f226:	f8cd a004 	str.w	sl, [sp, #4]
 801f22a:	f10d 0323 	add.w	r3, sp, #35	; 0x23
 801f22e:	4628      	mov	r0, r5
 801f230:	f7ff fd2e 	bl	801ec90 <__cvt>
 801f234:	4680      	mov	r8, r0
 801f236:	e648      	b.n	801eeca <_printf_float+0x112>

0801f238 <_printf_common>:
 801f238:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801f23c:	4691      	mov	r9, r2
 801f23e:	461f      	mov	r7, r3
 801f240:	688a      	ldr	r2, [r1, #8]
 801f242:	690b      	ldr	r3, [r1, #16]
 801f244:	f8dd 8020 	ldr.w	r8, [sp, #32]
 801f248:	4293      	cmp	r3, r2
 801f24a:	bfb8      	it	lt
 801f24c:	4613      	movlt	r3, r2
 801f24e:	f8c9 3000 	str.w	r3, [r9]
 801f252:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 801f256:	4606      	mov	r6, r0
 801f258:	460c      	mov	r4, r1
 801f25a:	b112      	cbz	r2, 801f262 <_printf_common+0x2a>
 801f25c:	3301      	adds	r3, #1
 801f25e:	f8c9 3000 	str.w	r3, [r9]
 801f262:	6823      	ldr	r3, [r4, #0]
 801f264:	0699      	lsls	r1, r3, #26
 801f266:	bf42      	ittt	mi
 801f268:	f8d9 3000 	ldrmi.w	r3, [r9]
 801f26c:	3302      	addmi	r3, #2
 801f26e:	f8c9 3000 	strmi.w	r3, [r9]
 801f272:	6825      	ldr	r5, [r4, #0]
 801f274:	f015 0506 	ands.w	r5, r5, #6
 801f278:	d107      	bne.n	801f28a <_printf_common+0x52>
 801f27a:	f104 0a19 	add.w	sl, r4, #25
 801f27e:	68e3      	ldr	r3, [r4, #12]
 801f280:	f8d9 2000 	ldr.w	r2, [r9]
 801f284:	1a9b      	subs	r3, r3, r2
 801f286:	42ab      	cmp	r3, r5
 801f288:	dc28      	bgt.n	801f2dc <_printf_common+0xa4>
 801f28a:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 801f28e:	6822      	ldr	r2, [r4, #0]
 801f290:	3300      	adds	r3, #0
 801f292:	bf18      	it	ne
 801f294:	2301      	movne	r3, #1
 801f296:	0692      	lsls	r2, r2, #26
 801f298:	d42d      	bmi.n	801f2f6 <_printf_common+0xbe>
 801f29a:	f104 0243 	add.w	r2, r4, #67	; 0x43
 801f29e:	4639      	mov	r1, r7
 801f2a0:	4630      	mov	r0, r6
 801f2a2:	47c0      	blx	r8
 801f2a4:	3001      	adds	r0, #1
 801f2a6:	d020      	beq.n	801f2ea <_printf_common+0xb2>
 801f2a8:	6823      	ldr	r3, [r4, #0]
 801f2aa:	68e5      	ldr	r5, [r4, #12]
 801f2ac:	f8d9 2000 	ldr.w	r2, [r9]
 801f2b0:	f003 0306 	and.w	r3, r3, #6
 801f2b4:	2b04      	cmp	r3, #4
 801f2b6:	bf08      	it	eq
 801f2b8:	1aad      	subeq	r5, r5, r2
 801f2ba:	68a3      	ldr	r3, [r4, #8]
 801f2bc:	6922      	ldr	r2, [r4, #16]
 801f2be:	bf0c      	ite	eq
 801f2c0:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 801f2c4:	2500      	movne	r5, #0
 801f2c6:	4293      	cmp	r3, r2
 801f2c8:	bfc4      	itt	gt
 801f2ca:	1a9b      	subgt	r3, r3, r2
 801f2cc:	18ed      	addgt	r5, r5, r3
 801f2ce:	f04f 0900 	mov.w	r9, #0
 801f2d2:	341a      	adds	r4, #26
 801f2d4:	454d      	cmp	r5, r9
 801f2d6:	d11a      	bne.n	801f30e <_printf_common+0xd6>
 801f2d8:	2000      	movs	r0, #0
 801f2da:	e008      	b.n	801f2ee <_printf_common+0xb6>
 801f2dc:	2301      	movs	r3, #1
 801f2de:	4652      	mov	r2, sl
 801f2e0:	4639      	mov	r1, r7
 801f2e2:	4630      	mov	r0, r6
 801f2e4:	47c0      	blx	r8
 801f2e6:	3001      	adds	r0, #1
 801f2e8:	d103      	bne.n	801f2f2 <_printf_common+0xba>
 801f2ea:	f04f 30ff 	mov.w	r0, #4294967295
 801f2ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801f2f2:	3501      	adds	r5, #1
 801f2f4:	e7c3      	b.n	801f27e <_printf_common+0x46>
 801f2f6:	18e1      	adds	r1, r4, r3
 801f2f8:	1c5a      	adds	r2, r3, #1
 801f2fa:	2030      	movs	r0, #48	; 0x30
 801f2fc:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 801f300:	4422      	add	r2, r4
 801f302:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 801f306:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 801f30a:	3302      	adds	r3, #2
 801f30c:	e7c5      	b.n	801f29a <_printf_common+0x62>
 801f30e:	2301      	movs	r3, #1
 801f310:	4622      	mov	r2, r4
 801f312:	4639      	mov	r1, r7
 801f314:	4630      	mov	r0, r6
 801f316:	47c0      	blx	r8
 801f318:	3001      	adds	r0, #1
 801f31a:	d0e6      	beq.n	801f2ea <_printf_common+0xb2>
 801f31c:	f109 0901 	add.w	r9, r9, #1
 801f320:	e7d8      	b.n	801f2d4 <_printf_common+0x9c>
	...

0801f324 <_printf_i>:
 801f324:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801f328:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 801f32c:	460c      	mov	r4, r1
 801f32e:	7e09      	ldrb	r1, [r1, #24]
 801f330:	b085      	sub	sp, #20
 801f332:	296e      	cmp	r1, #110	; 0x6e
 801f334:	4617      	mov	r7, r2
 801f336:	4606      	mov	r6, r0
 801f338:	4698      	mov	r8, r3
 801f33a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801f33c:	f000 80b3 	beq.w	801f4a6 <_printf_i+0x182>
 801f340:	d822      	bhi.n	801f388 <_printf_i+0x64>
 801f342:	2963      	cmp	r1, #99	; 0x63
 801f344:	d036      	beq.n	801f3b4 <_printf_i+0x90>
 801f346:	d80a      	bhi.n	801f35e <_printf_i+0x3a>
 801f348:	2900      	cmp	r1, #0
 801f34a:	f000 80b9 	beq.w	801f4c0 <_printf_i+0x19c>
 801f34e:	2958      	cmp	r1, #88	; 0x58
 801f350:	f000 8083 	beq.w	801f45a <_printf_i+0x136>
 801f354:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801f358:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 801f35c:	e032      	b.n	801f3c4 <_printf_i+0xa0>
 801f35e:	2964      	cmp	r1, #100	; 0x64
 801f360:	d001      	beq.n	801f366 <_printf_i+0x42>
 801f362:	2969      	cmp	r1, #105	; 0x69
 801f364:	d1f6      	bne.n	801f354 <_printf_i+0x30>
 801f366:	6820      	ldr	r0, [r4, #0]
 801f368:	6813      	ldr	r3, [r2, #0]
 801f36a:	0605      	lsls	r5, r0, #24
 801f36c:	f103 0104 	add.w	r1, r3, #4
 801f370:	d52a      	bpl.n	801f3c8 <_printf_i+0xa4>
 801f372:	681b      	ldr	r3, [r3, #0]
 801f374:	6011      	str	r1, [r2, #0]
 801f376:	2b00      	cmp	r3, #0
 801f378:	da03      	bge.n	801f382 <_printf_i+0x5e>
 801f37a:	222d      	movs	r2, #45	; 0x2d
 801f37c:	425b      	negs	r3, r3
 801f37e:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 801f382:	486f      	ldr	r0, [pc, #444]	; (801f540 <_printf_i+0x21c>)
 801f384:	220a      	movs	r2, #10
 801f386:	e039      	b.n	801f3fc <_printf_i+0xd8>
 801f388:	2973      	cmp	r1, #115	; 0x73
 801f38a:	f000 809d 	beq.w	801f4c8 <_printf_i+0x1a4>
 801f38e:	d808      	bhi.n	801f3a2 <_printf_i+0x7e>
 801f390:	296f      	cmp	r1, #111	; 0x6f
 801f392:	d020      	beq.n	801f3d6 <_printf_i+0xb2>
 801f394:	2970      	cmp	r1, #112	; 0x70
 801f396:	d1dd      	bne.n	801f354 <_printf_i+0x30>
 801f398:	6823      	ldr	r3, [r4, #0]
 801f39a:	f043 0320 	orr.w	r3, r3, #32
 801f39e:	6023      	str	r3, [r4, #0]
 801f3a0:	e003      	b.n	801f3aa <_printf_i+0x86>
 801f3a2:	2975      	cmp	r1, #117	; 0x75
 801f3a4:	d017      	beq.n	801f3d6 <_printf_i+0xb2>
 801f3a6:	2978      	cmp	r1, #120	; 0x78
 801f3a8:	d1d4      	bne.n	801f354 <_printf_i+0x30>
 801f3aa:	2378      	movs	r3, #120	; 0x78
 801f3ac:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 801f3b0:	4864      	ldr	r0, [pc, #400]	; (801f544 <_printf_i+0x220>)
 801f3b2:	e055      	b.n	801f460 <_printf_i+0x13c>
 801f3b4:	6813      	ldr	r3, [r2, #0]
 801f3b6:	1d19      	adds	r1, r3, #4
 801f3b8:	681b      	ldr	r3, [r3, #0]
 801f3ba:	6011      	str	r1, [r2, #0]
 801f3bc:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801f3c0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 801f3c4:	2301      	movs	r3, #1
 801f3c6:	e08c      	b.n	801f4e2 <_printf_i+0x1be>
 801f3c8:	681b      	ldr	r3, [r3, #0]
 801f3ca:	6011      	str	r1, [r2, #0]
 801f3cc:	f010 0f40 	tst.w	r0, #64	; 0x40
 801f3d0:	bf18      	it	ne
 801f3d2:	b21b      	sxthne	r3, r3
 801f3d4:	e7cf      	b.n	801f376 <_printf_i+0x52>
 801f3d6:	6813      	ldr	r3, [r2, #0]
 801f3d8:	6825      	ldr	r5, [r4, #0]
 801f3da:	1d18      	adds	r0, r3, #4
 801f3dc:	6010      	str	r0, [r2, #0]
 801f3de:	0628      	lsls	r0, r5, #24
 801f3e0:	d501      	bpl.n	801f3e6 <_printf_i+0xc2>
 801f3e2:	681b      	ldr	r3, [r3, #0]
 801f3e4:	e002      	b.n	801f3ec <_printf_i+0xc8>
 801f3e6:	0668      	lsls	r0, r5, #25
 801f3e8:	d5fb      	bpl.n	801f3e2 <_printf_i+0xbe>
 801f3ea:	881b      	ldrh	r3, [r3, #0]
 801f3ec:	4854      	ldr	r0, [pc, #336]	; (801f540 <_printf_i+0x21c>)
 801f3ee:	296f      	cmp	r1, #111	; 0x6f
 801f3f0:	bf14      	ite	ne
 801f3f2:	220a      	movne	r2, #10
 801f3f4:	2208      	moveq	r2, #8
 801f3f6:	2100      	movs	r1, #0
 801f3f8:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 801f3fc:	6865      	ldr	r5, [r4, #4]
 801f3fe:	60a5      	str	r5, [r4, #8]
 801f400:	2d00      	cmp	r5, #0
 801f402:	f2c0 8095 	blt.w	801f530 <_printf_i+0x20c>
 801f406:	6821      	ldr	r1, [r4, #0]
 801f408:	f021 0104 	bic.w	r1, r1, #4
 801f40c:	6021      	str	r1, [r4, #0]
 801f40e:	2b00      	cmp	r3, #0
 801f410:	d13d      	bne.n	801f48e <_printf_i+0x16a>
 801f412:	2d00      	cmp	r5, #0
 801f414:	f040 808e 	bne.w	801f534 <_printf_i+0x210>
 801f418:	4665      	mov	r5, ip
 801f41a:	2a08      	cmp	r2, #8
 801f41c:	d10b      	bne.n	801f436 <_printf_i+0x112>
 801f41e:	6823      	ldr	r3, [r4, #0]
 801f420:	07db      	lsls	r3, r3, #31
 801f422:	d508      	bpl.n	801f436 <_printf_i+0x112>
 801f424:	6923      	ldr	r3, [r4, #16]
 801f426:	6862      	ldr	r2, [r4, #4]
 801f428:	429a      	cmp	r2, r3
 801f42a:	bfde      	ittt	le
 801f42c:	2330      	movle	r3, #48	; 0x30
 801f42e:	f805 3c01 	strble.w	r3, [r5, #-1]
 801f432:	f105 35ff 	addle.w	r5, r5, #4294967295
 801f436:	ebac 0305 	sub.w	r3, ip, r5
 801f43a:	6123      	str	r3, [r4, #16]
 801f43c:	f8cd 8000 	str.w	r8, [sp]
 801f440:	463b      	mov	r3, r7
 801f442:	aa03      	add	r2, sp, #12
 801f444:	4621      	mov	r1, r4
 801f446:	4630      	mov	r0, r6
 801f448:	f7ff fef6 	bl	801f238 <_printf_common>
 801f44c:	3001      	adds	r0, #1
 801f44e:	d14d      	bne.n	801f4ec <_printf_i+0x1c8>
 801f450:	f04f 30ff 	mov.w	r0, #4294967295
 801f454:	b005      	add	sp, #20
 801f456:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801f45a:	4839      	ldr	r0, [pc, #228]	; (801f540 <_printf_i+0x21c>)
 801f45c:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 801f460:	6813      	ldr	r3, [r2, #0]
 801f462:	6821      	ldr	r1, [r4, #0]
 801f464:	1d1d      	adds	r5, r3, #4
 801f466:	681b      	ldr	r3, [r3, #0]
 801f468:	6015      	str	r5, [r2, #0]
 801f46a:	060a      	lsls	r2, r1, #24
 801f46c:	d50b      	bpl.n	801f486 <_printf_i+0x162>
 801f46e:	07ca      	lsls	r2, r1, #31
 801f470:	bf44      	itt	mi
 801f472:	f041 0120 	orrmi.w	r1, r1, #32
 801f476:	6021      	strmi	r1, [r4, #0]
 801f478:	b91b      	cbnz	r3, 801f482 <_printf_i+0x15e>
 801f47a:	6822      	ldr	r2, [r4, #0]
 801f47c:	f022 0220 	bic.w	r2, r2, #32
 801f480:	6022      	str	r2, [r4, #0]
 801f482:	2210      	movs	r2, #16
 801f484:	e7b7      	b.n	801f3f6 <_printf_i+0xd2>
 801f486:	064d      	lsls	r5, r1, #25
 801f488:	bf48      	it	mi
 801f48a:	b29b      	uxthmi	r3, r3
 801f48c:	e7ef      	b.n	801f46e <_printf_i+0x14a>
 801f48e:	4665      	mov	r5, ip
 801f490:	fbb3 f1f2 	udiv	r1, r3, r2
 801f494:	fb02 3311 	mls	r3, r2, r1, r3
 801f498:	5cc3      	ldrb	r3, [r0, r3]
 801f49a:	f805 3d01 	strb.w	r3, [r5, #-1]!
 801f49e:	460b      	mov	r3, r1
 801f4a0:	2900      	cmp	r1, #0
 801f4a2:	d1f5      	bne.n	801f490 <_printf_i+0x16c>
 801f4a4:	e7b9      	b.n	801f41a <_printf_i+0xf6>
 801f4a6:	6813      	ldr	r3, [r2, #0]
 801f4a8:	6825      	ldr	r5, [r4, #0]
 801f4aa:	6961      	ldr	r1, [r4, #20]
 801f4ac:	1d18      	adds	r0, r3, #4
 801f4ae:	6010      	str	r0, [r2, #0]
 801f4b0:	0628      	lsls	r0, r5, #24
 801f4b2:	681b      	ldr	r3, [r3, #0]
 801f4b4:	d501      	bpl.n	801f4ba <_printf_i+0x196>
 801f4b6:	6019      	str	r1, [r3, #0]
 801f4b8:	e002      	b.n	801f4c0 <_printf_i+0x19c>
 801f4ba:	066a      	lsls	r2, r5, #25
 801f4bc:	d5fb      	bpl.n	801f4b6 <_printf_i+0x192>
 801f4be:	8019      	strh	r1, [r3, #0]
 801f4c0:	2300      	movs	r3, #0
 801f4c2:	6123      	str	r3, [r4, #16]
 801f4c4:	4665      	mov	r5, ip
 801f4c6:	e7b9      	b.n	801f43c <_printf_i+0x118>
 801f4c8:	6813      	ldr	r3, [r2, #0]
 801f4ca:	1d19      	adds	r1, r3, #4
 801f4cc:	6011      	str	r1, [r2, #0]
 801f4ce:	681d      	ldr	r5, [r3, #0]
 801f4d0:	6862      	ldr	r2, [r4, #4]
 801f4d2:	2100      	movs	r1, #0
 801f4d4:	4628      	mov	r0, r5
 801f4d6:	f7e7 fd8b 	bl	8006ff0 <memchr>
 801f4da:	b108      	cbz	r0, 801f4e0 <_printf_i+0x1bc>
 801f4dc:	1b40      	subs	r0, r0, r5
 801f4de:	6060      	str	r0, [r4, #4]
 801f4e0:	6863      	ldr	r3, [r4, #4]
 801f4e2:	6123      	str	r3, [r4, #16]
 801f4e4:	2300      	movs	r3, #0
 801f4e6:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 801f4ea:	e7a7      	b.n	801f43c <_printf_i+0x118>
 801f4ec:	6923      	ldr	r3, [r4, #16]
 801f4ee:	462a      	mov	r2, r5
 801f4f0:	4639      	mov	r1, r7
 801f4f2:	4630      	mov	r0, r6
 801f4f4:	47c0      	blx	r8
 801f4f6:	3001      	adds	r0, #1
 801f4f8:	d0aa      	beq.n	801f450 <_printf_i+0x12c>
 801f4fa:	6823      	ldr	r3, [r4, #0]
 801f4fc:	079b      	lsls	r3, r3, #30
 801f4fe:	d413      	bmi.n	801f528 <_printf_i+0x204>
 801f500:	68e0      	ldr	r0, [r4, #12]
 801f502:	9b03      	ldr	r3, [sp, #12]
 801f504:	4298      	cmp	r0, r3
 801f506:	bfb8      	it	lt
 801f508:	4618      	movlt	r0, r3
 801f50a:	e7a3      	b.n	801f454 <_printf_i+0x130>
 801f50c:	2301      	movs	r3, #1
 801f50e:	464a      	mov	r2, r9
 801f510:	4639      	mov	r1, r7
 801f512:	4630      	mov	r0, r6
 801f514:	47c0      	blx	r8
 801f516:	3001      	adds	r0, #1
 801f518:	d09a      	beq.n	801f450 <_printf_i+0x12c>
 801f51a:	3501      	adds	r5, #1
 801f51c:	68e3      	ldr	r3, [r4, #12]
 801f51e:	9a03      	ldr	r2, [sp, #12]
 801f520:	1a9b      	subs	r3, r3, r2
 801f522:	42ab      	cmp	r3, r5
 801f524:	dcf2      	bgt.n	801f50c <_printf_i+0x1e8>
 801f526:	e7eb      	b.n	801f500 <_printf_i+0x1dc>
 801f528:	2500      	movs	r5, #0
 801f52a:	f104 0919 	add.w	r9, r4, #25
 801f52e:	e7f5      	b.n	801f51c <_printf_i+0x1f8>
 801f530:	2b00      	cmp	r3, #0
 801f532:	d1ac      	bne.n	801f48e <_printf_i+0x16a>
 801f534:	7803      	ldrb	r3, [r0, #0]
 801f536:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 801f53a:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801f53e:	e76c      	b.n	801f41a <_printf_i+0xf6>
 801f540:	08075e8a 	.word	0x08075e8a
 801f544:	08075e9b 	.word	0x08075e9b

0801f548 <iprintf>:
 801f548:	b40f      	push	{r0, r1, r2, r3}
 801f54a:	4b0a      	ldr	r3, [pc, #40]	; (801f574 <iprintf+0x2c>)
 801f54c:	b513      	push	{r0, r1, r4, lr}
 801f54e:	681c      	ldr	r4, [r3, #0]
 801f550:	b124      	cbz	r4, 801f55c <iprintf+0x14>
 801f552:	69a3      	ldr	r3, [r4, #24]
 801f554:	b913      	cbnz	r3, 801f55c <iprintf+0x14>
 801f556:	4620      	mov	r0, r4
 801f558:	f000 ff66 	bl	8020428 <__sinit>
 801f55c:	ab05      	add	r3, sp, #20
 801f55e:	9a04      	ldr	r2, [sp, #16]
 801f560:	68a1      	ldr	r1, [r4, #8]
 801f562:	9301      	str	r3, [sp, #4]
 801f564:	4620      	mov	r0, r4
 801f566:	f001 fc75 	bl	8020e54 <_vfiprintf_r>
 801f56a:	b002      	add	sp, #8
 801f56c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801f570:	b004      	add	sp, #16
 801f572:	4770      	bx	lr
 801f574:	20001558 	.word	0x20001558

0801f578 <_sbrk_r>:
 801f578:	b538      	push	{r3, r4, r5, lr}
 801f57a:	4c06      	ldr	r4, [pc, #24]	; (801f594 <_sbrk_r+0x1c>)
 801f57c:	2300      	movs	r3, #0
 801f57e:	4605      	mov	r5, r0
 801f580:	4608      	mov	r0, r1
 801f582:	6023      	str	r3, [r4, #0]
 801f584:	f7f9 fb8a 	bl	8018c9c <_sbrk>
 801f588:	1c43      	adds	r3, r0, #1
 801f58a:	d102      	bne.n	801f592 <_sbrk_r+0x1a>
 801f58c:	6823      	ldr	r3, [r4, #0]
 801f58e:	b103      	cbz	r3, 801f592 <_sbrk_r+0x1a>
 801f590:	602b      	str	r3, [r5, #0]
 801f592:	bd38      	pop	{r3, r4, r5, pc}
 801f594:	2001331c 	.word	0x2001331c

0801f598 <siprintf>:
 801f598:	b40e      	push	{r1, r2, r3}
 801f59a:	b500      	push	{lr}
 801f59c:	b09c      	sub	sp, #112	; 0x70
 801f59e:	ab1d      	add	r3, sp, #116	; 0x74
 801f5a0:	9002      	str	r0, [sp, #8]
 801f5a2:	9006      	str	r0, [sp, #24]
 801f5a4:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 801f5a8:	4809      	ldr	r0, [pc, #36]	; (801f5d0 <siprintf+0x38>)
 801f5aa:	9107      	str	r1, [sp, #28]
 801f5ac:	9104      	str	r1, [sp, #16]
 801f5ae:	4909      	ldr	r1, [pc, #36]	; (801f5d4 <siprintf+0x3c>)
 801f5b0:	f853 2b04 	ldr.w	r2, [r3], #4
 801f5b4:	9105      	str	r1, [sp, #20]
 801f5b6:	6800      	ldr	r0, [r0, #0]
 801f5b8:	9301      	str	r3, [sp, #4]
 801f5ba:	a902      	add	r1, sp, #8
 801f5bc:	f001 fb28 	bl	8020c10 <_svfiprintf_r>
 801f5c0:	9b02      	ldr	r3, [sp, #8]
 801f5c2:	2200      	movs	r2, #0
 801f5c4:	701a      	strb	r2, [r3, #0]
 801f5c6:	b01c      	add	sp, #112	; 0x70
 801f5c8:	f85d eb04 	ldr.w	lr, [sp], #4
 801f5cc:	b003      	add	sp, #12
 801f5ce:	4770      	bx	lr
 801f5d0:	20001558 	.word	0x20001558
 801f5d4:	ffff0208 	.word	0xffff0208

0801f5d8 <strncmp>:
 801f5d8:	b510      	push	{r4, lr}
 801f5da:	b16a      	cbz	r2, 801f5f8 <strncmp+0x20>
 801f5dc:	3901      	subs	r1, #1
 801f5de:	1884      	adds	r4, r0, r2
 801f5e0:	f810 3b01 	ldrb.w	r3, [r0], #1
 801f5e4:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 801f5e8:	4293      	cmp	r3, r2
 801f5ea:	d103      	bne.n	801f5f4 <strncmp+0x1c>
 801f5ec:	42a0      	cmp	r0, r4
 801f5ee:	d001      	beq.n	801f5f4 <strncmp+0x1c>
 801f5f0:	2b00      	cmp	r3, #0
 801f5f2:	d1f5      	bne.n	801f5e0 <strncmp+0x8>
 801f5f4:	1a98      	subs	r0, r3, r2
 801f5f6:	bd10      	pop	{r4, pc}
 801f5f8:	4610      	mov	r0, r2
 801f5fa:	e7fc      	b.n	801f5f6 <strncmp+0x1e>

0801f5fc <_strtol_l.isra.0>:
 801f5fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801f600:	4680      	mov	r8, r0
 801f602:	4689      	mov	r9, r1
 801f604:	4692      	mov	sl, r2
 801f606:	461e      	mov	r6, r3
 801f608:	460f      	mov	r7, r1
 801f60a:	463d      	mov	r5, r7
 801f60c:	9808      	ldr	r0, [sp, #32]
 801f60e:	f815 4b01 	ldrb.w	r4, [r5], #1
 801f612:	f000 ff93 	bl	802053c <__locale_ctype_ptr_l>
 801f616:	4420      	add	r0, r4
 801f618:	7843      	ldrb	r3, [r0, #1]
 801f61a:	f013 0308 	ands.w	r3, r3, #8
 801f61e:	d132      	bne.n	801f686 <_strtol_l.isra.0+0x8a>
 801f620:	2c2d      	cmp	r4, #45	; 0x2d
 801f622:	d132      	bne.n	801f68a <_strtol_l.isra.0+0x8e>
 801f624:	787c      	ldrb	r4, [r7, #1]
 801f626:	1cbd      	adds	r5, r7, #2
 801f628:	2201      	movs	r2, #1
 801f62a:	2e00      	cmp	r6, #0
 801f62c:	d05d      	beq.n	801f6ea <_strtol_l.isra.0+0xee>
 801f62e:	2e10      	cmp	r6, #16
 801f630:	d109      	bne.n	801f646 <_strtol_l.isra.0+0x4a>
 801f632:	2c30      	cmp	r4, #48	; 0x30
 801f634:	d107      	bne.n	801f646 <_strtol_l.isra.0+0x4a>
 801f636:	782b      	ldrb	r3, [r5, #0]
 801f638:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 801f63c:	2b58      	cmp	r3, #88	; 0x58
 801f63e:	d14f      	bne.n	801f6e0 <_strtol_l.isra.0+0xe4>
 801f640:	786c      	ldrb	r4, [r5, #1]
 801f642:	2610      	movs	r6, #16
 801f644:	3502      	adds	r5, #2
 801f646:	2a00      	cmp	r2, #0
 801f648:	bf14      	ite	ne
 801f64a:	f04f 4100 	movne.w	r1, #2147483648	; 0x80000000
 801f64e:	f06f 4100 	mvneq.w	r1, #2147483648	; 0x80000000
 801f652:	2700      	movs	r7, #0
 801f654:	fbb1 fcf6 	udiv	ip, r1, r6
 801f658:	4638      	mov	r0, r7
 801f65a:	fb06 1e1c 	mls	lr, r6, ip, r1
 801f65e:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
 801f662:	2b09      	cmp	r3, #9
 801f664:	d817      	bhi.n	801f696 <_strtol_l.isra.0+0x9a>
 801f666:	461c      	mov	r4, r3
 801f668:	42a6      	cmp	r6, r4
 801f66a:	dd23      	ble.n	801f6b4 <_strtol_l.isra.0+0xb8>
 801f66c:	1c7b      	adds	r3, r7, #1
 801f66e:	d007      	beq.n	801f680 <_strtol_l.isra.0+0x84>
 801f670:	4584      	cmp	ip, r0
 801f672:	d31c      	bcc.n	801f6ae <_strtol_l.isra.0+0xb2>
 801f674:	d101      	bne.n	801f67a <_strtol_l.isra.0+0x7e>
 801f676:	45a6      	cmp	lr, r4
 801f678:	db19      	blt.n	801f6ae <_strtol_l.isra.0+0xb2>
 801f67a:	fb00 4006 	mla	r0, r0, r6, r4
 801f67e:	2701      	movs	r7, #1
 801f680:	f815 4b01 	ldrb.w	r4, [r5], #1
 801f684:	e7eb      	b.n	801f65e <_strtol_l.isra.0+0x62>
 801f686:	462f      	mov	r7, r5
 801f688:	e7bf      	b.n	801f60a <_strtol_l.isra.0+0xe>
 801f68a:	2c2b      	cmp	r4, #43	; 0x2b
 801f68c:	bf04      	itt	eq
 801f68e:	1cbd      	addeq	r5, r7, #2
 801f690:	787c      	ldrbeq	r4, [r7, #1]
 801f692:	461a      	mov	r2, r3
 801f694:	e7c9      	b.n	801f62a <_strtol_l.isra.0+0x2e>
 801f696:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
 801f69a:	2b19      	cmp	r3, #25
 801f69c:	d801      	bhi.n	801f6a2 <_strtol_l.isra.0+0xa6>
 801f69e:	3c37      	subs	r4, #55	; 0x37
 801f6a0:	e7e2      	b.n	801f668 <_strtol_l.isra.0+0x6c>
 801f6a2:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
 801f6a6:	2b19      	cmp	r3, #25
 801f6a8:	d804      	bhi.n	801f6b4 <_strtol_l.isra.0+0xb8>
 801f6aa:	3c57      	subs	r4, #87	; 0x57
 801f6ac:	e7dc      	b.n	801f668 <_strtol_l.isra.0+0x6c>
 801f6ae:	f04f 37ff 	mov.w	r7, #4294967295
 801f6b2:	e7e5      	b.n	801f680 <_strtol_l.isra.0+0x84>
 801f6b4:	1c7b      	adds	r3, r7, #1
 801f6b6:	d108      	bne.n	801f6ca <_strtol_l.isra.0+0xce>
 801f6b8:	2322      	movs	r3, #34	; 0x22
 801f6ba:	f8c8 3000 	str.w	r3, [r8]
 801f6be:	4608      	mov	r0, r1
 801f6c0:	f1ba 0f00 	cmp.w	sl, #0
 801f6c4:	d107      	bne.n	801f6d6 <_strtol_l.isra.0+0xda>
 801f6c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801f6ca:	b102      	cbz	r2, 801f6ce <_strtol_l.isra.0+0xd2>
 801f6cc:	4240      	negs	r0, r0
 801f6ce:	f1ba 0f00 	cmp.w	sl, #0
 801f6d2:	d0f8      	beq.n	801f6c6 <_strtol_l.isra.0+0xca>
 801f6d4:	b10f      	cbz	r7, 801f6da <_strtol_l.isra.0+0xde>
 801f6d6:	f105 39ff 	add.w	r9, r5, #4294967295
 801f6da:	f8ca 9000 	str.w	r9, [sl]
 801f6de:	e7f2      	b.n	801f6c6 <_strtol_l.isra.0+0xca>
 801f6e0:	2430      	movs	r4, #48	; 0x30
 801f6e2:	2e00      	cmp	r6, #0
 801f6e4:	d1af      	bne.n	801f646 <_strtol_l.isra.0+0x4a>
 801f6e6:	2608      	movs	r6, #8
 801f6e8:	e7ad      	b.n	801f646 <_strtol_l.isra.0+0x4a>
 801f6ea:	2c30      	cmp	r4, #48	; 0x30
 801f6ec:	d0a3      	beq.n	801f636 <_strtol_l.isra.0+0x3a>
 801f6ee:	260a      	movs	r6, #10
 801f6f0:	e7a9      	b.n	801f646 <_strtol_l.isra.0+0x4a>
	...

0801f6f4 <strtol>:
 801f6f4:	4b08      	ldr	r3, [pc, #32]	; (801f718 <strtol+0x24>)
 801f6f6:	b537      	push	{r0, r1, r2, r4, r5, lr}
 801f6f8:	681c      	ldr	r4, [r3, #0]
 801f6fa:	4d08      	ldr	r5, [pc, #32]	; (801f71c <strtol+0x28>)
 801f6fc:	6a23      	ldr	r3, [r4, #32]
 801f6fe:	2b00      	cmp	r3, #0
 801f700:	bf08      	it	eq
 801f702:	462b      	moveq	r3, r5
 801f704:	9300      	str	r3, [sp, #0]
 801f706:	4613      	mov	r3, r2
 801f708:	460a      	mov	r2, r1
 801f70a:	4601      	mov	r1, r0
 801f70c:	4620      	mov	r0, r4
 801f70e:	f7ff ff75 	bl	801f5fc <_strtol_l.isra.0>
 801f712:	b003      	add	sp, #12
 801f714:	bd30      	pop	{r4, r5, pc}
 801f716:	bf00      	nop
 801f718:	20001558 	.word	0x20001558
 801f71c:	200015bc 	.word	0x200015bc

0801f720 <quorem>:
 801f720:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f724:	6903      	ldr	r3, [r0, #16]
 801f726:	690c      	ldr	r4, [r1, #16]
 801f728:	42a3      	cmp	r3, r4
 801f72a:	4680      	mov	r8, r0
 801f72c:	f2c0 8082 	blt.w	801f834 <quorem+0x114>
 801f730:	3c01      	subs	r4, #1
 801f732:	f101 0714 	add.w	r7, r1, #20
 801f736:	ea4f 0c84 	mov.w	ip, r4, lsl #2
 801f73a:	f100 0614 	add.w	r6, r0, #20
 801f73e:	f857 5024 	ldr.w	r5, [r7, r4, lsl #2]
 801f742:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 801f746:	eb06 030c 	add.w	r3, r6, ip
 801f74a:	3501      	adds	r5, #1
 801f74c:	eb07 090c 	add.w	r9, r7, ip
 801f750:	9301      	str	r3, [sp, #4]
 801f752:	fbb0 f5f5 	udiv	r5, r0, r5
 801f756:	b395      	cbz	r5, 801f7be <quorem+0x9e>
 801f758:	f04f 0a00 	mov.w	sl, #0
 801f75c:	4638      	mov	r0, r7
 801f75e:	46b6      	mov	lr, r6
 801f760:	46d3      	mov	fp, sl
 801f762:	f850 2b04 	ldr.w	r2, [r0], #4
 801f766:	b293      	uxth	r3, r2
 801f768:	fb05 a303 	mla	r3, r5, r3, sl
 801f76c:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 801f770:	b29b      	uxth	r3, r3
 801f772:	ebab 0303 	sub.w	r3, fp, r3
 801f776:	0c12      	lsrs	r2, r2, #16
 801f778:	f8de b000 	ldr.w	fp, [lr]
 801f77c:	fb05 a202 	mla	r2, r5, r2, sl
 801f780:	fa13 f38b 	uxtah	r3, r3, fp
 801f784:	ea4f 4a12 	mov.w	sl, r2, lsr #16
 801f788:	fa1f fb82 	uxth.w	fp, r2
 801f78c:	f8de 2000 	ldr.w	r2, [lr]
 801f790:	ebcb 4212 	rsb	r2, fp, r2, lsr #16
 801f794:	eb02 4223 	add.w	r2, r2, r3, asr #16
 801f798:	b29b      	uxth	r3, r3
 801f79a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 801f79e:	4581      	cmp	r9, r0
 801f7a0:	ea4f 4b22 	mov.w	fp, r2, asr #16
 801f7a4:	f84e 3b04 	str.w	r3, [lr], #4
 801f7a8:	d2db      	bcs.n	801f762 <quorem+0x42>
 801f7aa:	f856 300c 	ldr.w	r3, [r6, ip]
 801f7ae:	b933      	cbnz	r3, 801f7be <quorem+0x9e>
 801f7b0:	9b01      	ldr	r3, [sp, #4]
 801f7b2:	3b04      	subs	r3, #4
 801f7b4:	429e      	cmp	r6, r3
 801f7b6:	461a      	mov	r2, r3
 801f7b8:	d330      	bcc.n	801f81c <quorem+0xfc>
 801f7ba:	f8c8 4010 	str.w	r4, [r8, #16]
 801f7be:	4640      	mov	r0, r8
 801f7c0:	f001 f8f8 	bl	80209b4 <__mcmp>
 801f7c4:	2800      	cmp	r0, #0
 801f7c6:	db25      	blt.n	801f814 <quorem+0xf4>
 801f7c8:	3501      	adds	r5, #1
 801f7ca:	4630      	mov	r0, r6
 801f7cc:	f04f 0c00 	mov.w	ip, #0
 801f7d0:	f857 2b04 	ldr.w	r2, [r7], #4
 801f7d4:	f8d0 e000 	ldr.w	lr, [r0]
 801f7d8:	b293      	uxth	r3, r2
 801f7da:	ebac 0303 	sub.w	r3, ip, r3
 801f7de:	0c12      	lsrs	r2, r2, #16
 801f7e0:	fa13 f38e 	uxtah	r3, r3, lr
 801f7e4:	ebc2 421e 	rsb	r2, r2, lr, lsr #16
 801f7e8:	eb02 4223 	add.w	r2, r2, r3, asr #16
 801f7ec:	b29b      	uxth	r3, r3
 801f7ee:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 801f7f2:	45b9      	cmp	r9, r7
 801f7f4:	ea4f 4c22 	mov.w	ip, r2, asr #16
 801f7f8:	f840 3b04 	str.w	r3, [r0], #4
 801f7fc:	d2e8      	bcs.n	801f7d0 <quorem+0xb0>
 801f7fe:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 801f802:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 801f806:	b92a      	cbnz	r2, 801f814 <quorem+0xf4>
 801f808:	3b04      	subs	r3, #4
 801f80a:	429e      	cmp	r6, r3
 801f80c:	461a      	mov	r2, r3
 801f80e:	d30b      	bcc.n	801f828 <quorem+0x108>
 801f810:	f8c8 4010 	str.w	r4, [r8, #16]
 801f814:	4628      	mov	r0, r5
 801f816:	b003      	add	sp, #12
 801f818:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801f81c:	6812      	ldr	r2, [r2, #0]
 801f81e:	3b04      	subs	r3, #4
 801f820:	2a00      	cmp	r2, #0
 801f822:	d1ca      	bne.n	801f7ba <quorem+0x9a>
 801f824:	3c01      	subs	r4, #1
 801f826:	e7c5      	b.n	801f7b4 <quorem+0x94>
 801f828:	6812      	ldr	r2, [r2, #0]
 801f82a:	3b04      	subs	r3, #4
 801f82c:	2a00      	cmp	r2, #0
 801f82e:	d1ef      	bne.n	801f810 <quorem+0xf0>
 801f830:	3c01      	subs	r4, #1
 801f832:	e7ea      	b.n	801f80a <quorem+0xea>
 801f834:	2000      	movs	r0, #0
 801f836:	e7ee      	b.n	801f816 <quorem+0xf6>

0801f838 <_dtoa_r>:
 801f838:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f83c:	ec57 6b10 	vmov	r6, r7, d0
 801f840:	b097      	sub	sp, #92	; 0x5c
 801f842:	6a45      	ldr	r5, [r0, #36]	; 0x24
 801f844:	9106      	str	r1, [sp, #24]
 801f846:	4604      	mov	r4, r0
 801f848:	920b      	str	r2, [sp, #44]	; 0x2c
 801f84a:	9312      	str	r3, [sp, #72]	; 0x48
 801f84c:	f8dd 8080 	ldr.w	r8, [sp, #128]	; 0x80
 801f850:	e9cd 6700 	strd	r6, r7, [sp]
 801f854:	b93d      	cbnz	r5, 801f866 <_dtoa_r+0x2e>
 801f856:	2010      	movs	r0, #16
 801f858:	f7ff f940 	bl	801eadc <malloc>
 801f85c:	6260      	str	r0, [r4, #36]	; 0x24
 801f85e:	e9c0 5501 	strd	r5, r5, [r0, #4]
 801f862:	6005      	str	r5, [r0, #0]
 801f864:	60c5      	str	r5, [r0, #12]
 801f866:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801f868:	6819      	ldr	r1, [r3, #0]
 801f86a:	b151      	cbz	r1, 801f882 <_dtoa_r+0x4a>
 801f86c:	685a      	ldr	r2, [r3, #4]
 801f86e:	604a      	str	r2, [r1, #4]
 801f870:	2301      	movs	r3, #1
 801f872:	4093      	lsls	r3, r2
 801f874:	608b      	str	r3, [r1, #8]
 801f876:	4620      	mov	r0, r4
 801f878:	f000 feba 	bl	80205f0 <_Bfree>
 801f87c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801f87e:	2200      	movs	r2, #0
 801f880:	601a      	str	r2, [r3, #0]
 801f882:	1e3b      	subs	r3, r7, #0
 801f884:	bfbb      	ittet	lt
 801f886:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
 801f88a:	9301      	strlt	r3, [sp, #4]
 801f88c:	2300      	movge	r3, #0
 801f88e:	2201      	movlt	r2, #1
 801f890:	bfac      	ite	ge
 801f892:	f8c8 3000 	strge.w	r3, [r8]
 801f896:	f8c8 2000 	strlt.w	r2, [r8]
 801f89a:	4baf      	ldr	r3, [pc, #700]	; (801fb58 <_dtoa_r+0x320>)
 801f89c:	f8dd 8004 	ldr.w	r8, [sp, #4]
 801f8a0:	ea33 0308 	bics.w	r3, r3, r8
 801f8a4:	d114      	bne.n	801f8d0 <_dtoa_r+0x98>
 801f8a6:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801f8a8:	f242 730f 	movw	r3, #9999	; 0x270f
 801f8ac:	6013      	str	r3, [r2, #0]
 801f8ae:	9b00      	ldr	r3, [sp, #0]
 801f8b0:	b923      	cbnz	r3, 801f8bc <_dtoa_r+0x84>
 801f8b2:	f3c8 0013 	ubfx	r0, r8, #0, #20
 801f8b6:	2800      	cmp	r0, #0
 801f8b8:	f000 8542 	beq.w	8020340 <_dtoa_r+0xb08>
 801f8bc:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801f8be:	f8df b2ac 	ldr.w	fp, [pc, #684]	; 801fb6c <_dtoa_r+0x334>
 801f8c2:	2b00      	cmp	r3, #0
 801f8c4:	f000 8544 	beq.w	8020350 <_dtoa_r+0xb18>
 801f8c8:	f10b 0303 	add.w	r3, fp, #3
 801f8cc:	f000 bd3e 	b.w	802034c <_dtoa_r+0xb14>
 801f8d0:	e9dd 6700 	ldrd	r6, r7, [sp]
 801f8d4:	2200      	movs	r2, #0
 801f8d6:	2300      	movs	r3, #0
 801f8d8:	4630      	mov	r0, r6
 801f8da:	4639      	mov	r1, r7
 801f8dc:	f7e7 fffc 	bl	80078d8 <__aeabi_dcmpeq>
 801f8e0:	4681      	mov	r9, r0
 801f8e2:	b168      	cbz	r0, 801f900 <_dtoa_r+0xc8>
 801f8e4:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801f8e6:	2301      	movs	r3, #1
 801f8e8:	6013      	str	r3, [r2, #0]
 801f8ea:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801f8ec:	2b00      	cmp	r3, #0
 801f8ee:	f000 8524 	beq.w	802033a <_dtoa_r+0xb02>
 801f8f2:	4b9a      	ldr	r3, [pc, #616]	; (801fb5c <_dtoa_r+0x324>)
 801f8f4:	9a21      	ldr	r2, [sp, #132]	; 0x84
 801f8f6:	f103 3bff 	add.w	fp, r3, #4294967295
 801f8fa:	6013      	str	r3, [r2, #0]
 801f8fc:	f000 bd28 	b.w	8020350 <_dtoa_r+0xb18>
 801f900:	aa14      	add	r2, sp, #80	; 0x50
 801f902:	a915      	add	r1, sp, #84	; 0x54
 801f904:	ec47 6b10 	vmov	d0, r6, r7
 801f908:	4620      	mov	r0, r4
 801f90a:	f001 f8ca 	bl	8020aa2 <__d2b>
 801f90e:	f3c8 550a 	ubfx	r5, r8, #20, #11
 801f912:	9004      	str	r0, [sp, #16]
 801f914:	2d00      	cmp	r5, #0
 801f916:	d07c      	beq.n	801fa12 <_dtoa_r+0x1da>
 801f918:	f3c7 0313 	ubfx	r3, r7, #0, #20
 801f91c:	f043 5b7f 	orr.w	fp, r3, #1069547520	; 0x3fc00000
 801f920:	46b2      	mov	sl, r6
 801f922:	f44b 1b40 	orr.w	fp, fp, #3145728	; 0x300000
 801f926:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
 801f92a:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
 801f92e:	2200      	movs	r2, #0
 801f930:	4b8b      	ldr	r3, [pc, #556]	; (801fb60 <_dtoa_r+0x328>)
 801f932:	4650      	mov	r0, sl
 801f934:	4659      	mov	r1, fp
 801f936:	f7e7 fbaf 	bl	8007098 <__aeabi_dsub>
 801f93a:	a381      	add	r3, pc, #516	; (adr r3, 801fb40 <_dtoa_r+0x308>)
 801f93c:	e9d3 2300 	ldrd	r2, r3, [r3]
 801f940:	f7e7 fd62 	bl	8007408 <__aeabi_dmul>
 801f944:	a380      	add	r3, pc, #512	; (adr r3, 801fb48 <_dtoa_r+0x310>)
 801f946:	e9d3 2300 	ldrd	r2, r3, [r3]
 801f94a:	f7e7 fba7 	bl	800709c <__adddf3>
 801f94e:	4606      	mov	r6, r0
 801f950:	4628      	mov	r0, r5
 801f952:	460f      	mov	r7, r1
 801f954:	f7e7 fcee 	bl	8007334 <__aeabi_i2d>
 801f958:	a37d      	add	r3, pc, #500	; (adr r3, 801fb50 <_dtoa_r+0x318>)
 801f95a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801f95e:	f7e7 fd53 	bl	8007408 <__aeabi_dmul>
 801f962:	4602      	mov	r2, r0
 801f964:	460b      	mov	r3, r1
 801f966:	4630      	mov	r0, r6
 801f968:	4639      	mov	r1, r7
 801f96a:	f7e7 fb97 	bl	800709c <__adddf3>
 801f96e:	4606      	mov	r6, r0
 801f970:	460f      	mov	r7, r1
 801f972:	f7e7 fff9 	bl	8007968 <__aeabi_d2iz>
 801f976:	2200      	movs	r2, #0
 801f978:	4682      	mov	sl, r0
 801f97a:	2300      	movs	r3, #0
 801f97c:	4630      	mov	r0, r6
 801f97e:	4639      	mov	r1, r7
 801f980:	f7e7 ffb4 	bl	80078ec <__aeabi_dcmplt>
 801f984:	b148      	cbz	r0, 801f99a <_dtoa_r+0x162>
 801f986:	4650      	mov	r0, sl
 801f988:	f7e7 fcd4 	bl	8007334 <__aeabi_i2d>
 801f98c:	4632      	mov	r2, r6
 801f98e:	463b      	mov	r3, r7
 801f990:	f7e7 ffa2 	bl	80078d8 <__aeabi_dcmpeq>
 801f994:	b908      	cbnz	r0, 801f99a <_dtoa_r+0x162>
 801f996:	f10a 3aff 	add.w	sl, sl, #4294967295
 801f99a:	f1ba 0f16 	cmp.w	sl, #22
 801f99e:	d859      	bhi.n	801fa54 <_dtoa_r+0x21c>
 801f9a0:	4970      	ldr	r1, [pc, #448]	; (801fb64 <_dtoa_r+0x32c>)
 801f9a2:	eb01 01ca 	add.w	r1, r1, sl, lsl #3
 801f9a6:	e9dd 2300 	ldrd	r2, r3, [sp]
 801f9aa:	e9d1 0100 	ldrd	r0, r1, [r1]
 801f9ae:	f7e7 ffbb 	bl	8007928 <__aeabi_dcmpgt>
 801f9b2:	2800      	cmp	r0, #0
 801f9b4:	d050      	beq.n	801fa58 <_dtoa_r+0x220>
 801f9b6:	f10a 3aff 	add.w	sl, sl, #4294967295
 801f9ba:	2300      	movs	r3, #0
 801f9bc:	930f      	str	r3, [sp, #60]	; 0x3c
 801f9be:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801f9c0:	1b5d      	subs	r5, r3, r5
 801f9c2:	f1b5 0801 	subs.w	r8, r5, #1
 801f9c6:	bf49      	itett	mi
 801f9c8:	f1c5 0301 	rsbmi	r3, r5, #1
 801f9cc:	2300      	movpl	r3, #0
 801f9ce:	9305      	strmi	r3, [sp, #20]
 801f9d0:	f04f 0800 	movmi.w	r8, #0
 801f9d4:	bf58      	it	pl
 801f9d6:	9305      	strpl	r3, [sp, #20]
 801f9d8:	f1ba 0f00 	cmp.w	sl, #0
 801f9dc:	db3e      	blt.n	801fa5c <_dtoa_r+0x224>
 801f9de:	2300      	movs	r3, #0
 801f9e0:	44d0      	add	r8, sl
 801f9e2:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
 801f9e6:	9307      	str	r3, [sp, #28]
 801f9e8:	9b06      	ldr	r3, [sp, #24]
 801f9ea:	2b09      	cmp	r3, #9
 801f9ec:	f200 8090 	bhi.w	801fb10 <_dtoa_r+0x2d8>
 801f9f0:	2b05      	cmp	r3, #5
 801f9f2:	bfc4      	itt	gt
 801f9f4:	3b04      	subgt	r3, #4
 801f9f6:	9306      	strgt	r3, [sp, #24]
 801f9f8:	9b06      	ldr	r3, [sp, #24]
 801f9fa:	f1a3 0302 	sub.w	r3, r3, #2
 801f9fe:	bfcc      	ite	gt
 801fa00:	2500      	movgt	r5, #0
 801fa02:	2501      	movle	r5, #1
 801fa04:	2b03      	cmp	r3, #3
 801fa06:	f200 808f 	bhi.w	801fb28 <_dtoa_r+0x2f0>
 801fa0a:	e8df f003 	tbb	[pc, r3]
 801fa0e:	7f7d      	.short	0x7f7d
 801fa10:	7131      	.short	0x7131
 801fa12:	e9dd 5314 	ldrd	r5, r3, [sp, #80]	; 0x50
 801fa16:	441d      	add	r5, r3
 801fa18:	f205 4032 	addw	r0, r5, #1074	; 0x432
 801fa1c:	2820      	cmp	r0, #32
 801fa1e:	dd13      	ble.n	801fa48 <_dtoa_r+0x210>
 801fa20:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
 801fa24:	9b00      	ldr	r3, [sp, #0]
 801fa26:	fa08 f800 	lsl.w	r8, r8, r0
 801fa2a:	f205 4012 	addw	r0, r5, #1042	; 0x412
 801fa2e:	fa23 f000 	lsr.w	r0, r3, r0
 801fa32:	ea48 0000 	orr.w	r0, r8, r0
 801fa36:	f7e7 fc6d 	bl	8007314 <__aeabi_ui2d>
 801fa3a:	2301      	movs	r3, #1
 801fa3c:	4682      	mov	sl, r0
 801fa3e:	f1a1 7bf8 	sub.w	fp, r1, #32505856	; 0x1f00000
 801fa42:	3d01      	subs	r5, #1
 801fa44:	9313      	str	r3, [sp, #76]	; 0x4c
 801fa46:	e772      	b.n	801f92e <_dtoa_r+0xf6>
 801fa48:	9b00      	ldr	r3, [sp, #0]
 801fa4a:	f1c0 0020 	rsb	r0, r0, #32
 801fa4e:	fa03 f000 	lsl.w	r0, r3, r0
 801fa52:	e7f0      	b.n	801fa36 <_dtoa_r+0x1fe>
 801fa54:	2301      	movs	r3, #1
 801fa56:	e7b1      	b.n	801f9bc <_dtoa_r+0x184>
 801fa58:	900f      	str	r0, [sp, #60]	; 0x3c
 801fa5a:	e7b0      	b.n	801f9be <_dtoa_r+0x186>
 801fa5c:	9b05      	ldr	r3, [sp, #20]
 801fa5e:	eba3 030a 	sub.w	r3, r3, sl
 801fa62:	9305      	str	r3, [sp, #20]
 801fa64:	f1ca 0300 	rsb	r3, sl, #0
 801fa68:	9307      	str	r3, [sp, #28]
 801fa6a:	2300      	movs	r3, #0
 801fa6c:	930e      	str	r3, [sp, #56]	; 0x38
 801fa6e:	e7bb      	b.n	801f9e8 <_dtoa_r+0x1b0>
 801fa70:	2301      	movs	r3, #1
 801fa72:	930a      	str	r3, [sp, #40]	; 0x28
 801fa74:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801fa76:	2b00      	cmp	r3, #0
 801fa78:	dd59      	ble.n	801fb2e <_dtoa_r+0x2f6>
 801fa7a:	9302      	str	r3, [sp, #8]
 801fa7c:	4699      	mov	r9, r3
 801fa7e:	6a66      	ldr	r6, [r4, #36]	; 0x24
 801fa80:	2200      	movs	r2, #0
 801fa82:	6072      	str	r2, [r6, #4]
 801fa84:	2204      	movs	r2, #4
 801fa86:	f102 0014 	add.w	r0, r2, #20
 801fa8a:	4298      	cmp	r0, r3
 801fa8c:	6871      	ldr	r1, [r6, #4]
 801fa8e:	d953      	bls.n	801fb38 <_dtoa_r+0x300>
 801fa90:	4620      	mov	r0, r4
 801fa92:	f000 fd79 	bl	8020588 <_Balloc>
 801fa96:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801fa98:	6030      	str	r0, [r6, #0]
 801fa9a:	f1b9 0f0e 	cmp.w	r9, #14
 801fa9e:	f8d3 b000 	ldr.w	fp, [r3]
 801faa2:	f200 80e6 	bhi.w	801fc72 <_dtoa_r+0x43a>
 801faa6:	2d00      	cmp	r5, #0
 801faa8:	f000 80e3 	beq.w	801fc72 <_dtoa_r+0x43a>
 801faac:	ed9d 7b00 	vldr	d7, [sp]
 801fab0:	f1ba 0f00 	cmp.w	sl, #0
 801fab4:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 801fab8:	dd74      	ble.n	801fba4 <_dtoa_r+0x36c>
 801faba:	4a2a      	ldr	r2, [pc, #168]	; (801fb64 <_dtoa_r+0x32c>)
 801fabc:	f00a 030f 	and.w	r3, sl, #15
 801fac0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 801fac4:	ed93 7b00 	vldr	d7, [r3]
 801fac8:	ea4f 162a 	mov.w	r6, sl, asr #4
 801facc:	06f0      	lsls	r0, r6, #27
 801face:	ed8d 7b08 	vstr	d7, [sp, #32]
 801fad2:	d565      	bpl.n	801fba0 <_dtoa_r+0x368>
 801fad4:	4b24      	ldr	r3, [pc, #144]	; (801fb68 <_dtoa_r+0x330>)
 801fad6:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 801fada:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 801fade:	f7e7 fdbd 	bl	800765c <__aeabi_ddiv>
 801fae2:	e9cd 0100 	strd	r0, r1, [sp]
 801fae6:	f006 060f 	and.w	r6, r6, #15
 801faea:	2503      	movs	r5, #3
 801faec:	4f1e      	ldr	r7, [pc, #120]	; (801fb68 <_dtoa_r+0x330>)
 801faee:	e04c      	b.n	801fb8a <_dtoa_r+0x352>
 801faf0:	2301      	movs	r3, #1
 801faf2:	930a      	str	r3, [sp, #40]	; 0x28
 801faf4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801faf6:	4453      	add	r3, sl
 801faf8:	f103 0901 	add.w	r9, r3, #1
 801fafc:	9302      	str	r3, [sp, #8]
 801fafe:	464b      	mov	r3, r9
 801fb00:	2b01      	cmp	r3, #1
 801fb02:	bfb8      	it	lt
 801fb04:	2301      	movlt	r3, #1
 801fb06:	e7ba      	b.n	801fa7e <_dtoa_r+0x246>
 801fb08:	2300      	movs	r3, #0
 801fb0a:	e7b2      	b.n	801fa72 <_dtoa_r+0x23a>
 801fb0c:	2300      	movs	r3, #0
 801fb0e:	e7f0      	b.n	801faf2 <_dtoa_r+0x2ba>
 801fb10:	2501      	movs	r5, #1
 801fb12:	2300      	movs	r3, #0
 801fb14:	9306      	str	r3, [sp, #24]
 801fb16:	950a      	str	r5, [sp, #40]	; 0x28
 801fb18:	f04f 33ff 	mov.w	r3, #4294967295
 801fb1c:	9302      	str	r3, [sp, #8]
 801fb1e:	4699      	mov	r9, r3
 801fb20:	2200      	movs	r2, #0
 801fb22:	2312      	movs	r3, #18
 801fb24:	920b      	str	r2, [sp, #44]	; 0x2c
 801fb26:	e7aa      	b.n	801fa7e <_dtoa_r+0x246>
 801fb28:	2301      	movs	r3, #1
 801fb2a:	930a      	str	r3, [sp, #40]	; 0x28
 801fb2c:	e7f4      	b.n	801fb18 <_dtoa_r+0x2e0>
 801fb2e:	2301      	movs	r3, #1
 801fb30:	9302      	str	r3, [sp, #8]
 801fb32:	4699      	mov	r9, r3
 801fb34:	461a      	mov	r2, r3
 801fb36:	e7f5      	b.n	801fb24 <_dtoa_r+0x2ec>
 801fb38:	3101      	adds	r1, #1
 801fb3a:	6071      	str	r1, [r6, #4]
 801fb3c:	0052      	lsls	r2, r2, #1
 801fb3e:	e7a2      	b.n	801fa86 <_dtoa_r+0x24e>
 801fb40:	636f4361 	.word	0x636f4361
 801fb44:	3fd287a7 	.word	0x3fd287a7
 801fb48:	8b60c8b3 	.word	0x8b60c8b3
 801fb4c:	3fc68a28 	.word	0x3fc68a28
 801fb50:	509f79fb 	.word	0x509f79fb
 801fb54:	3fd34413 	.word	0x3fd34413
 801fb58:	7ff00000 	.word	0x7ff00000
 801fb5c:	08075e89 	.word	0x08075e89
 801fb60:	3ff80000 	.word	0x3ff80000
 801fb64:	08075f50 	.word	0x08075f50
 801fb68:	08075f28 	.word	0x08075f28
 801fb6c:	08075eb5 	.word	0x08075eb5
 801fb70:	07f1      	lsls	r1, r6, #31
 801fb72:	d508      	bpl.n	801fb86 <_dtoa_r+0x34e>
 801fb74:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 801fb78:	e9d7 2300 	ldrd	r2, r3, [r7]
 801fb7c:	f7e7 fc44 	bl	8007408 <__aeabi_dmul>
 801fb80:	e9cd 0108 	strd	r0, r1, [sp, #32]
 801fb84:	3501      	adds	r5, #1
 801fb86:	1076      	asrs	r6, r6, #1
 801fb88:	3708      	adds	r7, #8
 801fb8a:	2e00      	cmp	r6, #0
 801fb8c:	d1f0      	bne.n	801fb70 <_dtoa_r+0x338>
 801fb8e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 801fb92:	e9dd 0100 	ldrd	r0, r1, [sp]
 801fb96:	f7e7 fd61 	bl	800765c <__aeabi_ddiv>
 801fb9a:	e9cd 0100 	strd	r0, r1, [sp]
 801fb9e:	e01a      	b.n	801fbd6 <_dtoa_r+0x39e>
 801fba0:	2502      	movs	r5, #2
 801fba2:	e7a3      	b.n	801faec <_dtoa_r+0x2b4>
 801fba4:	f000 80a0 	beq.w	801fce8 <_dtoa_r+0x4b0>
 801fba8:	f1ca 0600 	rsb	r6, sl, #0
 801fbac:	4b9f      	ldr	r3, [pc, #636]	; (801fe2c <_dtoa_r+0x5f4>)
 801fbae:	4fa0      	ldr	r7, [pc, #640]	; (801fe30 <_dtoa_r+0x5f8>)
 801fbb0:	f006 020f 	and.w	r2, r6, #15
 801fbb4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801fbb8:	e9d3 2300 	ldrd	r2, r3, [r3]
 801fbbc:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 801fbc0:	f7e7 fc22 	bl	8007408 <__aeabi_dmul>
 801fbc4:	e9cd 0100 	strd	r0, r1, [sp]
 801fbc8:	1136      	asrs	r6, r6, #4
 801fbca:	2300      	movs	r3, #0
 801fbcc:	2502      	movs	r5, #2
 801fbce:	2e00      	cmp	r6, #0
 801fbd0:	d17f      	bne.n	801fcd2 <_dtoa_r+0x49a>
 801fbd2:	2b00      	cmp	r3, #0
 801fbd4:	d1e1      	bne.n	801fb9a <_dtoa_r+0x362>
 801fbd6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801fbd8:	2b00      	cmp	r3, #0
 801fbda:	f000 8087 	beq.w	801fcec <_dtoa_r+0x4b4>
 801fbde:	e9dd 6700 	ldrd	r6, r7, [sp]
 801fbe2:	2200      	movs	r2, #0
 801fbe4:	4b93      	ldr	r3, [pc, #588]	; (801fe34 <_dtoa_r+0x5fc>)
 801fbe6:	4630      	mov	r0, r6
 801fbe8:	4639      	mov	r1, r7
 801fbea:	f7e7 fe7f 	bl	80078ec <__aeabi_dcmplt>
 801fbee:	2800      	cmp	r0, #0
 801fbf0:	d07c      	beq.n	801fcec <_dtoa_r+0x4b4>
 801fbf2:	f1b9 0f00 	cmp.w	r9, #0
 801fbf6:	d079      	beq.n	801fcec <_dtoa_r+0x4b4>
 801fbf8:	9b02      	ldr	r3, [sp, #8]
 801fbfa:	2b00      	cmp	r3, #0
 801fbfc:	dd35      	ble.n	801fc6a <_dtoa_r+0x432>
 801fbfe:	f10a 33ff 	add.w	r3, sl, #4294967295
 801fc02:	9308      	str	r3, [sp, #32]
 801fc04:	4639      	mov	r1, r7
 801fc06:	2200      	movs	r2, #0
 801fc08:	4b8b      	ldr	r3, [pc, #556]	; (801fe38 <_dtoa_r+0x600>)
 801fc0a:	4630      	mov	r0, r6
 801fc0c:	f7e7 fbfc 	bl	8007408 <__aeabi_dmul>
 801fc10:	e9cd 0100 	strd	r0, r1, [sp]
 801fc14:	9f02      	ldr	r7, [sp, #8]
 801fc16:	3501      	adds	r5, #1
 801fc18:	4628      	mov	r0, r5
 801fc1a:	f7e7 fb8b 	bl	8007334 <__aeabi_i2d>
 801fc1e:	e9dd 2300 	ldrd	r2, r3, [sp]
 801fc22:	f7e7 fbf1 	bl	8007408 <__aeabi_dmul>
 801fc26:	2200      	movs	r2, #0
 801fc28:	4b84      	ldr	r3, [pc, #528]	; (801fe3c <_dtoa_r+0x604>)
 801fc2a:	f7e7 fa37 	bl	800709c <__adddf3>
 801fc2e:	4605      	mov	r5, r0
 801fc30:	f1a1 7650 	sub.w	r6, r1, #54525952	; 0x3400000
 801fc34:	2f00      	cmp	r7, #0
 801fc36:	d15d      	bne.n	801fcf4 <_dtoa_r+0x4bc>
 801fc38:	2200      	movs	r2, #0
 801fc3a:	4b81      	ldr	r3, [pc, #516]	; (801fe40 <_dtoa_r+0x608>)
 801fc3c:	e9dd 0100 	ldrd	r0, r1, [sp]
 801fc40:	f7e7 fa2a 	bl	8007098 <__aeabi_dsub>
 801fc44:	462a      	mov	r2, r5
 801fc46:	4633      	mov	r3, r6
 801fc48:	e9cd 0100 	strd	r0, r1, [sp]
 801fc4c:	f7e7 fe6c 	bl	8007928 <__aeabi_dcmpgt>
 801fc50:	2800      	cmp	r0, #0
 801fc52:	f040 8288 	bne.w	8020166 <_dtoa_r+0x92e>
 801fc56:	462a      	mov	r2, r5
 801fc58:	f106 4300 	add.w	r3, r6, #2147483648	; 0x80000000
 801fc5c:	e9dd 0100 	ldrd	r0, r1, [sp]
 801fc60:	f7e7 fe44 	bl	80078ec <__aeabi_dcmplt>
 801fc64:	2800      	cmp	r0, #0
 801fc66:	f040 827c 	bne.w	8020162 <_dtoa_r+0x92a>
 801fc6a:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
 801fc6e:	e9cd 2300 	strd	r2, r3, [sp]
 801fc72:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801fc74:	2b00      	cmp	r3, #0
 801fc76:	f2c0 8150 	blt.w	801ff1a <_dtoa_r+0x6e2>
 801fc7a:	f1ba 0f0e 	cmp.w	sl, #14
 801fc7e:	f300 814c 	bgt.w	801ff1a <_dtoa_r+0x6e2>
 801fc82:	4b6a      	ldr	r3, [pc, #424]	; (801fe2c <_dtoa_r+0x5f4>)
 801fc84:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 801fc88:	ed93 7b00 	vldr	d7, [r3]
 801fc8c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801fc8e:	2b00      	cmp	r3, #0
 801fc90:	ed8d 7b02 	vstr	d7, [sp, #8]
 801fc94:	f280 80d8 	bge.w	801fe48 <_dtoa_r+0x610>
 801fc98:	f1b9 0f00 	cmp.w	r9, #0
 801fc9c:	f300 80d4 	bgt.w	801fe48 <_dtoa_r+0x610>
 801fca0:	f040 825e 	bne.w	8020160 <_dtoa_r+0x928>
 801fca4:	2200      	movs	r2, #0
 801fca6:	4b66      	ldr	r3, [pc, #408]	; (801fe40 <_dtoa_r+0x608>)
 801fca8:	ec51 0b17 	vmov	r0, r1, d7
 801fcac:	f7e7 fbac 	bl	8007408 <__aeabi_dmul>
 801fcb0:	e9dd 2300 	ldrd	r2, r3, [sp]
 801fcb4:	f7e7 fe2e 	bl	8007914 <__aeabi_dcmpge>
 801fcb8:	464f      	mov	r7, r9
 801fcba:	464e      	mov	r6, r9
 801fcbc:	2800      	cmp	r0, #0
 801fcbe:	f040 8234 	bne.w	802012a <_dtoa_r+0x8f2>
 801fcc2:	2331      	movs	r3, #49	; 0x31
 801fcc4:	f10b 0501 	add.w	r5, fp, #1
 801fcc8:	f88b 3000 	strb.w	r3, [fp]
 801fccc:	f10a 0a01 	add.w	sl, sl, #1
 801fcd0:	e22f      	b.n	8020132 <_dtoa_r+0x8fa>
 801fcd2:	07f2      	lsls	r2, r6, #31
 801fcd4:	d505      	bpl.n	801fce2 <_dtoa_r+0x4aa>
 801fcd6:	e9d7 2300 	ldrd	r2, r3, [r7]
 801fcda:	f7e7 fb95 	bl	8007408 <__aeabi_dmul>
 801fcde:	3501      	adds	r5, #1
 801fce0:	2301      	movs	r3, #1
 801fce2:	1076      	asrs	r6, r6, #1
 801fce4:	3708      	adds	r7, #8
 801fce6:	e772      	b.n	801fbce <_dtoa_r+0x396>
 801fce8:	2502      	movs	r5, #2
 801fcea:	e774      	b.n	801fbd6 <_dtoa_r+0x39e>
 801fcec:	f8cd a020 	str.w	sl, [sp, #32]
 801fcf0:	464f      	mov	r7, r9
 801fcf2:	e791      	b.n	801fc18 <_dtoa_r+0x3e0>
 801fcf4:	4b4d      	ldr	r3, [pc, #308]	; (801fe2c <_dtoa_r+0x5f4>)
 801fcf6:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 801fcfa:	e953 0102 	ldrd	r0, r1, [r3, #-8]
 801fcfe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801fd00:	2b00      	cmp	r3, #0
 801fd02:	d047      	beq.n	801fd94 <_dtoa_r+0x55c>
 801fd04:	4602      	mov	r2, r0
 801fd06:	460b      	mov	r3, r1
 801fd08:	2000      	movs	r0, #0
 801fd0a:	494e      	ldr	r1, [pc, #312]	; (801fe44 <_dtoa_r+0x60c>)
 801fd0c:	f7e7 fca6 	bl	800765c <__aeabi_ddiv>
 801fd10:	462a      	mov	r2, r5
 801fd12:	4633      	mov	r3, r6
 801fd14:	f7e7 f9c0 	bl	8007098 <__aeabi_dsub>
 801fd18:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 801fd1c:	465d      	mov	r5, fp
 801fd1e:	e9dd 0100 	ldrd	r0, r1, [sp]
 801fd22:	f7e7 fe21 	bl	8007968 <__aeabi_d2iz>
 801fd26:	4606      	mov	r6, r0
 801fd28:	f7e7 fb04 	bl	8007334 <__aeabi_i2d>
 801fd2c:	4602      	mov	r2, r0
 801fd2e:	460b      	mov	r3, r1
 801fd30:	e9dd 0100 	ldrd	r0, r1, [sp]
 801fd34:	f7e7 f9b0 	bl	8007098 <__aeabi_dsub>
 801fd38:	3630      	adds	r6, #48	; 0x30
 801fd3a:	f805 6b01 	strb.w	r6, [r5], #1
 801fd3e:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 801fd42:	e9cd 0100 	strd	r0, r1, [sp]
 801fd46:	f7e7 fdd1 	bl	80078ec <__aeabi_dcmplt>
 801fd4a:	2800      	cmp	r0, #0
 801fd4c:	d163      	bne.n	801fe16 <_dtoa_r+0x5de>
 801fd4e:	e9dd 2300 	ldrd	r2, r3, [sp]
 801fd52:	2000      	movs	r0, #0
 801fd54:	4937      	ldr	r1, [pc, #220]	; (801fe34 <_dtoa_r+0x5fc>)
 801fd56:	f7e7 f99f 	bl	8007098 <__aeabi_dsub>
 801fd5a:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 801fd5e:	f7e7 fdc5 	bl	80078ec <__aeabi_dcmplt>
 801fd62:	2800      	cmp	r0, #0
 801fd64:	f040 80b7 	bne.w	801fed6 <_dtoa_r+0x69e>
 801fd68:	eba5 030b 	sub.w	r3, r5, fp
 801fd6c:	429f      	cmp	r7, r3
 801fd6e:	f77f af7c 	ble.w	801fc6a <_dtoa_r+0x432>
 801fd72:	2200      	movs	r2, #0
 801fd74:	4b30      	ldr	r3, [pc, #192]	; (801fe38 <_dtoa_r+0x600>)
 801fd76:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 801fd7a:	f7e7 fb45 	bl	8007408 <__aeabi_dmul>
 801fd7e:	2200      	movs	r2, #0
 801fd80:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 801fd84:	4b2c      	ldr	r3, [pc, #176]	; (801fe38 <_dtoa_r+0x600>)
 801fd86:	e9dd 0100 	ldrd	r0, r1, [sp]
 801fd8a:	f7e7 fb3d 	bl	8007408 <__aeabi_dmul>
 801fd8e:	e9cd 0100 	strd	r0, r1, [sp]
 801fd92:	e7c4      	b.n	801fd1e <_dtoa_r+0x4e6>
 801fd94:	462a      	mov	r2, r5
 801fd96:	4633      	mov	r3, r6
 801fd98:	f7e7 fb36 	bl	8007408 <__aeabi_dmul>
 801fd9c:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 801fda0:	eb0b 0507 	add.w	r5, fp, r7
 801fda4:	465e      	mov	r6, fp
 801fda6:	e9dd 0100 	ldrd	r0, r1, [sp]
 801fdaa:	f7e7 fddd 	bl	8007968 <__aeabi_d2iz>
 801fdae:	4607      	mov	r7, r0
 801fdb0:	f7e7 fac0 	bl	8007334 <__aeabi_i2d>
 801fdb4:	3730      	adds	r7, #48	; 0x30
 801fdb6:	4602      	mov	r2, r0
 801fdb8:	460b      	mov	r3, r1
 801fdba:	e9dd 0100 	ldrd	r0, r1, [sp]
 801fdbe:	f7e7 f96b 	bl	8007098 <__aeabi_dsub>
 801fdc2:	f806 7b01 	strb.w	r7, [r6], #1
 801fdc6:	42ae      	cmp	r6, r5
 801fdc8:	e9cd 0100 	strd	r0, r1, [sp]
 801fdcc:	f04f 0200 	mov.w	r2, #0
 801fdd0:	d126      	bne.n	801fe20 <_dtoa_r+0x5e8>
 801fdd2:	4b1c      	ldr	r3, [pc, #112]	; (801fe44 <_dtoa_r+0x60c>)
 801fdd4:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 801fdd8:	f7e7 f960 	bl	800709c <__adddf3>
 801fddc:	4602      	mov	r2, r0
 801fdde:	460b      	mov	r3, r1
 801fde0:	e9dd 0100 	ldrd	r0, r1, [sp]
 801fde4:	f7e7 fda0 	bl	8007928 <__aeabi_dcmpgt>
 801fde8:	2800      	cmp	r0, #0
 801fdea:	d174      	bne.n	801fed6 <_dtoa_r+0x69e>
 801fdec:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 801fdf0:	2000      	movs	r0, #0
 801fdf2:	4914      	ldr	r1, [pc, #80]	; (801fe44 <_dtoa_r+0x60c>)
 801fdf4:	f7e7 f950 	bl	8007098 <__aeabi_dsub>
 801fdf8:	4602      	mov	r2, r0
 801fdfa:	460b      	mov	r3, r1
 801fdfc:	e9dd 0100 	ldrd	r0, r1, [sp]
 801fe00:	f7e7 fd74 	bl	80078ec <__aeabi_dcmplt>
 801fe04:	2800      	cmp	r0, #0
 801fe06:	f43f af30 	beq.w	801fc6a <_dtoa_r+0x432>
 801fe0a:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 801fe0e:	2b30      	cmp	r3, #48	; 0x30
 801fe10:	f105 32ff 	add.w	r2, r5, #4294967295
 801fe14:	d002      	beq.n	801fe1c <_dtoa_r+0x5e4>
 801fe16:	f8dd a020 	ldr.w	sl, [sp, #32]
 801fe1a:	e04a      	b.n	801feb2 <_dtoa_r+0x67a>
 801fe1c:	4615      	mov	r5, r2
 801fe1e:	e7f4      	b.n	801fe0a <_dtoa_r+0x5d2>
 801fe20:	4b05      	ldr	r3, [pc, #20]	; (801fe38 <_dtoa_r+0x600>)
 801fe22:	f7e7 faf1 	bl	8007408 <__aeabi_dmul>
 801fe26:	e9cd 0100 	strd	r0, r1, [sp]
 801fe2a:	e7bc      	b.n	801fda6 <_dtoa_r+0x56e>
 801fe2c:	08075f50 	.word	0x08075f50
 801fe30:	08075f28 	.word	0x08075f28
 801fe34:	3ff00000 	.word	0x3ff00000
 801fe38:	40240000 	.word	0x40240000
 801fe3c:	401c0000 	.word	0x401c0000
 801fe40:	40140000 	.word	0x40140000
 801fe44:	3fe00000 	.word	0x3fe00000
 801fe48:	e9dd 6700 	ldrd	r6, r7, [sp]
 801fe4c:	465d      	mov	r5, fp
 801fe4e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 801fe52:	4630      	mov	r0, r6
 801fe54:	4639      	mov	r1, r7
 801fe56:	f7e7 fc01 	bl	800765c <__aeabi_ddiv>
 801fe5a:	f7e7 fd85 	bl	8007968 <__aeabi_d2iz>
 801fe5e:	4680      	mov	r8, r0
 801fe60:	f7e7 fa68 	bl	8007334 <__aeabi_i2d>
 801fe64:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 801fe68:	f7e7 face 	bl	8007408 <__aeabi_dmul>
 801fe6c:	4602      	mov	r2, r0
 801fe6e:	460b      	mov	r3, r1
 801fe70:	4630      	mov	r0, r6
 801fe72:	4639      	mov	r1, r7
 801fe74:	f108 0630 	add.w	r6, r8, #48	; 0x30
 801fe78:	f7e7 f90e 	bl	8007098 <__aeabi_dsub>
 801fe7c:	f805 6b01 	strb.w	r6, [r5], #1
 801fe80:	eba5 060b 	sub.w	r6, r5, fp
 801fe84:	45b1      	cmp	r9, r6
 801fe86:	4602      	mov	r2, r0
 801fe88:	460b      	mov	r3, r1
 801fe8a:	d139      	bne.n	801ff00 <_dtoa_r+0x6c8>
 801fe8c:	f7e7 f906 	bl	800709c <__adddf3>
 801fe90:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 801fe94:	4606      	mov	r6, r0
 801fe96:	460f      	mov	r7, r1
 801fe98:	f7e7 fd46 	bl	8007928 <__aeabi_dcmpgt>
 801fe9c:	b9c8      	cbnz	r0, 801fed2 <_dtoa_r+0x69a>
 801fe9e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 801fea2:	4630      	mov	r0, r6
 801fea4:	4639      	mov	r1, r7
 801fea6:	f7e7 fd17 	bl	80078d8 <__aeabi_dcmpeq>
 801feaa:	b110      	cbz	r0, 801feb2 <_dtoa_r+0x67a>
 801feac:	f018 0f01 	tst.w	r8, #1
 801feb0:	d10f      	bne.n	801fed2 <_dtoa_r+0x69a>
 801feb2:	9904      	ldr	r1, [sp, #16]
 801feb4:	4620      	mov	r0, r4
 801feb6:	f000 fb9b 	bl	80205f0 <_Bfree>
 801feba:	2300      	movs	r3, #0
 801febc:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801febe:	702b      	strb	r3, [r5, #0]
 801fec0:	f10a 0301 	add.w	r3, sl, #1
 801fec4:	6013      	str	r3, [r2, #0]
 801fec6:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801fec8:	2b00      	cmp	r3, #0
 801feca:	f000 8241 	beq.w	8020350 <_dtoa_r+0xb18>
 801fece:	601d      	str	r5, [r3, #0]
 801fed0:	e23e      	b.n	8020350 <_dtoa_r+0xb18>
 801fed2:	f8cd a020 	str.w	sl, [sp, #32]
 801fed6:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 801feda:	2a39      	cmp	r2, #57	; 0x39
 801fedc:	f105 33ff 	add.w	r3, r5, #4294967295
 801fee0:	d108      	bne.n	801fef4 <_dtoa_r+0x6bc>
 801fee2:	459b      	cmp	fp, r3
 801fee4:	d10a      	bne.n	801fefc <_dtoa_r+0x6c4>
 801fee6:	9b08      	ldr	r3, [sp, #32]
 801fee8:	3301      	adds	r3, #1
 801feea:	9308      	str	r3, [sp, #32]
 801feec:	2330      	movs	r3, #48	; 0x30
 801feee:	f88b 3000 	strb.w	r3, [fp]
 801fef2:	465b      	mov	r3, fp
 801fef4:	781a      	ldrb	r2, [r3, #0]
 801fef6:	3201      	adds	r2, #1
 801fef8:	701a      	strb	r2, [r3, #0]
 801fefa:	e78c      	b.n	801fe16 <_dtoa_r+0x5de>
 801fefc:	461d      	mov	r5, r3
 801fefe:	e7ea      	b.n	801fed6 <_dtoa_r+0x69e>
 801ff00:	2200      	movs	r2, #0
 801ff02:	4b9b      	ldr	r3, [pc, #620]	; (8020170 <_dtoa_r+0x938>)
 801ff04:	f7e7 fa80 	bl	8007408 <__aeabi_dmul>
 801ff08:	2200      	movs	r2, #0
 801ff0a:	2300      	movs	r3, #0
 801ff0c:	4606      	mov	r6, r0
 801ff0e:	460f      	mov	r7, r1
 801ff10:	f7e7 fce2 	bl	80078d8 <__aeabi_dcmpeq>
 801ff14:	2800      	cmp	r0, #0
 801ff16:	d09a      	beq.n	801fe4e <_dtoa_r+0x616>
 801ff18:	e7cb      	b.n	801feb2 <_dtoa_r+0x67a>
 801ff1a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801ff1c:	2a00      	cmp	r2, #0
 801ff1e:	f000 808b 	beq.w	8020038 <_dtoa_r+0x800>
 801ff22:	9a06      	ldr	r2, [sp, #24]
 801ff24:	2a01      	cmp	r2, #1
 801ff26:	dc6e      	bgt.n	8020006 <_dtoa_r+0x7ce>
 801ff28:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801ff2a:	2a00      	cmp	r2, #0
 801ff2c:	d067      	beq.n	801fffe <_dtoa_r+0x7c6>
 801ff2e:	f203 4333 	addw	r3, r3, #1075	; 0x433
 801ff32:	9f07      	ldr	r7, [sp, #28]
 801ff34:	9d05      	ldr	r5, [sp, #20]
 801ff36:	9a05      	ldr	r2, [sp, #20]
 801ff38:	2101      	movs	r1, #1
 801ff3a:	441a      	add	r2, r3
 801ff3c:	4620      	mov	r0, r4
 801ff3e:	9205      	str	r2, [sp, #20]
 801ff40:	4498      	add	r8, r3
 801ff42:	f000 fbf5 	bl	8020730 <__i2b>
 801ff46:	4606      	mov	r6, r0
 801ff48:	2d00      	cmp	r5, #0
 801ff4a:	dd0c      	ble.n	801ff66 <_dtoa_r+0x72e>
 801ff4c:	f1b8 0f00 	cmp.w	r8, #0
 801ff50:	dd09      	ble.n	801ff66 <_dtoa_r+0x72e>
 801ff52:	4545      	cmp	r5, r8
 801ff54:	9a05      	ldr	r2, [sp, #20]
 801ff56:	462b      	mov	r3, r5
 801ff58:	bfa8      	it	ge
 801ff5a:	4643      	movge	r3, r8
 801ff5c:	1ad2      	subs	r2, r2, r3
 801ff5e:	9205      	str	r2, [sp, #20]
 801ff60:	1aed      	subs	r5, r5, r3
 801ff62:	eba8 0803 	sub.w	r8, r8, r3
 801ff66:	9b07      	ldr	r3, [sp, #28]
 801ff68:	b1eb      	cbz	r3, 801ffa6 <_dtoa_r+0x76e>
 801ff6a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801ff6c:	2b00      	cmp	r3, #0
 801ff6e:	d067      	beq.n	8020040 <_dtoa_r+0x808>
 801ff70:	b18f      	cbz	r7, 801ff96 <_dtoa_r+0x75e>
 801ff72:	4631      	mov	r1, r6
 801ff74:	463a      	mov	r2, r7
 801ff76:	4620      	mov	r0, r4
 801ff78:	f000 fc7a 	bl	8020870 <__pow5mult>
 801ff7c:	9a04      	ldr	r2, [sp, #16]
 801ff7e:	4601      	mov	r1, r0
 801ff80:	4606      	mov	r6, r0
 801ff82:	4620      	mov	r0, r4
 801ff84:	f000 fbdd 	bl	8020742 <__multiply>
 801ff88:	9904      	ldr	r1, [sp, #16]
 801ff8a:	9008      	str	r0, [sp, #32]
 801ff8c:	4620      	mov	r0, r4
 801ff8e:	f000 fb2f 	bl	80205f0 <_Bfree>
 801ff92:	9b08      	ldr	r3, [sp, #32]
 801ff94:	9304      	str	r3, [sp, #16]
 801ff96:	9b07      	ldr	r3, [sp, #28]
 801ff98:	1bda      	subs	r2, r3, r7
 801ff9a:	d004      	beq.n	801ffa6 <_dtoa_r+0x76e>
 801ff9c:	9904      	ldr	r1, [sp, #16]
 801ff9e:	4620      	mov	r0, r4
 801ffa0:	f000 fc66 	bl	8020870 <__pow5mult>
 801ffa4:	9004      	str	r0, [sp, #16]
 801ffa6:	2101      	movs	r1, #1
 801ffa8:	4620      	mov	r0, r4
 801ffaa:	f000 fbc1 	bl	8020730 <__i2b>
 801ffae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801ffb0:	4607      	mov	r7, r0
 801ffb2:	2b00      	cmp	r3, #0
 801ffb4:	f000 81d0 	beq.w	8020358 <_dtoa_r+0xb20>
 801ffb8:	461a      	mov	r2, r3
 801ffba:	4601      	mov	r1, r0
 801ffbc:	4620      	mov	r0, r4
 801ffbe:	f000 fc57 	bl	8020870 <__pow5mult>
 801ffc2:	9b06      	ldr	r3, [sp, #24]
 801ffc4:	2b01      	cmp	r3, #1
 801ffc6:	4607      	mov	r7, r0
 801ffc8:	dc40      	bgt.n	802004c <_dtoa_r+0x814>
 801ffca:	9b00      	ldr	r3, [sp, #0]
 801ffcc:	2b00      	cmp	r3, #0
 801ffce:	d139      	bne.n	8020044 <_dtoa_r+0x80c>
 801ffd0:	9b01      	ldr	r3, [sp, #4]
 801ffd2:	f3c3 0313 	ubfx	r3, r3, #0, #20
 801ffd6:	2b00      	cmp	r3, #0
 801ffd8:	d136      	bne.n	8020048 <_dtoa_r+0x810>
 801ffda:	9b01      	ldr	r3, [sp, #4]
 801ffdc:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 801ffe0:	0d1b      	lsrs	r3, r3, #20
 801ffe2:	051b      	lsls	r3, r3, #20
 801ffe4:	b12b      	cbz	r3, 801fff2 <_dtoa_r+0x7ba>
 801ffe6:	9b05      	ldr	r3, [sp, #20]
 801ffe8:	3301      	adds	r3, #1
 801ffea:	9305      	str	r3, [sp, #20]
 801ffec:	f108 0801 	add.w	r8, r8, #1
 801fff0:	2301      	movs	r3, #1
 801fff2:	9307      	str	r3, [sp, #28]
 801fff4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801fff6:	2b00      	cmp	r3, #0
 801fff8:	d12a      	bne.n	8020050 <_dtoa_r+0x818>
 801fffa:	2001      	movs	r0, #1
 801fffc:	e030      	b.n	8020060 <_dtoa_r+0x828>
 801fffe:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8020000:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 8020004:	e795      	b.n	801ff32 <_dtoa_r+0x6fa>
 8020006:	9b07      	ldr	r3, [sp, #28]
 8020008:	f109 37ff 	add.w	r7, r9, #4294967295
 802000c:	42bb      	cmp	r3, r7
 802000e:	bfbf      	itttt	lt
 8020010:	9b07      	ldrlt	r3, [sp, #28]
 8020012:	9707      	strlt	r7, [sp, #28]
 8020014:	1afa      	sublt	r2, r7, r3
 8020016:	9b0e      	ldrlt	r3, [sp, #56]	; 0x38
 8020018:	bfbb      	ittet	lt
 802001a:	189b      	addlt	r3, r3, r2
 802001c:	930e      	strlt	r3, [sp, #56]	; 0x38
 802001e:	1bdf      	subge	r7, r3, r7
 8020020:	2700      	movlt	r7, #0
 8020022:	f1b9 0f00 	cmp.w	r9, #0
 8020026:	bfb5      	itete	lt
 8020028:	9b05      	ldrlt	r3, [sp, #20]
 802002a:	9d05      	ldrge	r5, [sp, #20]
 802002c:	eba3 0509 	sublt.w	r5, r3, r9
 8020030:	464b      	movge	r3, r9
 8020032:	bfb8      	it	lt
 8020034:	2300      	movlt	r3, #0
 8020036:	e77e      	b.n	801ff36 <_dtoa_r+0x6fe>
 8020038:	9f07      	ldr	r7, [sp, #28]
 802003a:	9d05      	ldr	r5, [sp, #20]
 802003c:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 802003e:	e783      	b.n	801ff48 <_dtoa_r+0x710>
 8020040:	9a07      	ldr	r2, [sp, #28]
 8020042:	e7ab      	b.n	801ff9c <_dtoa_r+0x764>
 8020044:	2300      	movs	r3, #0
 8020046:	e7d4      	b.n	801fff2 <_dtoa_r+0x7ba>
 8020048:	9b00      	ldr	r3, [sp, #0]
 802004a:	e7d2      	b.n	801fff2 <_dtoa_r+0x7ba>
 802004c:	2300      	movs	r3, #0
 802004e:	9307      	str	r3, [sp, #28]
 8020050:	693b      	ldr	r3, [r7, #16]
 8020052:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 8020056:	6918      	ldr	r0, [r3, #16]
 8020058:	f000 fb1c 	bl	8020694 <__hi0bits>
 802005c:	f1c0 0020 	rsb	r0, r0, #32
 8020060:	4440      	add	r0, r8
 8020062:	f010 001f 	ands.w	r0, r0, #31
 8020066:	d047      	beq.n	80200f8 <_dtoa_r+0x8c0>
 8020068:	f1c0 0320 	rsb	r3, r0, #32
 802006c:	2b04      	cmp	r3, #4
 802006e:	dd3b      	ble.n	80200e8 <_dtoa_r+0x8b0>
 8020070:	9b05      	ldr	r3, [sp, #20]
 8020072:	f1c0 001c 	rsb	r0, r0, #28
 8020076:	4403      	add	r3, r0
 8020078:	9305      	str	r3, [sp, #20]
 802007a:	4405      	add	r5, r0
 802007c:	4480      	add	r8, r0
 802007e:	9b05      	ldr	r3, [sp, #20]
 8020080:	2b00      	cmp	r3, #0
 8020082:	dd05      	ble.n	8020090 <_dtoa_r+0x858>
 8020084:	461a      	mov	r2, r3
 8020086:	9904      	ldr	r1, [sp, #16]
 8020088:	4620      	mov	r0, r4
 802008a:	f000 fc3f 	bl	802090c <__lshift>
 802008e:	9004      	str	r0, [sp, #16]
 8020090:	f1b8 0f00 	cmp.w	r8, #0
 8020094:	dd05      	ble.n	80200a2 <_dtoa_r+0x86a>
 8020096:	4639      	mov	r1, r7
 8020098:	4642      	mov	r2, r8
 802009a:	4620      	mov	r0, r4
 802009c:	f000 fc36 	bl	802090c <__lshift>
 80200a0:	4607      	mov	r7, r0
 80200a2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80200a4:	b353      	cbz	r3, 80200fc <_dtoa_r+0x8c4>
 80200a6:	4639      	mov	r1, r7
 80200a8:	9804      	ldr	r0, [sp, #16]
 80200aa:	f000 fc83 	bl	80209b4 <__mcmp>
 80200ae:	2800      	cmp	r0, #0
 80200b0:	da24      	bge.n	80200fc <_dtoa_r+0x8c4>
 80200b2:	2300      	movs	r3, #0
 80200b4:	220a      	movs	r2, #10
 80200b6:	9904      	ldr	r1, [sp, #16]
 80200b8:	4620      	mov	r0, r4
 80200ba:	f000 fab0 	bl	802061e <__multadd>
 80200be:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80200c0:	9004      	str	r0, [sp, #16]
 80200c2:	f10a 3aff 	add.w	sl, sl, #4294967295
 80200c6:	2b00      	cmp	r3, #0
 80200c8:	f000 814d 	beq.w	8020366 <_dtoa_r+0xb2e>
 80200cc:	2300      	movs	r3, #0
 80200ce:	4631      	mov	r1, r6
 80200d0:	220a      	movs	r2, #10
 80200d2:	4620      	mov	r0, r4
 80200d4:	f000 faa3 	bl	802061e <__multadd>
 80200d8:	9b02      	ldr	r3, [sp, #8]
 80200da:	2b00      	cmp	r3, #0
 80200dc:	4606      	mov	r6, r0
 80200de:	dc4f      	bgt.n	8020180 <_dtoa_r+0x948>
 80200e0:	9b06      	ldr	r3, [sp, #24]
 80200e2:	2b02      	cmp	r3, #2
 80200e4:	dd4c      	ble.n	8020180 <_dtoa_r+0x948>
 80200e6:	e011      	b.n	802010c <_dtoa_r+0x8d4>
 80200e8:	d0c9      	beq.n	802007e <_dtoa_r+0x846>
 80200ea:	9a05      	ldr	r2, [sp, #20]
 80200ec:	331c      	adds	r3, #28
 80200ee:	441a      	add	r2, r3
 80200f0:	9205      	str	r2, [sp, #20]
 80200f2:	441d      	add	r5, r3
 80200f4:	4498      	add	r8, r3
 80200f6:	e7c2      	b.n	802007e <_dtoa_r+0x846>
 80200f8:	4603      	mov	r3, r0
 80200fa:	e7f6      	b.n	80200ea <_dtoa_r+0x8b2>
 80200fc:	f1b9 0f00 	cmp.w	r9, #0
 8020100:	dc38      	bgt.n	8020174 <_dtoa_r+0x93c>
 8020102:	9b06      	ldr	r3, [sp, #24]
 8020104:	2b02      	cmp	r3, #2
 8020106:	dd35      	ble.n	8020174 <_dtoa_r+0x93c>
 8020108:	f8cd 9008 	str.w	r9, [sp, #8]
 802010c:	9b02      	ldr	r3, [sp, #8]
 802010e:	b963      	cbnz	r3, 802012a <_dtoa_r+0x8f2>
 8020110:	4639      	mov	r1, r7
 8020112:	2205      	movs	r2, #5
 8020114:	4620      	mov	r0, r4
 8020116:	f000 fa82 	bl	802061e <__multadd>
 802011a:	4601      	mov	r1, r0
 802011c:	4607      	mov	r7, r0
 802011e:	9804      	ldr	r0, [sp, #16]
 8020120:	f000 fc48 	bl	80209b4 <__mcmp>
 8020124:	2800      	cmp	r0, #0
 8020126:	f73f adcc 	bgt.w	801fcc2 <_dtoa_r+0x48a>
 802012a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802012c:	465d      	mov	r5, fp
 802012e:	ea6f 0a03 	mvn.w	sl, r3
 8020132:	f04f 0900 	mov.w	r9, #0
 8020136:	4639      	mov	r1, r7
 8020138:	4620      	mov	r0, r4
 802013a:	f000 fa59 	bl	80205f0 <_Bfree>
 802013e:	2e00      	cmp	r6, #0
 8020140:	f43f aeb7 	beq.w	801feb2 <_dtoa_r+0x67a>
 8020144:	f1b9 0f00 	cmp.w	r9, #0
 8020148:	d005      	beq.n	8020156 <_dtoa_r+0x91e>
 802014a:	45b1      	cmp	r9, r6
 802014c:	d003      	beq.n	8020156 <_dtoa_r+0x91e>
 802014e:	4649      	mov	r1, r9
 8020150:	4620      	mov	r0, r4
 8020152:	f000 fa4d 	bl	80205f0 <_Bfree>
 8020156:	4631      	mov	r1, r6
 8020158:	4620      	mov	r0, r4
 802015a:	f000 fa49 	bl	80205f0 <_Bfree>
 802015e:	e6a8      	b.n	801feb2 <_dtoa_r+0x67a>
 8020160:	2700      	movs	r7, #0
 8020162:	463e      	mov	r6, r7
 8020164:	e7e1      	b.n	802012a <_dtoa_r+0x8f2>
 8020166:	f8dd a020 	ldr.w	sl, [sp, #32]
 802016a:	463e      	mov	r6, r7
 802016c:	e5a9      	b.n	801fcc2 <_dtoa_r+0x48a>
 802016e:	bf00      	nop
 8020170:	40240000 	.word	0x40240000
 8020174:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020176:	f8cd 9008 	str.w	r9, [sp, #8]
 802017a:	2b00      	cmp	r3, #0
 802017c:	f000 80fa 	beq.w	8020374 <_dtoa_r+0xb3c>
 8020180:	2d00      	cmp	r5, #0
 8020182:	dd05      	ble.n	8020190 <_dtoa_r+0x958>
 8020184:	4631      	mov	r1, r6
 8020186:	462a      	mov	r2, r5
 8020188:	4620      	mov	r0, r4
 802018a:	f000 fbbf 	bl	802090c <__lshift>
 802018e:	4606      	mov	r6, r0
 8020190:	9b07      	ldr	r3, [sp, #28]
 8020192:	2b00      	cmp	r3, #0
 8020194:	d04c      	beq.n	8020230 <_dtoa_r+0x9f8>
 8020196:	6871      	ldr	r1, [r6, #4]
 8020198:	4620      	mov	r0, r4
 802019a:	f000 f9f5 	bl	8020588 <_Balloc>
 802019e:	6932      	ldr	r2, [r6, #16]
 80201a0:	3202      	adds	r2, #2
 80201a2:	4605      	mov	r5, r0
 80201a4:	0092      	lsls	r2, r2, #2
 80201a6:	f106 010c 	add.w	r1, r6, #12
 80201aa:	300c      	adds	r0, #12
 80201ac:	f7fe fcb5 	bl	801eb1a <memcpy>
 80201b0:	2201      	movs	r2, #1
 80201b2:	4629      	mov	r1, r5
 80201b4:	4620      	mov	r0, r4
 80201b6:	f000 fba9 	bl	802090c <__lshift>
 80201ba:	9b00      	ldr	r3, [sp, #0]
 80201bc:	f8cd b014 	str.w	fp, [sp, #20]
 80201c0:	f003 0301 	and.w	r3, r3, #1
 80201c4:	46b1      	mov	r9, r6
 80201c6:	9307      	str	r3, [sp, #28]
 80201c8:	4606      	mov	r6, r0
 80201ca:	4639      	mov	r1, r7
 80201cc:	9804      	ldr	r0, [sp, #16]
 80201ce:	f7ff faa7 	bl	801f720 <quorem>
 80201d2:	4649      	mov	r1, r9
 80201d4:	4605      	mov	r5, r0
 80201d6:	f100 0830 	add.w	r8, r0, #48	; 0x30
 80201da:	9804      	ldr	r0, [sp, #16]
 80201dc:	f000 fbea 	bl	80209b4 <__mcmp>
 80201e0:	4632      	mov	r2, r6
 80201e2:	9000      	str	r0, [sp, #0]
 80201e4:	4639      	mov	r1, r7
 80201e6:	4620      	mov	r0, r4
 80201e8:	f000 fbfe 	bl	80209e8 <__mdiff>
 80201ec:	68c3      	ldr	r3, [r0, #12]
 80201ee:	4602      	mov	r2, r0
 80201f0:	bb03      	cbnz	r3, 8020234 <_dtoa_r+0x9fc>
 80201f2:	4601      	mov	r1, r0
 80201f4:	9008      	str	r0, [sp, #32]
 80201f6:	9804      	ldr	r0, [sp, #16]
 80201f8:	f000 fbdc 	bl	80209b4 <__mcmp>
 80201fc:	9a08      	ldr	r2, [sp, #32]
 80201fe:	4603      	mov	r3, r0
 8020200:	4611      	mov	r1, r2
 8020202:	4620      	mov	r0, r4
 8020204:	9308      	str	r3, [sp, #32]
 8020206:	f000 f9f3 	bl	80205f0 <_Bfree>
 802020a:	9b08      	ldr	r3, [sp, #32]
 802020c:	b9a3      	cbnz	r3, 8020238 <_dtoa_r+0xa00>
 802020e:	9a06      	ldr	r2, [sp, #24]
 8020210:	b992      	cbnz	r2, 8020238 <_dtoa_r+0xa00>
 8020212:	9a07      	ldr	r2, [sp, #28]
 8020214:	b982      	cbnz	r2, 8020238 <_dtoa_r+0xa00>
 8020216:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 802021a:	d029      	beq.n	8020270 <_dtoa_r+0xa38>
 802021c:	9b00      	ldr	r3, [sp, #0]
 802021e:	2b00      	cmp	r3, #0
 8020220:	dd01      	ble.n	8020226 <_dtoa_r+0x9ee>
 8020222:	f105 0831 	add.w	r8, r5, #49	; 0x31
 8020226:	9b05      	ldr	r3, [sp, #20]
 8020228:	1c5d      	adds	r5, r3, #1
 802022a:	f883 8000 	strb.w	r8, [r3]
 802022e:	e782      	b.n	8020136 <_dtoa_r+0x8fe>
 8020230:	4630      	mov	r0, r6
 8020232:	e7c2      	b.n	80201ba <_dtoa_r+0x982>
 8020234:	2301      	movs	r3, #1
 8020236:	e7e3      	b.n	8020200 <_dtoa_r+0x9c8>
 8020238:	9a00      	ldr	r2, [sp, #0]
 802023a:	2a00      	cmp	r2, #0
 802023c:	db04      	blt.n	8020248 <_dtoa_r+0xa10>
 802023e:	d125      	bne.n	802028c <_dtoa_r+0xa54>
 8020240:	9a06      	ldr	r2, [sp, #24]
 8020242:	bb1a      	cbnz	r2, 802028c <_dtoa_r+0xa54>
 8020244:	9a07      	ldr	r2, [sp, #28]
 8020246:	bb0a      	cbnz	r2, 802028c <_dtoa_r+0xa54>
 8020248:	2b00      	cmp	r3, #0
 802024a:	ddec      	ble.n	8020226 <_dtoa_r+0x9ee>
 802024c:	2201      	movs	r2, #1
 802024e:	9904      	ldr	r1, [sp, #16]
 8020250:	4620      	mov	r0, r4
 8020252:	f000 fb5b 	bl	802090c <__lshift>
 8020256:	4639      	mov	r1, r7
 8020258:	9004      	str	r0, [sp, #16]
 802025a:	f000 fbab 	bl	80209b4 <__mcmp>
 802025e:	2800      	cmp	r0, #0
 8020260:	dc03      	bgt.n	802026a <_dtoa_r+0xa32>
 8020262:	d1e0      	bne.n	8020226 <_dtoa_r+0x9ee>
 8020264:	f018 0f01 	tst.w	r8, #1
 8020268:	d0dd      	beq.n	8020226 <_dtoa_r+0x9ee>
 802026a:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 802026e:	d1d8      	bne.n	8020222 <_dtoa_r+0x9ea>
 8020270:	9b05      	ldr	r3, [sp, #20]
 8020272:	9a05      	ldr	r2, [sp, #20]
 8020274:	1c5d      	adds	r5, r3, #1
 8020276:	2339      	movs	r3, #57	; 0x39
 8020278:	7013      	strb	r3, [r2, #0]
 802027a:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 802027e:	2b39      	cmp	r3, #57	; 0x39
 8020280:	f105 32ff 	add.w	r2, r5, #4294967295
 8020284:	d04f      	beq.n	8020326 <_dtoa_r+0xaee>
 8020286:	3301      	adds	r3, #1
 8020288:	7013      	strb	r3, [r2, #0]
 802028a:	e754      	b.n	8020136 <_dtoa_r+0x8fe>
 802028c:	9a05      	ldr	r2, [sp, #20]
 802028e:	2b00      	cmp	r3, #0
 8020290:	f102 0501 	add.w	r5, r2, #1
 8020294:	dd06      	ble.n	80202a4 <_dtoa_r+0xa6c>
 8020296:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 802029a:	d0e9      	beq.n	8020270 <_dtoa_r+0xa38>
 802029c:	f108 0801 	add.w	r8, r8, #1
 80202a0:	9b05      	ldr	r3, [sp, #20]
 80202a2:	e7c2      	b.n	802022a <_dtoa_r+0x9f2>
 80202a4:	9a02      	ldr	r2, [sp, #8]
 80202a6:	f805 8c01 	strb.w	r8, [r5, #-1]
 80202aa:	eba5 030b 	sub.w	r3, r5, fp
 80202ae:	4293      	cmp	r3, r2
 80202b0:	d021      	beq.n	80202f6 <_dtoa_r+0xabe>
 80202b2:	2300      	movs	r3, #0
 80202b4:	220a      	movs	r2, #10
 80202b6:	9904      	ldr	r1, [sp, #16]
 80202b8:	4620      	mov	r0, r4
 80202ba:	f000 f9b0 	bl	802061e <__multadd>
 80202be:	45b1      	cmp	r9, r6
 80202c0:	9004      	str	r0, [sp, #16]
 80202c2:	f04f 0300 	mov.w	r3, #0
 80202c6:	f04f 020a 	mov.w	r2, #10
 80202ca:	4649      	mov	r1, r9
 80202cc:	4620      	mov	r0, r4
 80202ce:	d105      	bne.n	80202dc <_dtoa_r+0xaa4>
 80202d0:	f000 f9a5 	bl	802061e <__multadd>
 80202d4:	4681      	mov	r9, r0
 80202d6:	4606      	mov	r6, r0
 80202d8:	9505      	str	r5, [sp, #20]
 80202da:	e776      	b.n	80201ca <_dtoa_r+0x992>
 80202dc:	f000 f99f 	bl	802061e <__multadd>
 80202e0:	4631      	mov	r1, r6
 80202e2:	4681      	mov	r9, r0
 80202e4:	2300      	movs	r3, #0
 80202e6:	220a      	movs	r2, #10
 80202e8:	4620      	mov	r0, r4
 80202ea:	f000 f998 	bl	802061e <__multadd>
 80202ee:	4606      	mov	r6, r0
 80202f0:	e7f2      	b.n	80202d8 <_dtoa_r+0xaa0>
 80202f2:	f04f 0900 	mov.w	r9, #0
 80202f6:	2201      	movs	r2, #1
 80202f8:	9904      	ldr	r1, [sp, #16]
 80202fa:	4620      	mov	r0, r4
 80202fc:	f000 fb06 	bl	802090c <__lshift>
 8020300:	4639      	mov	r1, r7
 8020302:	9004      	str	r0, [sp, #16]
 8020304:	f000 fb56 	bl	80209b4 <__mcmp>
 8020308:	2800      	cmp	r0, #0
 802030a:	dcb6      	bgt.n	802027a <_dtoa_r+0xa42>
 802030c:	d102      	bne.n	8020314 <_dtoa_r+0xadc>
 802030e:	f018 0f01 	tst.w	r8, #1
 8020312:	d1b2      	bne.n	802027a <_dtoa_r+0xa42>
 8020314:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 8020318:	2b30      	cmp	r3, #48	; 0x30
 802031a:	f105 32ff 	add.w	r2, r5, #4294967295
 802031e:	f47f af0a 	bne.w	8020136 <_dtoa_r+0x8fe>
 8020322:	4615      	mov	r5, r2
 8020324:	e7f6      	b.n	8020314 <_dtoa_r+0xadc>
 8020326:	4593      	cmp	fp, r2
 8020328:	d105      	bne.n	8020336 <_dtoa_r+0xafe>
 802032a:	2331      	movs	r3, #49	; 0x31
 802032c:	f10a 0a01 	add.w	sl, sl, #1
 8020330:	f88b 3000 	strb.w	r3, [fp]
 8020334:	e6ff      	b.n	8020136 <_dtoa_r+0x8fe>
 8020336:	4615      	mov	r5, r2
 8020338:	e79f      	b.n	802027a <_dtoa_r+0xa42>
 802033a:	f8df b064 	ldr.w	fp, [pc, #100]	; 80203a0 <_dtoa_r+0xb68>
 802033e:	e007      	b.n	8020350 <_dtoa_r+0xb18>
 8020340:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8020342:	f8df b060 	ldr.w	fp, [pc, #96]	; 80203a4 <_dtoa_r+0xb6c>
 8020346:	b11b      	cbz	r3, 8020350 <_dtoa_r+0xb18>
 8020348:	f10b 0308 	add.w	r3, fp, #8
 802034c:	9a21      	ldr	r2, [sp, #132]	; 0x84
 802034e:	6013      	str	r3, [r2, #0]
 8020350:	4658      	mov	r0, fp
 8020352:	b017      	add	sp, #92	; 0x5c
 8020354:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020358:	9b06      	ldr	r3, [sp, #24]
 802035a:	2b01      	cmp	r3, #1
 802035c:	f77f ae35 	ble.w	801ffca <_dtoa_r+0x792>
 8020360:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8020362:	9307      	str	r3, [sp, #28]
 8020364:	e649      	b.n	801fffa <_dtoa_r+0x7c2>
 8020366:	9b02      	ldr	r3, [sp, #8]
 8020368:	2b00      	cmp	r3, #0
 802036a:	dc03      	bgt.n	8020374 <_dtoa_r+0xb3c>
 802036c:	9b06      	ldr	r3, [sp, #24]
 802036e:	2b02      	cmp	r3, #2
 8020370:	f73f aecc 	bgt.w	802010c <_dtoa_r+0x8d4>
 8020374:	465d      	mov	r5, fp
 8020376:	4639      	mov	r1, r7
 8020378:	9804      	ldr	r0, [sp, #16]
 802037a:	f7ff f9d1 	bl	801f720 <quorem>
 802037e:	f100 0830 	add.w	r8, r0, #48	; 0x30
 8020382:	f805 8b01 	strb.w	r8, [r5], #1
 8020386:	9a02      	ldr	r2, [sp, #8]
 8020388:	eba5 030b 	sub.w	r3, r5, fp
 802038c:	429a      	cmp	r2, r3
 802038e:	ddb0      	ble.n	80202f2 <_dtoa_r+0xaba>
 8020390:	2300      	movs	r3, #0
 8020392:	220a      	movs	r2, #10
 8020394:	9904      	ldr	r1, [sp, #16]
 8020396:	4620      	mov	r0, r4
 8020398:	f000 f941 	bl	802061e <__multadd>
 802039c:	9004      	str	r0, [sp, #16]
 802039e:	e7ea      	b.n	8020376 <_dtoa_r+0xb3e>
 80203a0:	08075e88 	.word	0x08075e88
 80203a4:	08075eac 	.word	0x08075eac

080203a8 <std>:
 80203a8:	2300      	movs	r3, #0
 80203aa:	b510      	push	{r4, lr}
 80203ac:	4604      	mov	r4, r0
 80203ae:	e9c0 3300 	strd	r3, r3, [r0]
 80203b2:	6083      	str	r3, [r0, #8]
 80203b4:	8181      	strh	r1, [r0, #12]
 80203b6:	6643      	str	r3, [r0, #100]	; 0x64
 80203b8:	81c2      	strh	r2, [r0, #14]
 80203ba:	e9c0 3304 	strd	r3, r3, [r0, #16]
 80203be:	6183      	str	r3, [r0, #24]
 80203c0:	4619      	mov	r1, r3
 80203c2:	2208      	movs	r2, #8
 80203c4:	305c      	adds	r0, #92	; 0x5c
 80203c6:	f7fe fbb3 	bl	801eb30 <memset>
 80203ca:	4b05      	ldr	r3, [pc, #20]	; (80203e0 <std+0x38>)
 80203cc:	6263      	str	r3, [r4, #36]	; 0x24
 80203ce:	4b05      	ldr	r3, [pc, #20]	; (80203e4 <std+0x3c>)
 80203d0:	62a3      	str	r3, [r4, #40]	; 0x28
 80203d2:	4b05      	ldr	r3, [pc, #20]	; (80203e8 <std+0x40>)
 80203d4:	62e3      	str	r3, [r4, #44]	; 0x2c
 80203d6:	4b05      	ldr	r3, [pc, #20]	; (80203ec <std+0x44>)
 80203d8:	6224      	str	r4, [r4, #32]
 80203da:	6323      	str	r3, [r4, #48]	; 0x30
 80203dc:	bd10      	pop	{r4, pc}
 80203de:	bf00      	nop
 80203e0:	08021081 	.word	0x08021081
 80203e4:	080210a3 	.word	0x080210a3
 80203e8:	080210db 	.word	0x080210db
 80203ec:	080210ff 	.word	0x080210ff

080203f0 <_cleanup_r>:
 80203f0:	4901      	ldr	r1, [pc, #4]	; (80203f8 <_cleanup_r+0x8>)
 80203f2:	f000 b885 	b.w	8020500 <_fwalk_reent>
 80203f6:	bf00      	nop
 80203f8:	080213f5 	.word	0x080213f5

080203fc <__sfmoreglue>:
 80203fc:	b570      	push	{r4, r5, r6, lr}
 80203fe:	1e4a      	subs	r2, r1, #1
 8020400:	2568      	movs	r5, #104	; 0x68
 8020402:	4355      	muls	r5, r2
 8020404:	460e      	mov	r6, r1
 8020406:	f105 0174 	add.w	r1, r5, #116	; 0x74
 802040a:	f7fe fbe7 	bl	801ebdc <_malloc_r>
 802040e:	4604      	mov	r4, r0
 8020410:	b140      	cbz	r0, 8020424 <__sfmoreglue+0x28>
 8020412:	2100      	movs	r1, #0
 8020414:	e9c0 1600 	strd	r1, r6, [r0]
 8020418:	300c      	adds	r0, #12
 802041a:	60a0      	str	r0, [r4, #8]
 802041c:	f105 0268 	add.w	r2, r5, #104	; 0x68
 8020420:	f7fe fb86 	bl	801eb30 <memset>
 8020424:	4620      	mov	r0, r4
 8020426:	bd70      	pop	{r4, r5, r6, pc}

08020428 <__sinit>:
 8020428:	6983      	ldr	r3, [r0, #24]
 802042a:	b510      	push	{r4, lr}
 802042c:	4604      	mov	r4, r0
 802042e:	bb33      	cbnz	r3, 802047e <__sinit+0x56>
 8020430:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
 8020434:	6503      	str	r3, [r0, #80]	; 0x50
 8020436:	4b12      	ldr	r3, [pc, #72]	; (8020480 <__sinit+0x58>)
 8020438:	4a12      	ldr	r2, [pc, #72]	; (8020484 <__sinit+0x5c>)
 802043a:	681b      	ldr	r3, [r3, #0]
 802043c:	6282      	str	r2, [r0, #40]	; 0x28
 802043e:	4298      	cmp	r0, r3
 8020440:	bf04      	itt	eq
 8020442:	2301      	moveq	r3, #1
 8020444:	6183      	streq	r3, [r0, #24]
 8020446:	f000 f81f 	bl	8020488 <__sfp>
 802044a:	6060      	str	r0, [r4, #4]
 802044c:	4620      	mov	r0, r4
 802044e:	f000 f81b 	bl	8020488 <__sfp>
 8020452:	60a0      	str	r0, [r4, #8]
 8020454:	4620      	mov	r0, r4
 8020456:	f000 f817 	bl	8020488 <__sfp>
 802045a:	2200      	movs	r2, #0
 802045c:	60e0      	str	r0, [r4, #12]
 802045e:	2104      	movs	r1, #4
 8020460:	6860      	ldr	r0, [r4, #4]
 8020462:	f7ff ffa1 	bl	80203a8 <std>
 8020466:	2201      	movs	r2, #1
 8020468:	2109      	movs	r1, #9
 802046a:	68a0      	ldr	r0, [r4, #8]
 802046c:	f7ff ff9c 	bl	80203a8 <std>
 8020470:	2202      	movs	r2, #2
 8020472:	2112      	movs	r1, #18
 8020474:	68e0      	ldr	r0, [r4, #12]
 8020476:	f7ff ff97 	bl	80203a8 <std>
 802047a:	2301      	movs	r3, #1
 802047c:	61a3      	str	r3, [r4, #24]
 802047e:	bd10      	pop	{r4, pc}
 8020480:	08075e74 	.word	0x08075e74
 8020484:	080203f1 	.word	0x080203f1

08020488 <__sfp>:
 8020488:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802048a:	4b1b      	ldr	r3, [pc, #108]	; (80204f8 <__sfp+0x70>)
 802048c:	681e      	ldr	r6, [r3, #0]
 802048e:	69b3      	ldr	r3, [r6, #24]
 8020490:	4607      	mov	r7, r0
 8020492:	b913      	cbnz	r3, 802049a <__sfp+0x12>
 8020494:	4630      	mov	r0, r6
 8020496:	f7ff ffc7 	bl	8020428 <__sinit>
 802049a:	3648      	adds	r6, #72	; 0x48
 802049c:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 80204a0:	3b01      	subs	r3, #1
 80204a2:	d503      	bpl.n	80204ac <__sfp+0x24>
 80204a4:	6833      	ldr	r3, [r6, #0]
 80204a6:	b133      	cbz	r3, 80204b6 <__sfp+0x2e>
 80204a8:	6836      	ldr	r6, [r6, #0]
 80204aa:	e7f7      	b.n	802049c <__sfp+0x14>
 80204ac:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 80204b0:	b16d      	cbz	r5, 80204ce <__sfp+0x46>
 80204b2:	3468      	adds	r4, #104	; 0x68
 80204b4:	e7f4      	b.n	80204a0 <__sfp+0x18>
 80204b6:	2104      	movs	r1, #4
 80204b8:	4638      	mov	r0, r7
 80204ba:	f7ff ff9f 	bl	80203fc <__sfmoreglue>
 80204be:	6030      	str	r0, [r6, #0]
 80204c0:	2800      	cmp	r0, #0
 80204c2:	d1f1      	bne.n	80204a8 <__sfp+0x20>
 80204c4:	230c      	movs	r3, #12
 80204c6:	603b      	str	r3, [r7, #0]
 80204c8:	4604      	mov	r4, r0
 80204ca:	4620      	mov	r0, r4
 80204cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80204ce:	4b0b      	ldr	r3, [pc, #44]	; (80204fc <__sfp+0x74>)
 80204d0:	6665      	str	r5, [r4, #100]	; 0x64
 80204d2:	e9c4 5500 	strd	r5, r5, [r4]
 80204d6:	60a5      	str	r5, [r4, #8]
 80204d8:	e9c4 3503 	strd	r3, r5, [r4, #12]
 80204dc:	e9c4 5505 	strd	r5, r5, [r4, #20]
 80204e0:	2208      	movs	r2, #8
 80204e2:	4629      	mov	r1, r5
 80204e4:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 80204e8:	f7fe fb22 	bl	801eb30 <memset>
 80204ec:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 80204f0:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 80204f4:	e7e9      	b.n	80204ca <__sfp+0x42>
 80204f6:	bf00      	nop
 80204f8:	08075e74 	.word	0x08075e74
 80204fc:	ffff0001 	.word	0xffff0001

08020500 <_fwalk_reent>:
 8020500:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8020504:	4680      	mov	r8, r0
 8020506:	4689      	mov	r9, r1
 8020508:	f100 0448 	add.w	r4, r0, #72	; 0x48
 802050c:	2600      	movs	r6, #0
 802050e:	b914      	cbnz	r4, 8020516 <_fwalk_reent+0x16>
 8020510:	4630      	mov	r0, r6
 8020512:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8020516:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 802051a:	3f01      	subs	r7, #1
 802051c:	d501      	bpl.n	8020522 <_fwalk_reent+0x22>
 802051e:	6824      	ldr	r4, [r4, #0]
 8020520:	e7f5      	b.n	802050e <_fwalk_reent+0xe>
 8020522:	89ab      	ldrh	r3, [r5, #12]
 8020524:	2b01      	cmp	r3, #1
 8020526:	d907      	bls.n	8020538 <_fwalk_reent+0x38>
 8020528:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 802052c:	3301      	adds	r3, #1
 802052e:	d003      	beq.n	8020538 <_fwalk_reent+0x38>
 8020530:	4629      	mov	r1, r5
 8020532:	4640      	mov	r0, r8
 8020534:	47c8      	blx	r9
 8020536:	4306      	orrs	r6, r0
 8020538:	3568      	adds	r5, #104	; 0x68
 802053a:	e7ee      	b.n	802051a <_fwalk_reent+0x1a>

0802053c <__locale_ctype_ptr_l>:
 802053c:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 8020540:	4770      	bx	lr
	...

08020544 <_localeconv_r>:
 8020544:	4b04      	ldr	r3, [pc, #16]	; (8020558 <_localeconv_r+0x14>)
 8020546:	681b      	ldr	r3, [r3, #0]
 8020548:	6a18      	ldr	r0, [r3, #32]
 802054a:	4b04      	ldr	r3, [pc, #16]	; (802055c <_localeconv_r+0x18>)
 802054c:	2800      	cmp	r0, #0
 802054e:	bf08      	it	eq
 8020550:	4618      	moveq	r0, r3
 8020552:	30f0      	adds	r0, #240	; 0xf0
 8020554:	4770      	bx	lr
 8020556:	bf00      	nop
 8020558:	20001558 	.word	0x20001558
 802055c:	200015bc 	.word	0x200015bc

08020560 <__ascii_mbtowc>:
 8020560:	b082      	sub	sp, #8
 8020562:	b901      	cbnz	r1, 8020566 <__ascii_mbtowc+0x6>
 8020564:	a901      	add	r1, sp, #4
 8020566:	b142      	cbz	r2, 802057a <__ascii_mbtowc+0x1a>
 8020568:	b14b      	cbz	r3, 802057e <__ascii_mbtowc+0x1e>
 802056a:	7813      	ldrb	r3, [r2, #0]
 802056c:	600b      	str	r3, [r1, #0]
 802056e:	7812      	ldrb	r2, [r2, #0]
 8020570:	1c10      	adds	r0, r2, #0
 8020572:	bf18      	it	ne
 8020574:	2001      	movne	r0, #1
 8020576:	b002      	add	sp, #8
 8020578:	4770      	bx	lr
 802057a:	4610      	mov	r0, r2
 802057c:	e7fb      	b.n	8020576 <__ascii_mbtowc+0x16>
 802057e:	f06f 0001 	mvn.w	r0, #1
 8020582:	e7f8      	b.n	8020576 <__ascii_mbtowc+0x16>

08020584 <__malloc_lock>:
 8020584:	4770      	bx	lr

08020586 <__malloc_unlock>:
 8020586:	4770      	bx	lr

08020588 <_Balloc>:
 8020588:	b570      	push	{r4, r5, r6, lr}
 802058a:	6a45      	ldr	r5, [r0, #36]	; 0x24
 802058c:	4604      	mov	r4, r0
 802058e:	460e      	mov	r6, r1
 8020590:	b93d      	cbnz	r5, 80205a2 <_Balloc+0x1a>
 8020592:	2010      	movs	r0, #16
 8020594:	f7fe faa2 	bl	801eadc <malloc>
 8020598:	6260      	str	r0, [r4, #36]	; 0x24
 802059a:	e9c0 5501 	strd	r5, r5, [r0, #4]
 802059e:	6005      	str	r5, [r0, #0]
 80205a0:	60c5      	str	r5, [r0, #12]
 80205a2:	6a65      	ldr	r5, [r4, #36]	; 0x24
 80205a4:	68eb      	ldr	r3, [r5, #12]
 80205a6:	b183      	cbz	r3, 80205ca <_Balloc+0x42>
 80205a8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80205aa:	68db      	ldr	r3, [r3, #12]
 80205ac:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 80205b0:	b9b8      	cbnz	r0, 80205e2 <_Balloc+0x5a>
 80205b2:	2101      	movs	r1, #1
 80205b4:	fa01 f506 	lsl.w	r5, r1, r6
 80205b8:	1d6a      	adds	r2, r5, #5
 80205ba:	0092      	lsls	r2, r2, #2
 80205bc:	4620      	mov	r0, r4
 80205be:	f000 fabf 	bl	8020b40 <_calloc_r>
 80205c2:	b160      	cbz	r0, 80205de <_Balloc+0x56>
 80205c4:	e9c0 6501 	strd	r6, r5, [r0, #4]
 80205c8:	e00e      	b.n	80205e8 <_Balloc+0x60>
 80205ca:	2221      	movs	r2, #33	; 0x21
 80205cc:	2104      	movs	r1, #4
 80205ce:	4620      	mov	r0, r4
 80205d0:	f000 fab6 	bl	8020b40 <_calloc_r>
 80205d4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80205d6:	60e8      	str	r0, [r5, #12]
 80205d8:	68db      	ldr	r3, [r3, #12]
 80205da:	2b00      	cmp	r3, #0
 80205dc:	d1e4      	bne.n	80205a8 <_Balloc+0x20>
 80205de:	2000      	movs	r0, #0
 80205e0:	bd70      	pop	{r4, r5, r6, pc}
 80205e2:	6802      	ldr	r2, [r0, #0]
 80205e4:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
 80205e8:	2300      	movs	r3, #0
 80205ea:	e9c0 3303 	strd	r3, r3, [r0, #12]
 80205ee:	e7f7      	b.n	80205e0 <_Balloc+0x58>

080205f0 <_Bfree>:
 80205f0:	b570      	push	{r4, r5, r6, lr}
 80205f2:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80205f4:	4606      	mov	r6, r0
 80205f6:	460d      	mov	r5, r1
 80205f8:	b93c      	cbnz	r4, 802060a <_Bfree+0x1a>
 80205fa:	2010      	movs	r0, #16
 80205fc:	f7fe fa6e 	bl	801eadc <malloc>
 8020600:	6270      	str	r0, [r6, #36]	; 0x24
 8020602:	e9c0 4401 	strd	r4, r4, [r0, #4]
 8020606:	6004      	str	r4, [r0, #0]
 8020608:	60c4      	str	r4, [r0, #12]
 802060a:	b13d      	cbz	r5, 802061c <_Bfree+0x2c>
 802060c:	6a73      	ldr	r3, [r6, #36]	; 0x24
 802060e:	686a      	ldr	r2, [r5, #4]
 8020610:	68db      	ldr	r3, [r3, #12]
 8020612:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8020616:	6029      	str	r1, [r5, #0]
 8020618:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
 802061c:	bd70      	pop	{r4, r5, r6, pc}

0802061e <__multadd>:
 802061e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020622:	690d      	ldr	r5, [r1, #16]
 8020624:	461f      	mov	r7, r3
 8020626:	4606      	mov	r6, r0
 8020628:	460c      	mov	r4, r1
 802062a:	f101 0c14 	add.w	ip, r1, #20
 802062e:	2300      	movs	r3, #0
 8020630:	f8dc 0000 	ldr.w	r0, [ip]
 8020634:	b281      	uxth	r1, r0
 8020636:	fb02 7101 	mla	r1, r2, r1, r7
 802063a:	0c0f      	lsrs	r7, r1, #16
 802063c:	0c00      	lsrs	r0, r0, #16
 802063e:	fb02 7000 	mla	r0, r2, r0, r7
 8020642:	b289      	uxth	r1, r1
 8020644:	3301      	adds	r3, #1
 8020646:	eb01 4100 	add.w	r1, r1, r0, lsl #16
 802064a:	429d      	cmp	r5, r3
 802064c:	ea4f 4710 	mov.w	r7, r0, lsr #16
 8020650:	f84c 1b04 	str.w	r1, [ip], #4
 8020654:	dcec      	bgt.n	8020630 <__multadd+0x12>
 8020656:	b1d7      	cbz	r7, 802068e <__multadd+0x70>
 8020658:	68a3      	ldr	r3, [r4, #8]
 802065a:	42ab      	cmp	r3, r5
 802065c:	dc12      	bgt.n	8020684 <__multadd+0x66>
 802065e:	6861      	ldr	r1, [r4, #4]
 8020660:	4630      	mov	r0, r6
 8020662:	3101      	adds	r1, #1
 8020664:	f7ff ff90 	bl	8020588 <_Balloc>
 8020668:	6922      	ldr	r2, [r4, #16]
 802066a:	3202      	adds	r2, #2
 802066c:	f104 010c 	add.w	r1, r4, #12
 8020670:	4680      	mov	r8, r0
 8020672:	0092      	lsls	r2, r2, #2
 8020674:	300c      	adds	r0, #12
 8020676:	f7fe fa50 	bl	801eb1a <memcpy>
 802067a:	4621      	mov	r1, r4
 802067c:	4630      	mov	r0, r6
 802067e:	f7ff ffb7 	bl	80205f0 <_Bfree>
 8020682:	4644      	mov	r4, r8
 8020684:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 8020688:	3501      	adds	r5, #1
 802068a:	615f      	str	r7, [r3, #20]
 802068c:	6125      	str	r5, [r4, #16]
 802068e:	4620      	mov	r0, r4
 8020690:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08020694 <__hi0bits>:
 8020694:	0c02      	lsrs	r2, r0, #16
 8020696:	0412      	lsls	r2, r2, #16
 8020698:	4603      	mov	r3, r0
 802069a:	b9b2      	cbnz	r2, 80206ca <__hi0bits+0x36>
 802069c:	0403      	lsls	r3, r0, #16
 802069e:	2010      	movs	r0, #16
 80206a0:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
 80206a4:	bf04      	itt	eq
 80206a6:	021b      	lsleq	r3, r3, #8
 80206a8:	3008      	addeq	r0, #8
 80206aa:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
 80206ae:	bf04      	itt	eq
 80206b0:	011b      	lsleq	r3, r3, #4
 80206b2:	3004      	addeq	r0, #4
 80206b4:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
 80206b8:	bf04      	itt	eq
 80206ba:	009b      	lsleq	r3, r3, #2
 80206bc:	3002      	addeq	r0, #2
 80206be:	2b00      	cmp	r3, #0
 80206c0:	db06      	blt.n	80206d0 <__hi0bits+0x3c>
 80206c2:	005b      	lsls	r3, r3, #1
 80206c4:	d503      	bpl.n	80206ce <__hi0bits+0x3a>
 80206c6:	3001      	adds	r0, #1
 80206c8:	4770      	bx	lr
 80206ca:	2000      	movs	r0, #0
 80206cc:	e7e8      	b.n	80206a0 <__hi0bits+0xc>
 80206ce:	2020      	movs	r0, #32
 80206d0:	4770      	bx	lr

080206d2 <__lo0bits>:
 80206d2:	6803      	ldr	r3, [r0, #0]
 80206d4:	f013 0207 	ands.w	r2, r3, #7
 80206d8:	4601      	mov	r1, r0
 80206da:	d00b      	beq.n	80206f4 <__lo0bits+0x22>
 80206dc:	07da      	lsls	r2, r3, #31
 80206de:	d423      	bmi.n	8020728 <__lo0bits+0x56>
 80206e0:	0798      	lsls	r0, r3, #30
 80206e2:	bf49      	itett	mi
 80206e4:	085b      	lsrmi	r3, r3, #1
 80206e6:	089b      	lsrpl	r3, r3, #2
 80206e8:	2001      	movmi	r0, #1
 80206ea:	600b      	strmi	r3, [r1, #0]
 80206ec:	bf5c      	itt	pl
 80206ee:	600b      	strpl	r3, [r1, #0]
 80206f0:	2002      	movpl	r0, #2
 80206f2:	4770      	bx	lr
 80206f4:	b298      	uxth	r0, r3
 80206f6:	b9a8      	cbnz	r0, 8020724 <__lo0bits+0x52>
 80206f8:	0c1b      	lsrs	r3, r3, #16
 80206fa:	2010      	movs	r0, #16
 80206fc:	f013 0fff 	tst.w	r3, #255	; 0xff
 8020700:	bf04      	itt	eq
 8020702:	0a1b      	lsreq	r3, r3, #8
 8020704:	3008      	addeq	r0, #8
 8020706:	071a      	lsls	r2, r3, #28
 8020708:	bf04      	itt	eq
 802070a:	091b      	lsreq	r3, r3, #4
 802070c:	3004      	addeq	r0, #4
 802070e:	079a      	lsls	r2, r3, #30
 8020710:	bf04      	itt	eq
 8020712:	089b      	lsreq	r3, r3, #2
 8020714:	3002      	addeq	r0, #2
 8020716:	07da      	lsls	r2, r3, #31
 8020718:	d402      	bmi.n	8020720 <__lo0bits+0x4e>
 802071a:	085b      	lsrs	r3, r3, #1
 802071c:	d006      	beq.n	802072c <__lo0bits+0x5a>
 802071e:	3001      	adds	r0, #1
 8020720:	600b      	str	r3, [r1, #0]
 8020722:	4770      	bx	lr
 8020724:	4610      	mov	r0, r2
 8020726:	e7e9      	b.n	80206fc <__lo0bits+0x2a>
 8020728:	2000      	movs	r0, #0
 802072a:	4770      	bx	lr
 802072c:	2020      	movs	r0, #32
 802072e:	4770      	bx	lr

08020730 <__i2b>:
 8020730:	b510      	push	{r4, lr}
 8020732:	460c      	mov	r4, r1
 8020734:	2101      	movs	r1, #1
 8020736:	f7ff ff27 	bl	8020588 <_Balloc>
 802073a:	2201      	movs	r2, #1
 802073c:	6144      	str	r4, [r0, #20]
 802073e:	6102      	str	r2, [r0, #16]
 8020740:	bd10      	pop	{r4, pc}

08020742 <__multiply>:
 8020742:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020746:	4614      	mov	r4, r2
 8020748:	690a      	ldr	r2, [r1, #16]
 802074a:	6923      	ldr	r3, [r4, #16]
 802074c:	429a      	cmp	r2, r3
 802074e:	bfb8      	it	lt
 8020750:	460b      	movlt	r3, r1
 8020752:	4688      	mov	r8, r1
 8020754:	bfbc      	itt	lt
 8020756:	46a0      	movlt	r8, r4
 8020758:	461c      	movlt	r4, r3
 802075a:	f8d8 7010 	ldr.w	r7, [r8, #16]
 802075e:	f8d4 9010 	ldr.w	r9, [r4, #16]
 8020762:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8020766:	f8d8 1004 	ldr.w	r1, [r8, #4]
 802076a:	eb07 0609 	add.w	r6, r7, r9
 802076e:	42b3      	cmp	r3, r6
 8020770:	bfb8      	it	lt
 8020772:	3101      	addlt	r1, #1
 8020774:	f7ff ff08 	bl	8020588 <_Balloc>
 8020778:	f100 0514 	add.w	r5, r0, #20
 802077c:	eb05 0e86 	add.w	lr, r5, r6, lsl #2
 8020780:	462b      	mov	r3, r5
 8020782:	2200      	movs	r2, #0
 8020784:	4573      	cmp	r3, lr
 8020786:	d316      	bcc.n	80207b6 <__multiply+0x74>
 8020788:	f104 0214 	add.w	r2, r4, #20
 802078c:	f108 0114 	add.w	r1, r8, #20
 8020790:	eb02 0389 	add.w	r3, r2, r9, lsl #2
 8020794:	eb01 0787 	add.w	r7, r1, r7, lsl #2
 8020798:	9300      	str	r3, [sp, #0]
 802079a:	9b00      	ldr	r3, [sp, #0]
 802079c:	9201      	str	r2, [sp, #4]
 802079e:	4293      	cmp	r3, r2
 80207a0:	d80c      	bhi.n	80207bc <__multiply+0x7a>
 80207a2:	2e00      	cmp	r6, #0
 80207a4:	dd03      	ble.n	80207ae <__multiply+0x6c>
 80207a6:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
 80207aa:	2b00      	cmp	r3, #0
 80207ac:	d05d      	beq.n	802086a <__multiply+0x128>
 80207ae:	6106      	str	r6, [r0, #16]
 80207b0:	b003      	add	sp, #12
 80207b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80207b6:	f843 2b04 	str.w	r2, [r3], #4
 80207ba:	e7e3      	b.n	8020784 <__multiply+0x42>
 80207bc:	f8b2 b000 	ldrh.w	fp, [r2]
 80207c0:	f1bb 0f00 	cmp.w	fp, #0
 80207c4:	d023      	beq.n	802080e <__multiply+0xcc>
 80207c6:	4689      	mov	r9, r1
 80207c8:	46ac      	mov	ip, r5
 80207ca:	f04f 0800 	mov.w	r8, #0
 80207ce:	f859 4b04 	ldr.w	r4, [r9], #4
 80207d2:	f8dc a000 	ldr.w	sl, [ip]
 80207d6:	b2a3      	uxth	r3, r4
 80207d8:	fa1f fa8a 	uxth.w	sl, sl
 80207dc:	fb0b a303 	mla	r3, fp, r3, sl
 80207e0:	ea4f 4a14 	mov.w	sl, r4, lsr #16
 80207e4:	f8dc 4000 	ldr.w	r4, [ip]
 80207e8:	4443      	add	r3, r8
 80207ea:	ea4f 4814 	mov.w	r8, r4, lsr #16
 80207ee:	fb0b 840a 	mla	r4, fp, sl, r8
 80207f2:	eb04 4413 	add.w	r4, r4, r3, lsr #16
 80207f6:	46e2      	mov	sl, ip
 80207f8:	b29b      	uxth	r3, r3
 80207fa:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 80207fe:	454f      	cmp	r7, r9
 8020800:	ea4f 4814 	mov.w	r8, r4, lsr #16
 8020804:	f84a 3b04 	str.w	r3, [sl], #4
 8020808:	d82b      	bhi.n	8020862 <__multiply+0x120>
 802080a:	f8cc 8004 	str.w	r8, [ip, #4]
 802080e:	9b01      	ldr	r3, [sp, #4]
 8020810:	f8b3 a002 	ldrh.w	sl, [r3, #2]
 8020814:	3204      	adds	r2, #4
 8020816:	f1ba 0f00 	cmp.w	sl, #0
 802081a:	d020      	beq.n	802085e <__multiply+0x11c>
 802081c:	682b      	ldr	r3, [r5, #0]
 802081e:	4689      	mov	r9, r1
 8020820:	46a8      	mov	r8, r5
 8020822:	f04f 0b00 	mov.w	fp, #0
 8020826:	f8b9 c000 	ldrh.w	ip, [r9]
 802082a:	f8b8 4002 	ldrh.w	r4, [r8, #2]
 802082e:	fb0a 440c 	mla	r4, sl, ip, r4
 8020832:	445c      	add	r4, fp
 8020834:	46c4      	mov	ip, r8
 8020836:	b29b      	uxth	r3, r3
 8020838:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 802083c:	f84c 3b04 	str.w	r3, [ip], #4
 8020840:	f859 3b04 	ldr.w	r3, [r9], #4
 8020844:	f8b8 b004 	ldrh.w	fp, [r8, #4]
 8020848:	0c1b      	lsrs	r3, r3, #16
 802084a:	fb0a b303 	mla	r3, sl, r3, fp
 802084e:	eb03 4314 	add.w	r3, r3, r4, lsr #16
 8020852:	454f      	cmp	r7, r9
 8020854:	ea4f 4b13 	mov.w	fp, r3, lsr #16
 8020858:	d805      	bhi.n	8020866 <__multiply+0x124>
 802085a:	f8c8 3004 	str.w	r3, [r8, #4]
 802085e:	3504      	adds	r5, #4
 8020860:	e79b      	b.n	802079a <__multiply+0x58>
 8020862:	46d4      	mov	ip, sl
 8020864:	e7b3      	b.n	80207ce <__multiply+0x8c>
 8020866:	46e0      	mov	r8, ip
 8020868:	e7dd      	b.n	8020826 <__multiply+0xe4>
 802086a:	3e01      	subs	r6, #1
 802086c:	e799      	b.n	80207a2 <__multiply+0x60>
	...

08020870 <__pow5mult>:
 8020870:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8020874:	4615      	mov	r5, r2
 8020876:	f012 0203 	ands.w	r2, r2, #3
 802087a:	4606      	mov	r6, r0
 802087c:	460f      	mov	r7, r1
 802087e:	d007      	beq.n	8020890 <__pow5mult+0x20>
 8020880:	3a01      	subs	r2, #1
 8020882:	4c21      	ldr	r4, [pc, #132]	; (8020908 <__pow5mult+0x98>)
 8020884:	2300      	movs	r3, #0
 8020886:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 802088a:	f7ff fec8 	bl	802061e <__multadd>
 802088e:	4607      	mov	r7, r0
 8020890:	10ad      	asrs	r5, r5, #2
 8020892:	d035      	beq.n	8020900 <__pow5mult+0x90>
 8020894:	6a74      	ldr	r4, [r6, #36]	; 0x24
 8020896:	b93c      	cbnz	r4, 80208a8 <__pow5mult+0x38>
 8020898:	2010      	movs	r0, #16
 802089a:	f7fe f91f 	bl	801eadc <malloc>
 802089e:	6270      	str	r0, [r6, #36]	; 0x24
 80208a0:	e9c0 4401 	strd	r4, r4, [r0, #4]
 80208a4:	6004      	str	r4, [r0, #0]
 80208a6:	60c4      	str	r4, [r0, #12]
 80208a8:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
 80208ac:	f8d8 4008 	ldr.w	r4, [r8, #8]
 80208b0:	b94c      	cbnz	r4, 80208c6 <__pow5mult+0x56>
 80208b2:	f240 2171 	movw	r1, #625	; 0x271
 80208b6:	4630      	mov	r0, r6
 80208b8:	f7ff ff3a 	bl	8020730 <__i2b>
 80208bc:	2300      	movs	r3, #0
 80208be:	f8c8 0008 	str.w	r0, [r8, #8]
 80208c2:	4604      	mov	r4, r0
 80208c4:	6003      	str	r3, [r0, #0]
 80208c6:	f04f 0800 	mov.w	r8, #0
 80208ca:	07eb      	lsls	r3, r5, #31
 80208cc:	d50a      	bpl.n	80208e4 <__pow5mult+0x74>
 80208ce:	4639      	mov	r1, r7
 80208d0:	4622      	mov	r2, r4
 80208d2:	4630      	mov	r0, r6
 80208d4:	f7ff ff35 	bl	8020742 <__multiply>
 80208d8:	4639      	mov	r1, r7
 80208da:	4681      	mov	r9, r0
 80208dc:	4630      	mov	r0, r6
 80208de:	f7ff fe87 	bl	80205f0 <_Bfree>
 80208e2:	464f      	mov	r7, r9
 80208e4:	106d      	asrs	r5, r5, #1
 80208e6:	d00b      	beq.n	8020900 <__pow5mult+0x90>
 80208e8:	6820      	ldr	r0, [r4, #0]
 80208ea:	b938      	cbnz	r0, 80208fc <__pow5mult+0x8c>
 80208ec:	4622      	mov	r2, r4
 80208ee:	4621      	mov	r1, r4
 80208f0:	4630      	mov	r0, r6
 80208f2:	f7ff ff26 	bl	8020742 <__multiply>
 80208f6:	6020      	str	r0, [r4, #0]
 80208f8:	f8c0 8000 	str.w	r8, [r0]
 80208fc:	4604      	mov	r4, r0
 80208fe:	e7e4      	b.n	80208ca <__pow5mult+0x5a>
 8020900:	4638      	mov	r0, r7
 8020902:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8020906:	bf00      	nop
 8020908:	08076018 	.word	0x08076018

0802090c <__lshift>:
 802090c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8020910:	460c      	mov	r4, r1
 8020912:	ea4f 1a62 	mov.w	sl, r2, asr #5
 8020916:	6923      	ldr	r3, [r4, #16]
 8020918:	6849      	ldr	r1, [r1, #4]
 802091a:	eb0a 0903 	add.w	r9, sl, r3
 802091e:	68a3      	ldr	r3, [r4, #8]
 8020920:	4607      	mov	r7, r0
 8020922:	4616      	mov	r6, r2
 8020924:	f109 0501 	add.w	r5, r9, #1
 8020928:	42ab      	cmp	r3, r5
 802092a:	db32      	blt.n	8020992 <__lshift+0x86>
 802092c:	4638      	mov	r0, r7
 802092e:	f7ff fe2b 	bl	8020588 <_Balloc>
 8020932:	2300      	movs	r3, #0
 8020934:	4680      	mov	r8, r0
 8020936:	f100 0114 	add.w	r1, r0, #20
 802093a:	461a      	mov	r2, r3
 802093c:	4553      	cmp	r3, sl
 802093e:	db2b      	blt.n	8020998 <__lshift+0x8c>
 8020940:	6920      	ldr	r0, [r4, #16]
 8020942:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 8020946:	f104 0314 	add.w	r3, r4, #20
 802094a:	f016 021f 	ands.w	r2, r6, #31
 802094e:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8020952:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 8020956:	d025      	beq.n	80209a4 <__lshift+0x98>
 8020958:	f1c2 0e20 	rsb	lr, r2, #32
 802095c:	2000      	movs	r0, #0
 802095e:	681e      	ldr	r6, [r3, #0]
 8020960:	468a      	mov	sl, r1
 8020962:	4096      	lsls	r6, r2
 8020964:	4330      	orrs	r0, r6
 8020966:	f84a 0b04 	str.w	r0, [sl], #4
 802096a:	f853 0b04 	ldr.w	r0, [r3], #4
 802096e:	459c      	cmp	ip, r3
 8020970:	fa20 f00e 	lsr.w	r0, r0, lr
 8020974:	d814      	bhi.n	80209a0 <__lshift+0x94>
 8020976:	6048      	str	r0, [r1, #4]
 8020978:	b108      	cbz	r0, 802097e <__lshift+0x72>
 802097a:	f109 0502 	add.w	r5, r9, #2
 802097e:	3d01      	subs	r5, #1
 8020980:	4638      	mov	r0, r7
 8020982:	f8c8 5010 	str.w	r5, [r8, #16]
 8020986:	4621      	mov	r1, r4
 8020988:	f7ff fe32 	bl	80205f0 <_Bfree>
 802098c:	4640      	mov	r0, r8
 802098e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8020992:	3101      	adds	r1, #1
 8020994:	005b      	lsls	r3, r3, #1
 8020996:	e7c7      	b.n	8020928 <__lshift+0x1c>
 8020998:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 802099c:	3301      	adds	r3, #1
 802099e:	e7cd      	b.n	802093c <__lshift+0x30>
 80209a0:	4651      	mov	r1, sl
 80209a2:	e7dc      	b.n	802095e <__lshift+0x52>
 80209a4:	3904      	subs	r1, #4
 80209a6:	f853 2b04 	ldr.w	r2, [r3], #4
 80209aa:	f841 2f04 	str.w	r2, [r1, #4]!
 80209ae:	459c      	cmp	ip, r3
 80209b0:	d8f9      	bhi.n	80209a6 <__lshift+0x9a>
 80209b2:	e7e4      	b.n	802097e <__lshift+0x72>

080209b4 <__mcmp>:
 80209b4:	6903      	ldr	r3, [r0, #16]
 80209b6:	690a      	ldr	r2, [r1, #16]
 80209b8:	1a9b      	subs	r3, r3, r2
 80209ba:	b530      	push	{r4, r5, lr}
 80209bc:	d10c      	bne.n	80209d8 <__mcmp+0x24>
 80209be:	0092      	lsls	r2, r2, #2
 80209c0:	3014      	adds	r0, #20
 80209c2:	3114      	adds	r1, #20
 80209c4:	1884      	adds	r4, r0, r2
 80209c6:	4411      	add	r1, r2
 80209c8:	f854 5d04 	ldr.w	r5, [r4, #-4]!
 80209cc:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 80209d0:	4295      	cmp	r5, r2
 80209d2:	d003      	beq.n	80209dc <__mcmp+0x28>
 80209d4:	d305      	bcc.n	80209e2 <__mcmp+0x2e>
 80209d6:	2301      	movs	r3, #1
 80209d8:	4618      	mov	r0, r3
 80209da:	bd30      	pop	{r4, r5, pc}
 80209dc:	42a0      	cmp	r0, r4
 80209de:	d3f3      	bcc.n	80209c8 <__mcmp+0x14>
 80209e0:	e7fa      	b.n	80209d8 <__mcmp+0x24>
 80209e2:	f04f 33ff 	mov.w	r3, #4294967295
 80209e6:	e7f7      	b.n	80209d8 <__mcmp+0x24>

080209e8 <__mdiff>:
 80209e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80209ec:	460d      	mov	r5, r1
 80209ee:	4607      	mov	r7, r0
 80209f0:	4611      	mov	r1, r2
 80209f2:	4628      	mov	r0, r5
 80209f4:	4614      	mov	r4, r2
 80209f6:	f7ff ffdd 	bl	80209b4 <__mcmp>
 80209fa:	1e06      	subs	r6, r0, #0
 80209fc:	d108      	bne.n	8020a10 <__mdiff+0x28>
 80209fe:	4631      	mov	r1, r6
 8020a00:	4638      	mov	r0, r7
 8020a02:	f7ff fdc1 	bl	8020588 <_Balloc>
 8020a06:	2301      	movs	r3, #1
 8020a08:	e9c0 3604 	strd	r3, r6, [r0, #16]
 8020a0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8020a10:	bfa4      	itt	ge
 8020a12:	4623      	movge	r3, r4
 8020a14:	462c      	movge	r4, r5
 8020a16:	4638      	mov	r0, r7
 8020a18:	6861      	ldr	r1, [r4, #4]
 8020a1a:	bfa6      	itte	ge
 8020a1c:	461d      	movge	r5, r3
 8020a1e:	2600      	movge	r6, #0
 8020a20:	2601      	movlt	r6, #1
 8020a22:	f7ff fdb1 	bl	8020588 <_Balloc>
 8020a26:	692b      	ldr	r3, [r5, #16]
 8020a28:	60c6      	str	r6, [r0, #12]
 8020a2a:	6926      	ldr	r6, [r4, #16]
 8020a2c:	f105 0914 	add.w	r9, r5, #20
 8020a30:	f104 0214 	add.w	r2, r4, #20
 8020a34:	eb02 0786 	add.w	r7, r2, r6, lsl #2
 8020a38:	eb09 0883 	add.w	r8, r9, r3, lsl #2
 8020a3c:	f100 0514 	add.w	r5, r0, #20
 8020a40:	f04f 0e00 	mov.w	lr, #0
 8020a44:	f852 ab04 	ldr.w	sl, [r2], #4
 8020a48:	f859 4b04 	ldr.w	r4, [r9], #4
 8020a4c:	fa1e f18a 	uxtah	r1, lr, sl
 8020a50:	b2a3      	uxth	r3, r4
 8020a52:	1ac9      	subs	r1, r1, r3
 8020a54:	0c23      	lsrs	r3, r4, #16
 8020a56:	ebc3 431a 	rsb	r3, r3, sl, lsr #16
 8020a5a:	eb03 4321 	add.w	r3, r3, r1, asr #16
 8020a5e:	b289      	uxth	r1, r1
 8020a60:	ea4f 4e23 	mov.w	lr, r3, asr #16
 8020a64:	45c8      	cmp	r8, r9
 8020a66:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 8020a6a:	4694      	mov	ip, r2
 8020a6c:	f845 3b04 	str.w	r3, [r5], #4
 8020a70:	d8e8      	bhi.n	8020a44 <__mdiff+0x5c>
 8020a72:	45bc      	cmp	ip, r7
 8020a74:	d304      	bcc.n	8020a80 <__mdiff+0x98>
 8020a76:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8020a7a:	b183      	cbz	r3, 8020a9e <__mdiff+0xb6>
 8020a7c:	6106      	str	r6, [r0, #16]
 8020a7e:	e7c5      	b.n	8020a0c <__mdiff+0x24>
 8020a80:	f85c 1b04 	ldr.w	r1, [ip], #4
 8020a84:	fa1e f381 	uxtah	r3, lr, r1
 8020a88:	141a      	asrs	r2, r3, #16
 8020a8a:	eb02 4211 	add.w	r2, r2, r1, lsr #16
 8020a8e:	b29b      	uxth	r3, r3
 8020a90:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8020a94:	ea4f 4e22 	mov.w	lr, r2, asr #16
 8020a98:	f845 3b04 	str.w	r3, [r5], #4
 8020a9c:	e7e9      	b.n	8020a72 <__mdiff+0x8a>
 8020a9e:	3e01      	subs	r6, #1
 8020aa0:	e7e9      	b.n	8020a76 <__mdiff+0x8e>

08020aa2 <__d2b>:
 8020aa2:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8020aa6:	460e      	mov	r6, r1
 8020aa8:	2101      	movs	r1, #1
 8020aaa:	ec59 8b10 	vmov	r8, r9, d0
 8020aae:	4615      	mov	r5, r2
 8020ab0:	f7ff fd6a 	bl	8020588 <_Balloc>
 8020ab4:	f3c9 540a 	ubfx	r4, r9, #20, #11
 8020ab8:	4607      	mov	r7, r0
 8020aba:	f3c9 0313 	ubfx	r3, r9, #0, #20
 8020abe:	bb34      	cbnz	r4, 8020b0e <__d2b+0x6c>
 8020ac0:	9301      	str	r3, [sp, #4]
 8020ac2:	f1b8 0300 	subs.w	r3, r8, #0
 8020ac6:	d027      	beq.n	8020b18 <__d2b+0x76>
 8020ac8:	a802      	add	r0, sp, #8
 8020aca:	f840 3d08 	str.w	r3, [r0, #-8]!
 8020ace:	f7ff fe00 	bl	80206d2 <__lo0bits>
 8020ad2:	9900      	ldr	r1, [sp, #0]
 8020ad4:	b1f0      	cbz	r0, 8020b14 <__d2b+0x72>
 8020ad6:	9a01      	ldr	r2, [sp, #4]
 8020ad8:	f1c0 0320 	rsb	r3, r0, #32
 8020adc:	fa02 f303 	lsl.w	r3, r2, r3
 8020ae0:	430b      	orrs	r3, r1
 8020ae2:	40c2      	lsrs	r2, r0
 8020ae4:	617b      	str	r3, [r7, #20]
 8020ae6:	9201      	str	r2, [sp, #4]
 8020ae8:	9b01      	ldr	r3, [sp, #4]
 8020aea:	61bb      	str	r3, [r7, #24]
 8020aec:	2b00      	cmp	r3, #0
 8020aee:	bf14      	ite	ne
 8020af0:	2102      	movne	r1, #2
 8020af2:	2101      	moveq	r1, #1
 8020af4:	6139      	str	r1, [r7, #16]
 8020af6:	b1c4      	cbz	r4, 8020b2a <__d2b+0x88>
 8020af8:	f2a4 4433 	subw	r4, r4, #1075	; 0x433
 8020afc:	4404      	add	r4, r0
 8020afe:	6034      	str	r4, [r6, #0]
 8020b00:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 8020b04:	6028      	str	r0, [r5, #0]
 8020b06:	4638      	mov	r0, r7
 8020b08:	b003      	add	sp, #12
 8020b0a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8020b0e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8020b12:	e7d5      	b.n	8020ac0 <__d2b+0x1e>
 8020b14:	6179      	str	r1, [r7, #20]
 8020b16:	e7e7      	b.n	8020ae8 <__d2b+0x46>
 8020b18:	a801      	add	r0, sp, #4
 8020b1a:	f7ff fdda 	bl	80206d2 <__lo0bits>
 8020b1e:	9b01      	ldr	r3, [sp, #4]
 8020b20:	617b      	str	r3, [r7, #20]
 8020b22:	2101      	movs	r1, #1
 8020b24:	6139      	str	r1, [r7, #16]
 8020b26:	3020      	adds	r0, #32
 8020b28:	e7e5      	b.n	8020af6 <__d2b+0x54>
 8020b2a:	eb07 0381 	add.w	r3, r7, r1, lsl #2
 8020b2e:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 8020b32:	6030      	str	r0, [r6, #0]
 8020b34:	6918      	ldr	r0, [r3, #16]
 8020b36:	f7ff fdad 	bl	8020694 <__hi0bits>
 8020b3a:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
 8020b3e:	e7e1      	b.n	8020b04 <__d2b+0x62>

08020b40 <_calloc_r>:
 8020b40:	b538      	push	{r3, r4, r5, lr}
 8020b42:	fb02 f401 	mul.w	r4, r2, r1
 8020b46:	4621      	mov	r1, r4
 8020b48:	f7fe f848 	bl	801ebdc <_malloc_r>
 8020b4c:	4605      	mov	r5, r0
 8020b4e:	b118      	cbz	r0, 8020b58 <_calloc_r+0x18>
 8020b50:	4622      	mov	r2, r4
 8020b52:	2100      	movs	r1, #0
 8020b54:	f7fd ffec 	bl	801eb30 <memset>
 8020b58:	4628      	mov	r0, r5
 8020b5a:	bd38      	pop	{r3, r4, r5, pc}

08020b5c <__ssputs_r>:
 8020b5c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8020b60:	688e      	ldr	r6, [r1, #8]
 8020b62:	429e      	cmp	r6, r3
 8020b64:	4682      	mov	sl, r0
 8020b66:	460c      	mov	r4, r1
 8020b68:	4690      	mov	r8, r2
 8020b6a:	4699      	mov	r9, r3
 8020b6c:	d837      	bhi.n	8020bde <__ssputs_r+0x82>
 8020b6e:	898a      	ldrh	r2, [r1, #12]
 8020b70:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8020b74:	d031      	beq.n	8020bda <__ssputs_r+0x7e>
 8020b76:	6825      	ldr	r5, [r4, #0]
 8020b78:	6909      	ldr	r1, [r1, #16]
 8020b7a:	1a6f      	subs	r7, r5, r1
 8020b7c:	6965      	ldr	r5, [r4, #20]
 8020b7e:	2302      	movs	r3, #2
 8020b80:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8020b84:	fb95 f5f3 	sdiv	r5, r5, r3
 8020b88:	f109 0301 	add.w	r3, r9, #1
 8020b8c:	443b      	add	r3, r7
 8020b8e:	429d      	cmp	r5, r3
 8020b90:	bf38      	it	cc
 8020b92:	461d      	movcc	r5, r3
 8020b94:	0553      	lsls	r3, r2, #21
 8020b96:	d530      	bpl.n	8020bfa <__ssputs_r+0x9e>
 8020b98:	4629      	mov	r1, r5
 8020b9a:	f7fe f81f 	bl	801ebdc <_malloc_r>
 8020b9e:	4606      	mov	r6, r0
 8020ba0:	b950      	cbnz	r0, 8020bb8 <__ssputs_r+0x5c>
 8020ba2:	230c      	movs	r3, #12
 8020ba4:	f8ca 3000 	str.w	r3, [sl]
 8020ba8:	89a3      	ldrh	r3, [r4, #12]
 8020baa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8020bae:	81a3      	strh	r3, [r4, #12]
 8020bb0:	f04f 30ff 	mov.w	r0, #4294967295
 8020bb4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8020bb8:	463a      	mov	r2, r7
 8020bba:	6921      	ldr	r1, [r4, #16]
 8020bbc:	f7fd ffad 	bl	801eb1a <memcpy>
 8020bc0:	89a3      	ldrh	r3, [r4, #12]
 8020bc2:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 8020bc6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8020bca:	81a3      	strh	r3, [r4, #12]
 8020bcc:	6126      	str	r6, [r4, #16]
 8020bce:	6165      	str	r5, [r4, #20]
 8020bd0:	443e      	add	r6, r7
 8020bd2:	1bed      	subs	r5, r5, r7
 8020bd4:	6026      	str	r6, [r4, #0]
 8020bd6:	60a5      	str	r5, [r4, #8]
 8020bd8:	464e      	mov	r6, r9
 8020bda:	454e      	cmp	r6, r9
 8020bdc:	d900      	bls.n	8020be0 <__ssputs_r+0x84>
 8020bde:	464e      	mov	r6, r9
 8020be0:	4632      	mov	r2, r6
 8020be2:	4641      	mov	r1, r8
 8020be4:	6820      	ldr	r0, [r4, #0]
 8020be6:	f000 fca5 	bl	8021534 <memmove>
 8020bea:	68a3      	ldr	r3, [r4, #8]
 8020bec:	1b9b      	subs	r3, r3, r6
 8020bee:	60a3      	str	r3, [r4, #8]
 8020bf0:	6823      	ldr	r3, [r4, #0]
 8020bf2:	441e      	add	r6, r3
 8020bf4:	6026      	str	r6, [r4, #0]
 8020bf6:	2000      	movs	r0, #0
 8020bf8:	e7dc      	b.n	8020bb4 <__ssputs_r+0x58>
 8020bfa:	462a      	mov	r2, r5
 8020bfc:	f000 fcb3 	bl	8021566 <_realloc_r>
 8020c00:	4606      	mov	r6, r0
 8020c02:	2800      	cmp	r0, #0
 8020c04:	d1e2      	bne.n	8020bcc <__ssputs_r+0x70>
 8020c06:	6921      	ldr	r1, [r4, #16]
 8020c08:	4650      	mov	r0, sl
 8020c0a:	f7fd ff99 	bl	801eb40 <_free_r>
 8020c0e:	e7c8      	b.n	8020ba2 <__ssputs_r+0x46>

08020c10 <_svfiprintf_r>:
 8020c10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020c14:	461d      	mov	r5, r3
 8020c16:	898b      	ldrh	r3, [r1, #12]
 8020c18:	061f      	lsls	r7, r3, #24
 8020c1a:	b09d      	sub	sp, #116	; 0x74
 8020c1c:	4680      	mov	r8, r0
 8020c1e:	460c      	mov	r4, r1
 8020c20:	4616      	mov	r6, r2
 8020c22:	d50f      	bpl.n	8020c44 <_svfiprintf_r+0x34>
 8020c24:	690b      	ldr	r3, [r1, #16]
 8020c26:	b96b      	cbnz	r3, 8020c44 <_svfiprintf_r+0x34>
 8020c28:	2140      	movs	r1, #64	; 0x40
 8020c2a:	f7fd ffd7 	bl	801ebdc <_malloc_r>
 8020c2e:	6020      	str	r0, [r4, #0]
 8020c30:	6120      	str	r0, [r4, #16]
 8020c32:	b928      	cbnz	r0, 8020c40 <_svfiprintf_r+0x30>
 8020c34:	230c      	movs	r3, #12
 8020c36:	f8c8 3000 	str.w	r3, [r8]
 8020c3a:	f04f 30ff 	mov.w	r0, #4294967295
 8020c3e:	e0c8      	b.n	8020dd2 <_svfiprintf_r+0x1c2>
 8020c40:	2340      	movs	r3, #64	; 0x40
 8020c42:	6163      	str	r3, [r4, #20]
 8020c44:	2300      	movs	r3, #0
 8020c46:	9309      	str	r3, [sp, #36]	; 0x24
 8020c48:	2320      	movs	r3, #32
 8020c4a:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8020c4e:	2330      	movs	r3, #48	; 0x30
 8020c50:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8020c54:	9503      	str	r5, [sp, #12]
 8020c56:	f04f 0b01 	mov.w	fp, #1
 8020c5a:	4637      	mov	r7, r6
 8020c5c:	463d      	mov	r5, r7
 8020c5e:	f815 3b01 	ldrb.w	r3, [r5], #1
 8020c62:	b10b      	cbz	r3, 8020c68 <_svfiprintf_r+0x58>
 8020c64:	2b25      	cmp	r3, #37	; 0x25
 8020c66:	d13e      	bne.n	8020ce6 <_svfiprintf_r+0xd6>
 8020c68:	ebb7 0a06 	subs.w	sl, r7, r6
 8020c6c:	d00b      	beq.n	8020c86 <_svfiprintf_r+0x76>
 8020c6e:	4653      	mov	r3, sl
 8020c70:	4632      	mov	r2, r6
 8020c72:	4621      	mov	r1, r4
 8020c74:	4640      	mov	r0, r8
 8020c76:	f7ff ff71 	bl	8020b5c <__ssputs_r>
 8020c7a:	3001      	adds	r0, #1
 8020c7c:	f000 80a4 	beq.w	8020dc8 <_svfiprintf_r+0x1b8>
 8020c80:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020c82:	4453      	add	r3, sl
 8020c84:	9309      	str	r3, [sp, #36]	; 0x24
 8020c86:	783b      	ldrb	r3, [r7, #0]
 8020c88:	2b00      	cmp	r3, #0
 8020c8a:	f000 809d 	beq.w	8020dc8 <_svfiprintf_r+0x1b8>
 8020c8e:	2300      	movs	r3, #0
 8020c90:	f04f 32ff 	mov.w	r2, #4294967295
 8020c94:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8020c98:	9304      	str	r3, [sp, #16]
 8020c9a:	9307      	str	r3, [sp, #28]
 8020c9c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8020ca0:	931a      	str	r3, [sp, #104]	; 0x68
 8020ca2:	462f      	mov	r7, r5
 8020ca4:	2205      	movs	r2, #5
 8020ca6:	f817 1b01 	ldrb.w	r1, [r7], #1
 8020caa:	4850      	ldr	r0, [pc, #320]	; (8020dec <_svfiprintf_r+0x1dc>)
 8020cac:	f7e6 f9a0 	bl	8006ff0 <memchr>
 8020cb0:	9b04      	ldr	r3, [sp, #16]
 8020cb2:	b9d0      	cbnz	r0, 8020cea <_svfiprintf_r+0xda>
 8020cb4:	06d9      	lsls	r1, r3, #27
 8020cb6:	bf44      	itt	mi
 8020cb8:	2220      	movmi	r2, #32
 8020cba:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8020cbe:	071a      	lsls	r2, r3, #28
 8020cc0:	bf44      	itt	mi
 8020cc2:	222b      	movmi	r2, #43	; 0x2b
 8020cc4:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8020cc8:	782a      	ldrb	r2, [r5, #0]
 8020cca:	2a2a      	cmp	r2, #42	; 0x2a
 8020ccc:	d015      	beq.n	8020cfa <_svfiprintf_r+0xea>
 8020cce:	9a07      	ldr	r2, [sp, #28]
 8020cd0:	462f      	mov	r7, r5
 8020cd2:	2000      	movs	r0, #0
 8020cd4:	250a      	movs	r5, #10
 8020cd6:	4639      	mov	r1, r7
 8020cd8:	f811 3b01 	ldrb.w	r3, [r1], #1
 8020cdc:	3b30      	subs	r3, #48	; 0x30
 8020cde:	2b09      	cmp	r3, #9
 8020ce0:	d94d      	bls.n	8020d7e <_svfiprintf_r+0x16e>
 8020ce2:	b1b8      	cbz	r0, 8020d14 <_svfiprintf_r+0x104>
 8020ce4:	e00f      	b.n	8020d06 <_svfiprintf_r+0xf6>
 8020ce6:	462f      	mov	r7, r5
 8020ce8:	e7b8      	b.n	8020c5c <_svfiprintf_r+0x4c>
 8020cea:	4a40      	ldr	r2, [pc, #256]	; (8020dec <_svfiprintf_r+0x1dc>)
 8020cec:	1a80      	subs	r0, r0, r2
 8020cee:	fa0b f000 	lsl.w	r0, fp, r0
 8020cf2:	4318      	orrs	r0, r3
 8020cf4:	9004      	str	r0, [sp, #16]
 8020cf6:	463d      	mov	r5, r7
 8020cf8:	e7d3      	b.n	8020ca2 <_svfiprintf_r+0x92>
 8020cfa:	9a03      	ldr	r2, [sp, #12]
 8020cfc:	1d11      	adds	r1, r2, #4
 8020cfe:	6812      	ldr	r2, [r2, #0]
 8020d00:	9103      	str	r1, [sp, #12]
 8020d02:	2a00      	cmp	r2, #0
 8020d04:	db01      	blt.n	8020d0a <_svfiprintf_r+0xfa>
 8020d06:	9207      	str	r2, [sp, #28]
 8020d08:	e004      	b.n	8020d14 <_svfiprintf_r+0x104>
 8020d0a:	4252      	negs	r2, r2
 8020d0c:	f043 0302 	orr.w	r3, r3, #2
 8020d10:	9207      	str	r2, [sp, #28]
 8020d12:	9304      	str	r3, [sp, #16]
 8020d14:	783b      	ldrb	r3, [r7, #0]
 8020d16:	2b2e      	cmp	r3, #46	; 0x2e
 8020d18:	d10c      	bne.n	8020d34 <_svfiprintf_r+0x124>
 8020d1a:	787b      	ldrb	r3, [r7, #1]
 8020d1c:	2b2a      	cmp	r3, #42	; 0x2a
 8020d1e:	d133      	bne.n	8020d88 <_svfiprintf_r+0x178>
 8020d20:	9b03      	ldr	r3, [sp, #12]
 8020d22:	1d1a      	adds	r2, r3, #4
 8020d24:	681b      	ldr	r3, [r3, #0]
 8020d26:	9203      	str	r2, [sp, #12]
 8020d28:	2b00      	cmp	r3, #0
 8020d2a:	bfb8      	it	lt
 8020d2c:	f04f 33ff 	movlt.w	r3, #4294967295
 8020d30:	3702      	adds	r7, #2
 8020d32:	9305      	str	r3, [sp, #20]
 8020d34:	4d2e      	ldr	r5, [pc, #184]	; (8020df0 <_svfiprintf_r+0x1e0>)
 8020d36:	7839      	ldrb	r1, [r7, #0]
 8020d38:	2203      	movs	r2, #3
 8020d3a:	4628      	mov	r0, r5
 8020d3c:	f7e6 f958 	bl	8006ff0 <memchr>
 8020d40:	b138      	cbz	r0, 8020d52 <_svfiprintf_r+0x142>
 8020d42:	2340      	movs	r3, #64	; 0x40
 8020d44:	1b40      	subs	r0, r0, r5
 8020d46:	fa03 f000 	lsl.w	r0, r3, r0
 8020d4a:	9b04      	ldr	r3, [sp, #16]
 8020d4c:	4303      	orrs	r3, r0
 8020d4e:	3701      	adds	r7, #1
 8020d50:	9304      	str	r3, [sp, #16]
 8020d52:	7839      	ldrb	r1, [r7, #0]
 8020d54:	4827      	ldr	r0, [pc, #156]	; (8020df4 <_svfiprintf_r+0x1e4>)
 8020d56:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8020d5a:	2206      	movs	r2, #6
 8020d5c:	1c7e      	adds	r6, r7, #1
 8020d5e:	f7e6 f947 	bl	8006ff0 <memchr>
 8020d62:	2800      	cmp	r0, #0
 8020d64:	d038      	beq.n	8020dd8 <_svfiprintf_r+0x1c8>
 8020d66:	4b24      	ldr	r3, [pc, #144]	; (8020df8 <_svfiprintf_r+0x1e8>)
 8020d68:	bb13      	cbnz	r3, 8020db0 <_svfiprintf_r+0x1a0>
 8020d6a:	9b03      	ldr	r3, [sp, #12]
 8020d6c:	3307      	adds	r3, #7
 8020d6e:	f023 0307 	bic.w	r3, r3, #7
 8020d72:	3308      	adds	r3, #8
 8020d74:	9303      	str	r3, [sp, #12]
 8020d76:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020d78:	444b      	add	r3, r9
 8020d7a:	9309      	str	r3, [sp, #36]	; 0x24
 8020d7c:	e76d      	b.n	8020c5a <_svfiprintf_r+0x4a>
 8020d7e:	fb05 3202 	mla	r2, r5, r2, r3
 8020d82:	2001      	movs	r0, #1
 8020d84:	460f      	mov	r7, r1
 8020d86:	e7a6      	b.n	8020cd6 <_svfiprintf_r+0xc6>
 8020d88:	2300      	movs	r3, #0
 8020d8a:	3701      	adds	r7, #1
 8020d8c:	9305      	str	r3, [sp, #20]
 8020d8e:	4619      	mov	r1, r3
 8020d90:	250a      	movs	r5, #10
 8020d92:	4638      	mov	r0, r7
 8020d94:	f810 2b01 	ldrb.w	r2, [r0], #1
 8020d98:	3a30      	subs	r2, #48	; 0x30
 8020d9a:	2a09      	cmp	r2, #9
 8020d9c:	d903      	bls.n	8020da6 <_svfiprintf_r+0x196>
 8020d9e:	2b00      	cmp	r3, #0
 8020da0:	d0c8      	beq.n	8020d34 <_svfiprintf_r+0x124>
 8020da2:	9105      	str	r1, [sp, #20]
 8020da4:	e7c6      	b.n	8020d34 <_svfiprintf_r+0x124>
 8020da6:	fb05 2101 	mla	r1, r5, r1, r2
 8020daa:	2301      	movs	r3, #1
 8020dac:	4607      	mov	r7, r0
 8020dae:	e7f0      	b.n	8020d92 <_svfiprintf_r+0x182>
 8020db0:	ab03      	add	r3, sp, #12
 8020db2:	9300      	str	r3, [sp, #0]
 8020db4:	4622      	mov	r2, r4
 8020db6:	4b11      	ldr	r3, [pc, #68]	; (8020dfc <_svfiprintf_r+0x1ec>)
 8020db8:	a904      	add	r1, sp, #16
 8020dba:	4640      	mov	r0, r8
 8020dbc:	f7fd fffc 	bl	801edb8 <_printf_float>
 8020dc0:	f1b0 3fff 	cmp.w	r0, #4294967295
 8020dc4:	4681      	mov	r9, r0
 8020dc6:	d1d6      	bne.n	8020d76 <_svfiprintf_r+0x166>
 8020dc8:	89a3      	ldrh	r3, [r4, #12]
 8020dca:	065b      	lsls	r3, r3, #25
 8020dcc:	f53f af35 	bmi.w	8020c3a <_svfiprintf_r+0x2a>
 8020dd0:	9809      	ldr	r0, [sp, #36]	; 0x24
 8020dd2:	b01d      	add	sp, #116	; 0x74
 8020dd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020dd8:	ab03      	add	r3, sp, #12
 8020dda:	9300      	str	r3, [sp, #0]
 8020ddc:	4622      	mov	r2, r4
 8020dde:	4b07      	ldr	r3, [pc, #28]	; (8020dfc <_svfiprintf_r+0x1ec>)
 8020de0:	a904      	add	r1, sp, #16
 8020de2:	4640      	mov	r0, r8
 8020de4:	f7fe fa9e 	bl	801f324 <_printf_i>
 8020de8:	e7ea      	b.n	8020dc0 <_svfiprintf_r+0x1b0>
 8020dea:	bf00      	nop
 8020dec:	08076024 	.word	0x08076024
 8020df0:	0807602a 	.word	0x0807602a
 8020df4:	0807602e 	.word	0x0807602e
 8020df8:	0801edb9 	.word	0x0801edb9
 8020dfc:	08020b5d 	.word	0x08020b5d

08020e00 <__sfputc_r>:
 8020e00:	6893      	ldr	r3, [r2, #8]
 8020e02:	3b01      	subs	r3, #1
 8020e04:	2b00      	cmp	r3, #0
 8020e06:	b410      	push	{r4}
 8020e08:	6093      	str	r3, [r2, #8]
 8020e0a:	da08      	bge.n	8020e1e <__sfputc_r+0x1e>
 8020e0c:	6994      	ldr	r4, [r2, #24]
 8020e0e:	42a3      	cmp	r3, r4
 8020e10:	db01      	blt.n	8020e16 <__sfputc_r+0x16>
 8020e12:	290a      	cmp	r1, #10
 8020e14:	d103      	bne.n	8020e1e <__sfputc_r+0x1e>
 8020e16:	f85d 4b04 	ldr.w	r4, [sp], #4
 8020e1a:	f000 b975 	b.w	8021108 <__swbuf_r>
 8020e1e:	6813      	ldr	r3, [r2, #0]
 8020e20:	1c58      	adds	r0, r3, #1
 8020e22:	6010      	str	r0, [r2, #0]
 8020e24:	7019      	strb	r1, [r3, #0]
 8020e26:	4608      	mov	r0, r1
 8020e28:	f85d 4b04 	ldr.w	r4, [sp], #4
 8020e2c:	4770      	bx	lr

08020e2e <__sfputs_r>:
 8020e2e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8020e30:	4606      	mov	r6, r0
 8020e32:	460f      	mov	r7, r1
 8020e34:	4614      	mov	r4, r2
 8020e36:	18d5      	adds	r5, r2, r3
 8020e38:	42ac      	cmp	r4, r5
 8020e3a:	d101      	bne.n	8020e40 <__sfputs_r+0x12>
 8020e3c:	2000      	movs	r0, #0
 8020e3e:	e007      	b.n	8020e50 <__sfputs_r+0x22>
 8020e40:	463a      	mov	r2, r7
 8020e42:	f814 1b01 	ldrb.w	r1, [r4], #1
 8020e46:	4630      	mov	r0, r6
 8020e48:	f7ff ffda 	bl	8020e00 <__sfputc_r>
 8020e4c:	1c43      	adds	r3, r0, #1
 8020e4e:	d1f3      	bne.n	8020e38 <__sfputs_r+0xa>
 8020e50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08020e54 <_vfiprintf_r>:
 8020e54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020e58:	460c      	mov	r4, r1
 8020e5a:	b09d      	sub	sp, #116	; 0x74
 8020e5c:	4617      	mov	r7, r2
 8020e5e:	461d      	mov	r5, r3
 8020e60:	4606      	mov	r6, r0
 8020e62:	b118      	cbz	r0, 8020e6c <_vfiprintf_r+0x18>
 8020e64:	6983      	ldr	r3, [r0, #24]
 8020e66:	b90b      	cbnz	r3, 8020e6c <_vfiprintf_r+0x18>
 8020e68:	f7ff fade 	bl	8020428 <__sinit>
 8020e6c:	4b7c      	ldr	r3, [pc, #496]	; (8021060 <_vfiprintf_r+0x20c>)
 8020e6e:	429c      	cmp	r4, r3
 8020e70:	d158      	bne.n	8020f24 <_vfiprintf_r+0xd0>
 8020e72:	6874      	ldr	r4, [r6, #4]
 8020e74:	89a3      	ldrh	r3, [r4, #12]
 8020e76:	0718      	lsls	r0, r3, #28
 8020e78:	d55e      	bpl.n	8020f38 <_vfiprintf_r+0xe4>
 8020e7a:	6923      	ldr	r3, [r4, #16]
 8020e7c:	2b00      	cmp	r3, #0
 8020e7e:	d05b      	beq.n	8020f38 <_vfiprintf_r+0xe4>
 8020e80:	2300      	movs	r3, #0
 8020e82:	9309      	str	r3, [sp, #36]	; 0x24
 8020e84:	2320      	movs	r3, #32
 8020e86:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8020e8a:	2330      	movs	r3, #48	; 0x30
 8020e8c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8020e90:	9503      	str	r5, [sp, #12]
 8020e92:	f04f 0b01 	mov.w	fp, #1
 8020e96:	46b8      	mov	r8, r7
 8020e98:	4645      	mov	r5, r8
 8020e9a:	f815 3b01 	ldrb.w	r3, [r5], #1
 8020e9e:	b10b      	cbz	r3, 8020ea4 <_vfiprintf_r+0x50>
 8020ea0:	2b25      	cmp	r3, #37	; 0x25
 8020ea2:	d154      	bne.n	8020f4e <_vfiprintf_r+0xfa>
 8020ea4:	ebb8 0a07 	subs.w	sl, r8, r7
 8020ea8:	d00b      	beq.n	8020ec2 <_vfiprintf_r+0x6e>
 8020eaa:	4653      	mov	r3, sl
 8020eac:	463a      	mov	r2, r7
 8020eae:	4621      	mov	r1, r4
 8020eb0:	4630      	mov	r0, r6
 8020eb2:	f7ff ffbc 	bl	8020e2e <__sfputs_r>
 8020eb6:	3001      	adds	r0, #1
 8020eb8:	f000 80c2 	beq.w	8021040 <_vfiprintf_r+0x1ec>
 8020ebc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020ebe:	4453      	add	r3, sl
 8020ec0:	9309      	str	r3, [sp, #36]	; 0x24
 8020ec2:	f898 3000 	ldrb.w	r3, [r8]
 8020ec6:	2b00      	cmp	r3, #0
 8020ec8:	f000 80ba 	beq.w	8021040 <_vfiprintf_r+0x1ec>
 8020ecc:	2300      	movs	r3, #0
 8020ece:	f04f 32ff 	mov.w	r2, #4294967295
 8020ed2:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8020ed6:	9304      	str	r3, [sp, #16]
 8020ed8:	9307      	str	r3, [sp, #28]
 8020eda:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8020ede:	931a      	str	r3, [sp, #104]	; 0x68
 8020ee0:	46a8      	mov	r8, r5
 8020ee2:	2205      	movs	r2, #5
 8020ee4:	f818 1b01 	ldrb.w	r1, [r8], #1
 8020ee8:	485e      	ldr	r0, [pc, #376]	; (8021064 <_vfiprintf_r+0x210>)
 8020eea:	f7e6 f881 	bl	8006ff0 <memchr>
 8020eee:	9b04      	ldr	r3, [sp, #16]
 8020ef0:	bb78      	cbnz	r0, 8020f52 <_vfiprintf_r+0xfe>
 8020ef2:	06d9      	lsls	r1, r3, #27
 8020ef4:	bf44      	itt	mi
 8020ef6:	2220      	movmi	r2, #32
 8020ef8:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8020efc:	071a      	lsls	r2, r3, #28
 8020efe:	bf44      	itt	mi
 8020f00:	222b      	movmi	r2, #43	; 0x2b
 8020f02:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8020f06:	782a      	ldrb	r2, [r5, #0]
 8020f08:	2a2a      	cmp	r2, #42	; 0x2a
 8020f0a:	d02a      	beq.n	8020f62 <_vfiprintf_r+0x10e>
 8020f0c:	9a07      	ldr	r2, [sp, #28]
 8020f0e:	46a8      	mov	r8, r5
 8020f10:	2000      	movs	r0, #0
 8020f12:	250a      	movs	r5, #10
 8020f14:	4641      	mov	r1, r8
 8020f16:	f811 3b01 	ldrb.w	r3, [r1], #1
 8020f1a:	3b30      	subs	r3, #48	; 0x30
 8020f1c:	2b09      	cmp	r3, #9
 8020f1e:	d969      	bls.n	8020ff4 <_vfiprintf_r+0x1a0>
 8020f20:	b360      	cbz	r0, 8020f7c <_vfiprintf_r+0x128>
 8020f22:	e024      	b.n	8020f6e <_vfiprintf_r+0x11a>
 8020f24:	4b50      	ldr	r3, [pc, #320]	; (8021068 <_vfiprintf_r+0x214>)
 8020f26:	429c      	cmp	r4, r3
 8020f28:	d101      	bne.n	8020f2e <_vfiprintf_r+0xda>
 8020f2a:	68b4      	ldr	r4, [r6, #8]
 8020f2c:	e7a2      	b.n	8020e74 <_vfiprintf_r+0x20>
 8020f2e:	4b4f      	ldr	r3, [pc, #316]	; (802106c <_vfiprintf_r+0x218>)
 8020f30:	429c      	cmp	r4, r3
 8020f32:	bf08      	it	eq
 8020f34:	68f4      	ldreq	r4, [r6, #12]
 8020f36:	e79d      	b.n	8020e74 <_vfiprintf_r+0x20>
 8020f38:	4621      	mov	r1, r4
 8020f3a:	4630      	mov	r0, r6
 8020f3c:	f000 f956 	bl	80211ec <__swsetup_r>
 8020f40:	2800      	cmp	r0, #0
 8020f42:	d09d      	beq.n	8020e80 <_vfiprintf_r+0x2c>
 8020f44:	f04f 30ff 	mov.w	r0, #4294967295
 8020f48:	b01d      	add	sp, #116	; 0x74
 8020f4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020f4e:	46a8      	mov	r8, r5
 8020f50:	e7a2      	b.n	8020e98 <_vfiprintf_r+0x44>
 8020f52:	4a44      	ldr	r2, [pc, #272]	; (8021064 <_vfiprintf_r+0x210>)
 8020f54:	1a80      	subs	r0, r0, r2
 8020f56:	fa0b f000 	lsl.w	r0, fp, r0
 8020f5a:	4318      	orrs	r0, r3
 8020f5c:	9004      	str	r0, [sp, #16]
 8020f5e:	4645      	mov	r5, r8
 8020f60:	e7be      	b.n	8020ee0 <_vfiprintf_r+0x8c>
 8020f62:	9a03      	ldr	r2, [sp, #12]
 8020f64:	1d11      	adds	r1, r2, #4
 8020f66:	6812      	ldr	r2, [r2, #0]
 8020f68:	9103      	str	r1, [sp, #12]
 8020f6a:	2a00      	cmp	r2, #0
 8020f6c:	db01      	blt.n	8020f72 <_vfiprintf_r+0x11e>
 8020f6e:	9207      	str	r2, [sp, #28]
 8020f70:	e004      	b.n	8020f7c <_vfiprintf_r+0x128>
 8020f72:	4252      	negs	r2, r2
 8020f74:	f043 0302 	orr.w	r3, r3, #2
 8020f78:	9207      	str	r2, [sp, #28]
 8020f7a:	9304      	str	r3, [sp, #16]
 8020f7c:	f898 3000 	ldrb.w	r3, [r8]
 8020f80:	2b2e      	cmp	r3, #46	; 0x2e
 8020f82:	d10e      	bne.n	8020fa2 <_vfiprintf_r+0x14e>
 8020f84:	f898 3001 	ldrb.w	r3, [r8, #1]
 8020f88:	2b2a      	cmp	r3, #42	; 0x2a
 8020f8a:	d138      	bne.n	8020ffe <_vfiprintf_r+0x1aa>
 8020f8c:	9b03      	ldr	r3, [sp, #12]
 8020f8e:	1d1a      	adds	r2, r3, #4
 8020f90:	681b      	ldr	r3, [r3, #0]
 8020f92:	9203      	str	r2, [sp, #12]
 8020f94:	2b00      	cmp	r3, #0
 8020f96:	bfb8      	it	lt
 8020f98:	f04f 33ff 	movlt.w	r3, #4294967295
 8020f9c:	f108 0802 	add.w	r8, r8, #2
 8020fa0:	9305      	str	r3, [sp, #20]
 8020fa2:	4d33      	ldr	r5, [pc, #204]	; (8021070 <_vfiprintf_r+0x21c>)
 8020fa4:	f898 1000 	ldrb.w	r1, [r8]
 8020fa8:	2203      	movs	r2, #3
 8020faa:	4628      	mov	r0, r5
 8020fac:	f7e6 f820 	bl	8006ff0 <memchr>
 8020fb0:	b140      	cbz	r0, 8020fc4 <_vfiprintf_r+0x170>
 8020fb2:	2340      	movs	r3, #64	; 0x40
 8020fb4:	1b40      	subs	r0, r0, r5
 8020fb6:	fa03 f000 	lsl.w	r0, r3, r0
 8020fba:	9b04      	ldr	r3, [sp, #16]
 8020fbc:	4303      	orrs	r3, r0
 8020fbe:	f108 0801 	add.w	r8, r8, #1
 8020fc2:	9304      	str	r3, [sp, #16]
 8020fc4:	f898 1000 	ldrb.w	r1, [r8]
 8020fc8:	482a      	ldr	r0, [pc, #168]	; (8021074 <_vfiprintf_r+0x220>)
 8020fca:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8020fce:	2206      	movs	r2, #6
 8020fd0:	f108 0701 	add.w	r7, r8, #1
 8020fd4:	f7e6 f80c 	bl	8006ff0 <memchr>
 8020fd8:	2800      	cmp	r0, #0
 8020fda:	d037      	beq.n	802104c <_vfiprintf_r+0x1f8>
 8020fdc:	4b26      	ldr	r3, [pc, #152]	; (8021078 <_vfiprintf_r+0x224>)
 8020fde:	bb1b      	cbnz	r3, 8021028 <_vfiprintf_r+0x1d4>
 8020fe0:	9b03      	ldr	r3, [sp, #12]
 8020fe2:	3307      	adds	r3, #7
 8020fe4:	f023 0307 	bic.w	r3, r3, #7
 8020fe8:	3308      	adds	r3, #8
 8020fea:	9303      	str	r3, [sp, #12]
 8020fec:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020fee:	444b      	add	r3, r9
 8020ff0:	9309      	str	r3, [sp, #36]	; 0x24
 8020ff2:	e750      	b.n	8020e96 <_vfiprintf_r+0x42>
 8020ff4:	fb05 3202 	mla	r2, r5, r2, r3
 8020ff8:	2001      	movs	r0, #1
 8020ffa:	4688      	mov	r8, r1
 8020ffc:	e78a      	b.n	8020f14 <_vfiprintf_r+0xc0>
 8020ffe:	2300      	movs	r3, #0
 8021000:	f108 0801 	add.w	r8, r8, #1
 8021004:	9305      	str	r3, [sp, #20]
 8021006:	4619      	mov	r1, r3
 8021008:	250a      	movs	r5, #10
 802100a:	4640      	mov	r0, r8
 802100c:	f810 2b01 	ldrb.w	r2, [r0], #1
 8021010:	3a30      	subs	r2, #48	; 0x30
 8021012:	2a09      	cmp	r2, #9
 8021014:	d903      	bls.n	802101e <_vfiprintf_r+0x1ca>
 8021016:	2b00      	cmp	r3, #0
 8021018:	d0c3      	beq.n	8020fa2 <_vfiprintf_r+0x14e>
 802101a:	9105      	str	r1, [sp, #20]
 802101c:	e7c1      	b.n	8020fa2 <_vfiprintf_r+0x14e>
 802101e:	fb05 2101 	mla	r1, r5, r1, r2
 8021022:	2301      	movs	r3, #1
 8021024:	4680      	mov	r8, r0
 8021026:	e7f0      	b.n	802100a <_vfiprintf_r+0x1b6>
 8021028:	ab03      	add	r3, sp, #12
 802102a:	9300      	str	r3, [sp, #0]
 802102c:	4622      	mov	r2, r4
 802102e:	4b13      	ldr	r3, [pc, #76]	; (802107c <_vfiprintf_r+0x228>)
 8021030:	a904      	add	r1, sp, #16
 8021032:	4630      	mov	r0, r6
 8021034:	f7fd fec0 	bl	801edb8 <_printf_float>
 8021038:	f1b0 3fff 	cmp.w	r0, #4294967295
 802103c:	4681      	mov	r9, r0
 802103e:	d1d5      	bne.n	8020fec <_vfiprintf_r+0x198>
 8021040:	89a3      	ldrh	r3, [r4, #12]
 8021042:	065b      	lsls	r3, r3, #25
 8021044:	f53f af7e 	bmi.w	8020f44 <_vfiprintf_r+0xf0>
 8021048:	9809      	ldr	r0, [sp, #36]	; 0x24
 802104a:	e77d      	b.n	8020f48 <_vfiprintf_r+0xf4>
 802104c:	ab03      	add	r3, sp, #12
 802104e:	9300      	str	r3, [sp, #0]
 8021050:	4622      	mov	r2, r4
 8021052:	4b0a      	ldr	r3, [pc, #40]	; (802107c <_vfiprintf_r+0x228>)
 8021054:	a904      	add	r1, sp, #16
 8021056:	4630      	mov	r0, r6
 8021058:	f7fe f964 	bl	801f324 <_printf_i>
 802105c:	e7ec      	b.n	8021038 <_vfiprintf_r+0x1e4>
 802105e:	bf00      	nop
 8021060:	08075edc 	.word	0x08075edc
 8021064:	08076024 	.word	0x08076024
 8021068:	08075efc 	.word	0x08075efc
 802106c:	08075ebc 	.word	0x08075ebc
 8021070:	0807602a 	.word	0x0807602a
 8021074:	0807602e 	.word	0x0807602e
 8021078:	0801edb9 	.word	0x0801edb9
 802107c:	08020e2f 	.word	0x08020e2f

08021080 <__sread>:
 8021080:	b510      	push	{r4, lr}
 8021082:	460c      	mov	r4, r1
 8021084:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8021088:	f000 fa94 	bl	80215b4 <_read_r>
 802108c:	2800      	cmp	r0, #0
 802108e:	bfab      	itete	ge
 8021090:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8021092:	89a3      	ldrhlt	r3, [r4, #12]
 8021094:	181b      	addge	r3, r3, r0
 8021096:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 802109a:	bfac      	ite	ge
 802109c:	6563      	strge	r3, [r4, #84]	; 0x54
 802109e:	81a3      	strhlt	r3, [r4, #12]
 80210a0:	bd10      	pop	{r4, pc}

080210a2 <__swrite>:
 80210a2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80210a6:	461f      	mov	r7, r3
 80210a8:	898b      	ldrh	r3, [r1, #12]
 80210aa:	05db      	lsls	r3, r3, #23
 80210ac:	4605      	mov	r5, r0
 80210ae:	460c      	mov	r4, r1
 80210b0:	4616      	mov	r6, r2
 80210b2:	d505      	bpl.n	80210c0 <__swrite+0x1e>
 80210b4:	2302      	movs	r3, #2
 80210b6:	2200      	movs	r2, #0
 80210b8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80210bc:	f000 f9c4 	bl	8021448 <_lseek_r>
 80210c0:	89a3      	ldrh	r3, [r4, #12]
 80210c2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80210c6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80210ca:	81a3      	strh	r3, [r4, #12]
 80210cc:	4632      	mov	r2, r6
 80210ce:	463b      	mov	r3, r7
 80210d0:	4628      	mov	r0, r5
 80210d2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80210d6:	f000 b877 	b.w	80211c8 <_write_r>

080210da <__sseek>:
 80210da:	b510      	push	{r4, lr}
 80210dc:	460c      	mov	r4, r1
 80210de:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80210e2:	f000 f9b1 	bl	8021448 <_lseek_r>
 80210e6:	1c43      	adds	r3, r0, #1
 80210e8:	89a3      	ldrh	r3, [r4, #12]
 80210ea:	bf15      	itete	ne
 80210ec:	6560      	strne	r0, [r4, #84]	; 0x54
 80210ee:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 80210f2:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 80210f6:	81a3      	strheq	r3, [r4, #12]
 80210f8:	bf18      	it	ne
 80210fa:	81a3      	strhne	r3, [r4, #12]
 80210fc:	bd10      	pop	{r4, pc}

080210fe <__sclose>:
 80210fe:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8021102:	f000 b8e1 	b.w	80212c8 <_close_r>
	...

08021108 <__swbuf_r>:
 8021108:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802110a:	460e      	mov	r6, r1
 802110c:	4614      	mov	r4, r2
 802110e:	4605      	mov	r5, r0
 8021110:	b118      	cbz	r0, 802111a <__swbuf_r+0x12>
 8021112:	6983      	ldr	r3, [r0, #24]
 8021114:	b90b      	cbnz	r3, 802111a <__swbuf_r+0x12>
 8021116:	f7ff f987 	bl	8020428 <__sinit>
 802111a:	4b21      	ldr	r3, [pc, #132]	; (80211a0 <__swbuf_r+0x98>)
 802111c:	429c      	cmp	r4, r3
 802111e:	d12a      	bne.n	8021176 <__swbuf_r+0x6e>
 8021120:	686c      	ldr	r4, [r5, #4]
 8021122:	69a3      	ldr	r3, [r4, #24]
 8021124:	60a3      	str	r3, [r4, #8]
 8021126:	89a3      	ldrh	r3, [r4, #12]
 8021128:	071a      	lsls	r2, r3, #28
 802112a:	d52e      	bpl.n	802118a <__swbuf_r+0x82>
 802112c:	6923      	ldr	r3, [r4, #16]
 802112e:	b363      	cbz	r3, 802118a <__swbuf_r+0x82>
 8021130:	6923      	ldr	r3, [r4, #16]
 8021132:	6820      	ldr	r0, [r4, #0]
 8021134:	1ac0      	subs	r0, r0, r3
 8021136:	6963      	ldr	r3, [r4, #20]
 8021138:	b2f6      	uxtb	r6, r6
 802113a:	4283      	cmp	r3, r0
 802113c:	4637      	mov	r7, r6
 802113e:	dc04      	bgt.n	802114a <__swbuf_r+0x42>
 8021140:	4621      	mov	r1, r4
 8021142:	4628      	mov	r0, r5
 8021144:	f000 f956 	bl	80213f4 <_fflush_r>
 8021148:	bb28      	cbnz	r0, 8021196 <__swbuf_r+0x8e>
 802114a:	68a3      	ldr	r3, [r4, #8]
 802114c:	3b01      	subs	r3, #1
 802114e:	60a3      	str	r3, [r4, #8]
 8021150:	6823      	ldr	r3, [r4, #0]
 8021152:	1c5a      	adds	r2, r3, #1
 8021154:	6022      	str	r2, [r4, #0]
 8021156:	701e      	strb	r6, [r3, #0]
 8021158:	6963      	ldr	r3, [r4, #20]
 802115a:	3001      	adds	r0, #1
 802115c:	4283      	cmp	r3, r0
 802115e:	d004      	beq.n	802116a <__swbuf_r+0x62>
 8021160:	89a3      	ldrh	r3, [r4, #12]
 8021162:	07db      	lsls	r3, r3, #31
 8021164:	d519      	bpl.n	802119a <__swbuf_r+0x92>
 8021166:	2e0a      	cmp	r6, #10
 8021168:	d117      	bne.n	802119a <__swbuf_r+0x92>
 802116a:	4621      	mov	r1, r4
 802116c:	4628      	mov	r0, r5
 802116e:	f000 f941 	bl	80213f4 <_fflush_r>
 8021172:	b190      	cbz	r0, 802119a <__swbuf_r+0x92>
 8021174:	e00f      	b.n	8021196 <__swbuf_r+0x8e>
 8021176:	4b0b      	ldr	r3, [pc, #44]	; (80211a4 <__swbuf_r+0x9c>)
 8021178:	429c      	cmp	r4, r3
 802117a:	d101      	bne.n	8021180 <__swbuf_r+0x78>
 802117c:	68ac      	ldr	r4, [r5, #8]
 802117e:	e7d0      	b.n	8021122 <__swbuf_r+0x1a>
 8021180:	4b09      	ldr	r3, [pc, #36]	; (80211a8 <__swbuf_r+0xa0>)
 8021182:	429c      	cmp	r4, r3
 8021184:	bf08      	it	eq
 8021186:	68ec      	ldreq	r4, [r5, #12]
 8021188:	e7cb      	b.n	8021122 <__swbuf_r+0x1a>
 802118a:	4621      	mov	r1, r4
 802118c:	4628      	mov	r0, r5
 802118e:	f000 f82d 	bl	80211ec <__swsetup_r>
 8021192:	2800      	cmp	r0, #0
 8021194:	d0cc      	beq.n	8021130 <__swbuf_r+0x28>
 8021196:	f04f 37ff 	mov.w	r7, #4294967295
 802119a:	4638      	mov	r0, r7
 802119c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802119e:	bf00      	nop
 80211a0:	08075edc 	.word	0x08075edc
 80211a4:	08075efc 	.word	0x08075efc
 80211a8:	08075ebc 	.word	0x08075ebc

080211ac <__ascii_wctomb>:
 80211ac:	b149      	cbz	r1, 80211c2 <__ascii_wctomb+0x16>
 80211ae:	2aff      	cmp	r2, #255	; 0xff
 80211b0:	bf85      	ittet	hi
 80211b2:	238a      	movhi	r3, #138	; 0x8a
 80211b4:	6003      	strhi	r3, [r0, #0]
 80211b6:	700a      	strbls	r2, [r1, #0]
 80211b8:	f04f 30ff 	movhi.w	r0, #4294967295
 80211bc:	bf98      	it	ls
 80211be:	2001      	movls	r0, #1
 80211c0:	4770      	bx	lr
 80211c2:	4608      	mov	r0, r1
 80211c4:	4770      	bx	lr
	...

080211c8 <_write_r>:
 80211c8:	b538      	push	{r3, r4, r5, lr}
 80211ca:	4c07      	ldr	r4, [pc, #28]	; (80211e8 <_write_r+0x20>)
 80211cc:	4605      	mov	r5, r0
 80211ce:	4608      	mov	r0, r1
 80211d0:	4611      	mov	r1, r2
 80211d2:	2200      	movs	r2, #0
 80211d4:	6022      	str	r2, [r4, #0]
 80211d6:	461a      	mov	r2, r3
 80211d8:	f7f7 fd80 	bl	8018cdc <_write>
 80211dc:	1c43      	adds	r3, r0, #1
 80211de:	d102      	bne.n	80211e6 <_write_r+0x1e>
 80211e0:	6823      	ldr	r3, [r4, #0]
 80211e2:	b103      	cbz	r3, 80211e6 <_write_r+0x1e>
 80211e4:	602b      	str	r3, [r5, #0]
 80211e6:	bd38      	pop	{r3, r4, r5, pc}
 80211e8:	2001331c 	.word	0x2001331c

080211ec <__swsetup_r>:
 80211ec:	4b32      	ldr	r3, [pc, #200]	; (80212b8 <__swsetup_r+0xcc>)
 80211ee:	b570      	push	{r4, r5, r6, lr}
 80211f0:	681d      	ldr	r5, [r3, #0]
 80211f2:	4606      	mov	r6, r0
 80211f4:	460c      	mov	r4, r1
 80211f6:	b125      	cbz	r5, 8021202 <__swsetup_r+0x16>
 80211f8:	69ab      	ldr	r3, [r5, #24]
 80211fa:	b913      	cbnz	r3, 8021202 <__swsetup_r+0x16>
 80211fc:	4628      	mov	r0, r5
 80211fe:	f7ff f913 	bl	8020428 <__sinit>
 8021202:	4b2e      	ldr	r3, [pc, #184]	; (80212bc <__swsetup_r+0xd0>)
 8021204:	429c      	cmp	r4, r3
 8021206:	d10f      	bne.n	8021228 <__swsetup_r+0x3c>
 8021208:	686c      	ldr	r4, [r5, #4]
 802120a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802120e:	b29a      	uxth	r2, r3
 8021210:	0715      	lsls	r5, r2, #28
 8021212:	d42c      	bmi.n	802126e <__swsetup_r+0x82>
 8021214:	06d0      	lsls	r0, r2, #27
 8021216:	d411      	bmi.n	802123c <__swsetup_r+0x50>
 8021218:	2209      	movs	r2, #9
 802121a:	6032      	str	r2, [r6, #0]
 802121c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8021220:	81a3      	strh	r3, [r4, #12]
 8021222:	f04f 30ff 	mov.w	r0, #4294967295
 8021226:	e03e      	b.n	80212a6 <__swsetup_r+0xba>
 8021228:	4b25      	ldr	r3, [pc, #148]	; (80212c0 <__swsetup_r+0xd4>)
 802122a:	429c      	cmp	r4, r3
 802122c:	d101      	bne.n	8021232 <__swsetup_r+0x46>
 802122e:	68ac      	ldr	r4, [r5, #8]
 8021230:	e7eb      	b.n	802120a <__swsetup_r+0x1e>
 8021232:	4b24      	ldr	r3, [pc, #144]	; (80212c4 <__swsetup_r+0xd8>)
 8021234:	429c      	cmp	r4, r3
 8021236:	bf08      	it	eq
 8021238:	68ec      	ldreq	r4, [r5, #12]
 802123a:	e7e6      	b.n	802120a <__swsetup_r+0x1e>
 802123c:	0751      	lsls	r1, r2, #29
 802123e:	d512      	bpl.n	8021266 <__swsetup_r+0x7a>
 8021240:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8021242:	b141      	cbz	r1, 8021256 <__swsetup_r+0x6a>
 8021244:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8021248:	4299      	cmp	r1, r3
 802124a:	d002      	beq.n	8021252 <__swsetup_r+0x66>
 802124c:	4630      	mov	r0, r6
 802124e:	f7fd fc77 	bl	801eb40 <_free_r>
 8021252:	2300      	movs	r3, #0
 8021254:	6363      	str	r3, [r4, #52]	; 0x34
 8021256:	89a3      	ldrh	r3, [r4, #12]
 8021258:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 802125c:	81a3      	strh	r3, [r4, #12]
 802125e:	2300      	movs	r3, #0
 8021260:	6063      	str	r3, [r4, #4]
 8021262:	6923      	ldr	r3, [r4, #16]
 8021264:	6023      	str	r3, [r4, #0]
 8021266:	89a3      	ldrh	r3, [r4, #12]
 8021268:	f043 0308 	orr.w	r3, r3, #8
 802126c:	81a3      	strh	r3, [r4, #12]
 802126e:	6923      	ldr	r3, [r4, #16]
 8021270:	b94b      	cbnz	r3, 8021286 <__swsetup_r+0x9a>
 8021272:	89a3      	ldrh	r3, [r4, #12]
 8021274:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8021278:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 802127c:	d003      	beq.n	8021286 <__swsetup_r+0x9a>
 802127e:	4621      	mov	r1, r4
 8021280:	4630      	mov	r0, r6
 8021282:	f000 f917 	bl	80214b4 <__smakebuf_r>
 8021286:	89a2      	ldrh	r2, [r4, #12]
 8021288:	f012 0301 	ands.w	r3, r2, #1
 802128c:	d00c      	beq.n	80212a8 <__swsetup_r+0xbc>
 802128e:	2300      	movs	r3, #0
 8021290:	60a3      	str	r3, [r4, #8]
 8021292:	6963      	ldr	r3, [r4, #20]
 8021294:	425b      	negs	r3, r3
 8021296:	61a3      	str	r3, [r4, #24]
 8021298:	6923      	ldr	r3, [r4, #16]
 802129a:	b953      	cbnz	r3, 80212b2 <__swsetup_r+0xc6>
 802129c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80212a0:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 80212a4:	d1ba      	bne.n	802121c <__swsetup_r+0x30>
 80212a6:	bd70      	pop	{r4, r5, r6, pc}
 80212a8:	0792      	lsls	r2, r2, #30
 80212aa:	bf58      	it	pl
 80212ac:	6963      	ldrpl	r3, [r4, #20]
 80212ae:	60a3      	str	r3, [r4, #8]
 80212b0:	e7f2      	b.n	8021298 <__swsetup_r+0xac>
 80212b2:	2000      	movs	r0, #0
 80212b4:	e7f7      	b.n	80212a6 <__swsetup_r+0xba>
 80212b6:	bf00      	nop
 80212b8:	20001558 	.word	0x20001558
 80212bc:	08075edc 	.word	0x08075edc
 80212c0:	08075efc 	.word	0x08075efc
 80212c4:	08075ebc 	.word	0x08075ebc

080212c8 <_close_r>:
 80212c8:	b538      	push	{r3, r4, r5, lr}
 80212ca:	4c06      	ldr	r4, [pc, #24]	; (80212e4 <_close_r+0x1c>)
 80212cc:	2300      	movs	r3, #0
 80212ce:	4605      	mov	r5, r0
 80212d0:	4608      	mov	r0, r1
 80212d2:	6023      	str	r3, [r4, #0]
 80212d4:	f7f7 fd10 	bl	8018cf8 <_close>
 80212d8:	1c43      	adds	r3, r0, #1
 80212da:	d102      	bne.n	80212e2 <_close_r+0x1a>
 80212dc:	6823      	ldr	r3, [r4, #0]
 80212de:	b103      	cbz	r3, 80212e2 <_close_r+0x1a>
 80212e0:	602b      	str	r3, [r5, #0]
 80212e2:	bd38      	pop	{r3, r4, r5, pc}
 80212e4:	2001331c 	.word	0x2001331c

080212e8 <__sflush_r>:
 80212e8:	898a      	ldrh	r2, [r1, #12]
 80212ea:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80212ee:	4605      	mov	r5, r0
 80212f0:	0710      	lsls	r0, r2, #28
 80212f2:	460c      	mov	r4, r1
 80212f4:	d458      	bmi.n	80213a8 <__sflush_r+0xc0>
 80212f6:	684b      	ldr	r3, [r1, #4]
 80212f8:	2b00      	cmp	r3, #0
 80212fa:	dc05      	bgt.n	8021308 <__sflush_r+0x20>
 80212fc:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 80212fe:	2b00      	cmp	r3, #0
 8021300:	dc02      	bgt.n	8021308 <__sflush_r+0x20>
 8021302:	2000      	movs	r0, #0
 8021304:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8021308:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 802130a:	2e00      	cmp	r6, #0
 802130c:	d0f9      	beq.n	8021302 <__sflush_r+0x1a>
 802130e:	2300      	movs	r3, #0
 8021310:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8021314:	682f      	ldr	r7, [r5, #0]
 8021316:	6a21      	ldr	r1, [r4, #32]
 8021318:	602b      	str	r3, [r5, #0]
 802131a:	d032      	beq.n	8021382 <__sflush_r+0x9a>
 802131c:	6d60      	ldr	r0, [r4, #84]	; 0x54
 802131e:	89a3      	ldrh	r3, [r4, #12]
 8021320:	075a      	lsls	r2, r3, #29
 8021322:	d505      	bpl.n	8021330 <__sflush_r+0x48>
 8021324:	6863      	ldr	r3, [r4, #4]
 8021326:	1ac0      	subs	r0, r0, r3
 8021328:	6b63      	ldr	r3, [r4, #52]	; 0x34
 802132a:	b10b      	cbz	r3, 8021330 <__sflush_r+0x48>
 802132c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 802132e:	1ac0      	subs	r0, r0, r3
 8021330:	2300      	movs	r3, #0
 8021332:	4602      	mov	r2, r0
 8021334:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8021336:	6a21      	ldr	r1, [r4, #32]
 8021338:	4628      	mov	r0, r5
 802133a:	47b0      	blx	r6
 802133c:	1c43      	adds	r3, r0, #1
 802133e:	89a3      	ldrh	r3, [r4, #12]
 8021340:	d106      	bne.n	8021350 <__sflush_r+0x68>
 8021342:	6829      	ldr	r1, [r5, #0]
 8021344:	291d      	cmp	r1, #29
 8021346:	d848      	bhi.n	80213da <__sflush_r+0xf2>
 8021348:	4a29      	ldr	r2, [pc, #164]	; (80213f0 <__sflush_r+0x108>)
 802134a:	40ca      	lsrs	r2, r1
 802134c:	07d6      	lsls	r6, r2, #31
 802134e:	d544      	bpl.n	80213da <__sflush_r+0xf2>
 8021350:	2200      	movs	r2, #0
 8021352:	6062      	str	r2, [r4, #4]
 8021354:	04d9      	lsls	r1, r3, #19
 8021356:	6922      	ldr	r2, [r4, #16]
 8021358:	6022      	str	r2, [r4, #0]
 802135a:	d504      	bpl.n	8021366 <__sflush_r+0x7e>
 802135c:	1c42      	adds	r2, r0, #1
 802135e:	d101      	bne.n	8021364 <__sflush_r+0x7c>
 8021360:	682b      	ldr	r3, [r5, #0]
 8021362:	b903      	cbnz	r3, 8021366 <__sflush_r+0x7e>
 8021364:	6560      	str	r0, [r4, #84]	; 0x54
 8021366:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8021368:	602f      	str	r7, [r5, #0]
 802136a:	2900      	cmp	r1, #0
 802136c:	d0c9      	beq.n	8021302 <__sflush_r+0x1a>
 802136e:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8021372:	4299      	cmp	r1, r3
 8021374:	d002      	beq.n	802137c <__sflush_r+0x94>
 8021376:	4628      	mov	r0, r5
 8021378:	f7fd fbe2 	bl	801eb40 <_free_r>
 802137c:	2000      	movs	r0, #0
 802137e:	6360      	str	r0, [r4, #52]	; 0x34
 8021380:	e7c0      	b.n	8021304 <__sflush_r+0x1c>
 8021382:	2301      	movs	r3, #1
 8021384:	4628      	mov	r0, r5
 8021386:	47b0      	blx	r6
 8021388:	1c41      	adds	r1, r0, #1
 802138a:	d1c8      	bne.n	802131e <__sflush_r+0x36>
 802138c:	682b      	ldr	r3, [r5, #0]
 802138e:	2b00      	cmp	r3, #0
 8021390:	d0c5      	beq.n	802131e <__sflush_r+0x36>
 8021392:	2b1d      	cmp	r3, #29
 8021394:	d001      	beq.n	802139a <__sflush_r+0xb2>
 8021396:	2b16      	cmp	r3, #22
 8021398:	d101      	bne.n	802139e <__sflush_r+0xb6>
 802139a:	602f      	str	r7, [r5, #0]
 802139c:	e7b1      	b.n	8021302 <__sflush_r+0x1a>
 802139e:	89a3      	ldrh	r3, [r4, #12]
 80213a0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80213a4:	81a3      	strh	r3, [r4, #12]
 80213a6:	e7ad      	b.n	8021304 <__sflush_r+0x1c>
 80213a8:	690f      	ldr	r7, [r1, #16]
 80213aa:	2f00      	cmp	r7, #0
 80213ac:	d0a9      	beq.n	8021302 <__sflush_r+0x1a>
 80213ae:	0793      	lsls	r3, r2, #30
 80213b0:	680e      	ldr	r6, [r1, #0]
 80213b2:	bf08      	it	eq
 80213b4:	694b      	ldreq	r3, [r1, #20]
 80213b6:	600f      	str	r7, [r1, #0]
 80213b8:	bf18      	it	ne
 80213ba:	2300      	movne	r3, #0
 80213bc:	eba6 0807 	sub.w	r8, r6, r7
 80213c0:	608b      	str	r3, [r1, #8]
 80213c2:	f1b8 0f00 	cmp.w	r8, #0
 80213c6:	dd9c      	ble.n	8021302 <__sflush_r+0x1a>
 80213c8:	4643      	mov	r3, r8
 80213ca:	463a      	mov	r2, r7
 80213cc:	6a21      	ldr	r1, [r4, #32]
 80213ce:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 80213d0:	4628      	mov	r0, r5
 80213d2:	47b0      	blx	r6
 80213d4:	2800      	cmp	r0, #0
 80213d6:	dc06      	bgt.n	80213e6 <__sflush_r+0xfe>
 80213d8:	89a3      	ldrh	r3, [r4, #12]
 80213da:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80213de:	81a3      	strh	r3, [r4, #12]
 80213e0:	f04f 30ff 	mov.w	r0, #4294967295
 80213e4:	e78e      	b.n	8021304 <__sflush_r+0x1c>
 80213e6:	4407      	add	r7, r0
 80213e8:	eba8 0800 	sub.w	r8, r8, r0
 80213ec:	e7e9      	b.n	80213c2 <__sflush_r+0xda>
 80213ee:	bf00      	nop
 80213f0:	20400001 	.word	0x20400001

080213f4 <_fflush_r>:
 80213f4:	b538      	push	{r3, r4, r5, lr}
 80213f6:	690b      	ldr	r3, [r1, #16]
 80213f8:	4605      	mov	r5, r0
 80213fa:	460c      	mov	r4, r1
 80213fc:	b1db      	cbz	r3, 8021436 <_fflush_r+0x42>
 80213fe:	b118      	cbz	r0, 8021408 <_fflush_r+0x14>
 8021400:	6983      	ldr	r3, [r0, #24]
 8021402:	b90b      	cbnz	r3, 8021408 <_fflush_r+0x14>
 8021404:	f7ff f810 	bl	8020428 <__sinit>
 8021408:	4b0c      	ldr	r3, [pc, #48]	; (802143c <_fflush_r+0x48>)
 802140a:	429c      	cmp	r4, r3
 802140c:	d109      	bne.n	8021422 <_fflush_r+0x2e>
 802140e:	686c      	ldr	r4, [r5, #4]
 8021410:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8021414:	b17b      	cbz	r3, 8021436 <_fflush_r+0x42>
 8021416:	4621      	mov	r1, r4
 8021418:	4628      	mov	r0, r5
 802141a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802141e:	f7ff bf63 	b.w	80212e8 <__sflush_r>
 8021422:	4b07      	ldr	r3, [pc, #28]	; (8021440 <_fflush_r+0x4c>)
 8021424:	429c      	cmp	r4, r3
 8021426:	d101      	bne.n	802142c <_fflush_r+0x38>
 8021428:	68ac      	ldr	r4, [r5, #8]
 802142a:	e7f1      	b.n	8021410 <_fflush_r+0x1c>
 802142c:	4b05      	ldr	r3, [pc, #20]	; (8021444 <_fflush_r+0x50>)
 802142e:	429c      	cmp	r4, r3
 8021430:	bf08      	it	eq
 8021432:	68ec      	ldreq	r4, [r5, #12]
 8021434:	e7ec      	b.n	8021410 <_fflush_r+0x1c>
 8021436:	2000      	movs	r0, #0
 8021438:	bd38      	pop	{r3, r4, r5, pc}
 802143a:	bf00      	nop
 802143c:	08075edc 	.word	0x08075edc
 8021440:	08075efc 	.word	0x08075efc
 8021444:	08075ebc 	.word	0x08075ebc

08021448 <_lseek_r>:
 8021448:	b538      	push	{r3, r4, r5, lr}
 802144a:	4c07      	ldr	r4, [pc, #28]	; (8021468 <_lseek_r+0x20>)
 802144c:	4605      	mov	r5, r0
 802144e:	4608      	mov	r0, r1
 8021450:	4611      	mov	r1, r2
 8021452:	2200      	movs	r2, #0
 8021454:	6022      	str	r2, [r4, #0]
 8021456:	461a      	mov	r2, r3
 8021458:	f7f7 fc5a 	bl	8018d10 <_lseek>
 802145c:	1c43      	adds	r3, r0, #1
 802145e:	d102      	bne.n	8021466 <_lseek_r+0x1e>
 8021460:	6823      	ldr	r3, [r4, #0]
 8021462:	b103      	cbz	r3, 8021466 <_lseek_r+0x1e>
 8021464:	602b      	str	r3, [r5, #0]
 8021466:	bd38      	pop	{r3, r4, r5, pc}
 8021468:	2001331c 	.word	0x2001331c

0802146c <__swhatbuf_r>:
 802146c:	b570      	push	{r4, r5, r6, lr}
 802146e:	460e      	mov	r6, r1
 8021470:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8021474:	2900      	cmp	r1, #0
 8021476:	b096      	sub	sp, #88	; 0x58
 8021478:	4614      	mov	r4, r2
 802147a:	461d      	mov	r5, r3
 802147c:	da07      	bge.n	802148e <__swhatbuf_r+0x22>
 802147e:	2300      	movs	r3, #0
 8021480:	602b      	str	r3, [r5, #0]
 8021482:	89b3      	ldrh	r3, [r6, #12]
 8021484:	061a      	lsls	r2, r3, #24
 8021486:	d410      	bmi.n	80214aa <__swhatbuf_r+0x3e>
 8021488:	f44f 6380 	mov.w	r3, #1024	; 0x400
 802148c:	e00e      	b.n	80214ac <__swhatbuf_r+0x40>
 802148e:	466a      	mov	r2, sp
 8021490:	f000 f8a2 	bl	80215d8 <_fstat_r>
 8021494:	2800      	cmp	r0, #0
 8021496:	dbf2      	blt.n	802147e <__swhatbuf_r+0x12>
 8021498:	9a01      	ldr	r2, [sp, #4]
 802149a:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 802149e:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 80214a2:	425a      	negs	r2, r3
 80214a4:	415a      	adcs	r2, r3
 80214a6:	602a      	str	r2, [r5, #0]
 80214a8:	e7ee      	b.n	8021488 <__swhatbuf_r+0x1c>
 80214aa:	2340      	movs	r3, #64	; 0x40
 80214ac:	2000      	movs	r0, #0
 80214ae:	6023      	str	r3, [r4, #0]
 80214b0:	b016      	add	sp, #88	; 0x58
 80214b2:	bd70      	pop	{r4, r5, r6, pc}

080214b4 <__smakebuf_r>:
 80214b4:	898b      	ldrh	r3, [r1, #12]
 80214b6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80214b8:	079d      	lsls	r5, r3, #30
 80214ba:	4606      	mov	r6, r0
 80214bc:	460c      	mov	r4, r1
 80214be:	d507      	bpl.n	80214d0 <__smakebuf_r+0x1c>
 80214c0:	f104 0347 	add.w	r3, r4, #71	; 0x47
 80214c4:	6023      	str	r3, [r4, #0]
 80214c6:	6123      	str	r3, [r4, #16]
 80214c8:	2301      	movs	r3, #1
 80214ca:	6163      	str	r3, [r4, #20]
 80214cc:	b002      	add	sp, #8
 80214ce:	bd70      	pop	{r4, r5, r6, pc}
 80214d0:	ab01      	add	r3, sp, #4
 80214d2:	466a      	mov	r2, sp
 80214d4:	f7ff ffca 	bl	802146c <__swhatbuf_r>
 80214d8:	9900      	ldr	r1, [sp, #0]
 80214da:	4605      	mov	r5, r0
 80214dc:	4630      	mov	r0, r6
 80214de:	f7fd fb7d 	bl	801ebdc <_malloc_r>
 80214e2:	b948      	cbnz	r0, 80214f8 <__smakebuf_r+0x44>
 80214e4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80214e8:	059a      	lsls	r2, r3, #22
 80214ea:	d4ef      	bmi.n	80214cc <__smakebuf_r+0x18>
 80214ec:	f023 0303 	bic.w	r3, r3, #3
 80214f0:	f043 0302 	orr.w	r3, r3, #2
 80214f4:	81a3      	strh	r3, [r4, #12]
 80214f6:	e7e3      	b.n	80214c0 <__smakebuf_r+0xc>
 80214f8:	4b0d      	ldr	r3, [pc, #52]	; (8021530 <__smakebuf_r+0x7c>)
 80214fa:	62b3      	str	r3, [r6, #40]	; 0x28
 80214fc:	89a3      	ldrh	r3, [r4, #12]
 80214fe:	6020      	str	r0, [r4, #0]
 8021500:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8021504:	81a3      	strh	r3, [r4, #12]
 8021506:	9b00      	ldr	r3, [sp, #0]
 8021508:	6163      	str	r3, [r4, #20]
 802150a:	9b01      	ldr	r3, [sp, #4]
 802150c:	6120      	str	r0, [r4, #16]
 802150e:	b15b      	cbz	r3, 8021528 <__smakebuf_r+0x74>
 8021510:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8021514:	4630      	mov	r0, r6
 8021516:	f000 f871 	bl	80215fc <_isatty_r>
 802151a:	b128      	cbz	r0, 8021528 <__smakebuf_r+0x74>
 802151c:	89a3      	ldrh	r3, [r4, #12]
 802151e:	f023 0303 	bic.w	r3, r3, #3
 8021522:	f043 0301 	orr.w	r3, r3, #1
 8021526:	81a3      	strh	r3, [r4, #12]
 8021528:	89a3      	ldrh	r3, [r4, #12]
 802152a:	431d      	orrs	r5, r3
 802152c:	81a5      	strh	r5, [r4, #12]
 802152e:	e7cd      	b.n	80214cc <__smakebuf_r+0x18>
 8021530:	080203f1 	.word	0x080203f1

08021534 <memmove>:
 8021534:	4288      	cmp	r0, r1
 8021536:	b510      	push	{r4, lr}
 8021538:	eb01 0302 	add.w	r3, r1, r2
 802153c:	d807      	bhi.n	802154e <memmove+0x1a>
 802153e:	1e42      	subs	r2, r0, #1
 8021540:	4299      	cmp	r1, r3
 8021542:	d00a      	beq.n	802155a <memmove+0x26>
 8021544:	f811 4b01 	ldrb.w	r4, [r1], #1
 8021548:	f802 4f01 	strb.w	r4, [r2, #1]!
 802154c:	e7f8      	b.n	8021540 <memmove+0xc>
 802154e:	4283      	cmp	r3, r0
 8021550:	d9f5      	bls.n	802153e <memmove+0xa>
 8021552:	1881      	adds	r1, r0, r2
 8021554:	1ad2      	subs	r2, r2, r3
 8021556:	42d3      	cmn	r3, r2
 8021558:	d100      	bne.n	802155c <memmove+0x28>
 802155a:	bd10      	pop	{r4, pc}
 802155c:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8021560:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8021564:	e7f7      	b.n	8021556 <memmove+0x22>

08021566 <_realloc_r>:
 8021566:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8021568:	4607      	mov	r7, r0
 802156a:	4614      	mov	r4, r2
 802156c:	460e      	mov	r6, r1
 802156e:	b921      	cbnz	r1, 802157a <_realloc_r+0x14>
 8021570:	4611      	mov	r1, r2
 8021572:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8021576:	f7fd bb31 	b.w	801ebdc <_malloc_r>
 802157a:	b922      	cbnz	r2, 8021586 <_realloc_r+0x20>
 802157c:	f7fd fae0 	bl	801eb40 <_free_r>
 8021580:	4625      	mov	r5, r4
 8021582:	4628      	mov	r0, r5
 8021584:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8021586:	f000 f849 	bl	802161c <_malloc_usable_size_r>
 802158a:	42a0      	cmp	r0, r4
 802158c:	d20f      	bcs.n	80215ae <_realloc_r+0x48>
 802158e:	4621      	mov	r1, r4
 8021590:	4638      	mov	r0, r7
 8021592:	f7fd fb23 	bl	801ebdc <_malloc_r>
 8021596:	4605      	mov	r5, r0
 8021598:	2800      	cmp	r0, #0
 802159a:	d0f2      	beq.n	8021582 <_realloc_r+0x1c>
 802159c:	4631      	mov	r1, r6
 802159e:	4622      	mov	r2, r4
 80215a0:	f7fd fabb 	bl	801eb1a <memcpy>
 80215a4:	4631      	mov	r1, r6
 80215a6:	4638      	mov	r0, r7
 80215a8:	f7fd faca 	bl	801eb40 <_free_r>
 80215ac:	e7e9      	b.n	8021582 <_realloc_r+0x1c>
 80215ae:	4635      	mov	r5, r6
 80215b0:	e7e7      	b.n	8021582 <_realloc_r+0x1c>
	...

080215b4 <_read_r>:
 80215b4:	b538      	push	{r3, r4, r5, lr}
 80215b6:	4c07      	ldr	r4, [pc, #28]	; (80215d4 <_read_r+0x20>)
 80215b8:	4605      	mov	r5, r0
 80215ba:	4608      	mov	r0, r1
 80215bc:	4611      	mov	r1, r2
 80215be:	2200      	movs	r2, #0
 80215c0:	6022      	str	r2, [r4, #0]
 80215c2:	461a      	mov	r2, r3
 80215c4:	f7f7 fba6 	bl	8018d14 <_read>
 80215c8:	1c43      	adds	r3, r0, #1
 80215ca:	d102      	bne.n	80215d2 <_read_r+0x1e>
 80215cc:	6823      	ldr	r3, [r4, #0]
 80215ce:	b103      	cbz	r3, 80215d2 <_read_r+0x1e>
 80215d0:	602b      	str	r3, [r5, #0]
 80215d2:	bd38      	pop	{r3, r4, r5, pc}
 80215d4:	2001331c 	.word	0x2001331c

080215d8 <_fstat_r>:
 80215d8:	b538      	push	{r3, r4, r5, lr}
 80215da:	4c07      	ldr	r4, [pc, #28]	; (80215f8 <_fstat_r+0x20>)
 80215dc:	2300      	movs	r3, #0
 80215de:	4605      	mov	r5, r0
 80215e0:	4608      	mov	r0, r1
 80215e2:	4611      	mov	r1, r2
 80215e4:	6023      	str	r3, [r4, #0]
 80215e6:	f7f7 fb8b 	bl	8018d00 <_fstat>
 80215ea:	1c43      	adds	r3, r0, #1
 80215ec:	d102      	bne.n	80215f4 <_fstat_r+0x1c>
 80215ee:	6823      	ldr	r3, [r4, #0]
 80215f0:	b103      	cbz	r3, 80215f4 <_fstat_r+0x1c>
 80215f2:	602b      	str	r3, [r5, #0]
 80215f4:	bd38      	pop	{r3, r4, r5, pc}
 80215f6:	bf00      	nop
 80215f8:	2001331c 	.word	0x2001331c

080215fc <_isatty_r>:
 80215fc:	b538      	push	{r3, r4, r5, lr}
 80215fe:	4c06      	ldr	r4, [pc, #24]	; (8021618 <_isatty_r+0x1c>)
 8021600:	2300      	movs	r3, #0
 8021602:	4605      	mov	r5, r0
 8021604:	4608      	mov	r0, r1
 8021606:	6023      	str	r3, [r4, #0]
 8021608:	f7f7 fb80 	bl	8018d0c <_isatty>
 802160c:	1c43      	adds	r3, r0, #1
 802160e:	d102      	bne.n	8021616 <_isatty_r+0x1a>
 8021610:	6823      	ldr	r3, [r4, #0]
 8021612:	b103      	cbz	r3, 8021616 <_isatty_r+0x1a>
 8021614:	602b      	str	r3, [r5, #0]
 8021616:	bd38      	pop	{r3, r4, r5, pc}
 8021618:	2001331c 	.word	0x2001331c

0802161c <_malloc_usable_size_r>:
 802161c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8021620:	1f18      	subs	r0, r3, #4
 8021622:	2b00      	cmp	r3, #0
 8021624:	bfbc      	itt	lt
 8021626:	580b      	ldrlt	r3, [r1, r0]
 8021628:	18c0      	addlt	r0, r0, r3
 802162a:	4770      	bx	lr

0802162c <round>:
 802162c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802162e:	ec57 6b10 	vmov	r6, r7, d0
 8021632:	f3c7 500a 	ubfx	r0, r7, #20, #11
 8021636:	f2a0 34ff 	subw	r4, r0, #1023	; 0x3ff
 802163a:	2c13      	cmp	r4, #19
 802163c:	463b      	mov	r3, r7
 802163e:	463d      	mov	r5, r7
 8021640:	dc17      	bgt.n	8021672 <round+0x46>
 8021642:	2c00      	cmp	r4, #0
 8021644:	da09      	bge.n	802165a <round+0x2e>
 8021646:	3401      	adds	r4, #1
 8021648:	f007 4300 	and.w	r3, r7, #2147483648	; 0x80000000
 802164c:	d103      	bne.n	8021656 <round+0x2a>
 802164e:	f043 537f 	orr.w	r3, r3, #1069547520	; 0x3fc00000
 8021652:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 8021656:	2100      	movs	r1, #0
 8021658:	e02c      	b.n	80216b4 <round+0x88>
 802165a:	4a18      	ldr	r2, [pc, #96]	; (80216bc <round+0x90>)
 802165c:	4122      	asrs	r2, r4
 802165e:	4217      	tst	r7, r2
 8021660:	d100      	bne.n	8021664 <round+0x38>
 8021662:	b19e      	cbz	r6, 802168c <round+0x60>
 8021664:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8021668:	4123      	asrs	r3, r4
 802166a:	442b      	add	r3, r5
 802166c:	ea23 0302 	bic.w	r3, r3, r2
 8021670:	e7f1      	b.n	8021656 <round+0x2a>
 8021672:	2c33      	cmp	r4, #51	; 0x33
 8021674:	dd0d      	ble.n	8021692 <round+0x66>
 8021676:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
 802167a:	d107      	bne.n	802168c <round+0x60>
 802167c:	4630      	mov	r0, r6
 802167e:	4639      	mov	r1, r7
 8021680:	ee10 2a10 	vmov	r2, s0
 8021684:	f7e5 fd0a 	bl	800709c <__adddf3>
 8021688:	4606      	mov	r6, r0
 802168a:	460f      	mov	r7, r1
 802168c:	ec47 6b10 	vmov	d0, r6, r7
 8021690:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8021692:	f2a0 4213 	subw	r2, r0, #1043	; 0x413
 8021696:	f04f 30ff 	mov.w	r0, #4294967295
 802169a:	40d0      	lsrs	r0, r2
 802169c:	4206      	tst	r6, r0
 802169e:	d0f5      	beq.n	802168c <round+0x60>
 80216a0:	2201      	movs	r2, #1
 80216a2:	f1c4 0433 	rsb	r4, r4, #51	; 0x33
 80216a6:	fa02 f404 	lsl.w	r4, r2, r4
 80216aa:	1931      	adds	r1, r6, r4
 80216ac:	bf28      	it	cs
 80216ae:	189b      	addcs	r3, r3, r2
 80216b0:	ea21 0100 	bic.w	r1, r1, r0
 80216b4:	461f      	mov	r7, r3
 80216b6:	460e      	mov	r6, r1
 80216b8:	e7e8      	b.n	802168c <round+0x60>
 80216ba:	bf00      	nop
 80216bc:	000fffff 	.word	0x000fffff

080216c0 <tanhf>:
 80216c0:	b510      	push	{r4, lr}
 80216c2:	ee10 4a10 	vmov	r4, s0
 80216c6:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 80216ca:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 80216ce:	ed2d 8b02 	vpush	{d8}
 80216d2:	eef0 7a40 	vmov.f32	s15, s0
 80216d6:	db0c      	blt.n	80216f2 <tanhf+0x32>
 80216d8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80216dc:	ee87 0a27 	vdiv.f32	s0, s14, s15
 80216e0:	2c00      	cmp	r4, #0
 80216e2:	bfac      	ite	ge
 80216e4:	ee30 0a07 	vaddge.f32	s0, s0, s14
 80216e8:	ee30 0a47 	vsublt.f32	s0, s0, s14
 80216ec:	ecbd 8b02 	vpop	{d8}
 80216f0:	bd10      	pop	{r4, pc}
 80216f2:	4a1b      	ldr	r2, [pc, #108]	; (8021760 <tanhf+0xa0>)
 80216f4:	4293      	cmp	r3, r2
 80216f6:	dc30      	bgt.n	802175a <tanhf+0x9a>
 80216f8:	f1b3 5f10 	cmp.w	r3, #603979776	; 0x24000000
 80216fc:	da06      	bge.n	802170c <tanhf+0x4c>
 80216fe:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8021702:	ee37 0a80 	vadd.f32	s0, s15, s0
 8021706:	ee20 0a27 	vmul.f32	s0, s0, s15
 802170a:	e7ef      	b.n	80216ec <tanhf+0x2c>
 802170c:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 8021710:	eeb0 8a00 	vmov.f32	s16, #0	; 0x40000000  2.0
 8021714:	db12      	blt.n	802173c <tanhf+0x7c>
 8021716:	f000 ff9f 	bl	8022658 <fabsf>
 802171a:	ee30 0a00 	vadd.f32	s0, s0, s0
 802171e:	f000 fe6f 	bl	8022400 <expm1f>
 8021722:	ee30 0a08 	vadd.f32	s0, s0, s16
 8021726:	eec8 7a00 	vdiv.f32	s15, s16, s0
 802172a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802172e:	ee30 0a67 	vsub.f32	s0, s0, s15
 8021732:	2c00      	cmp	r4, #0
 8021734:	bfb8      	it	lt
 8021736:	eeb1 0a40 	vneglt.f32	s0, s0
 802173a:	e7d7      	b.n	80216ec <tanhf+0x2c>
 802173c:	f000 ff8c 	bl	8022658 <fabsf>
 8021740:	eef8 7a00 	vmov.f32	s15, #128	; 0xc0000000 -2.0
 8021744:	ee20 0a27 	vmul.f32	s0, s0, s15
 8021748:	f000 fe5a 	bl	8022400 <expm1f>
 802174c:	ee70 7a08 	vadd.f32	s15, s0, s16
 8021750:	eeb1 7a40 	vneg.f32	s14, s0
 8021754:	ee87 0a27 	vdiv.f32	s0, s14, s15
 8021758:	e7eb      	b.n	8021732 <tanhf+0x72>
 802175a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802175e:	e7e8      	b.n	8021732 <tanhf+0x72>
 8021760:	41afffff 	.word	0x41afffff

08021764 <expf>:
 8021764:	b530      	push	{r4, r5, lr}
 8021766:	ed2d 8b02 	vpush	{d8}
 802176a:	4d35      	ldr	r5, [pc, #212]	; (8021840 <expf+0xdc>)
 802176c:	b08b      	sub	sp, #44	; 0x2c
 802176e:	eeb0 8a40 	vmov.f32	s16, s0
 8021772:	f000 fa4b 	bl	8021c0c <__ieee754_expf>
 8021776:	f995 3000 	ldrsb.w	r3, [r5]
 802177a:	3301      	adds	r3, #1
 802177c:	ee10 4a10 	vmov	r4, s0
 8021780:	d030      	beq.n	80217e4 <expf+0x80>
 8021782:	eeb0 0a48 	vmov.f32	s0, s16
 8021786:	f000 ff6e 	bl	8022666 <finitef>
 802178a:	b358      	cbz	r0, 80217e4 <expf+0x80>
 802178c:	eddf 7a2d 	vldr	s15, [pc, #180]	; 8021844 <expf+0xe0>
 8021790:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8021794:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021798:	dd35      	ble.n	8021806 <expf+0xa2>
 802179a:	2303      	movs	r3, #3
 802179c:	9300      	str	r3, [sp, #0]
 802179e:	4b2a      	ldr	r3, [pc, #168]	; (8021848 <expf+0xe4>)
 80217a0:	9301      	str	r3, [sp, #4]
 80217a2:	ee18 0a10 	vmov	r0, s16
 80217a6:	2300      	movs	r3, #0
 80217a8:	9308      	str	r3, [sp, #32]
 80217aa:	f7e5 fdd5 	bl	8007358 <__aeabi_f2d>
 80217ae:	f995 3000 	ldrsb.w	r3, [r5]
 80217b2:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80217b6:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80217ba:	b9cb      	cbnz	r3, 80217f0 <expf+0x8c>
 80217bc:	4b23      	ldr	r3, [pc, #140]	; (802184c <expf+0xe8>)
 80217be:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 80217c2:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80217c6:	4668      	mov	r0, sp
 80217c8:	f000 fe0d 	bl	80223e6 <matherr>
 80217cc:	b1b0      	cbz	r0, 80217fc <expf+0x98>
 80217ce:	9b08      	ldr	r3, [sp, #32]
 80217d0:	b11b      	cbz	r3, 80217da <expf+0x76>
 80217d2:	f7fd f959 	bl	801ea88 <__errno>
 80217d6:	9b08      	ldr	r3, [sp, #32]
 80217d8:	6003      	str	r3, [r0, #0]
 80217da:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80217de:	f7e6 f8eb 	bl	80079b8 <__aeabi_d2f>
 80217e2:	4604      	mov	r4, r0
 80217e4:	ee00 4a10 	vmov	s0, r4
 80217e8:	b00b      	add	sp, #44	; 0x2c
 80217ea:	ecbd 8b02 	vpop	{d8}
 80217ee:	bd30      	pop	{r4, r5, pc}
 80217f0:	4917      	ldr	r1, [pc, #92]	; (8021850 <expf+0xec>)
 80217f2:	2000      	movs	r0, #0
 80217f4:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80217f8:	2b02      	cmp	r3, #2
 80217fa:	d1e4      	bne.n	80217c6 <expf+0x62>
 80217fc:	f7fd f944 	bl	801ea88 <__errno>
 8021800:	2322      	movs	r3, #34	; 0x22
 8021802:	6003      	str	r3, [r0, #0]
 8021804:	e7e3      	b.n	80217ce <expf+0x6a>
 8021806:	eddf 7a13 	vldr	s15, [pc, #76]	; 8021854 <expf+0xf0>
 802180a:	eeb4 8ae7 	vcmpe.f32	s16, s15
 802180e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021812:	d5e7      	bpl.n	80217e4 <expf+0x80>
 8021814:	2304      	movs	r3, #4
 8021816:	9300      	str	r3, [sp, #0]
 8021818:	4b0b      	ldr	r3, [pc, #44]	; (8021848 <expf+0xe4>)
 802181a:	9301      	str	r3, [sp, #4]
 802181c:	ee18 0a10 	vmov	r0, s16
 8021820:	2300      	movs	r3, #0
 8021822:	9308      	str	r3, [sp, #32]
 8021824:	f7e5 fd98 	bl	8007358 <__aeabi_f2d>
 8021828:	2300      	movs	r3, #0
 802182a:	2200      	movs	r2, #0
 802182c:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8021830:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8021834:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8021838:	f995 3000 	ldrsb.w	r3, [r5]
 802183c:	e7dc      	b.n	80217f8 <expf+0x94>
 802183e:	bf00      	nop
 8021840:	20001728 	.word	0x20001728
 8021844:	42b17180 	.word	0x42b17180
 8021848:	08076136 	.word	0x08076136
 802184c:	47efffff 	.word	0x47efffff
 8021850:	7ff00000 	.word	0x7ff00000
 8021854:	c2cff1b5 	.word	0xc2cff1b5

08021858 <log10f>:
 8021858:	b510      	push	{r4, lr}
 802185a:	ed2d 8b02 	vpush	{d8}
 802185e:	b08a      	sub	sp, #40	; 0x28
 8021860:	eeb0 8a40 	vmov.f32	s16, s0
 8021864:	f000 faa6 	bl	8021db4 <__ieee754_log10f>
 8021868:	4b31      	ldr	r3, [pc, #196]	; (8021930 <log10f+0xd8>)
 802186a:	f993 4000 	ldrsb.w	r4, [r3]
 802186e:	1c63      	adds	r3, r4, #1
 8021870:	d059      	beq.n	8021926 <log10f+0xce>
 8021872:	eeb4 8a48 	vcmp.f32	s16, s16
 8021876:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802187a:	d654      	bvs.n	8021926 <log10f+0xce>
 802187c:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8021880:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021884:	d84f      	bhi.n	8021926 <log10f+0xce>
 8021886:	4b2b      	ldr	r3, [pc, #172]	; (8021934 <log10f+0xdc>)
 8021888:	9301      	str	r3, [sp, #4]
 802188a:	ee18 0a10 	vmov	r0, s16
 802188e:	2300      	movs	r3, #0
 8021890:	9308      	str	r3, [sp, #32]
 8021892:	f7e5 fd61 	bl	8007358 <__aeabi_f2d>
 8021896:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802189a:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802189e:	b994      	cbnz	r4, 80218c6 <log10f+0x6e>
 80218a0:	4b25      	ldr	r3, [pc, #148]	; (8021938 <log10f+0xe0>)
 80218a2:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80218a6:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 80218aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80218ae:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80218b2:	d025      	beq.n	8021900 <log10f+0xa8>
 80218b4:	2301      	movs	r3, #1
 80218b6:	2c02      	cmp	r4, #2
 80218b8:	9300      	str	r3, [sp, #0]
 80218ba:	d116      	bne.n	80218ea <log10f+0x92>
 80218bc:	f7fd f8e4 	bl	801ea88 <__errno>
 80218c0:	2321      	movs	r3, #33	; 0x21
 80218c2:	6003      	str	r3, [r0, #0]
 80218c4:	e016      	b.n	80218f4 <log10f+0x9c>
 80218c6:	4b1d      	ldr	r3, [pc, #116]	; (802193c <log10f+0xe4>)
 80218c8:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80218cc:	2200      	movs	r2, #0
 80218ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80218d2:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80218d6:	d1ed      	bne.n	80218b4 <log10f+0x5c>
 80218d8:	2302      	movs	r3, #2
 80218da:	429c      	cmp	r4, r3
 80218dc:	9300      	str	r3, [sp, #0]
 80218de:	d111      	bne.n	8021904 <log10f+0xac>
 80218e0:	f7fd f8d2 	bl	801ea88 <__errno>
 80218e4:	2322      	movs	r3, #34	; 0x22
 80218e6:	6003      	str	r3, [r0, #0]
 80218e8:	e011      	b.n	802190e <log10f+0xb6>
 80218ea:	4668      	mov	r0, sp
 80218ec:	f000 fd7b 	bl	80223e6 <matherr>
 80218f0:	2800      	cmp	r0, #0
 80218f2:	d0e3      	beq.n	80218bc <log10f+0x64>
 80218f4:	4812      	ldr	r0, [pc, #72]	; (8021940 <log10f+0xe8>)
 80218f6:	f000 fd7b 	bl	80223f0 <nan>
 80218fa:	ed8d 0b06 	vstr	d0, [sp, #24]
 80218fe:	e006      	b.n	802190e <log10f+0xb6>
 8021900:	2302      	movs	r3, #2
 8021902:	9300      	str	r3, [sp, #0]
 8021904:	4668      	mov	r0, sp
 8021906:	f000 fd6e 	bl	80223e6 <matherr>
 802190a:	2800      	cmp	r0, #0
 802190c:	d0e8      	beq.n	80218e0 <log10f+0x88>
 802190e:	9b08      	ldr	r3, [sp, #32]
 8021910:	b11b      	cbz	r3, 802191a <log10f+0xc2>
 8021912:	f7fd f8b9 	bl	801ea88 <__errno>
 8021916:	9b08      	ldr	r3, [sp, #32]
 8021918:	6003      	str	r3, [r0, #0]
 802191a:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802191e:	f7e6 f84b 	bl	80079b8 <__aeabi_d2f>
 8021922:	ee00 0a10 	vmov	s0, r0
 8021926:	b00a      	add	sp, #40	; 0x28
 8021928:	ecbd 8b02 	vpop	{d8}
 802192c:	bd10      	pop	{r4, pc}
 802192e:	bf00      	nop
 8021930:	20001728 	.word	0x20001728
 8021934:	0807613b 	.word	0x0807613b
 8021938:	c7efffff 	.word	0xc7efffff
 802193c:	fff00000 	.word	0xfff00000
 8021940:	08076029 	.word	0x08076029

08021944 <powf>:
 8021944:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 8021948:	ed2d 8b04 	vpush	{d8-d9}
 802194c:	4ca7      	ldr	r4, [pc, #668]	; (8021bec <powf+0x2a8>)
 802194e:	b08a      	sub	sp, #40	; 0x28
 8021950:	eef0 8a40 	vmov.f32	s17, s0
 8021954:	eeb0 8a60 	vmov.f32	s16, s1
 8021958:	f000 fa82 	bl	8021e60 <__ieee754_powf>
 802195c:	f994 5000 	ldrsb.w	r5, [r4]
 8021960:	1c6b      	adds	r3, r5, #1
 8021962:	eeb0 9a40 	vmov.f32	s18, s0
 8021966:	4626      	mov	r6, r4
 8021968:	d05f      	beq.n	8021a2a <powf+0xe6>
 802196a:	eeb4 8a48 	vcmp.f32	s16, s16
 802196e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021972:	d65a      	bvs.n	8021a2a <powf+0xe6>
 8021974:	eef4 8a68 	vcmp.f32	s17, s17
 8021978:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802197c:	d721      	bvc.n	80219c2 <powf+0x7e>
 802197e:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8021982:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021986:	d150      	bne.n	8021a2a <powf+0xe6>
 8021988:	2301      	movs	r3, #1
 802198a:	9300      	str	r3, [sp, #0]
 802198c:	4b98      	ldr	r3, [pc, #608]	; (8021bf0 <powf+0x2ac>)
 802198e:	9301      	str	r3, [sp, #4]
 8021990:	ee18 0a90 	vmov	r0, s17
 8021994:	2300      	movs	r3, #0
 8021996:	9308      	str	r3, [sp, #32]
 8021998:	f7e5 fcde 	bl	8007358 <__aeabi_f2d>
 802199c:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80219a0:	ee18 0a10 	vmov	r0, s16
 80219a4:	f7e5 fcd8 	bl	8007358 <__aeabi_f2d>
 80219a8:	4b92      	ldr	r3, [pc, #584]	; (8021bf4 <powf+0x2b0>)
 80219aa:	2200      	movs	r2, #0
 80219ac:	2d02      	cmp	r5, #2
 80219ae:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80219b2:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80219b6:	d032      	beq.n	8021a1e <powf+0xda>
 80219b8:	4668      	mov	r0, sp
 80219ba:	f000 fd14 	bl	80223e6 <matherr>
 80219be:	bb40      	cbnz	r0, 8021a12 <powf+0xce>
 80219c0:	e065      	b.n	8021a8e <powf+0x14a>
 80219c2:	eddf 9a8d 	vldr	s19, [pc, #564]	; 8021bf8 <powf+0x2b4>
 80219c6:	eef4 8a69 	vcmp.f32	s17, s19
 80219ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80219ce:	d163      	bne.n	8021a98 <powf+0x154>
 80219d0:	eeb4 8a69 	vcmp.f32	s16, s19
 80219d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80219d8:	d12e      	bne.n	8021a38 <powf+0xf4>
 80219da:	2301      	movs	r3, #1
 80219dc:	9300      	str	r3, [sp, #0]
 80219de:	4b84      	ldr	r3, [pc, #528]	; (8021bf0 <powf+0x2ac>)
 80219e0:	9301      	str	r3, [sp, #4]
 80219e2:	ee18 0a90 	vmov	r0, s17
 80219e6:	2300      	movs	r3, #0
 80219e8:	9308      	str	r3, [sp, #32]
 80219ea:	f7e5 fcb5 	bl	8007358 <__aeabi_f2d>
 80219ee:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80219f2:	ee18 0a10 	vmov	r0, s16
 80219f6:	f7e5 fcaf 	bl	8007358 <__aeabi_f2d>
 80219fa:	2200      	movs	r2, #0
 80219fc:	2300      	movs	r3, #0
 80219fe:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8021a02:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8021a06:	2d00      	cmp	r5, #0
 8021a08:	d0d6      	beq.n	80219b8 <powf+0x74>
 8021a0a:	4b7a      	ldr	r3, [pc, #488]	; (8021bf4 <powf+0x2b0>)
 8021a0c:	2200      	movs	r2, #0
 8021a0e:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8021a12:	9b08      	ldr	r3, [sp, #32]
 8021a14:	b11b      	cbz	r3, 8021a1e <powf+0xda>
 8021a16:	f7fd f837 	bl	801ea88 <__errno>
 8021a1a:	9b08      	ldr	r3, [sp, #32]
 8021a1c:	6003      	str	r3, [r0, #0]
 8021a1e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8021a22:	f7e5 ffc9 	bl	80079b8 <__aeabi_d2f>
 8021a26:	ee09 0a10 	vmov	s18, r0
 8021a2a:	eeb0 0a49 	vmov.f32	s0, s18
 8021a2e:	b00a      	add	sp, #40	; 0x28
 8021a30:	ecbd 8b04 	vpop	{d8-d9}
 8021a34:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
 8021a38:	eeb0 0a48 	vmov.f32	s0, s16
 8021a3c:	f000 fe13 	bl	8022666 <finitef>
 8021a40:	2800      	cmp	r0, #0
 8021a42:	d0f2      	beq.n	8021a2a <powf+0xe6>
 8021a44:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8021a48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021a4c:	d5ed      	bpl.n	8021a2a <powf+0xe6>
 8021a4e:	2301      	movs	r3, #1
 8021a50:	9300      	str	r3, [sp, #0]
 8021a52:	4b67      	ldr	r3, [pc, #412]	; (8021bf0 <powf+0x2ac>)
 8021a54:	9301      	str	r3, [sp, #4]
 8021a56:	ee18 0a90 	vmov	r0, s17
 8021a5a:	2300      	movs	r3, #0
 8021a5c:	9308      	str	r3, [sp, #32]
 8021a5e:	f7e5 fc7b 	bl	8007358 <__aeabi_f2d>
 8021a62:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8021a66:	ee18 0a10 	vmov	r0, s16
 8021a6a:	f7e5 fc75 	bl	8007358 <__aeabi_f2d>
 8021a6e:	f994 3000 	ldrsb.w	r3, [r4]
 8021a72:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8021a76:	b923      	cbnz	r3, 8021a82 <powf+0x13e>
 8021a78:	2200      	movs	r2, #0
 8021a7a:	2300      	movs	r3, #0
 8021a7c:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8021a80:	e79a      	b.n	80219b8 <powf+0x74>
 8021a82:	495e      	ldr	r1, [pc, #376]	; (8021bfc <powf+0x2b8>)
 8021a84:	2000      	movs	r0, #0
 8021a86:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8021a8a:	2b02      	cmp	r3, #2
 8021a8c:	d194      	bne.n	80219b8 <powf+0x74>
 8021a8e:	f7fc fffb 	bl	801ea88 <__errno>
 8021a92:	2321      	movs	r3, #33	; 0x21
 8021a94:	6003      	str	r3, [r0, #0]
 8021a96:	e7bc      	b.n	8021a12 <powf+0xce>
 8021a98:	f000 fde5 	bl	8022666 <finitef>
 8021a9c:	4605      	mov	r5, r0
 8021a9e:	2800      	cmp	r0, #0
 8021aa0:	d173      	bne.n	8021b8a <powf+0x246>
 8021aa2:	eeb0 0a68 	vmov.f32	s0, s17
 8021aa6:	f000 fdde 	bl	8022666 <finitef>
 8021aaa:	2800      	cmp	r0, #0
 8021aac:	d06d      	beq.n	8021b8a <powf+0x246>
 8021aae:	eeb0 0a48 	vmov.f32	s0, s16
 8021ab2:	f000 fdd8 	bl	8022666 <finitef>
 8021ab6:	2800      	cmp	r0, #0
 8021ab8:	d067      	beq.n	8021b8a <powf+0x246>
 8021aba:	ee18 0a90 	vmov	r0, s17
 8021abe:	f7e5 fc4b 	bl	8007358 <__aeabi_f2d>
 8021ac2:	4680      	mov	r8, r0
 8021ac4:	ee18 0a10 	vmov	r0, s16
 8021ac8:	4689      	mov	r9, r1
 8021aca:	f7e5 fc45 	bl	8007358 <__aeabi_f2d>
 8021ace:	eeb4 9a49 	vcmp.f32	s18, s18
 8021ad2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021ad6:	f994 4000 	ldrsb.w	r4, [r4]
 8021ada:	4b45      	ldr	r3, [pc, #276]	; (8021bf0 <powf+0x2ac>)
 8021adc:	d713      	bvc.n	8021b06 <powf+0x1c2>
 8021ade:	2201      	movs	r2, #1
 8021ae0:	e9cd 2300 	strd	r2, r3, [sp]
 8021ae4:	9508      	str	r5, [sp, #32]
 8021ae6:	e9cd 8902 	strd	r8, r9, [sp, #8]
 8021aea:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8021aee:	2c00      	cmp	r4, #0
 8021af0:	d0c2      	beq.n	8021a78 <powf+0x134>
 8021af2:	eec9 7aa9 	vdiv.f32	s15, s19, s19
 8021af6:	ee17 0a90 	vmov	r0, s15
 8021afa:	f7e5 fc2d 	bl	8007358 <__aeabi_f2d>
 8021afe:	2c02      	cmp	r4, #2
 8021b00:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8021b04:	e7c2      	b.n	8021a8c <powf+0x148>
 8021b06:	2203      	movs	r2, #3
 8021b08:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8021b0c:	e9cd 2300 	strd	r2, r3, [sp]
 8021b10:	9508      	str	r5, [sp, #32]
 8021b12:	e9cd 8902 	strd	r8, r9, [sp, #8]
 8021b16:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8021b1a:	ee28 8a27 	vmul.f32	s16, s16, s15
 8021b1e:	b9fc      	cbnz	r4, 8021b60 <powf+0x21c>
 8021b20:	4b37      	ldr	r3, [pc, #220]	; (8021c00 <powf+0x2bc>)
 8021b22:	eef5 8ac0 	vcmpe.f32	s17, #0.0
 8021b26:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 8021b2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021b2e:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8021b32:	d553      	bpl.n	8021bdc <powf+0x298>
 8021b34:	eeb0 0a48 	vmov.f32	s0, s16
 8021b38:	f000 fda6 	bl	8022688 <rintf>
 8021b3c:	eeb4 0a48 	vcmp.f32	s0, s16
 8021b40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021b44:	d004      	beq.n	8021b50 <powf+0x20c>
 8021b46:	4b2f      	ldr	r3, [pc, #188]	; (8021c04 <powf+0x2c0>)
 8021b48:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 8021b4c:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8021b50:	f996 3000 	ldrsb.w	r3, [r6]
 8021b54:	2b02      	cmp	r3, #2
 8021b56:	d141      	bne.n	8021bdc <powf+0x298>
 8021b58:	f7fc ff96 	bl	801ea88 <__errno>
 8021b5c:	2322      	movs	r3, #34	; 0x22
 8021b5e:	e799      	b.n	8021a94 <powf+0x150>
 8021b60:	4b29      	ldr	r3, [pc, #164]	; (8021c08 <powf+0x2c4>)
 8021b62:	eef5 8ac0 	vcmpe.f32	s17, #0.0
 8021b66:	2200      	movs	r2, #0
 8021b68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021b6c:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8021b70:	d5ee      	bpl.n	8021b50 <powf+0x20c>
 8021b72:	eeb0 0a48 	vmov.f32	s0, s16
 8021b76:	f000 fd87 	bl	8022688 <rintf>
 8021b7a:	eeb4 0a48 	vcmp.f32	s0, s16
 8021b7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021b82:	d0e5      	beq.n	8021b50 <powf+0x20c>
 8021b84:	2200      	movs	r2, #0
 8021b86:	4b1d      	ldr	r3, [pc, #116]	; (8021bfc <powf+0x2b8>)
 8021b88:	e7e0      	b.n	8021b4c <powf+0x208>
 8021b8a:	eeb5 9a40 	vcmp.f32	s18, #0.0
 8021b8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021b92:	f47f af4a 	bne.w	8021a2a <powf+0xe6>
 8021b96:	eeb0 0a68 	vmov.f32	s0, s17
 8021b9a:	f000 fd64 	bl	8022666 <finitef>
 8021b9e:	2800      	cmp	r0, #0
 8021ba0:	f43f af43 	beq.w	8021a2a <powf+0xe6>
 8021ba4:	eeb0 0a48 	vmov.f32	s0, s16
 8021ba8:	f000 fd5d 	bl	8022666 <finitef>
 8021bac:	2800      	cmp	r0, #0
 8021bae:	f43f af3c 	beq.w	8021a2a <powf+0xe6>
 8021bb2:	2304      	movs	r3, #4
 8021bb4:	9300      	str	r3, [sp, #0]
 8021bb6:	4b0e      	ldr	r3, [pc, #56]	; (8021bf0 <powf+0x2ac>)
 8021bb8:	9301      	str	r3, [sp, #4]
 8021bba:	ee18 0a90 	vmov	r0, s17
 8021bbe:	2300      	movs	r3, #0
 8021bc0:	9308      	str	r3, [sp, #32]
 8021bc2:	f7e5 fbc9 	bl	8007358 <__aeabi_f2d>
 8021bc6:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8021bca:	ee18 0a10 	vmov	r0, s16
 8021bce:	f7e5 fbc3 	bl	8007358 <__aeabi_f2d>
 8021bd2:	2200      	movs	r2, #0
 8021bd4:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8021bd8:	2300      	movs	r3, #0
 8021bda:	e7b7      	b.n	8021b4c <powf+0x208>
 8021bdc:	4668      	mov	r0, sp
 8021bde:	f000 fc02 	bl	80223e6 <matherr>
 8021be2:	2800      	cmp	r0, #0
 8021be4:	f47f af15 	bne.w	8021a12 <powf+0xce>
 8021be8:	e7b6      	b.n	8021b58 <powf+0x214>
 8021bea:	bf00      	nop
 8021bec:	20001728 	.word	0x20001728
 8021bf0:	08076142 	.word	0x08076142
 8021bf4:	3ff00000 	.word	0x3ff00000
 8021bf8:	00000000 	.word	0x00000000
 8021bfc:	fff00000 	.word	0xfff00000
 8021c00:	47efffff 	.word	0x47efffff
 8021c04:	c7efffff 	.word	0xc7efffff
 8021c08:	7ff00000 	.word	0x7ff00000

08021c0c <__ieee754_expf>:
 8021c0c:	ee10 2a10 	vmov	r2, s0
 8021c10:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
 8021c14:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8021c18:	d902      	bls.n	8021c20 <__ieee754_expf+0x14>
 8021c1a:	ee30 0a00 	vadd.f32	s0, s0, s0
 8021c1e:	4770      	bx	lr
 8021c20:	ea4f 73d2 	mov.w	r3, r2, lsr #31
 8021c24:	d106      	bne.n	8021c34 <__ieee754_expf+0x28>
 8021c26:	eddf 7a51 	vldr	s15, [pc, #324]	; 8021d6c <__ieee754_expf+0x160>
 8021c2a:	2b00      	cmp	r3, #0
 8021c2c:	bf18      	it	ne
 8021c2e:	eeb0 0a67 	vmovne.f32	s0, s15
 8021c32:	4770      	bx	lr
 8021c34:	484e      	ldr	r0, [pc, #312]	; (8021d70 <__ieee754_expf+0x164>)
 8021c36:	4282      	cmp	r2, r0
 8021c38:	dd04      	ble.n	8021c44 <__ieee754_expf+0x38>
 8021c3a:	ed9f 0a4e 	vldr	s0, [pc, #312]	; 8021d74 <__ieee754_expf+0x168>
 8021c3e:	ee20 0a00 	vmul.f32	s0, s0, s0
 8021c42:	4770      	bx	lr
 8021c44:	2a00      	cmp	r2, #0
 8021c46:	da03      	bge.n	8021c50 <__ieee754_expf+0x44>
 8021c48:	4a4b      	ldr	r2, [pc, #300]	; (8021d78 <__ieee754_expf+0x16c>)
 8021c4a:	4291      	cmp	r1, r2
 8021c4c:	f200 808a 	bhi.w	8021d64 <__ieee754_expf+0x158>
 8021c50:	4a4a      	ldr	r2, [pc, #296]	; (8021d7c <__ieee754_expf+0x170>)
 8021c52:	4291      	cmp	r1, r2
 8021c54:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 8021c58:	d954      	bls.n	8021d04 <__ieee754_expf+0xf8>
 8021c5a:	4a49      	ldr	r2, [pc, #292]	; (8021d80 <__ieee754_expf+0x174>)
 8021c5c:	4291      	cmp	r1, r2
 8021c5e:	ea4f 0283 	mov.w	r2, r3, lsl #2
 8021c62:	d836      	bhi.n	8021cd2 <__ieee754_expf+0xc6>
 8021c64:	4947      	ldr	r1, [pc, #284]	; (8021d84 <__ieee754_expf+0x178>)
 8021c66:	4411      	add	r1, r2
 8021c68:	ed91 7a00 	vldr	s14, [r1]
 8021c6c:	4946      	ldr	r1, [pc, #280]	; (8021d88 <__ieee754_expf+0x17c>)
 8021c6e:	440a      	add	r2, r1
 8021c70:	edd2 7a00 	vldr	s15, [r2]
 8021c74:	ee30 7a47 	vsub.f32	s14, s0, s14
 8021c78:	f1c3 0201 	rsb	r2, r3, #1
 8021c7c:	1ad2      	subs	r2, r2, r3
 8021c7e:	ee37 0a67 	vsub.f32	s0, s14, s15
 8021c82:	ee60 6a00 	vmul.f32	s13, s0, s0
 8021c86:	eddf 5a41 	vldr	s11, [pc, #260]	; 8021d8c <__ieee754_expf+0x180>
 8021c8a:	ed9f 5a41 	vldr	s10, [pc, #260]	; 8021d90 <__ieee754_expf+0x184>
 8021c8e:	eea6 5aa5 	vfma.f32	s10, s13, s11
 8021c92:	eddf 5a40 	vldr	s11, [pc, #256]	; 8021d94 <__ieee754_expf+0x188>
 8021c96:	eee5 5a26 	vfma.f32	s11, s10, s13
 8021c9a:	ed9f 5a3f 	vldr	s10, [pc, #252]	; 8021d98 <__ieee754_expf+0x18c>
 8021c9e:	eea5 5aa6 	vfma.f32	s10, s11, s13
 8021ca2:	eddf 5a3e 	vldr	s11, [pc, #248]	; 8021d9c <__ieee754_expf+0x190>
 8021ca6:	eee5 5a26 	vfma.f32	s11, s10, s13
 8021caa:	eeb0 5a40 	vmov.f32	s10, s0
 8021cae:	eea5 5ae6 	vfms.f32	s10, s11, s13
 8021cb2:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
 8021cb6:	eef0 6a45 	vmov.f32	s13, s10
 8021cba:	ee20 5a05 	vmul.f32	s10, s0, s10
 8021cbe:	bb92      	cbnz	r2, 8021d26 <__ieee754_expf+0x11a>
 8021cc0:	ee76 6ae5 	vsub.f32	s13, s13, s11
 8021cc4:	eec5 7a26 	vdiv.f32	s15, s10, s13
 8021cc8:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8021ccc:	ee36 0a40 	vsub.f32	s0, s12, s0
 8021cd0:	4770      	bx	lr
 8021cd2:	4b33      	ldr	r3, [pc, #204]	; (8021da0 <__ieee754_expf+0x194>)
 8021cd4:	ed9f 7a33 	vldr	s14, [pc, #204]	; 8021da4 <__ieee754_expf+0x198>
 8021cd8:	4413      	add	r3, r2
 8021cda:	edd3 7a00 	vldr	s15, [r3]
 8021cde:	eee0 7a07 	vfma.f32	s15, s0, s14
 8021ce2:	ed9f 7a31 	vldr	s14, [pc, #196]	; 8021da8 <__ieee754_expf+0x19c>
 8021ce6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8021cea:	ee17 2a90 	vmov	r2, s15
 8021cee:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8021cf2:	eea7 0ac7 	vfms.f32	s0, s15, s14
 8021cf6:	eeb0 7a40 	vmov.f32	s14, s0
 8021cfa:	ed9f 0a2c 	vldr	s0, [pc, #176]	; 8021dac <__ieee754_expf+0x1a0>
 8021cfe:	ee67 7a80 	vmul.f32	s15, s15, s0
 8021d02:	e7bc      	b.n	8021c7e <__ieee754_expf+0x72>
 8021d04:	f1b1 5f46 	cmp.w	r1, #830472192	; 0x31800000
 8021d08:	d20b      	bcs.n	8021d22 <__ieee754_expf+0x116>
 8021d0a:	eddf 6a1a 	vldr	s13, [pc, #104]	; 8021d74 <__ieee754_expf+0x168>
 8021d0e:	ee70 6a26 	vadd.f32	s13, s0, s13
 8021d12:	eef4 6ac6 	vcmpe.f32	s13, s12
 8021d16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021d1a:	dd02      	ble.n	8021d22 <__ieee754_expf+0x116>
 8021d1c:	ee30 0a06 	vadd.f32	s0, s0, s12
 8021d20:	4770      	bx	lr
 8021d22:	2200      	movs	r2, #0
 8021d24:	e7ad      	b.n	8021c82 <__ieee754_expf+0x76>
 8021d26:	ee75 6ae6 	vsub.f32	s13, s11, s13
 8021d2a:	f112 0f7d 	cmn.w	r2, #125	; 0x7d
 8021d2e:	ee85 0a26 	vdiv.f32	s0, s10, s13
 8021d32:	bfb8      	it	lt
 8021d34:	3264      	addlt	r2, #100	; 0x64
 8021d36:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8021d3a:	ee37 0ac7 	vsub.f32	s0, s15, s14
 8021d3e:	ee76 7a40 	vsub.f32	s15, s12, s0
 8021d42:	ee17 3a90 	vmov	r3, s15
 8021d46:	bfab      	itete	ge
 8021d48:	eb03 53c2 	addge.w	r3, r3, r2, lsl #23
 8021d4c:	eb03 53c2 	addlt.w	r3, r3, r2, lsl #23
 8021d50:	ee00 3a10 	vmovge	s0, r3
 8021d54:	eddf 7a16 	vldrlt	s15, [pc, #88]	; 8021db0 <__ieee754_expf+0x1a4>
 8021d58:	bfbc      	itt	lt
 8021d5a:	ee00 3a10 	vmovlt	s0, r3
 8021d5e:	ee20 0a27 	vmullt.f32	s0, s0, s15
 8021d62:	4770      	bx	lr
 8021d64:	ed9f 0a01 	vldr	s0, [pc, #4]	; 8021d6c <__ieee754_expf+0x160>
 8021d68:	4770      	bx	lr
 8021d6a:	bf00      	nop
 8021d6c:	00000000 	.word	0x00000000
 8021d70:	42b17217 	.word	0x42b17217
 8021d74:	7149f2ca 	.word	0x7149f2ca
 8021d78:	42cff1b5 	.word	0x42cff1b5
 8021d7c:	3eb17218 	.word	0x3eb17218
 8021d80:	3f851591 	.word	0x3f851591
 8021d84:	08076150 	.word	0x08076150
 8021d88:	08076158 	.word	0x08076158
 8021d8c:	3331bb4c 	.word	0x3331bb4c
 8021d90:	b5ddea0e 	.word	0xb5ddea0e
 8021d94:	388ab355 	.word	0x388ab355
 8021d98:	bb360b61 	.word	0xbb360b61
 8021d9c:	3e2aaaab 	.word	0x3e2aaaab
 8021da0:	08076148 	.word	0x08076148
 8021da4:	3fb8aa3b 	.word	0x3fb8aa3b
 8021da8:	3f317180 	.word	0x3f317180
 8021dac:	3717f7d1 	.word	0x3717f7d1
 8021db0:	0d800000 	.word	0x0d800000

08021db4 <__ieee754_log10f>:
 8021db4:	b508      	push	{r3, lr}
 8021db6:	ee10 2a10 	vmov	r2, s0
 8021dba:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
 8021dbe:	ed2d 8b02 	vpush	{d8}
 8021dc2:	d108      	bne.n	8021dd6 <__ieee754_log10f+0x22>
 8021dc4:	ed9f 7a20 	vldr	s14, [pc, #128]	; 8021e48 <__ieee754_log10f+0x94>
 8021dc8:	eddf 7a20 	vldr	s15, [pc, #128]	; 8021e4c <__ieee754_log10f+0x98>
 8021dcc:	ee87 0a27 	vdiv.f32	s0, s14, s15
 8021dd0:	ecbd 8b02 	vpop	{d8}
 8021dd4:	bd08      	pop	{r3, pc}
 8021dd6:	2a00      	cmp	r2, #0
 8021dd8:	da02      	bge.n	8021de0 <__ieee754_log10f+0x2c>
 8021dda:	ee30 7a40 	vsub.f32	s14, s0, s0
 8021dde:	e7f3      	b.n	8021dc8 <__ieee754_log10f+0x14>
 8021de0:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8021de4:	db02      	blt.n	8021dec <__ieee754_log10f+0x38>
 8021de6:	ee30 0a00 	vadd.f32	s0, s0, s0
 8021dea:	e7f1      	b.n	8021dd0 <__ieee754_log10f+0x1c>
 8021dec:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 8021df0:	bfbf      	itttt	lt
 8021df2:	eddf 7a17 	vldrlt	s15, [pc, #92]	; 8021e50 <__ieee754_log10f+0x9c>
 8021df6:	ee60 7a27 	vmullt.f32	s15, s0, s15
 8021dfa:	f06f 0118 	mvnlt.w	r1, #24
 8021dfe:	ee17 2a90 	vmovlt	r2, s15
 8021e02:	ea4f 53e2 	mov.w	r3, r2, asr #23
 8021e06:	bfa8      	it	ge
 8021e08:	2100      	movge	r1, #0
 8021e0a:	3b7f      	subs	r3, #127	; 0x7f
 8021e0c:	440b      	add	r3, r1
 8021e0e:	0fd9      	lsrs	r1, r3, #31
 8021e10:	440b      	add	r3, r1
 8021e12:	f3c2 0216 	ubfx	r2, r2, #0, #23
 8021e16:	f1c1 017f 	rsb	r1, r1, #127	; 0x7f
 8021e1a:	ee07 3a90 	vmov	s15, r3
 8021e1e:	ea42 53c1 	orr.w	r3, r2, r1, lsl #23
 8021e22:	ee00 3a10 	vmov	s0, r3
 8021e26:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
 8021e2a:	f000 fce7 	bl	80227fc <__ieee754_logf>
 8021e2e:	eddf 7a09 	vldr	s15, [pc, #36]	; 8021e54 <__ieee754_log10f+0xa0>
 8021e32:	ee20 0a27 	vmul.f32	s0, s0, s15
 8021e36:	eddf 7a08 	vldr	s15, [pc, #32]	; 8021e58 <__ieee754_log10f+0xa4>
 8021e3a:	eea8 0a27 	vfma.f32	s0, s16, s15
 8021e3e:	eddf 7a07 	vldr	s15, [pc, #28]	; 8021e5c <__ieee754_log10f+0xa8>
 8021e42:	eea8 0a27 	vfma.f32	s0, s16, s15
 8021e46:	e7c3      	b.n	8021dd0 <__ieee754_log10f+0x1c>
 8021e48:	cc000000 	.word	0xcc000000
 8021e4c:	00000000 	.word	0x00000000
 8021e50:	4c000000 	.word	0x4c000000
 8021e54:	3ede5bd9 	.word	0x3ede5bd9
 8021e58:	355427db 	.word	0x355427db
 8021e5c:	3e9a2080 	.word	0x3e9a2080

08021e60 <__ieee754_powf>:
 8021e60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8021e64:	ee10 5a90 	vmov	r5, s1
 8021e68:	f035 4700 	bics.w	r7, r5, #2147483648	; 0x80000000
 8021e6c:	ed2d 8b02 	vpush	{d8}
 8021e70:	eeb0 8a40 	vmov.f32	s16, s0
 8021e74:	eef0 8a60 	vmov.f32	s17, s1
 8021e78:	f000 8293 	beq.w	80223a2 <__ieee754_powf+0x542>
 8021e7c:	ee10 8a10 	vmov	r8, s0
 8021e80:	f028 4400 	bic.w	r4, r8, #2147483648	; 0x80000000
 8021e84:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8021e88:	dc06      	bgt.n	8021e98 <__ieee754_powf+0x38>
 8021e8a:	f1b7 4fff 	cmp.w	r7, #2139095040	; 0x7f800000
 8021e8e:	dd0a      	ble.n	8021ea6 <__ieee754_powf+0x46>
 8021e90:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
 8021e94:	f000 8285 	beq.w	80223a2 <__ieee754_powf+0x542>
 8021e98:	ecbd 8b02 	vpop	{d8}
 8021e9c:	48d9      	ldr	r0, [pc, #868]	; (8022204 <__ieee754_powf+0x3a4>)
 8021e9e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8021ea2:	f000 bbeb 	b.w	802267c <nanf>
 8021ea6:	f1b8 0f00 	cmp.w	r8, #0
 8021eaa:	da1d      	bge.n	8021ee8 <__ieee754_powf+0x88>
 8021eac:	f1b7 4f97 	cmp.w	r7, #1266679808	; 0x4b800000
 8021eb0:	da2c      	bge.n	8021f0c <__ieee754_powf+0xac>
 8021eb2:	f1b7 5f7e 	cmp.w	r7, #1065353216	; 0x3f800000
 8021eb6:	db30      	blt.n	8021f1a <__ieee754_powf+0xba>
 8021eb8:	15fb      	asrs	r3, r7, #23
 8021eba:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
 8021ebe:	fa47 f603 	asr.w	r6, r7, r3
 8021ec2:	fa06 f303 	lsl.w	r3, r6, r3
 8021ec6:	42bb      	cmp	r3, r7
 8021ec8:	d127      	bne.n	8021f1a <__ieee754_powf+0xba>
 8021eca:	f006 0601 	and.w	r6, r6, #1
 8021ece:	f1c6 0602 	rsb	r6, r6, #2
 8021ed2:	f1b7 5f7e 	cmp.w	r7, #1065353216	; 0x3f800000
 8021ed6:	d122      	bne.n	8021f1e <__ieee754_powf+0xbe>
 8021ed8:	2d00      	cmp	r5, #0
 8021eda:	f280 8268 	bge.w	80223ae <__ieee754_powf+0x54e>
 8021ede:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8021ee2:	ee87 0a88 	vdiv.f32	s0, s15, s16
 8021ee6:	e00d      	b.n	8021f04 <__ieee754_powf+0xa4>
 8021ee8:	2600      	movs	r6, #0
 8021eea:	f1b7 4fff 	cmp.w	r7, #2139095040	; 0x7f800000
 8021eee:	d1f0      	bne.n	8021ed2 <__ieee754_powf+0x72>
 8021ef0:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
 8021ef4:	f000 8255 	beq.w	80223a2 <__ieee754_powf+0x542>
 8021ef8:	dd0a      	ble.n	8021f10 <__ieee754_powf+0xb0>
 8021efa:	2d00      	cmp	r5, #0
 8021efc:	f280 8254 	bge.w	80223a8 <__ieee754_powf+0x548>
 8021f00:	ed9f 0ac1 	vldr	s0, [pc, #772]	; 8022208 <__ieee754_powf+0x3a8>
 8021f04:	ecbd 8b02 	vpop	{d8}
 8021f08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8021f0c:	2602      	movs	r6, #2
 8021f0e:	e7ec      	b.n	8021eea <__ieee754_powf+0x8a>
 8021f10:	2d00      	cmp	r5, #0
 8021f12:	daf5      	bge.n	8021f00 <__ieee754_powf+0xa0>
 8021f14:	eeb1 0a68 	vneg.f32	s0, s17
 8021f18:	e7f4      	b.n	8021f04 <__ieee754_powf+0xa4>
 8021f1a:	2600      	movs	r6, #0
 8021f1c:	e7d9      	b.n	8021ed2 <__ieee754_powf+0x72>
 8021f1e:	f1b5 4f80 	cmp.w	r5, #1073741824	; 0x40000000
 8021f22:	d102      	bne.n	8021f2a <__ieee754_powf+0xca>
 8021f24:	ee28 0a08 	vmul.f32	s0, s16, s16
 8021f28:	e7ec      	b.n	8021f04 <__ieee754_powf+0xa4>
 8021f2a:	f1b5 5f7c 	cmp.w	r5, #1056964608	; 0x3f000000
 8021f2e:	eeb0 0a48 	vmov.f32	s0, s16
 8021f32:	d108      	bne.n	8021f46 <__ieee754_powf+0xe6>
 8021f34:	f1b8 0f00 	cmp.w	r8, #0
 8021f38:	db05      	blt.n	8021f46 <__ieee754_powf+0xe6>
 8021f3a:	ecbd 8b02 	vpop	{d8}
 8021f3e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8021f42:	f000 ba4d 	b.w	80223e0 <__ieee754_sqrtf>
 8021f46:	f000 fb87 	bl	8022658 <fabsf>
 8021f4a:	b124      	cbz	r4, 8021f56 <__ieee754_powf+0xf6>
 8021f4c:	f028 4340 	bic.w	r3, r8, #3221225472	; 0xc0000000
 8021f50:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 8021f54:	d117      	bne.n	8021f86 <__ieee754_powf+0x126>
 8021f56:	2d00      	cmp	r5, #0
 8021f58:	bfbc      	itt	lt
 8021f5a:	eef7 7a00 	vmovlt.f32	s15, #112	; 0x3f800000  1.0
 8021f5e:	ee87 0a80 	vdivlt.f32	s0, s15, s0
 8021f62:	f1b8 0f00 	cmp.w	r8, #0
 8021f66:	dacd      	bge.n	8021f04 <__ieee754_powf+0xa4>
 8021f68:	f1a4 547e 	sub.w	r4, r4, #1065353216	; 0x3f800000
 8021f6c:	ea54 0306 	orrs.w	r3, r4, r6
 8021f70:	d104      	bne.n	8021f7c <__ieee754_powf+0x11c>
 8021f72:	ee70 7a40 	vsub.f32	s15, s0, s0
 8021f76:	ee87 0aa7 	vdiv.f32	s0, s15, s15
 8021f7a:	e7c3      	b.n	8021f04 <__ieee754_powf+0xa4>
 8021f7c:	2e01      	cmp	r6, #1
 8021f7e:	d1c1      	bne.n	8021f04 <__ieee754_powf+0xa4>
 8021f80:	eeb1 0a40 	vneg.f32	s0, s0
 8021f84:	e7be      	b.n	8021f04 <__ieee754_powf+0xa4>
 8021f86:	ea4f 70d8 	mov.w	r0, r8, lsr #31
 8021f8a:	3801      	subs	r0, #1
 8021f8c:	ea56 0300 	orrs.w	r3, r6, r0
 8021f90:	d104      	bne.n	8021f9c <__ieee754_powf+0x13c>
 8021f92:	ee38 8a48 	vsub.f32	s16, s16, s16
 8021f96:	ee88 0a08 	vdiv.f32	s0, s16, s16
 8021f9a:	e7b3      	b.n	8021f04 <__ieee754_powf+0xa4>
 8021f9c:	f1b7 4f9a 	cmp.w	r7, #1291845632	; 0x4d000000
 8021fa0:	dd6d      	ble.n	802207e <__ieee754_powf+0x21e>
 8021fa2:	4b9a      	ldr	r3, [pc, #616]	; (802220c <__ieee754_powf+0x3ac>)
 8021fa4:	429c      	cmp	r4, r3
 8021fa6:	dc06      	bgt.n	8021fb6 <__ieee754_powf+0x156>
 8021fa8:	2d00      	cmp	r5, #0
 8021faa:	daa9      	bge.n	8021f00 <__ieee754_powf+0xa0>
 8021fac:	ed9f 0a98 	vldr	s0, [pc, #608]	; 8022210 <__ieee754_powf+0x3b0>
 8021fb0:	ee20 0a00 	vmul.f32	s0, s0, s0
 8021fb4:	e7a6      	b.n	8021f04 <__ieee754_powf+0xa4>
 8021fb6:	4b97      	ldr	r3, [pc, #604]	; (8022214 <__ieee754_powf+0x3b4>)
 8021fb8:	429c      	cmp	r4, r3
 8021fba:	dd02      	ble.n	8021fc2 <__ieee754_powf+0x162>
 8021fbc:	2d00      	cmp	r5, #0
 8021fbe:	dcf5      	bgt.n	8021fac <__ieee754_powf+0x14c>
 8021fc0:	e79e      	b.n	8021f00 <__ieee754_powf+0xa0>
 8021fc2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8021fc6:	ee30 0a67 	vsub.f32	s0, s0, s15
 8021fca:	ed9f 7a93 	vldr	s14, [pc, #588]	; 8022218 <__ieee754_powf+0x3b8>
 8021fce:	eef1 6a40 	vneg.f32	s13, s0
 8021fd2:	eef5 7a00 	vmov.f32	s15, #80	; 0x3e800000  0.250
 8021fd6:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8021fda:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8021fde:	eee7 7a40 	vfms.f32	s15, s14, s0
 8021fe2:	ee60 0a00 	vmul.f32	s1, s0, s0
 8021fe6:	ed9f 7a8d 	vldr	s14, [pc, #564]	; 802221c <__ieee754_powf+0x3bc>
 8021fea:	ee67 0aa0 	vmul.f32	s1, s15, s1
 8021fee:	eddf 7a8c 	vldr	s15, [pc, #560]	; 8022220 <__ieee754_powf+0x3c0>
 8021ff2:	ee67 7ae0 	vnmul.f32	s15, s15, s1
 8021ff6:	eee0 7a07 	vfma.f32	s15, s0, s14
 8021ffa:	ed9f 7a8a 	vldr	s14, [pc, #552]	; 8022224 <__ieee754_powf+0x3c4>
 8021ffe:	eeb0 6a67 	vmov.f32	s12, s15
 8022002:	eea0 6a07 	vfma.f32	s12, s0, s14
 8022006:	ee16 3a10 	vmov	r3, s12
 802200a:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 802200e:	f023 030f 	bic.w	r3, r3, #15
 8022012:	ee00 3a90 	vmov	s1, r3
 8022016:	eee6 0a87 	vfma.f32	s1, s13, s14
 802201a:	ee77 7ae0 	vsub.f32	s15, s15, s1
 802201e:	f425 657f 	bic.w	r5, r5, #4080	; 0xff0
 8022022:	f025 050f 	bic.w	r5, r5, #15
 8022026:	ee07 5a10 	vmov	s14, r5
 802202a:	ee67 0aa8 	vmul.f32	s1, s15, s17
 802202e:	ee38 7ac7 	vsub.f32	s14, s17, s14
 8022032:	ee07 3a90 	vmov	s15, r3
 8022036:	eee7 0a27 	vfma.f32	s1, s14, s15
 802203a:	3e01      	subs	r6, #1
 802203c:	ea56 0200 	orrs.w	r2, r6, r0
 8022040:	ee07 5a10 	vmov	s14, r5
 8022044:	ee67 7a87 	vmul.f32	s15, s15, s14
 8022048:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 802204c:	ee30 7aa7 	vadd.f32	s14, s1, s15
 8022050:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 8022054:	ee17 4a10 	vmov	r4, s14
 8022058:	bf08      	it	eq
 802205a:	eeb0 8a40 	vmoveq.f32	s16, s0
 802205e:	2c00      	cmp	r4, #0
 8022060:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 8022064:	f340 8184 	ble.w	8022370 <__ieee754_powf+0x510>
 8022068:	f1b3 4f86 	cmp.w	r3, #1124073472	; 0x43000000
 802206c:	f340 80fc 	ble.w	8022268 <__ieee754_powf+0x408>
 8022070:	eddf 7a67 	vldr	s15, [pc, #412]	; 8022210 <__ieee754_powf+0x3b0>
 8022074:	ee28 0a27 	vmul.f32	s0, s16, s15
 8022078:	ee20 0a27 	vmul.f32	s0, s0, s15
 802207c:	e742      	b.n	8021f04 <__ieee754_powf+0xa4>
 802207e:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
 8022082:	bfbf      	itttt	lt
 8022084:	eddf 7a68 	vldrlt	s15, [pc, #416]	; 8022228 <__ieee754_powf+0x3c8>
 8022088:	ee60 7a27 	vmullt.f32	s15, s0, s15
 802208c:	f06f 0217 	mvnlt.w	r2, #23
 8022090:	ee17 4a90 	vmovlt	r4, s15
 8022094:	ea4f 53e4 	mov.w	r3, r4, asr #23
 8022098:	bfa8      	it	ge
 802209a:	2200      	movge	r2, #0
 802209c:	3b7f      	subs	r3, #127	; 0x7f
 802209e:	4413      	add	r3, r2
 80220a0:	4a62      	ldr	r2, [pc, #392]	; (802222c <__ieee754_powf+0x3cc>)
 80220a2:	f3c4 0416 	ubfx	r4, r4, #0, #23
 80220a6:	4294      	cmp	r4, r2
 80220a8:	f044 517e 	orr.w	r1, r4, #1065353216	; 0x3f800000
 80220ac:	dd06      	ble.n	80220bc <__ieee754_powf+0x25c>
 80220ae:	4a60      	ldr	r2, [pc, #384]	; (8022230 <__ieee754_powf+0x3d0>)
 80220b0:	4294      	cmp	r4, r2
 80220b2:	f340 80a5 	ble.w	8022200 <__ieee754_powf+0x3a0>
 80220b6:	3301      	adds	r3, #1
 80220b8:	f5a1 0100 	sub.w	r1, r1, #8388608	; 0x800000
 80220bc:	2400      	movs	r4, #0
 80220be:	4a5d      	ldr	r2, [pc, #372]	; (8022234 <__ieee754_powf+0x3d4>)
 80220c0:	00a7      	lsls	r7, r4, #2
 80220c2:	443a      	add	r2, r7
 80220c4:	ee07 1a90 	vmov	s15, r1
 80220c8:	ed92 7a00 	vldr	s14, [r2]
 80220cc:	4a5a      	ldr	r2, [pc, #360]	; (8022238 <__ieee754_powf+0x3d8>)
 80220ce:	ee37 6a27 	vadd.f32	s12, s14, s15
 80220d2:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 80220d6:	eec5 6a06 	vdiv.f32	s13, s10, s12
 80220da:	1049      	asrs	r1, r1, #1
 80220dc:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 80220e0:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
 80220e4:	eb01 5144 	add.w	r1, r1, r4, lsl #21
 80220e8:	ee77 5ac7 	vsub.f32	s11, s15, s14
 80220ec:	ee06 1a10 	vmov	s12, r1
 80220f0:	ee65 4aa6 	vmul.f32	s9, s11, s13
 80220f4:	ee14 ca90 	vmov	ip, s9
 80220f8:	ea02 0c0c 	and.w	ip, r2, ip
 80220fc:	ee05 ca10 	vmov	s10, ip
 8022100:	eeb1 4a45 	vneg.f32	s8, s10
 8022104:	eee4 5a06 	vfma.f32	s11, s8, s12
 8022108:	ee36 6a47 	vsub.f32	s12, s12, s14
 802210c:	ed9f 7a4b 	vldr	s14, [pc, #300]	; 802223c <__ieee754_powf+0x3dc>
 8022110:	ee37 6ac6 	vsub.f32	s12, s15, s12
 8022114:	ee64 7aa4 	vmul.f32	s15, s9, s9
 8022118:	eee4 5a06 	vfma.f32	s11, s8, s12
 802211c:	ee67 3aa7 	vmul.f32	s7, s15, s15
 8022120:	ee25 6aa6 	vmul.f32	s12, s11, s13
 8022124:	eddf 5a46 	vldr	s11, [pc, #280]	; 8022240 <__ieee754_powf+0x3e0>
 8022128:	eea7 7aa5 	vfma.f32	s14, s15, s11
 802212c:	eddf 5a45 	vldr	s11, [pc, #276]	; 8022244 <__ieee754_powf+0x3e4>
 8022130:	eee7 5a27 	vfma.f32	s11, s14, s15
 8022134:	ed9f 7a38 	vldr	s14, [pc, #224]	; 8022218 <__ieee754_powf+0x3b8>
 8022138:	eea5 7aa7 	vfma.f32	s14, s11, s15
 802213c:	eddf 5a42 	vldr	s11, [pc, #264]	; 8022248 <__ieee754_powf+0x3e8>
 8022140:	eee7 5a27 	vfma.f32	s11, s14, s15
 8022144:	ed9f 7a41 	vldr	s14, [pc, #260]	; 802224c <__ieee754_powf+0x3ec>
 8022148:	ee75 6a24 	vadd.f32	s13, s10, s9
 802214c:	eea5 7aa7 	vfma.f32	s14, s11, s15
 8022150:	ee66 6a86 	vmul.f32	s13, s13, s12
 8022154:	eef0 5a08 	vmov.f32	s11, #8	; 0x40400000  3.0
 8022158:	eef0 7a65 	vmov.f32	s15, s11
 802215c:	eee3 6a87 	vfma.f32	s13, s7, s14
 8022160:	eee5 7a05 	vfma.f32	s15, s10, s10
 8022164:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8022168:	ee17 1a90 	vmov	r1, s15
 802216c:	4011      	ands	r1, r2
 802216e:	ee07 1a90 	vmov	s15, r1
 8022172:	ee37 7ae5 	vsub.f32	s14, s15, s11
 8022176:	eddf 5a36 	vldr	s11, [pc, #216]	; 8022250 <__ieee754_powf+0x3f0>
 802217a:	eea4 7a05 	vfma.f32	s14, s8, s10
 802217e:	ee36 7ac7 	vsub.f32	s14, s13, s14
 8022182:	ee27 7a24 	vmul.f32	s14, s14, s9
 8022186:	eea7 7a86 	vfma.f32	s14, s15, s12
 802218a:	eeb0 6a47 	vmov.f32	s12, s14
 802218e:	eea5 6a27 	vfma.f32	s12, s10, s15
 8022192:	ee16 1a10 	vmov	r1, s12
 8022196:	4011      	ands	r1, r2
 8022198:	ee06 1a90 	vmov	s13, r1
 802219c:	eee4 6a27 	vfma.f32	s13, s8, s15
 80221a0:	eddf 7a2c 	vldr	s15, [pc, #176]	; 8022254 <__ieee754_powf+0x3f4>
 80221a4:	ee37 7a66 	vsub.f32	s14, s14, s13
 80221a8:	ee06 1a10 	vmov	s12, r1
 80221ac:	ee27 7a27 	vmul.f32	s14, s14, s15
 80221b0:	eddf 7a29 	vldr	s15, [pc, #164]	; 8022258 <__ieee754_powf+0x3f8>
 80221b4:	4929      	ldr	r1, [pc, #164]	; (802225c <__ieee754_powf+0x3fc>)
 80221b6:	eea6 7a27 	vfma.f32	s14, s12, s15
 80221ba:	4439      	add	r1, r7
 80221bc:	edd1 7a00 	vldr	s15, [r1]
 80221c0:	ee37 7a27 	vadd.f32	s14, s14, s15
 80221c4:	ee07 3a90 	vmov	s15, r3
 80221c8:	eef0 0a47 	vmov.f32	s1, s14
 80221cc:	4b24      	ldr	r3, [pc, #144]	; (8022260 <__ieee754_powf+0x400>)
 80221ce:	eee6 0a25 	vfma.f32	s1, s12, s11
 80221d2:	443b      	add	r3, r7
 80221d4:	ed93 5a00 	vldr	s10, [r3]
 80221d8:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 80221dc:	ee70 0a85 	vadd.f32	s1, s1, s10
 80221e0:	ee70 7aa6 	vadd.f32	s15, s1, s13
 80221e4:	ee17 3a90 	vmov	r3, s15
 80221e8:	4013      	ands	r3, r2
 80221ea:	ee07 3a90 	vmov	s15, r3
 80221ee:	ee77 7ae6 	vsub.f32	s15, s15, s13
 80221f2:	ee77 7ac5 	vsub.f32	s15, s15, s10
 80221f6:	eee6 7a65 	vfms.f32	s15, s12, s11
 80221fa:	ee77 7a67 	vsub.f32	s15, s14, s15
 80221fe:	e70e      	b.n	802201e <__ieee754_powf+0x1be>
 8022200:	2401      	movs	r4, #1
 8022202:	e75c      	b.n	80220be <__ieee754_powf+0x25e>
 8022204:	08076029 	.word	0x08076029
 8022208:	00000000 	.word	0x00000000
 802220c:	3f7ffff7 	.word	0x3f7ffff7
 8022210:	7149f2ca 	.word	0x7149f2ca
 8022214:	3f800007 	.word	0x3f800007
 8022218:	3eaaaaab 	.word	0x3eaaaaab
 802221c:	36eca570 	.word	0x36eca570
 8022220:	3fb8aa3b 	.word	0x3fb8aa3b
 8022224:	3fb8aa00 	.word	0x3fb8aa00
 8022228:	4b800000 	.word	0x4b800000
 802222c:	001cc471 	.word	0x001cc471
 8022230:	005db3d6 	.word	0x005db3d6
 8022234:	08076160 	.word	0x08076160
 8022238:	fffff000 	.word	0xfffff000
 802223c:	3e6c3255 	.word	0x3e6c3255
 8022240:	3e53f142 	.word	0x3e53f142
 8022244:	3e8ba305 	.word	0x3e8ba305
 8022248:	3edb6db7 	.word	0x3edb6db7
 802224c:	3f19999a 	.word	0x3f19999a
 8022250:	3f763800 	.word	0x3f763800
 8022254:	3f76384f 	.word	0x3f76384f
 8022258:	369dc3a0 	.word	0x369dc3a0
 802225c:	08076170 	.word	0x08076170
 8022260:	08076168 	.word	0x08076168
 8022264:	3338aa3c 	.word	0x3338aa3c
 8022268:	f040 8092 	bne.w	8022390 <__ieee754_powf+0x530>
 802226c:	ed5f 6a03 	vldr	s13, [pc, #-12]	; 8022264 <__ieee754_powf+0x404>
 8022270:	ee37 7a67 	vsub.f32	s14, s14, s15
 8022274:	ee70 6aa6 	vadd.f32	s13, s1, s13
 8022278:	eef4 6ac7 	vcmpe.f32	s13, s14
 802227c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022280:	f73f aef6 	bgt.w	8022070 <__ieee754_powf+0x210>
 8022284:	15db      	asrs	r3, r3, #23
 8022286:	f1a3 007e 	sub.w	r0, r3, #126	; 0x7e
 802228a:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 802228e:	4103      	asrs	r3, r0
 8022290:	4423      	add	r3, r4
 8022292:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 8022296:	4947      	ldr	r1, [pc, #284]	; (80223b4 <__ieee754_powf+0x554>)
 8022298:	3a7f      	subs	r2, #127	; 0x7f
 802229a:	4111      	asrs	r1, r2
 802229c:	ea23 0101 	bic.w	r1, r3, r1
 80222a0:	f3c3 0016 	ubfx	r0, r3, #0, #23
 80222a4:	ee07 1a10 	vmov	s14, r1
 80222a8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80222ac:	f1c2 0217 	rsb	r2, r2, #23
 80222b0:	4110      	asrs	r0, r2
 80222b2:	2c00      	cmp	r4, #0
 80222b4:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80222b8:	bfb8      	it	lt
 80222ba:	4240      	neglt	r0, r0
 80222bc:	ee37 7aa0 	vadd.f32	s14, s15, s1
 80222c0:	eddf 6a3d 	vldr	s13, [pc, #244]	; 80223b8 <__ieee754_powf+0x558>
 80222c4:	ee17 3a10 	vmov	r3, s14
 80222c8:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 80222cc:	f023 030f 	bic.w	r3, r3, #15
 80222d0:	ee07 3a10 	vmov	s14, r3
 80222d4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80222d8:	ee70 0ae7 	vsub.f32	s1, s1, s15
 80222dc:	eddf 7a37 	vldr	s15, [pc, #220]	; 80223bc <__ieee754_powf+0x55c>
 80222e0:	ee67 7a27 	vmul.f32	s15, s14, s15
 80222e4:	eee0 7aa6 	vfma.f32	s15, s1, s13
 80222e8:	eddf 6a35 	vldr	s13, [pc, #212]	; 80223c0 <__ieee754_powf+0x560>
 80222ec:	eeb0 0a67 	vmov.f32	s0, s15
 80222f0:	eea7 0a26 	vfma.f32	s0, s14, s13
 80222f4:	eeb0 6a40 	vmov.f32	s12, s0
 80222f8:	eea7 6a66 	vfms.f32	s12, s14, s13
 80222fc:	ee20 7a00 	vmul.f32	s14, s0, s0
 8022300:	ee77 7ac6 	vsub.f32	s15, s15, s12
 8022304:	eddf 6a2f 	vldr	s13, [pc, #188]	; 80223c4 <__ieee754_powf+0x564>
 8022308:	ed9f 6a2f 	vldr	s12, [pc, #188]	; 80223c8 <__ieee754_powf+0x568>
 802230c:	eea7 6a26 	vfma.f32	s12, s14, s13
 8022310:	eddf 6a2e 	vldr	s13, [pc, #184]	; 80223cc <__ieee754_powf+0x56c>
 8022314:	eee6 6a07 	vfma.f32	s13, s12, s14
 8022318:	ed9f 6a2d 	vldr	s12, [pc, #180]	; 80223d0 <__ieee754_powf+0x570>
 802231c:	eea6 6a87 	vfma.f32	s12, s13, s14
 8022320:	eddf 6a2c 	vldr	s13, [pc, #176]	; 80223d4 <__ieee754_powf+0x574>
 8022324:	eee6 6a07 	vfma.f32	s13, s12, s14
 8022328:	eeb0 6a40 	vmov.f32	s12, s0
 802232c:	eea6 6ac7 	vfms.f32	s12, s13, s14
 8022330:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 8022334:	eeb0 7a46 	vmov.f32	s14, s12
 8022338:	ee77 6a66 	vsub.f32	s13, s14, s13
 802233c:	ee20 6a06 	vmul.f32	s12, s0, s12
 8022340:	eee0 7a27 	vfma.f32	s15, s0, s15
 8022344:	ee86 7a26 	vdiv.f32	s14, s12, s13
 8022348:	ee77 7a67 	vsub.f32	s15, s14, s15
 802234c:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8022350:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8022354:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8022358:	ee10 3a10 	vmov	r3, s0
 802235c:	eb03 53c0 	add.w	r3, r3, r0, lsl #23
 8022360:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8022364:	da1a      	bge.n	802239c <__ieee754_powf+0x53c>
 8022366:	f000 f9e9 	bl	802273c <scalbnf>
 802236a:	ee20 0a08 	vmul.f32	s0, s0, s16
 802236e:	e5c9      	b.n	8021f04 <__ieee754_powf+0xa4>
 8022370:	4a19      	ldr	r2, [pc, #100]	; (80223d8 <__ieee754_powf+0x578>)
 8022372:	4293      	cmp	r3, r2
 8022374:	dd02      	ble.n	802237c <__ieee754_powf+0x51c>
 8022376:	eddf 7a19 	vldr	s15, [pc, #100]	; 80223dc <__ieee754_powf+0x57c>
 802237a:	e67b      	b.n	8022074 <__ieee754_powf+0x214>
 802237c:	d108      	bne.n	8022390 <__ieee754_powf+0x530>
 802237e:	ee37 7a67 	vsub.f32	s14, s14, s15
 8022382:	eeb4 7ae0 	vcmpe.f32	s14, s1
 8022386:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802238a:	f6ff af7b 	blt.w	8022284 <__ieee754_powf+0x424>
 802238e:	e7f2      	b.n	8022376 <__ieee754_powf+0x516>
 8022390:	f1b3 5f7c 	cmp.w	r3, #1056964608	; 0x3f000000
 8022394:	f73f af76 	bgt.w	8022284 <__ieee754_powf+0x424>
 8022398:	2000      	movs	r0, #0
 802239a:	e78f      	b.n	80222bc <__ieee754_powf+0x45c>
 802239c:	ee00 3a10 	vmov	s0, r3
 80223a0:	e7e3      	b.n	802236a <__ieee754_powf+0x50a>
 80223a2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80223a6:	e5ad      	b.n	8021f04 <__ieee754_powf+0xa4>
 80223a8:	eeb0 0a68 	vmov.f32	s0, s17
 80223ac:	e5aa      	b.n	8021f04 <__ieee754_powf+0xa4>
 80223ae:	eeb0 0a48 	vmov.f32	s0, s16
 80223b2:	e5a7      	b.n	8021f04 <__ieee754_powf+0xa4>
 80223b4:	007fffff 	.word	0x007fffff
 80223b8:	3f317218 	.word	0x3f317218
 80223bc:	35bfbe8c 	.word	0x35bfbe8c
 80223c0:	3f317200 	.word	0x3f317200
 80223c4:	3331bb4c 	.word	0x3331bb4c
 80223c8:	b5ddea0e 	.word	0xb5ddea0e
 80223cc:	388ab355 	.word	0x388ab355
 80223d0:	bb360b61 	.word	0xbb360b61
 80223d4:	3e2aaaab 	.word	0x3e2aaaab
 80223d8:	43160000 	.word	0x43160000
 80223dc:	0da24260 	.word	0x0da24260

080223e0 <__ieee754_sqrtf>:
 80223e0:	eeb1 0ac0 	vsqrt.f32	s0, s0
 80223e4:	4770      	bx	lr

080223e6 <matherr>:
 80223e6:	2000      	movs	r0, #0
 80223e8:	4770      	bx	lr
 80223ea:	0000      	movs	r0, r0
 80223ec:	0000      	movs	r0, r0
	...

080223f0 <nan>:
 80223f0:	ed9f 0b01 	vldr	d0, [pc, #4]	; 80223f8 <nan+0x8>
 80223f4:	4770      	bx	lr
 80223f6:	bf00      	nop
 80223f8:	00000000 	.word	0x00000000
 80223fc:	7ff80000 	.word	0x7ff80000

08022400 <expm1f>:
 8022400:	ee10 2a10 	vmov	r2, s0
 8022404:	4985      	ldr	r1, [pc, #532]	; (802261c <expm1f+0x21c>)
 8022406:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 802240a:	428b      	cmp	r3, r1
 802240c:	d924      	bls.n	8022458 <expm1f+0x58>
 802240e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8022412:	d902      	bls.n	802241a <expm1f+0x1a>
 8022414:	ee30 0a00 	vadd.f32	s0, s0, s0
 8022418:	4770      	bx	lr
 802241a:	d106      	bne.n	802242a <expm1f+0x2a>
 802241c:	2a00      	cmp	r2, #0
 802241e:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 8022422:	bfb8      	it	lt
 8022424:	eeb0 0a67 	vmovlt.f32	s0, s15
 8022428:	4770      	bx	lr
 802242a:	2a00      	cmp	r2, #0
 802242c:	db08      	blt.n	8022440 <expm1f+0x40>
 802242e:	4a7c      	ldr	r2, [pc, #496]	; (8022620 <expm1f+0x220>)
 8022430:	4293      	cmp	r3, r2
 8022432:	f240 80eb 	bls.w	802260c <expm1f+0x20c>
 8022436:	ed9f 0a7b 	vldr	s0, [pc, #492]	; 8022624 <expm1f+0x224>
 802243a:	ee20 0a00 	vmul.f32	s0, s0, s0
 802243e:	4770      	bx	lr
 8022440:	eddf 7a79 	vldr	s15, [pc, #484]	; 8022628 <expm1f+0x228>
 8022444:	ee70 7a27 	vadd.f32	s15, s0, s15
 8022448:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802244c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022450:	d554      	bpl.n	80224fc <expm1f+0xfc>
 8022452:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 8022456:	4770      	bx	lr
 8022458:	4974      	ldr	r1, [pc, #464]	; (802262c <expm1f+0x22c>)
 802245a:	428b      	cmp	r3, r1
 802245c:	d96d      	bls.n	802253a <expm1f+0x13a>
 802245e:	4974      	ldr	r1, [pc, #464]	; (8022630 <expm1f+0x230>)
 8022460:	428b      	cmp	r3, r1
 8022462:	d84b      	bhi.n	80224fc <expm1f+0xfc>
 8022464:	ed9f 7a73 	vldr	s14, [pc, #460]	; 8022634 <expm1f+0x234>
 8022468:	2a00      	cmp	r2, #0
 802246a:	bfa7      	ittee	ge
 802246c:	ee30 7a47 	vsubge.f32	s14, s0, s14
 8022470:	eddf 7a71 	vldrge	s15, [pc, #452]	; 8022638 <expm1f+0x238>
 8022474:	eddf 7a71 	vldrlt	s15, [pc, #452]	; 802263c <expm1f+0x23c>
 8022478:	ee30 7a07 	vaddlt.f32	s14, s0, s14
 802247c:	bfac      	ite	ge
 802247e:	2301      	movge	r3, #1
 8022480:	f04f 33ff 	movlt.w	r3, #4294967295
 8022484:	ee37 0a67 	vsub.f32	s0, s14, s15
 8022488:	ee37 7a40 	vsub.f32	s14, s14, s0
 802248c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8022490:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
 8022494:	ee20 5a25 	vmul.f32	s10, s0, s11
 8022498:	eddf 6a69 	vldr	s13, [pc, #420]	; 8022640 <expm1f+0x240>
 802249c:	ed9f 6a69 	vldr	s12, [pc, #420]	; 8022644 <expm1f+0x244>
 80224a0:	ee20 7a05 	vmul.f32	s14, s0, s10
 80224a4:	eea7 6a26 	vfma.f32	s12, s14, s13
 80224a8:	eddf 6a67 	vldr	s13, [pc, #412]	; 8022648 <expm1f+0x248>
 80224ac:	eee6 6a07 	vfma.f32	s13, s12, s14
 80224b0:	ed9f 6a66 	vldr	s12, [pc, #408]	; 802264c <expm1f+0x24c>
 80224b4:	eea6 6a87 	vfma.f32	s12, s13, s14
 80224b8:	eddf 6a65 	vldr	s13, [pc, #404]	; 8022650 <expm1f+0x250>
 80224bc:	eee6 6a07 	vfma.f32	s13, s12, s14
 80224c0:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 80224c4:	eef0 4a46 	vmov.f32	s9, s12
 80224c8:	eee6 4a87 	vfma.f32	s9, s13, s14
 80224cc:	eef0 6a64 	vmov.f32	s13, s9
 80224d0:	eef0 4a08 	vmov.f32	s9, #8	; 0x40400000  3.0
 80224d4:	eee5 4a66 	vfms.f32	s9, s10, s13
 80224d8:	ee36 5ae4 	vsub.f32	s10, s13, s9
 80224dc:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
 80224e0:	eee0 6a64 	vfms.f32	s13, s0, s9
 80224e4:	eef0 4a66 	vmov.f32	s9, s13
 80224e8:	eec5 6a24 	vdiv.f32	s13, s10, s9
 80224ec:	ee66 6a87 	vmul.f32	s13, s13, s14
 80224f0:	bb8b      	cbnz	r3, 8022556 <expm1f+0x156>
 80224f2:	eef0 7a47 	vmov.f32	s15, s14
 80224f6:	eed0 7a26 	vfnms.f32	s15, s0, s13
 80224fa:	e027      	b.n	802254c <expm1f+0x14c>
 80224fc:	eddf 7a55 	vldr	s15, [pc, #340]	; 8022654 <expm1f+0x254>
 8022500:	2a00      	cmp	r2, #0
 8022502:	ee20 7a27 	vmul.f32	s14, s0, s15
 8022506:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 802250a:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 802250e:	bfa8      	it	ge
 8022510:	eef0 7a66 	vmovge.f32	s15, s13
 8022514:	ee77 7a87 	vadd.f32	s15, s15, s14
 8022518:	ed9f 7a46 	vldr	s14, [pc, #280]	; 8022634 <expm1f+0x234>
 802251c:	eddf 6a46 	vldr	s13, [pc, #280]	; 8022638 <expm1f+0x238>
 8022520:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8022524:	ee17 3a90 	vmov	r3, s15
 8022528:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802252c:	eea7 0ac7 	vfms.f32	s0, s15, s14
 8022530:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8022534:	eeb0 7a40 	vmov.f32	s14, s0
 8022538:	e7a4      	b.n	8022484 <expm1f+0x84>
 802253a:	f1b3 5f4c 	cmp.w	r3, #855638016	; 0x33000000
 802253e:	d208      	bcs.n	8022552 <expm1f+0x152>
 8022540:	eddf 7a38 	vldr	s15, [pc, #224]	; 8022624 <expm1f+0x224>
 8022544:	ee70 7a27 	vadd.f32	s15, s0, s15
 8022548:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802254c:	ee30 0a67 	vsub.f32	s0, s0, s15
 8022550:	4770      	bx	lr
 8022552:	2300      	movs	r3, #0
 8022554:	e79c      	b.n	8022490 <expm1f+0x90>
 8022556:	ee76 6ae7 	vsub.f32	s13, s13, s15
 802255a:	1c5a      	adds	r2, r3, #1
 802255c:	eed6 7a80 	vfnms.f32	s15, s13, s0
 8022560:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8022564:	d106      	bne.n	8022574 <expm1f+0x174>
 8022566:	ee70 7a67 	vsub.f32	s15, s0, s15
 802256a:	eebe 0a00 	vmov.f32	s0, #224	; 0xbf000000 -0.5
 802256e:	eea7 0aa5 	vfma.f32	s0, s15, s11
 8022572:	4770      	bx	lr
 8022574:	2b01      	cmp	r3, #1
 8022576:	d118      	bne.n	80225aa <expm1f+0x1aa>
 8022578:	eebd 7a00 	vmov.f32	s14, #208	; 0xbe800000 -0.250
 802257c:	eeb4 0ac7 	vcmpe.f32	s0, s14
 8022580:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022584:	bf41      	itttt	mi
 8022586:	ee30 0a25 	vaddmi.f32	s0, s0, s11
 802258a:	ee37 0ac0 	vsubmi.f32	s0, s15, s0
 802258e:	eef8 7a00 	vmovmi.f32	s15, #128	; 0xc0000000 -2.0
 8022592:	ee20 0a27 	vmulmi.f32	s0, s0, s15
 8022596:	bf5f      	itttt	pl
 8022598:	ee30 0a67 	vsubpl.f32	s0, s0, s15
 802259c:	eef0 7a00 	vmovpl.f32	s15, #0	; 0x40000000  2.0
 80225a0:	eea0 6a27 	vfmapl.f32	s12, s0, s15
 80225a4:	eeb0 0a46 	vmovpl.f32	s0, s12
 80225a8:	4770      	bx	lr
 80225aa:	1c5a      	adds	r2, r3, #1
 80225ac:	2a39      	cmp	r2, #57	; 0x39
 80225ae:	ea4f 51c3 	mov.w	r1, r3, lsl #23
 80225b2:	d90b      	bls.n	80225cc <expm1f+0x1cc>
 80225b4:	ee37 0ac0 	vsub.f32	s0, s15, s0
 80225b8:	ee36 0a40 	vsub.f32	s0, s12, s0
 80225bc:	ee10 3a10 	vmov	r3, s0
 80225c0:	440b      	add	r3, r1
 80225c2:	ee00 3a10 	vmov	s0, r3
 80225c6:	ee30 0a46 	vsub.f32	s0, s0, s12
 80225ca:	4770      	bx	lr
 80225cc:	2b16      	cmp	r3, #22
 80225ce:	dc11      	bgt.n	80225f4 <expm1f+0x1f4>
 80225d0:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80225d4:	fa42 f303 	asr.w	r3, r2, r3
 80225d8:	f1c3 537e 	rsb	r3, r3, #1065353216	; 0x3f800000
 80225dc:	ee37 0ac0 	vsub.f32	s0, s15, s0
 80225e0:	ee07 3a90 	vmov	s15, r3
 80225e4:	ee37 0ac0 	vsub.f32	s0, s15, s0
 80225e8:	ee10 3a10 	vmov	r3, s0
 80225ec:	440b      	add	r3, r1
 80225ee:	ee00 3a10 	vmov	s0, r3
 80225f2:	4770      	bx	lr
 80225f4:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
 80225f8:	05db      	lsls	r3, r3, #23
 80225fa:	ee07 3a10 	vmov	s14, r3
 80225fe:	ee77 7a87 	vadd.f32	s15, s15, s14
 8022602:	ee30 0a67 	vsub.f32	s0, s0, s15
 8022606:	ee30 0a06 	vadd.f32	s0, s0, s12
 802260a:	e7ed      	b.n	80225e8 <expm1f+0x1e8>
 802260c:	eddf 7a11 	vldr	s15, [pc, #68]	; 8022654 <expm1f+0x254>
 8022610:	ee20 7a27 	vmul.f32	s14, s0, s15
 8022614:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8022618:	e77c      	b.n	8022514 <expm1f+0x114>
 802261a:	bf00      	nop
 802261c:	4195b843 	.word	0x4195b843
 8022620:	42b17217 	.word	0x42b17217
 8022624:	7149f2ca 	.word	0x7149f2ca
 8022628:	0da24260 	.word	0x0da24260
 802262c:	3eb17218 	.word	0x3eb17218
 8022630:	3f851591 	.word	0x3f851591
 8022634:	3f317180 	.word	0x3f317180
 8022638:	3717f7d1 	.word	0x3717f7d1
 802263c:	b717f7d1 	.word	0xb717f7d1
 8022640:	b457edbb 	.word	0xb457edbb
 8022644:	36867e54 	.word	0x36867e54
 8022648:	b8a670cd 	.word	0xb8a670cd
 802264c:	3ad00d01 	.word	0x3ad00d01
 8022650:	bd088889 	.word	0xbd088889
 8022654:	3fb8aa3b 	.word	0x3fb8aa3b

08022658 <fabsf>:
 8022658:	ee10 3a10 	vmov	r3, s0
 802265c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8022660:	ee00 3a10 	vmov	s0, r3
 8022664:	4770      	bx	lr

08022666 <finitef>:
 8022666:	ee10 3a10 	vmov	r3, s0
 802266a:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 802266e:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 8022672:	bfac      	ite	ge
 8022674:	2000      	movge	r0, #0
 8022676:	2001      	movlt	r0, #1
 8022678:	4770      	bx	lr
	...

0802267c <nanf>:
 802267c:	ed9f 0a01 	vldr	s0, [pc, #4]	; 8022684 <nanf+0x8>
 8022680:	4770      	bx	lr
 8022682:	bf00      	nop
 8022684:	7fc00000 	.word	0x7fc00000

08022688 <rintf>:
 8022688:	b513      	push	{r0, r1, r4, lr}
 802268a:	ee10 1a10 	vmov	r1, s0
 802268e:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8022692:	0ddc      	lsrs	r4, r3, #23
 8022694:	3c7f      	subs	r4, #127	; 0x7f
 8022696:	2c16      	cmp	r4, #22
 8022698:	dc46      	bgt.n	8022728 <rintf+0xa0>
 802269a:	b32b      	cbz	r3, 80226e8 <rintf+0x60>
 802269c:	2c00      	cmp	r4, #0
 802269e:	ee10 2a10 	vmov	r2, s0
 80226a2:	ea4f 70d1 	mov.w	r0, r1, lsr #31
 80226a6:	da21      	bge.n	80226ec <rintf+0x64>
 80226a8:	f3c1 0316 	ubfx	r3, r1, #0, #23
 80226ac:	425b      	negs	r3, r3
 80226ae:	4a21      	ldr	r2, [pc, #132]	; (8022734 <rintf+0xac>)
 80226b0:	0a5b      	lsrs	r3, r3, #9
 80226b2:	0d09      	lsrs	r1, r1, #20
 80226b4:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80226b8:	0509      	lsls	r1, r1, #20
 80226ba:	430b      	orrs	r3, r1
 80226bc:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 80226c0:	ee07 3a90 	vmov	s15, r3
 80226c4:	edd2 6a00 	vldr	s13, [r2]
 80226c8:	ee36 7aa7 	vadd.f32	s14, s13, s15
 80226cc:	ed8d 7a01 	vstr	s14, [sp, #4]
 80226d0:	eddd 7a01 	vldr	s15, [sp, #4]
 80226d4:	ee77 7ae6 	vsub.f32	s15, s15, s13
 80226d8:	ee17 3a90 	vmov	r3, s15
 80226dc:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80226e0:	ea43 73c0 	orr.w	r3, r3, r0, lsl #31
 80226e4:	ee00 3a10 	vmov	s0, r3
 80226e8:	b002      	add	sp, #8
 80226ea:	bd10      	pop	{r4, pc}
 80226ec:	4b12      	ldr	r3, [pc, #72]	; (8022738 <rintf+0xb0>)
 80226ee:	4123      	asrs	r3, r4
 80226f0:	4219      	tst	r1, r3
 80226f2:	d0f9      	beq.n	80226e8 <rintf+0x60>
 80226f4:	085b      	lsrs	r3, r3, #1
 80226f6:	4219      	tst	r1, r3
 80226f8:	d006      	beq.n	8022708 <rintf+0x80>
 80226fa:	ea21 0203 	bic.w	r2, r1, r3
 80226fe:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8022702:	fa43 f404 	asr.w	r4, r3, r4
 8022706:	4322      	orrs	r2, r4
 8022708:	4b0a      	ldr	r3, [pc, #40]	; (8022734 <rintf+0xac>)
 802270a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 802270e:	ed90 7a00 	vldr	s14, [r0]
 8022712:	ee07 2a90 	vmov	s15, r2
 8022716:	ee77 7a27 	vadd.f32	s15, s14, s15
 802271a:	edcd 7a01 	vstr	s15, [sp, #4]
 802271e:	ed9d 0a01 	vldr	s0, [sp, #4]
 8022722:	ee30 0a47 	vsub.f32	s0, s0, s14
 8022726:	e7df      	b.n	80226e8 <rintf+0x60>
 8022728:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802272c:	d3dc      	bcc.n	80226e8 <rintf+0x60>
 802272e:	ee30 0a00 	vadd.f32	s0, s0, s0
 8022732:	e7d9      	b.n	80226e8 <rintf+0x60>
 8022734:	08076178 	.word	0x08076178
 8022738:	007fffff 	.word	0x007fffff

0802273c <scalbnf>:
 802273c:	b508      	push	{r3, lr}
 802273e:	ee10 2a10 	vmov	r2, s0
 8022742:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
 8022746:	ed2d 8b02 	vpush	{d8}
 802274a:	eef0 0a40 	vmov.f32	s1, s0
 802274e:	d004      	beq.n	802275a <scalbnf+0x1e>
 8022750:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8022754:	d306      	bcc.n	8022764 <scalbnf+0x28>
 8022756:	ee70 0a00 	vadd.f32	s1, s0, s0
 802275a:	ecbd 8b02 	vpop	{d8}
 802275e:	eeb0 0a60 	vmov.f32	s0, s1
 8022762:	bd08      	pop	{r3, pc}
 8022764:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8022768:	d21c      	bcs.n	80227a4 <scalbnf+0x68>
 802276a:	4b1f      	ldr	r3, [pc, #124]	; (80227e8 <scalbnf+0xac>)
 802276c:	eddf 7a1f 	vldr	s15, [pc, #124]	; 80227ec <scalbnf+0xb0>
 8022770:	4298      	cmp	r0, r3
 8022772:	ee60 0a27 	vmul.f32	s1, s0, s15
 8022776:	db10      	blt.n	802279a <scalbnf+0x5e>
 8022778:	ee10 2a90 	vmov	r2, s1
 802277c:	f3c2 53c7 	ubfx	r3, r2, #23, #8
 8022780:	3b19      	subs	r3, #25
 8022782:	4403      	add	r3, r0
 8022784:	2bfe      	cmp	r3, #254	; 0xfe
 8022786:	dd0f      	ble.n	80227a8 <scalbnf+0x6c>
 8022788:	ed9f 8a19 	vldr	s16, [pc, #100]	; 80227f0 <scalbnf+0xb4>
 802278c:	eeb0 0a48 	vmov.f32	s0, s16
 8022790:	f000 f922 	bl	80229d8 <copysignf>
 8022794:	ee60 0a08 	vmul.f32	s1, s0, s16
 8022798:	e7df      	b.n	802275a <scalbnf+0x1e>
 802279a:	eddf 7a16 	vldr	s15, [pc, #88]	; 80227f4 <scalbnf+0xb8>
 802279e:	ee60 0aa7 	vmul.f32	s1, s1, s15
 80227a2:	e7da      	b.n	802275a <scalbnf+0x1e>
 80227a4:	0ddb      	lsrs	r3, r3, #23
 80227a6:	e7ec      	b.n	8022782 <scalbnf+0x46>
 80227a8:	2b00      	cmp	r3, #0
 80227aa:	dd06      	ble.n	80227ba <scalbnf+0x7e>
 80227ac:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 80227b0:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
 80227b4:	ee00 3a90 	vmov	s1, r3
 80227b8:	e7cf      	b.n	802275a <scalbnf+0x1e>
 80227ba:	f113 0f16 	cmn.w	r3, #22
 80227be:	da06      	bge.n	80227ce <scalbnf+0x92>
 80227c0:	f24c 3350 	movw	r3, #50000	; 0xc350
 80227c4:	4298      	cmp	r0, r3
 80227c6:	dcdf      	bgt.n	8022788 <scalbnf+0x4c>
 80227c8:	ed9f 8a0a 	vldr	s16, [pc, #40]	; 80227f4 <scalbnf+0xb8>
 80227cc:	e7de      	b.n	802278c <scalbnf+0x50>
 80227ce:	3319      	adds	r3, #25
 80227d0:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 80227d4:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
 80227d8:	eddf 7a07 	vldr	s15, [pc, #28]	; 80227f8 <scalbnf+0xbc>
 80227dc:	ee07 3a10 	vmov	s14, r3
 80227e0:	ee67 0a27 	vmul.f32	s1, s14, s15
 80227e4:	e7b9      	b.n	802275a <scalbnf+0x1e>
 80227e6:	bf00      	nop
 80227e8:	ffff3cb0 	.word	0xffff3cb0
 80227ec:	4c000000 	.word	0x4c000000
 80227f0:	7149f2ca 	.word	0x7149f2ca
 80227f4:	0da24260 	.word	0x0da24260
 80227f8:	33000000 	.word	0x33000000

080227fc <__ieee754_logf>:
 80227fc:	ee10 3a10 	vmov	r3, s0
 8022800:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 8022804:	d106      	bne.n	8022814 <__ieee754_logf+0x18>
 8022806:	ed9f 7a65 	vldr	s14, [pc, #404]	; 802299c <__ieee754_logf+0x1a0>
 802280a:	eddf 7a65 	vldr	s15, [pc, #404]	; 80229a0 <__ieee754_logf+0x1a4>
 802280e:	ee87 0a27 	vdiv.f32	s0, s14, s15
 8022812:	4770      	bx	lr
 8022814:	2b00      	cmp	r3, #0
 8022816:	da02      	bge.n	802281e <__ieee754_logf+0x22>
 8022818:	ee30 7a40 	vsub.f32	s14, s0, s0
 802281c:	e7f5      	b.n	802280a <__ieee754_logf+0xe>
 802281e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8022822:	db02      	blt.n	802282a <__ieee754_logf+0x2e>
 8022824:	ee30 0a00 	vadd.f32	s0, s0, s0
 8022828:	4770      	bx	lr
 802282a:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 802282e:	bfbf      	itttt	lt
 8022830:	eddf 7a5c 	vldrlt	s15, [pc, #368]	; 80229a4 <__ieee754_logf+0x1a8>
 8022834:	ee60 7a27 	vmullt.f32	s15, s0, s15
 8022838:	f06f 0118 	mvnlt.w	r1, #24
 802283c:	ee17 3a90 	vmovlt	r3, s15
 8022840:	ea4f 52e3 	mov.w	r2, r3, asr #23
 8022844:	bfa8      	it	ge
 8022846:	2100      	movge	r1, #0
 8022848:	3a7f      	subs	r2, #127	; 0x7f
 802284a:	440a      	add	r2, r1
 802284c:	4956      	ldr	r1, [pc, #344]	; (80229a8 <__ieee754_logf+0x1ac>)
 802284e:	f3c3 0316 	ubfx	r3, r3, #0, #23
 8022852:	4419      	add	r1, r3
 8022854:	f401 0100 	and.w	r1, r1, #8388608	; 0x800000
 8022858:	eb02 52d1 	add.w	r2, r2, r1, lsr #23
 802285c:	f081 517e 	eor.w	r1, r1, #1065353216	; 0x3f800000
 8022860:	4319      	orrs	r1, r3
 8022862:	ee07 1a90 	vmov	s15, r1
 8022866:	f103 010f 	add.w	r1, r3, #15
 802286a:	f3c1 0116 	ubfx	r1, r1, #0, #23
 802286e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8022872:	290f      	cmp	r1, #15
 8022874:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8022878:	dc31      	bgt.n	80228de <__ieee754_logf+0xe2>
 802287a:	eeb5 0a40 	vcmp.f32	s0, #0.0
 802287e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022882:	d10f      	bne.n	80228a4 <__ieee754_logf+0xa8>
 8022884:	2a00      	cmp	r2, #0
 8022886:	f000 8085 	beq.w	8022994 <__ieee754_logf+0x198>
 802288a:	ee07 2a90 	vmov	s15, r2
 802288e:	ed9f 0a47 	vldr	s0, [pc, #284]	; 80229ac <__ieee754_logf+0x1b0>
 8022892:	ed9f 7a47 	vldr	s14, [pc, #284]	; 80229b0 <__ieee754_logf+0x1b4>
 8022896:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802289a:	ee27 0a80 	vmul.f32	s0, s15, s0
 802289e:	eea7 0a87 	vfma.f32	s0, s15, s14
 80228a2:	4770      	bx	lr
 80228a4:	eddf 7a43 	vldr	s15, [pc, #268]	; 80229b4 <__ieee754_logf+0x1b8>
 80228a8:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 80228ac:	eea0 7a67 	vfms.f32	s14, s0, s15
 80228b0:	ee60 7a00 	vmul.f32	s15, s0, s0
 80228b4:	ee27 7a27 	vmul.f32	s14, s14, s15
 80228b8:	b912      	cbnz	r2, 80228c0 <__ieee754_logf+0xc4>
 80228ba:	ee30 0a47 	vsub.f32	s0, s0, s14
 80228be:	4770      	bx	lr
 80228c0:	ee07 2a90 	vmov	s15, r2
 80228c4:	eddf 6a39 	vldr	s13, [pc, #228]	; 80229ac <__ieee754_logf+0x1b0>
 80228c8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80228cc:	eea7 7ae6 	vfms.f32	s14, s15, s13
 80228d0:	ee37 0a40 	vsub.f32	s0, s14, s0
 80228d4:	ed9f 7a36 	vldr	s14, [pc, #216]	; 80229b0 <__ieee754_logf+0x1b4>
 80228d8:	ee97 0a87 	vfnms.f32	s0, s15, s14
 80228dc:	4770      	bx	lr
 80228de:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 80228e2:	ee70 7a27 	vadd.f32	s15, s0, s15
 80228e6:	eddf 5a34 	vldr	s11, [pc, #208]	; 80229b8 <__ieee754_logf+0x1bc>
 80228ea:	eddf 4a34 	vldr	s9, [pc, #208]	; 80229bc <__ieee754_logf+0x1c0>
 80228ee:	4934      	ldr	r1, [pc, #208]	; (80229c0 <__ieee754_logf+0x1c4>)
 80228f0:	ee80 6a27 	vdiv.f32	s12, s0, s15
 80228f4:	4419      	add	r1, r3
 80228f6:	f5c3 1357 	rsb	r3, r3, #3522560	; 0x35c000
 80228fa:	f503 7322 	add.w	r3, r3, #648	; 0x288
 80228fe:	430b      	orrs	r3, r1
 8022900:	2b00      	cmp	r3, #0
 8022902:	ee07 2a90 	vmov	s15, r2
 8022906:	ee26 5a06 	vmul.f32	s10, s12, s12
 802290a:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 802290e:	ee25 7a05 	vmul.f32	s14, s10, s10
 8022912:	eddf 7a2c 	vldr	s15, [pc, #176]	; 80229c4 <__ieee754_logf+0x1c8>
 8022916:	eee7 7a25 	vfma.f32	s15, s14, s11
 802291a:	eddf 5a2b 	vldr	s11, [pc, #172]	; 80229c8 <__ieee754_logf+0x1cc>
 802291e:	eee7 5a87 	vfma.f32	s11, s15, s14
 8022922:	eddf 7a2a 	vldr	s15, [pc, #168]	; 80229cc <__ieee754_logf+0x1d0>
 8022926:	eee7 7a24 	vfma.f32	s15, s14, s9
 802292a:	eddf 4a29 	vldr	s9, [pc, #164]	; 80229d0 <__ieee754_logf+0x1d4>
 802292e:	eee7 4a87 	vfma.f32	s9, s15, s14
 8022932:	eddf 7a28 	vldr	s15, [pc, #160]	; 80229d4 <__ieee754_logf+0x1d8>
 8022936:	eee4 7a87 	vfma.f32	s15, s9, s14
 802293a:	ee67 7a85 	vmul.f32	s15, s15, s10
 802293e:	eee5 7a87 	vfma.f32	s15, s11, s14
 8022942:	dd1c      	ble.n	802297e <__ieee754_logf+0x182>
 8022944:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8022948:	ee20 7a07 	vmul.f32	s14, s0, s14
 802294c:	ee27 7a00 	vmul.f32	s14, s14, s0
 8022950:	ee77 7a87 	vadd.f32	s15, s15, s14
 8022954:	ee67 7a86 	vmul.f32	s15, s15, s12
 8022958:	b922      	cbnz	r2, 8022964 <__ieee754_logf+0x168>
 802295a:	ee77 7a67 	vsub.f32	s15, s14, s15
 802295e:	ee30 0a67 	vsub.f32	s0, s0, s15
 8022962:	4770      	bx	lr
 8022964:	ed9f 6a11 	vldr	s12, [pc, #68]	; 80229ac <__ieee754_logf+0x1b0>
 8022968:	eee6 7a86 	vfma.f32	s15, s13, s12
 802296c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8022970:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8022974:	eddf 7a0e 	vldr	s15, [pc, #56]	; 80229b0 <__ieee754_logf+0x1b4>
 8022978:	ee96 0aa7 	vfnms.f32	s0, s13, s15
 802297c:	4770      	bx	lr
 802297e:	ee70 7a67 	vsub.f32	s15, s0, s15
 8022982:	ee67 7a86 	vmul.f32	s15, s15, s12
 8022986:	2a00      	cmp	r2, #0
 8022988:	d0e9      	beq.n	802295e <__ieee754_logf+0x162>
 802298a:	ed9f 7a08 	vldr	s14, [pc, #32]	; 80229ac <__ieee754_logf+0x1b0>
 802298e:	eee6 7ac7 	vfms.f32	s15, s13, s14
 8022992:	e7ed      	b.n	8022970 <__ieee754_logf+0x174>
 8022994:	ed9f 0a02 	vldr	s0, [pc, #8]	; 80229a0 <__ieee754_logf+0x1a4>
 8022998:	4770      	bx	lr
 802299a:	bf00      	nop
 802299c:	cc000000 	.word	0xcc000000
 80229a0:	00000000 	.word	0x00000000
 80229a4:	4c000000 	.word	0x4c000000
 80229a8:	004afb20 	.word	0x004afb20
 80229ac:	3717f7d1 	.word	0x3717f7d1
 80229b0:	3f317180 	.word	0x3f317180
 80229b4:	3eaaaaab 	.word	0x3eaaaaab
 80229b8:	3e1cd04f 	.word	0x3e1cd04f
 80229bc:	3e178897 	.word	0x3e178897
 80229c0:	ffcf5c30 	.word	0xffcf5c30
 80229c4:	3e638e29 	.word	0x3e638e29
 80229c8:	3ecccccd 	.word	0x3ecccccd
 80229cc:	3e3a3325 	.word	0x3e3a3325
 80229d0:	3e924925 	.word	0x3e924925
 80229d4:	3f2aaaab 	.word	0x3f2aaaab

080229d8 <copysignf>:
 80229d8:	ee10 3a10 	vmov	r3, s0
 80229dc:	ee10 2a90 	vmov	r2, s1
 80229e0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80229e4:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
 80229e8:	4313      	orrs	r3, r2
 80229ea:	ee00 3a10 	vmov	s0, r3
 80229ee:	4770      	bx	lr

080229f0 <_init>:
 80229f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80229f2:	bf00      	nop
 80229f4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80229f6:	bc08      	pop	{r3}
 80229f8:	469e      	mov	lr, r3
 80229fa:	4770      	bx	lr

080229fc <_fini>:
 80229fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80229fe:	bf00      	nop
 8022a00:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8022a02:	bc08      	pop	{r3}
 8022a04:	469e      	mov	lr, r3
 8022a06:	4770      	bx	lr
